// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_management_backend.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_device_5fmanagement_5fbackend_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_device_5fmanagement_5fbackend_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include "components/policy/proto/policy_proto_export.h"
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_device_5fmanagement_5fbackend_2eproto POLICY_PROTO_EXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct POLICY_PROTO_EXPORT TableStruct_device_5fmanagement_5fbackend_2eproto {
static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[154]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace enterprise_management {
class ActiveDirectoryEnrollPlayUserRequest;
class ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal _ActiveDirectoryEnrollPlayUserRequest_default_instance_;
class ActiveDirectoryEnrollPlayUserResponse;
class ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal _ActiveDirectoryEnrollPlayUserResponse_default_instance_;
class ActiveDirectoryPlayActivityRequest;
class ActiveDirectoryPlayActivityRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ActiveDirectoryPlayActivityRequestDefaultTypeInternal _ActiveDirectoryPlayActivityRequest_default_instance_;
class ActiveDirectoryPlayActivityResponse;
class ActiveDirectoryPlayActivityResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ActiveDirectoryPlayActivityResponseDefaultTypeInternal _ActiveDirectoryPlayActivityResponse_default_instance_;
class ActiveDirectoryUserSigninRequest;
class ActiveDirectoryUserSigninRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ActiveDirectoryUserSigninRequestDefaultTypeInternal _ActiveDirectoryUserSigninRequest_default_instance_;
class ActiveDirectoryUserSigninResponse;
class ActiveDirectoryUserSigninResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ActiveDirectoryUserSigninResponseDefaultTypeInternal _ActiveDirectoryUserSigninResponse_default_instance_;
class ActiveTimePeriod;
class ActiveTimePeriodDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ActiveTimePeriodDefaultTypeInternal _ActiveTimePeriod_default_instance_;
class AndroidAppInfo;
class AndroidAppInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AndroidAppInfoDefaultTypeInternal _AndroidAppInfo_default_instance_;
class AndroidAppPermission;
class AndroidAppPermissionDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AndroidAppPermissionDefaultTypeInternal _AndroidAppPermission_default_instance_;
class AndroidStatus;
class AndroidStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AndroidStatusDefaultTypeInternal _AndroidStatus_default_instance_;
class App;
class AppDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppDefaultTypeInternal _App_default_instance_;
class AppActivity;
class AppActivityDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppActivityDefaultTypeInternal _AppActivity_default_instance_;
class AppInfo;
class AppInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppInfoDefaultTypeInternal _AppInfo_default_instance_;
class AppInstallReport;
class AppInstallReportDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppInstallReportDefaultTypeInternal _AppInstallReport_default_instance_;
class AppInstallReportLogEvent;
class AppInstallReportLogEventDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppInstallReportLogEventDefaultTypeInternal _AppInstallReportLogEvent_default_instance_;
class AppInstallReportRequest;
class AppInstallReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppInstallReportRequestDefaultTypeInternal _AppInstallReportRequest_default_instance_;
class AppInstallReportResponse;
class AppInstallReportResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppInstallReportResponseDefaultTypeInternal _AppInstallReportResponse_default_instance_;
class AppStatus;
class AppStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern AppStatusDefaultTypeInternal _AppStatus_default_instance_;
class BacklightInfo;
class BacklightInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern BacklightInfoDefaultTypeInternal _BacklightInfo_default_instance_;
class BatteryInfo;
class BatteryInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern BatteryInfoDefaultTypeInternal _BatteryInfo_default_instance_;
class BatterySample;
class BatterySampleDefaultTypeInternal;
POLICY_PROTO_EXPORT extern BatterySampleDefaultTypeInternal _BatterySample_default_instance_;
class BluetoothAdapterInfo;
class BluetoothAdapterInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern BluetoothAdapterInfoDefaultTypeInternal _BluetoothAdapterInfo_default_instance_;
class BoardStatus;
class BoardStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern BoardStatusDefaultTypeInternal _BoardStatus_default_instance_;
class BrowserReport;
class BrowserReportDefaultTypeInternal;
POLICY_PROTO_EXPORT extern BrowserReportDefaultTypeInternal _BrowserReport_default_instance_;
class CPUTempInfo;
class CPUTempInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CPUTempInfoDefaultTypeInternal _CPUTempInfo_default_instance_;
class CertificateBasedDeviceRegisterRequest;
class CertificateBasedDeviceRegisterRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CertificateBasedDeviceRegisterRequestDefaultTypeInternal _CertificateBasedDeviceRegisterRequest_default_instance_;
class CertificateBasedDeviceRegistrationData;
class CertificateBasedDeviceRegistrationDataDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CertificateBasedDeviceRegistrationDataDefaultTypeInternal _CertificateBasedDeviceRegistrationData_default_instance_;
class CheckAndroidManagementRequest;
class CheckAndroidManagementRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CheckAndroidManagementRequestDefaultTypeInternal _CheckAndroidManagementRequest_default_instance_;
class CheckAndroidManagementResponse;
class CheckAndroidManagementResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CheckAndroidManagementResponseDefaultTypeInternal _CheckAndroidManagementResponse_default_instance_;
class CheckDeviceLicenseRequest;
class CheckDeviceLicenseRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CheckDeviceLicenseRequestDefaultTypeInternal _CheckDeviceLicenseRequest_default_instance_;
class CheckDeviceLicenseResponse;
class CheckDeviceLicenseResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CheckDeviceLicenseResponseDefaultTypeInternal _CheckDeviceLicenseResponse_default_instance_;
class CheckDevicePairingRequest;
class CheckDevicePairingRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CheckDevicePairingRequestDefaultTypeInternal _CheckDevicePairingRequest_default_instance_;
class CheckDevicePairingResponse;
class CheckDevicePairingResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CheckDevicePairingResponseDefaultTypeInternal _CheckDevicePairingResponse_default_instance_;
class ChildStatusReportRequest;
class ChildStatusReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChildStatusReportRequestDefaultTypeInternal _ChildStatusReportRequest_default_instance_;
class ChildStatusReportResponse;
class ChildStatusReportResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChildStatusReportResponseDefaultTypeInternal _ChildStatusReportResponse_default_instance_;
class ChromeDesktopReportRequest;
class ChromeDesktopReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChromeDesktopReportRequestDefaultTypeInternal _ChromeDesktopReportRequest_default_instance_;
class ChromeDesktopReportResponse;
class ChromeDesktopReportResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChromeDesktopReportResponseDefaultTypeInternal _ChromeDesktopReportResponse_default_instance_;
class ChromeOsUserReportRequest;
class ChromeOsUserReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChromeOsUserReportRequestDefaultTypeInternal _ChromeOsUserReportRequest_default_instance_;
class ChromeOsUserReportResponse;
class ChromeOsUserReportResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChromeOsUserReportResponseDefaultTypeInternal _ChromeOsUserReportResponse_default_instance_;
class ChromeSignedInUser;
class ChromeSignedInUserDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChromeSignedInUserDefaultTypeInternal _ChromeSignedInUser_default_instance_;
class ChromeUserProfileInfo;
class ChromeUserProfileInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChromeUserProfileInfoDefaultTypeInternal _ChromeUserProfileInfo_default_instance_;
class ChromeUserProfileReport;
class ChromeUserProfileReportDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ChromeUserProfileReportDefaultTypeInternal _ChromeUserProfileReport_default_instance_;
class ClientActionRequired;
class ClientActionRequiredDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ClientActionRequiredDefaultTypeInternal _ClientActionRequired_default_instance_;
class ClientCertificateProvisioningRequest;
class ClientCertificateProvisioningRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ClientCertificateProvisioningRequestDefaultTypeInternal _ClientCertificateProvisioningRequest_default_instance_;
class ClientCertificateProvisioningResponse;
class ClientCertificateProvisioningResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ClientCertificateProvisioningResponseDefaultTypeInternal _ClientCertificateProvisioningResponse_default_instance_;
class CpuCStateInfo;
class CpuCStateInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CpuCStateInfoDefaultTypeInternal _CpuCStateInfo_default_instance_;
class CpuInfo;
class CpuInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CpuInfoDefaultTypeInternal _CpuInfo_default_instance_;
class CpuUtilizationInfo;
class CpuUtilizationInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CpuUtilizationInfoDefaultTypeInternal _CpuUtilizationInfo_default_instance_;
class CrashReportInfo;
class CrashReportInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CrashReportInfoDefaultTypeInternal _CrashReportInfo_default_instance_;
class CrostiniApp;
class CrostiniAppDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CrostiniAppDefaultTypeInternal _CrostiniApp_default_instance_;
class CrostiniStatus;
class CrostiniStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CrostiniStatusDefaultTypeInternal _CrostiniStatus_default_instance_;
class CustomerLogo;
class CustomerLogoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern CustomerLogoDefaultTypeInternal _CustomerLogo_default_instance_;
class DEPRECATEDPolicyPublicKeyAndDomain;
class DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal _DEPRECATEDPolicyPublicKeyAndDomain_default_instance_;
class DeviceAttributeUpdatePermissionRequest;
class DeviceAttributeUpdatePermissionRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceAttributeUpdatePermissionRequestDefaultTypeInternal _DeviceAttributeUpdatePermissionRequest_default_instance_;
class DeviceAttributeUpdatePermissionResponse;
class DeviceAttributeUpdatePermissionResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceAttributeUpdatePermissionResponseDefaultTypeInternal _DeviceAttributeUpdatePermissionResponse_default_instance_;
class DeviceAttributeUpdateRequest;
class DeviceAttributeUpdateRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceAttributeUpdateRequestDefaultTypeInternal _DeviceAttributeUpdateRequest_default_instance_;
class DeviceAttributeUpdateResponse;
class DeviceAttributeUpdateResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceAttributeUpdateResponseDefaultTypeInternal _DeviceAttributeUpdateResponse_default_instance_;
class DeviceAutoEnrollmentRequest;
class DeviceAutoEnrollmentRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceAutoEnrollmentRequestDefaultTypeInternal _DeviceAutoEnrollmentRequest_default_instance_;
class DeviceAutoEnrollmentResponse;
class DeviceAutoEnrollmentResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceAutoEnrollmentResponseDefaultTypeInternal _DeviceAutoEnrollmentResponse_default_instance_;
class DeviceCertUploadRequest;
class DeviceCertUploadRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceCertUploadRequestDefaultTypeInternal _DeviceCertUploadRequest_default_instance_;
class DeviceCertUploadResponse;
class DeviceCertUploadResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceCertUploadResponseDefaultTypeInternal _DeviceCertUploadResponse_default_instance_;
class DeviceInitialEnrollmentStateRequest;
class DeviceInitialEnrollmentStateRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceInitialEnrollmentStateRequestDefaultTypeInternal _DeviceInitialEnrollmentStateRequest_default_instance_;
class DeviceInitialEnrollmentStateResponse;
class DeviceInitialEnrollmentStateResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceInitialEnrollmentStateResponseDefaultTypeInternal _DeviceInitialEnrollmentStateResponse_default_instance_;
class DeviceManagementRequest;
class DeviceManagementRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceManagementRequestDefaultTypeInternal _DeviceManagementRequest_default_instance_;
class DeviceManagementResponse;
class DeviceManagementResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceManagementResponseDefaultTypeInternal _DeviceManagementResponse_default_instance_;
class DevicePairingRequest;
class DevicePairingRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DevicePairingRequestDefaultTypeInternal _DevicePairingRequest_default_instance_;
class DevicePairingResponse;
class DevicePairingResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DevicePairingResponseDefaultTypeInternal _DevicePairingResponse_default_instance_;
class DevicePolicyRequest;
class DevicePolicyRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DevicePolicyRequestDefaultTypeInternal _DevicePolicyRequest_default_instance_;
class DevicePolicyResponse;
class DevicePolicyResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DevicePolicyResponseDefaultTypeInternal _DevicePolicyResponse_default_instance_;
class DeviceRegisterConfiguration;
class DeviceRegisterConfigurationDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceRegisterConfigurationDefaultTypeInternal _DeviceRegisterConfiguration_default_instance_;
class DeviceRegisterIdentification;
class DeviceRegisterIdentificationDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceRegisterIdentificationDefaultTypeInternal _DeviceRegisterIdentification_default_instance_;
class DeviceRegisterRequest;
class DeviceRegisterRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceRegisterRequestDefaultTypeInternal _DeviceRegisterRequest_default_instance_;
class DeviceRegisterResponse;
class DeviceRegisterResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceRegisterResponseDefaultTypeInternal _DeviceRegisterResponse_default_instance_;
class DeviceRemoteCommandRequest;
class DeviceRemoteCommandRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceRemoteCommandRequestDefaultTypeInternal _DeviceRemoteCommandRequest_default_instance_;
class DeviceRemoteCommandResponse;
class DeviceRemoteCommandResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceRemoteCommandResponseDefaultTypeInternal _DeviceRemoteCommandResponse_default_instance_;
class DeviceServiceApiAccessRequest;
class DeviceServiceApiAccessRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceServiceApiAccessRequestDefaultTypeInternal _DeviceServiceApiAccessRequest_default_instance_;
class DeviceServiceApiAccessResponse;
class DeviceServiceApiAccessResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceServiceApiAccessResponseDefaultTypeInternal _DeviceServiceApiAccessResponse_default_instance_;
class DeviceState;
class DeviceStateDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceStateDefaultTypeInternal _DeviceState_default_instance_;
class DeviceStateKeyUpdateRequest;
class DeviceStateKeyUpdateRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceStateKeyUpdateRequestDefaultTypeInternal _DeviceStateKeyUpdateRequest_default_instance_;
class DeviceStateRetrievalInfo;
class DeviceStateRetrievalInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceStateRetrievalInfoDefaultTypeInternal _DeviceStateRetrievalInfo_default_instance_;
class DeviceStateRetrievalRequest;
class DeviceStateRetrievalRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceStateRetrievalRequestDefaultTypeInternal _DeviceStateRetrievalRequest_default_instance_;
class DeviceStateRetrievalResponse;
class DeviceStateRetrievalResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceStateRetrievalResponseDefaultTypeInternal _DeviceStateRetrievalResponse_default_instance_;
class DeviceStatusReportRequest;
class DeviceStatusReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceStatusReportRequestDefaultTypeInternal _DeviceStatusReportRequest_default_instance_;
class DeviceStatusReportResponse;
class DeviceStatusReportResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceStatusReportResponseDefaultTypeInternal _DeviceStatusReportResponse_default_instance_;
class DeviceUnregisterRequest;
class DeviceUnregisterRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceUnregisterRequestDefaultTypeInternal _DeviceUnregisterRequest_default_instance_;
class DeviceUnregisterResponse;
class DeviceUnregisterResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceUnregisterResponseDefaultTypeInternal _DeviceUnregisterResponse_default_instance_;
class DeviceUser;
class DeviceUserDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DeviceUserDefaultTypeInternal _DeviceUser_default_instance_;
class DisabledState;
class DisabledStateDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DisabledStateDefaultTypeInternal _DisabledState_default_instance_;
class DiskInfo;
class DiskInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DiskInfoDefaultTypeInternal _DiskInfo_default_instance_;
class DiskLifetimeEstimation;
class DiskLifetimeEstimationDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DiskLifetimeEstimationDefaultTypeInternal _DiskLifetimeEstimation_default_instance_;
class DisplayInfo;
class DisplayInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DisplayInfoDefaultTypeInternal _DisplayInfo_default_instance_;
class DownloadCertRequest;
class DownloadCertRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DownloadCertRequestDefaultTypeInternal _DownloadCertRequest_default_instance_;
class DownloadCertResponse;
class DownloadCertResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern DownloadCertResponseDefaultTypeInternal _DownloadCertResponse_default_instance_;
class Extension;
class ExtensionDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class ExtensionInstallReport;
class ExtensionInstallReportDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ExtensionInstallReportDefaultTypeInternal _ExtensionInstallReport_default_instance_;
class ExtensionInstallReportLogEvent;
class ExtensionInstallReportLogEventDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ExtensionInstallReportLogEventDefaultTypeInternal _ExtensionInstallReportLogEvent_default_instance_;
class ExtensionInstallReportRequest;
class ExtensionInstallReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ExtensionInstallReportRequestDefaultTypeInternal _ExtensionInstallReportRequest_default_instance_;
class ExtensionPolicy;
class ExtensionPolicyDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ExtensionPolicyDefaultTypeInternal _ExtensionPolicy_default_instance_;
class ExtensionRequest;
class ExtensionRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ExtensionRequestDefaultTypeInternal _ExtensionRequest_default_instance_;
class FanInfo;
class FanInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern FanInfoDefaultTypeInternal _FanInfo_default_instance_;
class FinishCsrRequest;
class FinishCsrRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern FinishCsrRequestDefaultTypeInternal _FinishCsrRequest_default_instance_;
class FinishCsrResponse;
class FinishCsrResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern FinishCsrResponseDefaultTypeInternal _FinishCsrResponse_default_instance_;
class GcmIdUpdateRequest;
class GcmIdUpdateRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern GcmIdUpdateRequestDefaultTypeInternal _GcmIdUpdateRequest_default_instance_;
class GcmIdUpdateResponse;
class GcmIdUpdateResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern GcmIdUpdateResponseDefaultTypeInternal _GcmIdUpdateResponse_default_instance_;
class GlobalCpuInfo;
class GlobalCpuInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern GlobalCpuInfoDefaultTypeInternal _GlobalCpuInfo_default_instance_;
class GraphicsAdapterInfo;
class GraphicsAdapterInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern GraphicsAdapterInfoDefaultTypeInternal _GraphicsAdapterInfo_default_instance_;
class GraphicsStatus;
class GraphicsStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern GraphicsStatusDefaultTypeInternal _GraphicsStatus_default_instance_;
class LicenseAvailability;
class LicenseAvailabilityDefaultTypeInternal;
POLICY_PROTO_EXPORT extern LicenseAvailabilityDefaultTypeInternal _LicenseAvailability_default_instance_;
class LicenseType;
class LicenseTypeDefaultTypeInternal;
POLICY_PROTO_EXPORT extern LicenseTypeDefaultTypeInternal _LicenseType_default_instance_;
class LogicalCpuInfo;
class LogicalCpuInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern LogicalCpuInfoDefaultTypeInternal _LogicalCpuInfo_default_instance_;
class MemoryInfo;
class MemoryInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
class NetworkInterface;
class NetworkInterfaceDefaultTypeInternal;
POLICY_PROTO_EXPORT extern NetworkInterfaceDefaultTypeInternal _NetworkInterface_default_instance_;
class NetworkState;
class NetworkStateDefaultTypeInternal;
POLICY_PROTO_EXPORT extern NetworkStateDefaultTypeInternal _NetworkState_default_instance_;
class OSReport;
class OSReportDefaultTypeInternal;
POLICY_PROTO_EXPORT extern OSReportDefaultTypeInternal _OSReport_default_instance_;
class OsUpdateStatus;
class OsUpdateStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern OsUpdateStatusDefaultTypeInternal _OsUpdateStatus_default_instance_;
class Plugin;
class PluginDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PluginDefaultTypeInternal _Plugin_default_instance_;
class Policy;
class PolicyDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyDefaultTypeInternal _Policy_default_instance_;
class PolicyData;
class PolicyDataDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyDataDefaultTypeInternal _PolicyData_default_instance_;
class PolicyFetchRequest;
class PolicyFetchRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyFetchRequestDefaultTypeInternal _PolicyFetchRequest_default_instance_;
class PolicyFetchResponse;
class PolicyFetchResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyFetchResponseDefaultTypeInternal _PolicyFetchResponse_default_instance_;
class PolicyFetchTimestamp;
class PolicyFetchTimestampDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyFetchTimestampDefaultTypeInternal _PolicyFetchTimestamp_default_instance_;
class PolicyValidationReportRequest;
class PolicyValidationReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyValidationReportRequestDefaultTypeInternal _PolicyValidationReportRequest_default_instance_;
class PolicyValidationReportResponse;
class PolicyValidationReportResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyValidationReportResponseDefaultTypeInternal _PolicyValidationReportResponse_default_instance_;
class PolicyValueValidationIssue;
class PolicyValueValidationIssueDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PolicyValueValidationIssueDefaultTypeInternal _PolicyValueValidationIssue_default_instance_;
class PowerStatus;
class PowerStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PowerStatusDefaultTypeInternal _PowerStatus_default_instance_;
class PublicKeyVerificationData;
class PublicKeyVerificationDataDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PublicKeyVerificationDataDefaultTypeInternal _PublicKeyVerificationData_default_instance_;
class PublicSamlUserRequest;
class PublicSamlUserRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PublicSamlUserRequestDefaultTypeInternal _PublicSamlUserRequest_default_instance_;
class PublicSamlUserResponse;
class PublicSamlUserResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern PublicSamlUserResponseDefaultTypeInternal _PublicSamlUserResponse_default_instance_;
class RefreshAccountRequest;
class RefreshAccountRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern RefreshAccountRequestDefaultTypeInternal _RefreshAccountRequest_default_instance_;
class RefreshAccountResponse;
class RefreshAccountResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern RefreshAccountResponseDefaultTypeInternal _RefreshAccountResponse_default_instance_;
class RegisterBrowserRequest;
class RegisterBrowserRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern RegisterBrowserRequestDefaultTypeInternal _RegisterBrowserRequest_default_instance_;
class RemoteCommand;
class RemoteCommandDefaultTypeInternal;
POLICY_PROTO_EXPORT extern RemoteCommandDefaultTypeInternal _RemoteCommand_default_instance_;
class RemoteCommandResult;
class RemoteCommandResultDefaultTypeInternal;
POLICY_PROTO_EXPORT extern RemoteCommandResultDefaultTypeInternal _RemoteCommandResult_default_instance_;
class RsuLookupKeyUploadRequest;
class RsuLookupKeyUploadRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern RsuLookupKeyUploadRequestDefaultTypeInternal _RsuLookupKeyUploadRequest_default_instance_;
class RsuLookupKeyUploadResponse;
class RsuLookupKeyUploadResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern RsuLookupKeyUploadResponseDefaultTypeInternal _RsuLookupKeyUploadResponse_default_instance_;
class SamlParametersProto;
class SamlParametersProtoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern SamlParametersProtoDefaultTypeInternal _SamlParametersProto_default_instance_;
class ScreenTimeSpan;
class ScreenTimeSpanDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ScreenTimeSpanDefaultTypeInternal _ScreenTimeSpan_default_instance_;
class SessionStatusReportRequest;
class SessionStatusReportRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern SessionStatusReportRequestDefaultTypeInternal _SessionStatusReportRequest_default_instance_;
class SessionStatusReportResponse;
class SessionStatusReportResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern SessionStatusReportResponseDefaultTypeInternal _SessionStatusReportResponse_default_instance_;
class SignedData;
class SignedDataDefaultTypeInternal;
POLICY_PROTO_EXPORT extern SignedDataDefaultTypeInternal _SignedData_default_instance_;
class StartCsrRequest;
class StartCsrRequestDefaultTypeInternal;
POLICY_PROTO_EXPORT extern StartCsrRequestDefaultTypeInternal _StartCsrRequest_default_instance_;
class StartCsrResponse;
class StartCsrResponseDefaultTypeInternal;
POLICY_PROTO_EXPORT extern StartCsrResponseDefaultTypeInternal _StartCsrResponse_default_instance_;
class StatefulPartitionInfo;
class StatefulPartitionInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern StatefulPartitionInfoDefaultTypeInternal _StatefulPartitionInfo_default_instance_;
class StorageStatus;
class StorageStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern StorageStatusDefaultTypeInternal _StorageStatus_default_instance_;
class SystemFreeRamInfo;
class SystemFreeRamInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern SystemFreeRamInfoDefaultTypeInternal _SystemFreeRamInfo_default_instance_;
class SystemState;
class SystemStateDefaultTypeInternal;
POLICY_PROTO_EXPORT extern SystemStateDefaultTypeInternal _SystemState_default_instance_;
class SystemStatus;
class SystemStatusDefaultTypeInternal;
POLICY_PROTO_EXPORT extern SystemStatusDefaultTypeInternal _SystemStatus_default_instance_;
class ThermalInfo;
class ThermalInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ThermalInfoDefaultTypeInternal _ThermalInfo_default_instance_;
class ThermalSample;
class ThermalSampleDefaultTypeInternal;
POLICY_PROTO_EXPORT extern ThermalSampleDefaultTypeInternal _ThermalSample_default_instance_;
class TimePeriod;
class TimePeriodDefaultTypeInternal;
POLICY_PROTO_EXPORT extern TimePeriodDefaultTypeInternal _TimePeriod_default_instance_;
class TimezoneInfo;
class TimezoneInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern TimezoneInfoDefaultTypeInternal _TimezoneInfo_default_instance_;
class TpmStatusInfo;
class TpmStatusInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern TpmStatusInfoDefaultTypeInternal _TpmStatusInfo_default_instance_;
class TpmVersionInfo;
class TpmVersionInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern TpmVersionInfoDefaultTypeInternal _TpmVersionInfo_default_instance_;
class VolumeInfo;
class VolumeInfoDefaultTypeInternal;
POLICY_PROTO_EXPORT extern VolumeInfoDefaultTypeInternal _VolumeInfo_default_instance_;
}  // namespace enterprise_management
PROTOBUF_NAMESPACE_OPEN
template<> POLICY_PROTO_EXPORT ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ActiveDirectoryPlayActivityRequest* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ActiveDirectoryPlayActivityResponse* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ActiveDirectoryUserSigninRequest* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ActiveDirectoryUserSigninResponse* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ActiveTimePeriod* Arena::CreateMaybeMessage<::enterprise_management::ActiveTimePeriod>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AndroidAppInfo* Arena::CreateMaybeMessage<::enterprise_management::AndroidAppInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AndroidAppPermission* Arena::CreateMaybeMessage<::enterprise_management::AndroidAppPermission>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AndroidStatus* Arena::CreateMaybeMessage<::enterprise_management::AndroidStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::App* Arena::CreateMaybeMessage<::enterprise_management::App>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AppActivity* Arena::CreateMaybeMessage<::enterprise_management::AppActivity>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AppInfo* Arena::CreateMaybeMessage<::enterprise_management::AppInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AppInstallReport* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReport>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AppInstallReportLogEvent* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReportLogEvent>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AppInstallReportRequest* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AppInstallReportResponse* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReportResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::AppStatus* Arena::CreateMaybeMessage<::enterprise_management::AppStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::BacklightInfo* Arena::CreateMaybeMessage<::enterprise_management::BacklightInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::BatteryInfo* Arena::CreateMaybeMessage<::enterprise_management::BatteryInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::BatterySample* Arena::CreateMaybeMessage<::enterprise_management::BatterySample>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::BluetoothAdapterInfo* Arena::CreateMaybeMessage<::enterprise_management::BluetoothAdapterInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::BoardStatus* Arena::CreateMaybeMessage<::enterprise_management::BoardStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::BrowserReport* Arena::CreateMaybeMessage<::enterprise_management::BrowserReport>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CPUTempInfo* Arena::CreateMaybeMessage<::enterprise_management::CPUTempInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CertificateBasedDeviceRegisterRequest* Arena::CreateMaybeMessage<::enterprise_management::CertificateBasedDeviceRegisterRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CertificateBasedDeviceRegistrationData* Arena::CreateMaybeMessage<::enterprise_management::CertificateBasedDeviceRegistrationData>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CheckAndroidManagementRequest* Arena::CreateMaybeMessage<::enterprise_management::CheckAndroidManagementRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CheckAndroidManagementResponse* Arena::CreateMaybeMessage<::enterprise_management::CheckAndroidManagementResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CheckDeviceLicenseRequest* Arena::CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CheckDeviceLicenseResponse* Arena::CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CheckDevicePairingRequest* Arena::CreateMaybeMessage<::enterprise_management::CheckDevicePairingRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CheckDevicePairingResponse* Arena::CreateMaybeMessage<::enterprise_management::CheckDevicePairingResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChildStatusReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ChildStatusReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChildStatusReportResponse* Arena::CreateMaybeMessage<::enterprise_management::ChildStatusReportResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChromeDesktopReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ChromeDesktopReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChromeDesktopReportResponse* Arena::CreateMaybeMessage<::enterprise_management::ChromeDesktopReportResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChromeOsUserReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ChromeOsUserReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChromeOsUserReportResponse* Arena::CreateMaybeMessage<::enterprise_management::ChromeOsUserReportResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChromeSignedInUser* Arena::CreateMaybeMessage<::enterprise_management::ChromeSignedInUser>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChromeUserProfileInfo* Arena::CreateMaybeMessage<::enterprise_management::ChromeUserProfileInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ChromeUserProfileReport* Arena::CreateMaybeMessage<::enterprise_management::ChromeUserProfileReport>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ClientActionRequired* Arena::CreateMaybeMessage<::enterprise_management::ClientActionRequired>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ClientCertificateProvisioningRequest* Arena::CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ClientCertificateProvisioningResponse* Arena::CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CpuCStateInfo* Arena::CreateMaybeMessage<::enterprise_management::CpuCStateInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CpuInfo* Arena::CreateMaybeMessage<::enterprise_management::CpuInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CpuUtilizationInfo* Arena::CreateMaybeMessage<::enterprise_management::CpuUtilizationInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CrashReportInfo* Arena::CreateMaybeMessage<::enterprise_management::CrashReportInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CrostiniApp* Arena::CreateMaybeMessage<::enterprise_management::CrostiniApp>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CrostiniStatus* Arena::CreateMaybeMessage<::enterprise_management::CrostiniStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::CustomerLogo* Arena::CreateMaybeMessage<::enterprise_management::CustomerLogo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DEPRECATEDPolicyPublicKeyAndDomain* Arena::CreateMaybeMessage<::enterprise_management::DEPRECATEDPolicyPublicKeyAndDomain>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceAttributeUpdatePermissionRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceAttributeUpdatePermissionResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceAttributeUpdateRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceAttributeUpdateResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceAutoEnrollmentRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceAutoEnrollmentResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceCertUploadRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceCertUploadRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceCertUploadResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceCertUploadResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceInitialEnrollmentStateRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceInitialEnrollmentStateResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceManagementRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceManagementRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceManagementResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceManagementResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DevicePairingRequest* Arena::CreateMaybeMessage<::enterprise_management::DevicePairingRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DevicePairingResponse* Arena::CreateMaybeMessage<::enterprise_management::DevicePairingResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DevicePolicyRequest* Arena::CreateMaybeMessage<::enterprise_management::DevicePolicyRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DevicePolicyResponse* Arena::CreateMaybeMessage<::enterprise_management::DevicePolicyResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceRegisterConfiguration* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterConfiguration>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceRegisterIdentification* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterIdentification>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceRegisterRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceRegisterResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceRemoteCommandRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceRemoteCommandResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceServiceApiAccessRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceServiceApiAccessResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceState* Arena::CreateMaybeMessage<::enterprise_management::DeviceState>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceStateKeyUpdateRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateKeyUpdateRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceStateRetrievalInfo* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceStateRetrievalRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceStateRetrievalResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceStatusReportRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceStatusReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceStatusReportResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceStatusReportResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceUnregisterRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceUnregisterRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceUnregisterResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceUnregisterResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DeviceUser* Arena::CreateMaybeMessage<::enterprise_management::DeviceUser>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DisabledState* Arena::CreateMaybeMessage<::enterprise_management::DisabledState>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DiskInfo* Arena::CreateMaybeMessage<::enterprise_management::DiskInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DiskLifetimeEstimation* Arena::CreateMaybeMessage<::enterprise_management::DiskLifetimeEstimation>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DisplayInfo* Arena::CreateMaybeMessage<::enterprise_management::DisplayInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DownloadCertRequest* Arena::CreateMaybeMessage<::enterprise_management::DownloadCertRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::DownloadCertResponse* Arena::CreateMaybeMessage<::enterprise_management::DownloadCertResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::Extension* Arena::CreateMaybeMessage<::enterprise_management::Extension>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ExtensionInstallReport* Arena::CreateMaybeMessage<::enterprise_management::ExtensionInstallReport>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ExtensionInstallReportLogEvent* Arena::CreateMaybeMessage<::enterprise_management::ExtensionInstallReportLogEvent>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ExtensionInstallReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ExtensionInstallReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ExtensionPolicy* Arena::CreateMaybeMessage<::enterprise_management::ExtensionPolicy>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ExtensionRequest* Arena::CreateMaybeMessage<::enterprise_management::ExtensionRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::FanInfo* Arena::CreateMaybeMessage<::enterprise_management::FanInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::FinishCsrRequest* Arena::CreateMaybeMessage<::enterprise_management::FinishCsrRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::FinishCsrResponse* Arena::CreateMaybeMessage<::enterprise_management::FinishCsrResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::GcmIdUpdateRequest* Arena::CreateMaybeMessage<::enterprise_management::GcmIdUpdateRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::GcmIdUpdateResponse* Arena::CreateMaybeMessage<::enterprise_management::GcmIdUpdateResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::GlobalCpuInfo* Arena::CreateMaybeMessage<::enterprise_management::GlobalCpuInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::GraphicsAdapterInfo* Arena::CreateMaybeMessage<::enterprise_management::GraphicsAdapterInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::GraphicsStatus* Arena::CreateMaybeMessage<::enterprise_management::GraphicsStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::LicenseAvailability* Arena::CreateMaybeMessage<::enterprise_management::LicenseAvailability>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::LicenseType* Arena::CreateMaybeMessage<::enterprise_management::LicenseType>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::LogicalCpuInfo* Arena::CreateMaybeMessage<::enterprise_management::LogicalCpuInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::MemoryInfo* Arena::CreateMaybeMessage<::enterprise_management::MemoryInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::NetworkInterface* Arena::CreateMaybeMessage<::enterprise_management::NetworkInterface>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::NetworkState* Arena::CreateMaybeMessage<::enterprise_management::NetworkState>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::OSReport* Arena::CreateMaybeMessage<::enterprise_management::OSReport>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::OsUpdateStatus* Arena::CreateMaybeMessage<::enterprise_management::OsUpdateStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::Plugin* Arena::CreateMaybeMessage<::enterprise_management::Plugin>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::Policy* Arena::CreateMaybeMessage<::enterprise_management::Policy>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PolicyData* Arena::CreateMaybeMessage<::enterprise_management::PolicyData>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PolicyFetchRequest* Arena::CreateMaybeMessage<::enterprise_management::PolicyFetchRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PolicyFetchResponse* Arena::CreateMaybeMessage<::enterprise_management::PolicyFetchResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PolicyFetchTimestamp* Arena::CreateMaybeMessage<::enterprise_management::PolicyFetchTimestamp>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PolicyValidationReportRequest* Arena::CreateMaybeMessage<::enterprise_management::PolicyValidationReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PolicyValidationReportResponse* Arena::CreateMaybeMessage<::enterprise_management::PolicyValidationReportResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PolicyValueValidationIssue* Arena::CreateMaybeMessage<::enterprise_management::PolicyValueValidationIssue>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PowerStatus* Arena::CreateMaybeMessage<::enterprise_management::PowerStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PublicKeyVerificationData* Arena::CreateMaybeMessage<::enterprise_management::PublicKeyVerificationData>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PublicSamlUserRequest* Arena::CreateMaybeMessage<::enterprise_management::PublicSamlUserRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::PublicSamlUserResponse* Arena::CreateMaybeMessage<::enterprise_management::PublicSamlUserResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::RefreshAccountRequest* Arena::CreateMaybeMessage<::enterprise_management::RefreshAccountRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::RefreshAccountResponse* Arena::CreateMaybeMessage<::enterprise_management::RefreshAccountResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::RegisterBrowserRequest* Arena::CreateMaybeMessage<::enterprise_management::RegisterBrowserRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::RemoteCommand* Arena::CreateMaybeMessage<::enterprise_management::RemoteCommand>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::RemoteCommandResult* Arena::CreateMaybeMessage<::enterprise_management::RemoteCommandResult>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::RsuLookupKeyUploadRequest* Arena::CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::RsuLookupKeyUploadResponse* Arena::CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::SamlParametersProto* Arena::CreateMaybeMessage<::enterprise_management::SamlParametersProto>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ScreenTimeSpan* Arena::CreateMaybeMessage<::enterprise_management::ScreenTimeSpan>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::SessionStatusReportRequest* Arena::CreateMaybeMessage<::enterprise_management::SessionStatusReportRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::SessionStatusReportResponse* Arena::CreateMaybeMessage<::enterprise_management::SessionStatusReportResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::SignedData* Arena::CreateMaybeMessage<::enterprise_management::SignedData>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::StartCsrRequest* Arena::CreateMaybeMessage<::enterprise_management::StartCsrRequest>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::StartCsrResponse* Arena::CreateMaybeMessage<::enterprise_management::StartCsrResponse>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::StatefulPartitionInfo* Arena::CreateMaybeMessage<::enterprise_management::StatefulPartitionInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::StorageStatus* Arena::CreateMaybeMessage<::enterprise_management::StorageStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::SystemFreeRamInfo* Arena::CreateMaybeMessage<::enterprise_management::SystemFreeRamInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::SystemState* Arena::CreateMaybeMessage<::enterprise_management::SystemState>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::SystemStatus* Arena::CreateMaybeMessage<::enterprise_management::SystemStatus>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ThermalInfo* Arena::CreateMaybeMessage<::enterprise_management::ThermalInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::ThermalSample* Arena::CreateMaybeMessage<::enterprise_management::ThermalSample>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::TimePeriod* Arena::CreateMaybeMessage<::enterprise_management::TimePeriod>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::TimezoneInfo* Arena::CreateMaybeMessage<::enterprise_management::TimezoneInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::TpmStatusInfo* Arena::CreateMaybeMessage<::enterprise_management::TpmStatusInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::TpmVersionInfo* Arena::CreateMaybeMessage<::enterprise_management::TpmVersionInfo>(Arena*);
template<> POLICY_PROTO_EXPORT ::enterprise_management::VolumeInfo* Arena::CreateMaybeMessage<::enterprise_management::VolumeInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace enterprise_management {

enum LicenseType_LicenseTypeEnum : int {
LicenseType_LicenseTypeEnum_UNDEFINED = 0,
LicenseType_LicenseTypeEnum_CDM_PERPETUAL = 1,
LicenseType_LicenseTypeEnum_CDM_ANNUAL = 2,
LicenseType_LicenseTypeEnum_KIOSK = 3
};
POLICY_PROTO_EXPORT bool LicenseType_LicenseTypeEnum_IsValid(int value);
constexpr LicenseType_LicenseTypeEnum LicenseType_LicenseTypeEnum_LicenseTypeEnum_MIN = LicenseType_LicenseTypeEnum_UNDEFINED;
constexpr LicenseType_LicenseTypeEnum LicenseType_LicenseTypeEnum_LicenseTypeEnum_MAX = LicenseType_LicenseTypeEnum_KIOSK;
constexpr int LicenseType_LicenseTypeEnum_LicenseTypeEnum_ARRAYSIZE = LicenseType_LicenseTypeEnum_LicenseTypeEnum_MAX + 1;

const std::string& LicenseType_LicenseTypeEnum_Name(LicenseType_LicenseTypeEnum value);
template<typename T>
inline const std::string& LicenseType_LicenseTypeEnum_Name(T enum_t_value) {
static_assert(::std::is_same<T, LicenseType_LicenseTypeEnum>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function LicenseType_LicenseTypeEnum_Name.");
return LicenseType_LicenseTypeEnum_Name(static_cast<LicenseType_LicenseTypeEnum>(enum_t_value));
}
bool LicenseType_LicenseTypeEnum_Parse(
const std::string& name, LicenseType_LicenseTypeEnum* value);
enum DeviceRegisterRequest_Type : int {
DeviceRegisterRequest_Type_TT = 0,
DeviceRegisterRequest_Type_USER = 1,
DeviceRegisterRequest_Type_DEVICE = 2,
DeviceRegisterRequest_Type_BROWSER = 3,
DeviceRegisterRequest_Type_ANDROID_BROWSER = 4
};
POLICY_PROTO_EXPORT bool DeviceRegisterRequest_Type_IsValid(int value);
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest_Type_Type_MIN = DeviceRegisterRequest_Type_TT;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest_Type_Type_MAX = DeviceRegisterRequest_Type_ANDROID_BROWSER;
constexpr int DeviceRegisterRequest_Type_Type_ARRAYSIZE = DeviceRegisterRequest_Type_Type_MAX + 1;

const std::string& DeviceRegisterRequest_Type_Name(DeviceRegisterRequest_Type value);
template<typename T>
inline const std::string& DeviceRegisterRequest_Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceRegisterRequest_Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceRegisterRequest_Type_Name.");
return DeviceRegisterRequest_Type_Name(static_cast<DeviceRegisterRequest_Type>(enum_t_value));
}
bool DeviceRegisterRequest_Type_Parse(
const std::string& name, DeviceRegisterRequest_Type* value);
enum DeviceRegisterRequest_Flavor : int {
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL = 0,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL_RENEW = 1,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_FORCED = 2,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_ADVERTISED = 3,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_FORCED = 4,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_ADVERTISED = 5,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_RECOVERY = 6,
DeviceRegisterRequest_Flavor_FLAVOR_USER_REGISTRATION = 7,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION = 8,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED = 9,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED = 10,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK = 11,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_USB_ENROLLMENT = 12,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED = 13,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED = 14,
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK = 15
};
POLICY_PROTO_EXPORT bool DeviceRegisterRequest_Flavor_IsValid(int value);
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest_Flavor_Flavor_MIN = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest_Flavor_Flavor_MAX = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK;
constexpr int DeviceRegisterRequest_Flavor_Flavor_ARRAYSIZE = DeviceRegisterRequest_Flavor_Flavor_MAX + 1;

const std::string& DeviceRegisterRequest_Flavor_Name(DeviceRegisterRequest_Flavor value);
template<typename T>
inline const std::string& DeviceRegisterRequest_Flavor_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceRegisterRequest_Flavor>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceRegisterRequest_Flavor_Name.");
return DeviceRegisterRequest_Flavor_Name(static_cast<DeviceRegisterRequest_Flavor>(enum_t_value));
}
bool DeviceRegisterRequest_Flavor_Parse(
const std::string& name, DeviceRegisterRequest_Flavor* value);
enum DeviceRegisterRequest_Lifetime : int {
DeviceRegisterRequest_Lifetime_LIFETIME_UNDEFINED = 0,
DeviceRegisterRequest_Lifetime_LIFETIME_INDEFINITE = 1,
DeviceRegisterRequest_Lifetime_LIFETIME_EPHEMERAL_USER = 2
};
POLICY_PROTO_EXPORT bool DeviceRegisterRequest_Lifetime_IsValid(int value);
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest_Lifetime_Lifetime_MIN = DeviceRegisterRequest_Lifetime_LIFETIME_UNDEFINED;
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest_Lifetime_Lifetime_MAX = DeviceRegisterRequest_Lifetime_LIFETIME_EPHEMERAL_USER;
constexpr int DeviceRegisterRequest_Lifetime_Lifetime_ARRAYSIZE = DeviceRegisterRequest_Lifetime_Lifetime_MAX + 1;

const std::string& DeviceRegisterRequest_Lifetime_Name(DeviceRegisterRequest_Lifetime value);
template<typename T>
inline const std::string& DeviceRegisterRequest_Lifetime_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceRegisterRequest_Lifetime>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceRegisterRequest_Lifetime_Name.");
return DeviceRegisterRequest_Lifetime_Name(static_cast<DeviceRegisterRequest_Lifetime>(enum_t_value));
}
bool DeviceRegisterRequest_Lifetime_Parse(
const std::string& name, DeviceRegisterRequest_Lifetime* value);
enum DeviceRegisterResponse_DeviceMode : int {
DeviceRegisterResponse_DeviceMode_ENTERPRISE = 0,
DeviceRegisterResponse_DeviceMode_RETAIL_DEPRECATED = 1,
DeviceRegisterResponse_DeviceMode_CHROME_AD = 2,
DeviceRegisterResponse_DeviceMode_DEMO = 3
};
POLICY_PROTO_EXPORT bool DeviceRegisterResponse_DeviceMode_IsValid(int value);
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse_DeviceMode_DeviceMode_MIN = DeviceRegisterResponse_DeviceMode_ENTERPRISE;
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse_DeviceMode_DeviceMode_MAX = DeviceRegisterResponse_DeviceMode_DEMO;
constexpr int DeviceRegisterResponse_DeviceMode_DeviceMode_ARRAYSIZE = DeviceRegisterResponse_DeviceMode_DeviceMode_MAX + 1;

const std::string& DeviceRegisterResponse_DeviceMode_Name(DeviceRegisterResponse_DeviceMode value);
template<typename T>
inline const std::string& DeviceRegisterResponse_DeviceMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceRegisterResponse_DeviceMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceRegisterResponse_DeviceMode_Name.");
return DeviceRegisterResponse_DeviceMode_Name(static_cast<DeviceRegisterResponse_DeviceMode>(enum_t_value));
}
bool DeviceRegisterResponse_DeviceMode_Parse(
const std::string& name, DeviceRegisterResponse_DeviceMode* value);
enum DeviceCertUploadRequest_CertificateType : int {
DeviceCertUploadRequest_CertificateType_CERTIFICATE_TYPE_UNSPECIFIED = 0,
DeviceCertUploadRequest_CertificateType_ENTERPRISE_MACHINE_CERTIFICATE = 1,
DeviceCertUploadRequest_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE = 2
};
POLICY_PROTO_EXPORT bool DeviceCertUploadRequest_CertificateType_IsValid(int value);
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest_CertificateType_CertificateType_MIN = DeviceCertUploadRequest_CertificateType_CERTIFICATE_TYPE_UNSPECIFIED;
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest_CertificateType_CertificateType_MAX = DeviceCertUploadRequest_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
constexpr int DeviceCertUploadRequest_CertificateType_CertificateType_ARRAYSIZE = DeviceCertUploadRequest_CertificateType_CertificateType_MAX + 1;

const std::string& DeviceCertUploadRequest_CertificateType_Name(DeviceCertUploadRequest_CertificateType value);
template<typename T>
inline const std::string& DeviceCertUploadRequest_CertificateType_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceCertUploadRequest_CertificateType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceCertUploadRequest_CertificateType_Name.");
return DeviceCertUploadRequest_CertificateType_Name(static_cast<DeviceCertUploadRequest_CertificateType>(enum_t_value));
}
bool DeviceCertUploadRequest_CertificateType_Parse(
const std::string& name, DeviceCertUploadRequest_CertificateType* value);
enum DeviceServiceApiAccessRequest_DeviceType : int {
DeviceServiceApiAccessRequest_DeviceType_CHROME_OS = 0,
DeviceServiceApiAccessRequest_DeviceType_ANDROID_OS = 1,
DeviceServiceApiAccessRequest_DeviceType_CHROME_OS_DEMO_MODE = 2,
DeviceServiceApiAccessRequest_DeviceType_CHROME_BROWSER = 3
};
POLICY_PROTO_EXPORT bool DeviceServiceApiAccessRequest_DeviceType_IsValid(int value);
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest_DeviceType_DeviceType_MIN = DeviceServiceApiAccessRequest_DeviceType_CHROME_OS;
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX = DeviceServiceApiAccessRequest_DeviceType_CHROME_BROWSER;
constexpr int DeviceServiceApiAccessRequest_DeviceType_DeviceType_ARRAYSIZE = DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX + 1;

const std::string& DeviceServiceApiAccessRequest_DeviceType_Name(DeviceServiceApiAccessRequest_DeviceType value);
template<typename T>
inline const std::string& DeviceServiceApiAccessRequest_DeviceType_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceServiceApiAccessRequest_DeviceType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceServiceApiAccessRequest_DeviceType_Name.");
return DeviceServiceApiAccessRequest_DeviceType_Name(static_cast<DeviceServiceApiAccessRequest_DeviceType>(enum_t_value));
}
bool DeviceServiceApiAccessRequest_DeviceType_Parse(
const std::string& name, DeviceServiceApiAccessRequest_DeviceType* value);
enum PolicyFetchRequest_SignatureType : int {
PolicyFetchRequest_SignatureType_NONE = 0,
PolicyFetchRequest_SignatureType_SHA1_RSA = 1,
PolicyFetchRequest_SignatureType_SHA256_RSA = 2
};
POLICY_PROTO_EXPORT bool PolicyFetchRequest_SignatureType_IsValid(int value);
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest_SignatureType_SignatureType_MIN = PolicyFetchRequest_SignatureType_NONE;
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest_SignatureType_SignatureType_MAX = PolicyFetchRequest_SignatureType_SHA256_RSA;
constexpr int PolicyFetchRequest_SignatureType_SignatureType_ARRAYSIZE = PolicyFetchRequest_SignatureType_SignatureType_MAX + 1;

const std::string& PolicyFetchRequest_SignatureType_Name(PolicyFetchRequest_SignatureType value);
template<typename T>
inline const std::string& PolicyFetchRequest_SignatureType_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyFetchRequest_SignatureType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyFetchRequest_SignatureType_Name.");
return PolicyFetchRequest_SignatureType_Name(static_cast<PolicyFetchRequest_SignatureType>(enum_t_value));
}
bool PolicyFetchRequest_SignatureType_Parse(
const std::string& name, PolicyFetchRequest_SignatureType* value);
enum DeviceState_DeviceMode : int {
DeviceState_DeviceMode_DEVICE_MODE_NORMAL = 0,
DeviceState_DeviceMode_DEVICE_MODE_DISABLED = 1
};
POLICY_PROTO_EXPORT bool DeviceState_DeviceMode_IsValid(int value);
constexpr DeviceState_DeviceMode DeviceState_DeviceMode_DeviceMode_MIN = DeviceState_DeviceMode_DEVICE_MODE_NORMAL;
constexpr DeviceState_DeviceMode DeviceState_DeviceMode_DeviceMode_MAX = DeviceState_DeviceMode_DEVICE_MODE_DISABLED;
constexpr int DeviceState_DeviceMode_DeviceMode_ARRAYSIZE = DeviceState_DeviceMode_DeviceMode_MAX + 1;

const std::string& DeviceState_DeviceMode_Name(DeviceState_DeviceMode value);
template<typename T>
inline const std::string& DeviceState_DeviceMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceState_DeviceMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceState_DeviceMode_Name.");
return DeviceState_DeviceMode_Name(static_cast<DeviceState_DeviceMode>(enum_t_value));
}
bool DeviceState_DeviceMode_Parse(
const std::string& name, DeviceState_DeviceMode* value);
enum PolicyData_AssociationState : int {
PolicyData_AssociationState_ACTIVE = 0,
PolicyData_AssociationState_UNMANAGED = 1,
PolicyData_AssociationState_DEPROVISIONED = 2
};
POLICY_PROTO_EXPORT bool PolicyData_AssociationState_IsValid(int value);
constexpr PolicyData_AssociationState PolicyData_AssociationState_AssociationState_MIN = PolicyData_AssociationState_ACTIVE;
constexpr PolicyData_AssociationState PolicyData_AssociationState_AssociationState_MAX = PolicyData_AssociationState_DEPROVISIONED;
constexpr int PolicyData_AssociationState_AssociationState_ARRAYSIZE = PolicyData_AssociationState_AssociationState_MAX + 1;

const std::string& PolicyData_AssociationState_Name(PolicyData_AssociationState value);
template<typename T>
inline const std::string& PolicyData_AssociationState_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyData_AssociationState>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyData_AssociationState_Name.");
return PolicyData_AssociationState_Name(static_cast<PolicyData_AssociationState>(enum_t_value));
}
bool PolicyData_AssociationState_Parse(
const std::string& name, PolicyData_AssociationState* value);
enum PolicyData_ManagementMode : int {
PolicyData_ManagementMode_LOCAL_OWNER = 0,
PolicyData_ManagementMode_ENTERPRISE_MANAGED = 1,
PolicyData_ManagementMode_OBSOLETE_CONSUMER_MANAGED = 2
};
POLICY_PROTO_EXPORT bool PolicyData_ManagementMode_IsValid(int value);
constexpr PolicyData_ManagementMode PolicyData_ManagementMode_ManagementMode_MIN = PolicyData_ManagementMode_LOCAL_OWNER;
constexpr PolicyData_ManagementMode PolicyData_ManagementMode_ManagementMode_MAX = PolicyData_ManagementMode_OBSOLETE_CONSUMER_MANAGED;
constexpr int PolicyData_ManagementMode_ManagementMode_ARRAYSIZE = PolicyData_ManagementMode_ManagementMode_MAX + 1;

const std::string& PolicyData_ManagementMode_Name(PolicyData_ManagementMode value);
template<typename T>
inline const std::string& PolicyData_ManagementMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyData_ManagementMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyData_ManagementMode_Name.");
return PolicyData_ManagementMode_Name(static_cast<PolicyData_ManagementMode>(enum_t_value));
}
bool PolicyData_ManagementMode_Parse(
const std::string& name, PolicyData_ManagementMode* value);
enum PolicyData_MarketSegment : int {
PolicyData_MarketSegment_MARKET_SEGMENT_UNSPECIFIED = 0,
PolicyData_MarketSegment_ENROLLED_EDUCATION = 1,
PolicyData_MarketSegment_ENROLLED_ENTERPRISE = 2
};
POLICY_PROTO_EXPORT bool PolicyData_MarketSegment_IsValid(int value);
constexpr PolicyData_MarketSegment PolicyData_MarketSegment_MarketSegment_MIN = PolicyData_MarketSegment_MARKET_SEGMENT_UNSPECIFIED;
constexpr PolicyData_MarketSegment PolicyData_MarketSegment_MarketSegment_MAX = PolicyData_MarketSegment_ENROLLED_ENTERPRISE;
constexpr int PolicyData_MarketSegment_MarketSegment_ARRAYSIZE = PolicyData_MarketSegment_MarketSegment_MAX + 1;

const std::string& PolicyData_MarketSegment_Name(PolicyData_MarketSegment value);
template<typename T>
inline const std::string& PolicyData_MarketSegment_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyData_MarketSegment>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyData_MarketSegment_Name.");
return PolicyData_MarketSegment_Name(static_cast<PolicyData_MarketSegment>(enum_t_value));
}
bool PolicyData_MarketSegment_Parse(
const std::string& name, PolicyData_MarketSegment* value);
enum NetworkInterface_NetworkDeviceType : int {
NetworkInterface_NetworkDeviceType_TYPE_ETHERNET = 0,
NetworkInterface_NetworkDeviceType_TYPE_WIFI = 1,
NetworkInterface_NetworkDeviceType_TYPE_BLUETOOTH = 3,
NetworkInterface_NetworkDeviceType_TYPE_CELLULAR = 4
};
POLICY_PROTO_EXPORT bool NetworkInterface_NetworkDeviceType_IsValid(int value);
constexpr NetworkInterface_NetworkDeviceType NetworkInterface_NetworkDeviceType_NetworkDeviceType_MIN = NetworkInterface_NetworkDeviceType_TYPE_ETHERNET;
constexpr NetworkInterface_NetworkDeviceType NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX = NetworkInterface_NetworkDeviceType_TYPE_CELLULAR;
constexpr int NetworkInterface_NetworkDeviceType_NetworkDeviceType_ARRAYSIZE = NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX + 1;

const std::string& NetworkInterface_NetworkDeviceType_Name(NetworkInterface_NetworkDeviceType value);
template<typename T>
inline const std::string& NetworkInterface_NetworkDeviceType_Name(T enum_t_value) {
static_assert(::std::is_same<T, NetworkInterface_NetworkDeviceType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function NetworkInterface_NetworkDeviceType_Name.");
return NetworkInterface_NetworkDeviceType_Name(static_cast<NetworkInterface_NetworkDeviceType>(enum_t_value));
}
bool NetworkInterface_NetworkDeviceType_Parse(
const std::string& name, NetworkInterface_NetworkDeviceType* value);
enum NetworkState_ConnectionState : int {
NetworkState_ConnectionState_IDLE = 0,
NetworkState_ConnectionState_CARRIER = 1,
NetworkState_ConnectionState_ASSOCIATION = 2,
NetworkState_ConnectionState_CONFIGURATION = 3,
NetworkState_ConnectionState_READY = 4,
NetworkState_ConnectionState_PORTAL = 5,
NetworkState_ConnectionState_OFFLINE = 6,
NetworkState_ConnectionState_ONLINE = 7,
NetworkState_ConnectionState_DISCONNECT = 8,
NetworkState_ConnectionState_FAILURE = 9,
NetworkState_ConnectionState_ACTIVATION_FAILURE = 10,
NetworkState_ConnectionState_UNKNOWN = 11
};
POLICY_PROTO_EXPORT bool NetworkState_ConnectionState_IsValid(int value);
constexpr NetworkState_ConnectionState NetworkState_ConnectionState_ConnectionState_MIN = NetworkState_ConnectionState_IDLE;
constexpr NetworkState_ConnectionState NetworkState_ConnectionState_ConnectionState_MAX = NetworkState_ConnectionState_UNKNOWN;
constexpr int NetworkState_ConnectionState_ConnectionState_ARRAYSIZE = NetworkState_ConnectionState_ConnectionState_MAX + 1;

const std::string& NetworkState_ConnectionState_Name(NetworkState_ConnectionState value);
template<typename T>
inline const std::string& NetworkState_ConnectionState_Name(T enum_t_value) {
static_assert(::std::is_same<T, NetworkState_ConnectionState>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function NetworkState_ConnectionState_Name.");
return NetworkState_ConnectionState_Name(static_cast<NetworkState_ConnectionState>(enum_t_value));
}
bool NetworkState_ConnectionState_Parse(
const std::string& name, NetworkState_ConnectionState* value);
enum DeviceUser_UserType : int {
DeviceUser_UserType_USER_TYPE_MANAGED = 0,
DeviceUser_UserType_USER_TYPE_UNMANAGED = 1
};
POLICY_PROTO_EXPORT bool DeviceUser_UserType_IsValid(int value);
constexpr DeviceUser_UserType DeviceUser_UserType_UserType_MIN = DeviceUser_UserType_USER_TYPE_MANAGED;
constexpr DeviceUser_UserType DeviceUser_UserType_UserType_MAX = DeviceUser_UserType_USER_TYPE_UNMANAGED;
constexpr int DeviceUser_UserType_UserType_ARRAYSIZE = DeviceUser_UserType_UserType_MAX + 1;

const std::string& DeviceUser_UserType_Name(DeviceUser_UserType value);
template<typename T>
inline const std::string& DeviceUser_UserType_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceUser_UserType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceUser_UserType_Name.");
return DeviceUser_UserType_Name(static_cast<DeviceUser_UserType>(enum_t_value));
}
bool DeviceUser_UserType_Parse(
const std::string& name, DeviceUser_UserType* value);
enum PowerStatus_PowerSource : int {
PowerStatus_PowerSource_POWER_UNKNOWN = 0,
PowerStatus_PowerSource_POWER_AC = 1,
PowerStatus_PowerSource_POWER_BATTERY = 2
};
POLICY_PROTO_EXPORT bool PowerStatus_PowerSource_IsValid(int value);
constexpr PowerStatus_PowerSource PowerStatus_PowerSource_PowerSource_MIN = PowerStatus_PowerSource_POWER_UNKNOWN;
constexpr PowerStatus_PowerSource PowerStatus_PowerSource_PowerSource_MAX = PowerStatus_PowerSource_POWER_BATTERY;
constexpr int PowerStatus_PowerSource_PowerSource_ARRAYSIZE = PowerStatus_PowerSource_PowerSource_MAX + 1;

const std::string& PowerStatus_PowerSource_Name(PowerStatus_PowerSource value);
template<typename T>
inline const std::string& PowerStatus_PowerSource_Name(T enum_t_value) {
static_assert(::std::is_same<T, PowerStatus_PowerSource>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PowerStatus_PowerSource_Name.");
return PowerStatus_PowerSource_Name(static_cast<PowerStatus_PowerSource>(enum_t_value));
}
bool PowerStatus_PowerSource_Parse(
const std::string& name, PowerStatus_PowerSource* value);
enum CpuInfo_Architecture : int {
CpuInfo_Architecture_ARCHITECTURE_UNSPECIFIED = 0,
CpuInfo_Architecture_X86_64 = 1,
CpuInfo_Architecture_AARCH64 = 2,
CpuInfo_Architecture_ARMV7L = 3
};
POLICY_PROTO_EXPORT bool CpuInfo_Architecture_IsValid(int value);
constexpr CpuInfo_Architecture CpuInfo_Architecture_Architecture_MIN = CpuInfo_Architecture_ARCHITECTURE_UNSPECIFIED;
constexpr CpuInfo_Architecture CpuInfo_Architecture_Architecture_MAX = CpuInfo_Architecture_ARMV7L;
constexpr int CpuInfo_Architecture_Architecture_ARRAYSIZE = CpuInfo_Architecture_Architecture_MAX + 1;

const std::string& CpuInfo_Architecture_Name(CpuInfo_Architecture value);
template<typename T>
inline const std::string& CpuInfo_Architecture_Name(T enum_t_value) {
static_assert(::std::is_same<T, CpuInfo_Architecture>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CpuInfo_Architecture_Name.");
return CpuInfo_Architecture_Name(static_cast<CpuInfo_Architecture>(enum_t_value));
}
bool CpuInfo_Architecture_Parse(
const std::string& name, CpuInfo_Architecture* value);
enum CrashReportInfo_CrashReportUploadStatus : int {
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UNKNOWN = 0,
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_NOT_UPLOADED = 1,
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING = 2,
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING_USER_REQUESTED = 3,
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UPLOADED = 4
};
POLICY_PROTO_EXPORT bool CrashReportInfo_CrashReportUploadStatus_IsValid(int value);
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MIN = CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UNKNOWN;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MAX = CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UPLOADED;
constexpr int CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_ARRAYSIZE = CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MAX + 1;

const std::string& CrashReportInfo_CrashReportUploadStatus_Name(CrashReportInfo_CrashReportUploadStatus value);
template<typename T>
inline const std::string& CrashReportInfo_CrashReportUploadStatus_Name(T enum_t_value) {
static_assert(::std::is_same<T, CrashReportInfo_CrashReportUploadStatus>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CrashReportInfo_CrashReportUploadStatus_Name.");
return CrashReportInfo_CrashReportUploadStatus_Name(static_cast<CrashReportInfo_CrashReportUploadStatus>(enum_t_value));
}
bool CrashReportInfo_CrashReportUploadStatus_Parse(
const std::string& name, CrashReportInfo_CrashReportUploadStatus* value);
enum OsUpdateStatus_UpdateStatus : int {
OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE = 0,
OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_NOT_STARTED = 1,
OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_IN_PROGRESS = 2,
OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT = 3
};
POLICY_PROTO_EXPORT bool OsUpdateStatus_UpdateStatus_IsValid(int value);
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus_UpdateStatus_UpdateStatus_MIN = OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE;
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus_UpdateStatus_UpdateStatus_MAX = OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT;
constexpr int OsUpdateStatus_UpdateStatus_UpdateStatus_ARRAYSIZE = OsUpdateStatus_UpdateStatus_UpdateStatus_MAX + 1;

const std::string& OsUpdateStatus_UpdateStatus_Name(OsUpdateStatus_UpdateStatus value);
template<typename T>
inline const std::string& OsUpdateStatus_UpdateStatus_Name(T enum_t_value) {
static_assert(::std::is_same<T, OsUpdateStatus_UpdateStatus>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function OsUpdateStatus_UpdateStatus_Name.");
return OsUpdateStatus_UpdateStatus_Name(static_cast<OsUpdateStatus_UpdateStatus>(enum_t_value));
}
bool OsUpdateStatus_UpdateStatus_Parse(
const std::string& name, OsUpdateStatus_UpdateStatus* value);
enum AppInfo_AppType : int {
AppInfo_AppType_TYPE_UNKNOWN = 0,
AppInfo_AppType_TYPE_ARC = 1,
AppInfo_AppType_TYPE_BUILTIN = 2,
AppInfo_AppType_TYPE_CROSTINI = 3,
AppInfo_AppType_TYPE_EXTENSION = 4,
AppInfo_AppType_TYPE_WEB = 5,
AppInfo_AppType_TYPE_PLUGINVM = 6
};
POLICY_PROTO_EXPORT bool AppInfo_AppType_IsValid(int value);
constexpr AppInfo_AppType AppInfo_AppType_AppType_MIN = AppInfo_AppType_TYPE_UNKNOWN;
constexpr AppInfo_AppType AppInfo_AppType_AppType_MAX = AppInfo_AppType_TYPE_PLUGINVM;
constexpr int AppInfo_AppType_AppType_ARRAYSIZE = AppInfo_AppType_AppType_MAX + 1;

const std::string& AppInfo_AppType_Name(AppInfo_AppType value);
template<typename T>
inline const std::string& AppInfo_AppType_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppInfo_AppType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppInfo_AppType_Name.");
return AppInfo_AppType_Name(static_cast<AppInfo_AppType>(enum_t_value));
}
bool AppInfo_AppType_Parse(
const std::string& name, AppInfo_AppType* value);
enum AppInfo_Status : int {
AppInfo_Status_STATUS_UNKNOWN = 0,
AppInfo_Status_STATUS_INSTALLED = 1,
AppInfo_Status_STATUS_DISABLED = 2,
AppInfo_Status_STATUS_UNINSTALLED = 3
};
POLICY_PROTO_EXPORT bool AppInfo_Status_IsValid(int value);
constexpr AppInfo_Status AppInfo_Status_Status_MIN = AppInfo_Status_STATUS_UNKNOWN;
constexpr AppInfo_Status AppInfo_Status_Status_MAX = AppInfo_Status_STATUS_UNINSTALLED;
constexpr int AppInfo_Status_Status_ARRAYSIZE = AppInfo_Status_Status_MAX + 1;

const std::string& AppInfo_Status_Name(AppInfo_Status value);
template<typename T>
inline const std::string& AppInfo_Status_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppInfo_Status>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppInfo_Status_Name.");
return AppInfo_Status_Name(static_cast<AppInfo_Status>(enum_t_value));
}
bool AppInfo_Status_Parse(
const std::string& name, AppInfo_Status* value);
enum AndroidAppInfo_AndroidAppStatus : int {
AndroidAppInfo_AndroidAppStatus_STATUS_UNKNOWN = 0,
AndroidAppInfo_AndroidAppStatus_STATUS_ENABLED = 1,
AndroidAppInfo_AndroidAppStatus_STATUS_SUSPENDED = 2,
AndroidAppInfo_AndroidAppStatus_STATUS_DISABLED = 3
};
POLICY_PROTO_EXPORT bool AndroidAppInfo_AndroidAppStatus_IsValid(int value);
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MIN = AndroidAppInfo_AndroidAppStatus_STATUS_UNKNOWN;
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MAX = AndroidAppInfo_AndroidAppStatus_STATUS_DISABLED;
constexpr int AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_ARRAYSIZE = AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MAX + 1;

const std::string& AndroidAppInfo_AndroidAppStatus_Name(AndroidAppInfo_AndroidAppStatus value);
template<typename T>
inline const std::string& AndroidAppInfo_AndroidAppStatus_Name(T enum_t_value) {
static_assert(::std::is_same<T, AndroidAppInfo_AndroidAppStatus>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AndroidAppInfo_AndroidAppStatus_Name.");
return AndroidAppInfo_AndroidAppStatus_Name(static_cast<AndroidAppInfo_AndroidAppStatus>(enum_t_value));
}
bool AndroidAppInfo_AndroidAppStatus_Parse(
const std::string& name, AndroidAppInfo_AndroidAppStatus* value);
enum AndroidAppInfo_InstalledSource : int {
AndroidAppInfo_InstalledSource_SOURCE_UNKNOWN = 0,
AndroidAppInfo_InstalledSource_SOURCE_BY_ADMIN = 1,
AndroidAppInfo_InstalledSource_SOURCE_BY_USER = 2,
AndroidAppInfo_InstalledSource_SOURCE_NOT_INSTALLED = 3
};
POLICY_PROTO_EXPORT bool AndroidAppInfo_InstalledSource_IsValid(int value);
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo_InstalledSource_InstalledSource_MIN = AndroidAppInfo_InstalledSource_SOURCE_UNKNOWN;
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo_InstalledSource_InstalledSource_MAX = AndroidAppInfo_InstalledSource_SOURCE_NOT_INSTALLED;
constexpr int AndroidAppInfo_InstalledSource_InstalledSource_ARRAYSIZE = AndroidAppInfo_InstalledSource_InstalledSource_MAX + 1;

const std::string& AndroidAppInfo_InstalledSource_Name(AndroidAppInfo_InstalledSource value);
template<typename T>
inline const std::string& AndroidAppInfo_InstalledSource_Name(T enum_t_value) {
static_assert(::std::is_same<T, AndroidAppInfo_InstalledSource>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AndroidAppInfo_InstalledSource_Name.");
return AndroidAppInfo_InstalledSource_Name(static_cast<AndroidAppInfo_InstalledSource>(enum_t_value));
}
bool AndroidAppInfo_InstalledSource_Parse(
const std::string& name, AndroidAppInfo_InstalledSource* value);
enum Extension_ExtensionType : int {
Extension_ExtensionType_TYPE_UNKNOWN = 0,
Extension_ExtensionType_TYPE_EXTENSION = 1,
Extension_ExtensionType_TYPE_HOSTED_APP = 2,
Extension_ExtensionType_TYPE_PACKAGED_APP = 3,
Extension_ExtensionType_TYPE_LEGACY_PACKAGED_APP = 4,
Extension_ExtensionType_TYPE_THEME = 5,
Extension_ExtensionType_TYPE_USER_SCRIPT = 6,
Extension_ExtensionType_TYPE_PLATFORM_APP = 7,
Extension_ExtensionType_TYPE_LOGIN_SCREEN_EXTENSION = 8
};
POLICY_PROTO_EXPORT bool Extension_ExtensionType_IsValid(int value);
constexpr Extension_ExtensionType Extension_ExtensionType_ExtensionType_MIN = Extension_ExtensionType_TYPE_UNKNOWN;
constexpr Extension_ExtensionType Extension_ExtensionType_ExtensionType_MAX = Extension_ExtensionType_TYPE_LOGIN_SCREEN_EXTENSION;
constexpr int Extension_ExtensionType_ExtensionType_ARRAYSIZE = Extension_ExtensionType_ExtensionType_MAX + 1;

const std::string& Extension_ExtensionType_Name(Extension_ExtensionType value);
template<typename T>
inline const std::string& Extension_ExtensionType_Name(T enum_t_value) {
static_assert(::std::is_same<T, Extension_ExtensionType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Extension_ExtensionType_Name.");
return Extension_ExtensionType_Name(static_cast<Extension_ExtensionType>(enum_t_value));
}
bool Extension_ExtensionType_Parse(
const std::string& name, Extension_ExtensionType* value);
enum Extension_InstallType : int {
Extension_InstallType_TYPE_NORMAL = 0,
Extension_InstallType_TYPE_DEVELOPMENT = 1,
Extension_InstallType_TYPE_SIDELOAD = 2,
Extension_InstallType_TYPE_ADMIN = 3,
Extension_InstallType_TYPE_OTHER = 4
};
POLICY_PROTO_EXPORT bool Extension_InstallType_IsValid(int value);
constexpr Extension_InstallType Extension_InstallType_InstallType_MIN = Extension_InstallType_TYPE_NORMAL;
constexpr Extension_InstallType Extension_InstallType_InstallType_MAX = Extension_InstallType_TYPE_OTHER;
constexpr int Extension_InstallType_InstallType_ARRAYSIZE = Extension_InstallType_InstallType_MAX + 1;

const std::string& Extension_InstallType_Name(Extension_InstallType value);
template<typename T>
inline const std::string& Extension_InstallType_Name(T enum_t_value) {
static_assert(::std::is_same<T, Extension_InstallType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Extension_InstallType_Name.");
return Extension_InstallType_Name(static_cast<Extension_InstallType>(enum_t_value));
}
bool Extension_InstallType_Parse(
const std::string& name, Extension_InstallType* value);
enum Policy_PolicyLevel : int {
Policy_PolicyLevel_LEVEL_UNKNOWN = 0,
Policy_PolicyLevel_LEVEL_RECOMMENDED = 1,
Policy_PolicyLevel_LEVEL_MANDATORY = 2
};
POLICY_PROTO_EXPORT bool Policy_PolicyLevel_IsValid(int value);
constexpr Policy_PolicyLevel Policy_PolicyLevel_PolicyLevel_MIN = Policy_PolicyLevel_LEVEL_UNKNOWN;
constexpr Policy_PolicyLevel Policy_PolicyLevel_PolicyLevel_MAX = Policy_PolicyLevel_LEVEL_MANDATORY;
constexpr int Policy_PolicyLevel_PolicyLevel_ARRAYSIZE = Policy_PolicyLevel_PolicyLevel_MAX + 1;

const std::string& Policy_PolicyLevel_Name(Policy_PolicyLevel value);
template<typename T>
inline const std::string& Policy_PolicyLevel_Name(T enum_t_value) {
static_assert(::std::is_same<T, Policy_PolicyLevel>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Policy_PolicyLevel_Name.");
return Policy_PolicyLevel_Name(static_cast<Policy_PolicyLevel>(enum_t_value));
}
bool Policy_PolicyLevel_Parse(
const std::string& name, Policy_PolicyLevel* value);
enum Policy_PolicyScope : int {
Policy_PolicyScope_SCOPE_UNKNOWN = 0,
Policy_PolicyScope_SCOPE_USER = 1,
Policy_PolicyScope_SCOPE_MACHINE = 2
};
POLICY_PROTO_EXPORT bool Policy_PolicyScope_IsValid(int value);
constexpr Policy_PolicyScope Policy_PolicyScope_PolicyScope_MIN = Policy_PolicyScope_SCOPE_UNKNOWN;
constexpr Policy_PolicyScope Policy_PolicyScope_PolicyScope_MAX = Policy_PolicyScope_SCOPE_MACHINE;
constexpr int Policy_PolicyScope_PolicyScope_ARRAYSIZE = Policy_PolicyScope_PolicyScope_MAX + 1;

const std::string& Policy_PolicyScope_Name(Policy_PolicyScope value);
template<typename T>
inline const std::string& Policy_PolicyScope_Name(T enum_t_value) {
static_assert(::std::is_same<T, Policy_PolicyScope>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Policy_PolicyScope_Name.");
return Policy_PolicyScope_Name(static_cast<Policy_PolicyScope>(enum_t_value));
}
bool Policy_PolicyScope_Parse(
const std::string& name, Policy_PolicyScope* value);
enum Policy_PolicySource : int {
Policy_PolicySource_SOURCE_UNKNOWN = 0,
Policy_PolicySource_SOURCE_ENTERPRISE_DEFAULT = 1,
Policy_PolicySource_SOURCE_CLOUD = 2,
Policy_PolicySource_SOURCE_ACTIVE_DIRECTORY = 3,
Policy_PolicySource_SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE = 4,
Policy_PolicySource_SOURCE_PLATFORM = 5,
Policy_PolicySource_SOURCE_PRIORITY_CLOUD = 6,
Policy_PolicySource_SOURCE_MERGED = 7
};
POLICY_PROTO_EXPORT bool Policy_PolicySource_IsValid(int value);
constexpr Policy_PolicySource Policy_PolicySource_PolicySource_MIN = Policy_PolicySource_SOURCE_UNKNOWN;
constexpr Policy_PolicySource Policy_PolicySource_PolicySource_MAX = Policy_PolicySource_SOURCE_MERGED;
constexpr int Policy_PolicySource_PolicySource_ARRAYSIZE = Policy_PolicySource_PolicySource_MAX + 1;

const std::string& Policy_PolicySource_Name(Policy_PolicySource value);
template<typename T>
inline const std::string& Policy_PolicySource_Name(T enum_t_value) {
static_assert(::std::is_same<T, Policy_PolicySource>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Policy_PolicySource_Name.");
return Policy_PolicySource_Name(static_cast<Policy_PolicySource>(enum_t_value));
}
bool Policy_PolicySource_Parse(
const std::string& name, Policy_PolicySource* value);
enum PolicyValueValidationIssue_ValueValidationIssueSeverity : int {
PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED = 0,
PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_WARNING = 1,
PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_ERROR = 2
};
POLICY_PROTO_EXPORT bool PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(int value);
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MIN = PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED;
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MAX = PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_ERROR;
constexpr int PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_ARRAYSIZE = PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MAX + 1;

const std::string& PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(PolicyValueValidationIssue_ValueValidationIssueSeverity value);
template<typename T>
inline const std::string& PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyValueValidationIssue_ValueValidationIssueSeverity>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyValueValidationIssue_ValueValidationIssueSeverity_Name.");
return PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(static_cast<PolicyValueValidationIssue_ValueValidationIssueSeverity>(enum_t_value));
}
bool PolicyValueValidationIssue_ValueValidationIssueSeverity_Parse(
const std::string& name, PolicyValueValidationIssue_ValueValidationIssueSeverity* value);
enum PolicyValidationReportRequest_ValidationResultType : int {
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED = 0,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_SUCCESS = 1,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE = 2,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_SIGNATURE = 3,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT = 4,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR = 5,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE = 6,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID = 7,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_TIMESTAMP = 8,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DM_TOKEN = 9,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DEVICE_ID = 10,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_USER = 11,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR = 12,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE = 13,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_WARNING = 14,
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_ERROR = 15
};
POLICY_PROTO_EXPORT bool PolicyValidationReportRequest_ValidationResultType_IsValid(int value);
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MIN = PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MAX = PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_ERROR;
constexpr int PolicyValidationReportRequest_ValidationResultType_ValidationResultType_ARRAYSIZE = PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MAX + 1;

const std::string& PolicyValidationReportRequest_ValidationResultType_Name(PolicyValidationReportRequest_ValidationResultType value);
template<typename T>
inline const std::string& PolicyValidationReportRequest_ValidationResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyValidationReportRequest_ValidationResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyValidationReportRequest_ValidationResultType_Name.");
return PolicyValidationReportRequest_ValidationResultType_Name(static_cast<PolicyValidationReportRequest_ValidationResultType>(enum_t_value));
}
bool PolicyValidationReportRequest_ValidationResultType_Parse(
const std::string& name, PolicyValidationReportRequest_ValidationResultType* value);
enum DeviceAutoEnrollmentRequest_EnrollmentCheckType : int {
DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_UNSPECIFIED = 0,
DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FRE = 1,
DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT = 2
};
POLICY_PROTO_EXPORT bool DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(int value);
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MIN = DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_UNSPECIFIED;
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MAX = DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT;
constexpr int DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_ARRAYSIZE = DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MAX + 1;

const std::string& DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(DeviceAutoEnrollmentRequest_EnrollmentCheckType value);
template<typename T>
inline const std::string& DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceAutoEnrollmentRequest_EnrollmentCheckType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name.");
return DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(static_cast<DeviceAutoEnrollmentRequest_EnrollmentCheckType>(enum_t_value));
}
bool DeviceAutoEnrollmentRequest_EnrollmentCheckType_Parse(
const std::string& name, DeviceAutoEnrollmentRequest_EnrollmentCheckType* value);
enum DeviceStateRetrievalResponse_RestoreMode : int {
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE = 0,
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_REQUESTED = 1,
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ENFORCED = 2,
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_DISABLED = 3,
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ZERO_TOUCH = 4
};
POLICY_PROTO_EXPORT bool DeviceStateRetrievalResponse_RestoreMode_IsValid(int value);
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MIN = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ZERO_TOUCH;
constexpr int DeviceStateRetrievalResponse_RestoreMode_RestoreMode_ARRAYSIZE = DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX + 1;

const std::string& DeviceStateRetrievalResponse_RestoreMode_Name(DeviceStateRetrievalResponse_RestoreMode value);
template<typename T>
inline const std::string& DeviceStateRetrievalResponse_RestoreMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceStateRetrievalResponse_RestoreMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceStateRetrievalResponse_RestoreMode_Name.");
return DeviceStateRetrievalResponse_RestoreMode_Name(static_cast<DeviceStateRetrievalResponse_RestoreMode>(enum_t_value));
}
bool DeviceStateRetrievalResponse_RestoreMode_Parse(
const std::string& name, DeviceStateRetrievalResponse_RestoreMode* value);
enum DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode : int {
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_NONE = 0,
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED = 1,
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED = 2
};
POLICY_PROTO_EXPORT bool DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(int value);
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MIN = DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_NONE;
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MAX = DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED;
constexpr int DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_ARRAYSIZE = DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MAX + 1;

const std::string& DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value);
template<typename T>
inline const std::string& DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name.");
return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(static_cast<DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode>(enum_t_value));
}
bool DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Parse(
const std::string& name, DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode* value);
enum DevicePairingResponse_StatusCode : int {
DevicePairingResponse_StatusCode_SUCCESS = 0,
DevicePairingResponse_StatusCode_FAILED = 1,
DevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND = 2,
DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND = 3,
DevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED = 4,
DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED = 5
};
POLICY_PROTO_EXPORT bool DevicePairingResponse_StatusCode_IsValid(int value);
constexpr DevicePairingResponse_StatusCode DevicePairingResponse_StatusCode_StatusCode_MIN = DevicePairingResponse_StatusCode_SUCCESS;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse_StatusCode_StatusCode_MAX = DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
constexpr int DevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE = DevicePairingResponse_StatusCode_StatusCode_MAX + 1;

const std::string& DevicePairingResponse_StatusCode_Name(DevicePairingResponse_StatusCode value);
template<typename T>
inline const std::string& DevicePairingResponse_StatusCode_Name(T enum_t_value) {
static_assert(::std::is_same<T, DevicePairingResponse_StatusCode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DevicePairingResponse_StatusCode_Name.");
return DevicePairingResponse_StatusCode_Name(static_cast<DevicePairingResponse_StatusCode>(enum_t_value));
}
bool DevicePairingResponse_StatusCode_Parse(
const std::string& name, DevicePairingResponse_StatusCode* value);
enum CheckDevicePairingResponse_StatusCode : int {
CheckDevicePairingResponse_StatusCode_PAIRED = 0,
CheckDevicePairingResponse_StatusCode_NOT_PAIRED = 1,
CheckDevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND = 2,
CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND = 3,
CheckDevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED = 4,
CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED = 5,
CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY = 6
};
POLICY_PROTO_EXPORT bool CheckDevicePairingResponse_StatusCode_IsValid(int value);
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse_StatusCode_StatusCode_MIN = CheckDevicePairingResponse_StatusCode_PAIRED;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse_StatusCode_StatusCode_MAX = CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY;
constexpr int CheckDevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE = CheckDevicePairingResponse_StatusCode_StatusCode_MAX + 1;

const std::string& CheckDevicePairingResponse_StatusCode_Name(CheckDevicePairingResponse_StatusCode value);
template<typename T>
inline const std::string& CheckDevicePairingResponse_StatusCode_Name(T enum_t_value) {
static_assert(::std::is_same<T, CheckDevicePairingResponse_StatusCode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CheckDevicePairingResponse_StatusCode_Name.");
return CheckDevicePairingResponse_StatusCode_Name(static_cast<CheckDevicePairingResponse_StatusCode>(enum_t_value));
}
bool CheckDevicePairingResponse_StatusCode_Parse(
const std::string& name, CheckDevicePairingResponse_StatusCode* value);
enum RemoteCommand_Type : int {
RemoteCommand_Type_COMMAND_ECHO_TEST = -1,
RemoteCommand_Type_DEVICE_REBOOT = 0,
RemoteCommand_Type_DEVICE_SCREENSHOT = 1,
RemoteCommand_Type_DEVICE_SET_VOLUME = 2,
RemoteCommand_Type_DEVICE_FETCH_STATUS = 3,
RemoteCommand_Type_USER_ARC_COMMAND = 4,
RemoteCommand_Type_DEVICE_WIPE_USERS = 5,
RemoteCommand_Type_DEVICE_START_CRD_SESSION = 6,
RemoteCommand_Type_DEVICE_REMOTE_POWERWASH = 7,
RemoteCommand_Type_DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE = 8,
RemoteCommand_Type_DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES = 9,
RemoteCommand_Type_DEVICE_RUN_DIAGNOSTIC_ROUTINE = 10,
RemoteCommand_Type_DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE = 11
};
POLICY_PROTO_EXPORT bool RemoteCommand_Type_IsValid(int value);
constexpr RemoteCommand_Type RemoteCommand_Type_Type_MIN = RemoteCommand_Type_COMMAND_ECHO_TEST;
constexpr RemoteCommand_Type RemoteCommand_Type_Type_MAX = RemoteCommand_Type_DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE;
constexpr int RemoteCommand_Type_Type_ARRAYSIZE = RemoteCommand_Type_Type_MAX + 1;

const std::string& RemoteCommand_Type_Name(RemoteCommand_Type value);
template<typename T>
inline const std::string& RemoteCommand_Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, RemoteCommand_Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function RemoteCommand_Type_Name.");
return RemoteCommand_Type_Name(static_cast<RemoteCommand_Type>(enum_t_value));
}
bool RemoteCommand_Type_Parse(
const std::string& name, RemoteCommand_Type* value);
enum RemoteCommandResult_ResultType : int {
RemoteCommandResult_ResultType_RESULT_IGNORED = 0,
RemoteCommandResult_ResultType_RESULT_FAILURE = 1,
RemoteCommandResult_ResultType_RESULT_SUCCESS = 2
};
POLICY_PROTO_EXPORT bool RemoteCommandResult_ResultType_IsValid(int value);
constexpr RemoteCommandResult_ResultType RemoteCommandResult_ResultType_ResultType_MIN = RemoteCommandResult_ResultType_RESULT_IGNORED;
constexpr RemoteCommandResult_ResultType RemoteCommandResult_ResultType_ResultType_MAX = RemoteCommandResult_ResultType_RESULT_SUCCESS;
constexpr int RemoteCommandResult_ResultType_ResultType_ARRAYSIZE = RemoteCommandResult_ResultType_ResultType_MAX + 1;

const std::string& RemoteCommandResult_ResultType_Name(RemoteCommandResult_ResultType value);
template<typename T>
inline const std::string& RemoteCommandResult_ResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, RemoteCommandResult_ResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function RemoteCommandResult_ResultType_Name.");
return RemoteCommandResult_ResultType_Name(static_cast<RemoteCommandResult_ResultType>(enum_t_value));
}
bool RemoteCommandResult_ResultType_Parse(
const std::string& name, RemoteCommandResult_ResultType* value);
enum DeviceAttributeUpdatePermissionResponse_ResultType : int {
DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED = 0,
DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED = 1
};
POLICY_PROTO_EXPORT bool DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(int value);
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MIN = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED;
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED;
constexpr int DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_ARRAYSIZE = DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX + 1;

const std::string& DeviceAttributeUpdatePermissionResponse_ResultType_Name(DeviceAttributeUpdatePermissionResponse_ResultType value);
template<typename T>
inline const std::string& DeviceAttributeUpdatePermissionResponse_ResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceAttributeUpdatePermissionResponse_ResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceAttributeUpdatePermissionResponse_ResultType_Name.");
return DeviceAttributeUpdatePermissionResponse_ResultType_Name(static_cast<DeviceAttributeUpdatePermissionResponse_ResultType>(enum_t_value));
}
bool DeviceAttributeUpdatePermissionResponse_ResultType_Parse(
const std::string& name, DeviceAttributeUpdatePermissionResponse_ResultType* value);
enum DeviceAttributeUpdateResponse_ResultType : int {
DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR = 0,
DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS = 1
};
POLICY_PROTO_EXPORT bool DeviceAttributeUpdateResponse_ResultType_IsValid(int value);
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse_ResultType_ResultType_MIN = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR;
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse_ResultType_ResultType_MAX = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS;
constexpr int DeviceAttributeUpdateResponse_ResultType_ResultType_ARRAYSIZE = DeviceAttributeUpdateResponse_ResultType_ResultType_MAX + 1;

const std::string& DeviceAttributeUpdateResponse_ResultType_Name(DeviceAttributeUpdateResponse_ResultType value);
template<typename T>
inline const std::string& DeviceAttributeUpdateResponse_ResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceAttributeUpdateResponse_ResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceAttributeUpdateResponse_ResultType_Name.");
return DeviceAttributeUpdateResponse_ResultType_Name(static_cast<DeviceAttributeUpdateResponse_ResultType>(enum_t_value));
}
bool DeviceAttributeUpdateResponse_ResultType_Parse(
const std::string& name, DeviceAttributeUpdateResponse_ResultType* value);
enum CertificateBasedDeviceRegistrationData_CertificateType : int {
CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN = 0,
CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE = 1
};
POLICY_PROTO_EXPORT bool CertificateBasedDeviceRegistrationData_CertificateType_IsValid(int value);
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MIN = CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN;
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX = CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
constexpr int CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_ARRAYSIZE = CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX + 1;

const std::string& CertificateBasedDeviceRegistrationData_CertificateType_Name(CertificateBasedDeviceRegistrationData_CertificateType value);
template<typename T>
inline const std::string& CertificateBasedDeviceRegistrationData_CertificateType_Name(T enum_t_value) {
static_assert(::std::is_same<T, CertificateBasedDeviceRegistrationData_CertificateType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CertificateBasedDeviceRegistrationData_CertificateType_Name.");
return CertificateBasedDeviceRegistrationData_CertificateType_Name(static_cast<CertificateBasedDeviceRegistrationData_CertificateType>(enum_t_value));
}
bool CertificateBasedDeviceRegistrationData_CertificateType_Parse(
const std::string& name, CertificateBasedDeviceRegistrationData_CertificateType* value);
enum CheckDeviceLicenseResponse_LicenseSelectionMode : int {
CheckDeviceLicenseResponse_LicenseSelectionMode_UNDEFINED = 0,
CheckDeviceLicenseResponse_LicenseSelectionMode_USER_SELECTION = 1,
CheckDeviceLicenseResponse_LicenseSelectionMode_ADMIN_SELECTION = 2
};
POLICY_PROTO_EXPORT bool CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(int value);
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MIN = CheckDeviceLicenseResponse_LicenseSelectionMode_UNDEFINED;
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MAX = CheckDeviceLicenseResponse_LicenseSelectionMode_ADMIN_SELECTION;
constexpr int CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_ARRAYSIZE = CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MAX + 1;

const std::string& CheckDeviceLicenseResponse_LicenseSelectionMode_Name(CheckDeviceLicenseResponse_LicenseSelectionMode value);
template<typename T>
inline const std::string& CheckDeviceLicenseResponse_LicenseSelectionMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, CheckDeviceLicenseResponse_LicenseSelectionMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CheckDeviceLicenseResponse_LicenseSelectionMode_Name.");
return CheckDeviceLicenseResponse_LicenseSelectionMode_Name(static_cast<CheckDeviceLicenseResponse_LicenseSelectionMode>(enum_t_value));
}
bool CheckDeviceLicenseResponse_LicenseSelectionMode_Parse(
const std::string& name, CheckDeviceLicenseResponse_LicenseSelectionMode* value);
enum ExtensionInstallReportLogEvent_EventType : int {
ExtensionInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN = 0,
ExtensionInstallReportLogEvent_EventType_POLICY_REQUEST = 1,
ExtensionInstallReportLogEvent_EventType_SUCCESS = 2,
ExtensionInstallReportLogEvent_EventType_CANCELED = 3,
ExtensionInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE = 4,
ExtensionInstallReportLogEvent_EventType_SESSION_STATE_CHANGE = 5,
ExtensionInstallReportLogEvent_EventType_INSTALLATION_FAILED = 6
};
POLICY_PROTO_EXPORT bool ExtensionInstallReportLogEvent_EventType_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent_EventType_EventType_MIN = ExtensionInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent_EventType_EventType_MAX = ExtensionInstallReportLogEvent_EventType_INSTALLATION_FAILED;
constexpr int ExtensionInstallReportLogEvent_EventType_EventType_ARRAYSIZE = ExtensionInstallReportLogEvent_EventType_EventType_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_EventType_Name(ExtensionInstallReportLogEvent_EventType value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_EventType_Name(T enum_t_value) {
static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_EventType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ExtensionInstallReportLogEvent_EventType_Name.");
return ExtensionInstallReportLogEvent_EventType_Name(static_cast<ExtensionInstallReportLogEvent_EventType>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_EventType_Parse(
const std::string& name, ExtensionInstallReportLogEvent_EventType* value);
enum ExtensionInstallReportLogEvent_SessionStateChangeType : int {
ExtensionInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN = 0,
ExtensionInstallReportLogEvent_SessionStateChangeType_LOGIN = 1,
ExtensionInstallReportLogEvent_SessionStateChangeType_LOGOUT = 2,
ExtensionInstallReportLogEvent_SessionStateChangeType_SUSPEND = 3,
ExtensionInstallReportLogEvent_SessionStateChangeType_RESUME = 4
};
POLICY_PROTO_EXPORT bool ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN = ExtensionInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX = ExtensionInstallReportLogEvent_SessionStateChangeType_RESUME;
constexpr int ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE = ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_SessionStateChangeType_Name(ExtensionInstallReportLogEvent_SessionStateChangeType value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_SessionStateChangeType_Name(T enum_t_value) {
static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_SessionStateChangeType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ExtensionInstallReportLogEvent_SessionStateChangeType_Name.");
return ExtensionInstallReportLogEvent_SessionStateChangeType_Name(static_cast<ExtensionInstallReportLogEvent_SessionStateChangeType>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_SessionStateChangeType_Parse(
const std::string& name, ExtensionInstallReportLogEvent_SessionStateChangeType* value);
enum AppInstallReportLogEvent_EventType : int {
AppInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN = 0,
AppInstallReportLogEvent_EventType_SERVER_REQUEST = 1,
AppInstallReportLogEvent_EventType_CLOUDDPC_REQUEST = 2,
AppInstallReportLogEvent_EventType_CLOUDDPS_REQUEST = 3,
AppInstallReportLogEvent_EventType_CLOUDDPS_RESPONSE = 4,
AppInstallReportLogEvent_EventType_PHONESKY_LOG = 5,
AppInstallReportLogEvent_EventType_SUCCESS = 6,
AppInstallReportLogEvent_EventType_CANCELED = 7,
AppInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE = 8,
AppInstallReportLogEvent_EventType_SESSION_STATE_CHANGE = 9,
AppInstallReportLogEvent_EventType_INSTALLATION_STARTED = 10,
AppInstallReportLogEvent_EventType_INSTALLATION_FINISHED = 11,
AppInstallReportLogEvent_EventType_INSTALLATION_FAILED = 12,
AppInstallReportLogEvent_EventType_DIRECT_INSTALL = 13,
AppInstallReportLogEvent_EventType_CLOUDDPC_MAIN_LOOP_FAILED = 14
};
POLICY_PROTO_EXPORT bool AppInstallReportLogEvent_EventType_IsValid(int value);
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent_EventType_EventType_MIN = AppInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent_EventType_EventType_MAX = AppInstallReportLogEvent_EventType_CLOUDDPC_MAIN_LOOP_FAILED;
constexpr int AppInstallReportLogEvent_EventType_EventType_ARRAYSIZE = AppInstallReportLogEvent_EventType_EventType_MAX + 1;

const std::string& AppInstallReportLogEvent_EventType_Name(AppInstallReportLogEvent_EventType value);
template<typename T>
inline const std::string& AppInstallReportLogEvent_EventType_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppInstallReportLogEvent_EventType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppInstallReportLogEvent_EventType_Name.");
return AppInstallReportLogEvent_EventType_Name(static_cast<AppInstallReportLogEvent_EventType>(enum_t_value));
}
bool AppInstallReportLogEvent_EventType_Parse(
const std::string& name, AppInstallReportLogEvent_EventType* value);
enum AppInstallReportLogEvent_SessionStateChangeType : int {
AppInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN = 0,
AppInstallReportLogEvent_SessionStateChangeType_LOGIN = 1,
AppInstallReportLogEvent_SessionStateChangeType_LOGOUT = 2,
AppInstallReportLogEvent_SessionStateChangeType_SUSPEND = 3,
AppInstallReportLogEvent_SessionStateChangeType_RESUME = 4
};
POLICY_PROTO_EXPORT bool AppInstallReportLogEvent_SessionStateChangeType_IsValid(int value);
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN = AppInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX = AppInstallReportLogEvent_SessionStateChangeType_RESUME;
constexpr int AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE = AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX + 1;

const std::string& AppInstallReportLogEvent_SessionStateChangeType_Name(AppInstallReportLogEvent_SessionStateChangeType value);
template<typename T>
inline const std::string& AppInstallReportLogEvent_SessionStateChangeType_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppInstallReportLogEvent_SessionStateChangeType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppInstallReportLogEvent_SessionStateChangeType_Name.");
return AppInstallReportLogEvent_SessionStateChangeType_Name(static_cast<AppInstallReportLogEvent_SessionStateChangeType>(enum_t_value));
}
bool AppInstallReportLogEvent_SessionStateChangeType_Parse(
const std::string& name, AppInstallReportLogEvent_SessionStateChangeType* value);
enum RefreshAccountRequest_AccountType : int {
RefreshAccountRequest_AccountType_ACCOUNT_TYPE_UNSPECIFIED = 0,
RefreshAccountRequest_AccountType_CHROME_OS_DEMO_MODE = 1
};
POLICY_PROTO_EXPORT bool RefreshAccountRequest_AccountType_IsValid(int value);
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest_AccountType_AccountType_MIN = RefreshAccountRequest_AccountType_ACCOUNT_TYPE_UNSPECIFIED;
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest_AccountType_AccountType_MAX = RefreshAccountRequest_AccountType_CHROME_OS_DEMO_MODE;
constexpr int RefreshAccountRequest_AccountType_AccountType_ARRAYSIZE = RefreshAccountRequest_AccountType_AccountType_MAX + 1;

const std::string& RefreshAccountRequest_AccountType_Name(RefreshAccountRequest_AccountType value);
template<typename T>
inline const std::string& RefreshAccountRequest_AccountType_Name(T enum_t_value) {
static_assert(::std::is_same<T, RefreshAccountRequest_AccountType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function RefreshAccountRequest_AccountType_Name.");
return RefreshAccountRequest_AccountType_Name(static_cast<RefreshAccountRequest_AccountType>(enum_t_value));
}
bool RefreshAccountRequest_AccountType_Parse(
const std::string& name, RefreshAccountRequest_AccountType* value);
enum App_AppType : int {
App_AppType_UNKNOWN = 0,
App_AppType_ARC = 1,
App_AppType_BUILT_IN = 2,
App_AppType_CROSTINI = 3,
App_AppType_EXTENSION = 4,
App_AppType_WEB = 5,
App_AppType_PLUGIN_VM = 6
};
POLICY_PROTO_EXPORT bool App_AppType_IsValid(int value);
constexpr App_AppType App_AppType_AppType_MIN = App_AppType_UNKNOWN;
constexpr App_AppType App_AppType_AppType_MAX = App_AppType_PLUGIN_VM;
constexpr int App_AppType_AppType_ARRAYSIZE = App_AppType_AppType_MAX + 1;

const std::string& App_AppType_Name(App_AppType value);
template<typename T>
inline const std::string& App_AppType_Name(T enum_t_value) {
static_assert(::std::is_same<T, App_AppType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function App_AppType_Name.");
return App_AppType_Name(static_cast<App_AppType>(enum_t_value));
}
bool App_AppType_Parse(
const std::string& name, App_AppType* value);
enum AppActivity_AppState : int {
AppActivity_AppState_UNKNOWN = 0,
AppActivity_AppState_DEFAULT = 1,
AppActivity_AppState_ALWAYS_AVAILABLE = 2,
AppActivity_AppState_BLOCKED = 3,
AppActivity_AppState_LIMIT_REACHED = 4,
AppActivity_AppState_UNINSTALLED = 5
};
POLICY_PROTO_EXPORT bool AppActivity_AppState_IsValid(int value);
constexpr AppActivity_AppState AppActivity_AppState_AppState_MIN = AppActivity_AppState_UNKNOWN;
constexpr AppActivity_AppState AppActivity_AppState_AppState_MAX = AppActivity_AppState_UNINSTALLED;
constexpr int AppActivity_AppState_AppState_ARRAYSIZE = AppActivity_AppState_AppState_MAX + 1;

const std::string& AppActivity_AppState_Name(AppActivity_AppState value);
template<typename T>
inline const std::string& AppActivity_AppState_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppActivity_AppState>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppActivity_AppState_Name.");
return AppActivity_AppState_Name(static_cast<AppActivity_AppState>(enum_t_value));
}
bool AppActivity_AppState_Parse(
const std::string& name, AppActivity_AppState* value);
enum ClientCertificateProvisioningResponse_Error : int {
ClientCertificateProvisioningResponse_Error_UNDEFINED = 0,
ClientCertificateProvisioningResponse_Error_TIMED_OUT = 1,
ClientCertificateProvisioningResponse_Error_IDENTITY_VERIFICATION_ERROR = 2,
ClientCertificateProvisioningResponse_Error_CA_ERROR = 3,
ClientCertificateProvisioningResponse_Error_INCONSISTENT_DATA = 4
};
POLICY_PROTO_EXPORT bool ClientCertificateProvisioningResponse_Error_IsValid(int value);
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse_Error_Error_MIN = ClientCertificateProvisioningResponse_Error_UNDEFINED;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse_Error_Error_MAX = ClientCertificateProvisioningResponse_Error_INCONSISTENT_DATA;
constexpr int ClientCertificateProvisioningResponse_Error_Error_ARRAYSIZE = ClientCertificateProvisioningResponse_Error_Error_MAX + 1;

const std::string& ClientCertificateProvisioningResponse_Error_Name(ClientCertificateProvisioningResponse_Error value);
template<typename T>
inline const std::string& ClientCertificateProvisioningResponse_Error_Name(T enum_t_value) {
static_assert(::std::is_same<T, ClientCertificateProvisioningResponse_Error>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ClientCertificateProvisioningResponse_Error_Name.");
return ClientCertificateProvisioningResponse_Error_Name(static_cast<ClientCertificateProvisioningResponse_Error>(enum_t_value));
}
bool ClientCertificateProvisioningResponse_Error_Parse(
const std::string& name, ClientCertificateProvisioningResponse_Error* value);
enum Channel : int {
CHANNEL_UNKNOWN = 0,
CHANNEL_CANARY = 1,
CHANNEL_DEV = 2,
CHANNEL_BETA = 3,
CHANNEL_STABLE = 4
};
POLICY_PROTO_EXPORT bool Channel_IsValid(int value);
constexpr Channel Channel_MIN = CHANNEL_UNKNOWN;
constexpr Channel Channel_MAX = CHANNEL_STABLE;
constexpr int Channel_ARRAYSIZE = Channel_MAX + 1;

const std::string& Channel_Name(Channel value);
template<typename T>
inline const std::string& Channel_Name(T enum_t_value) {
static_assert(::std::is_same<T, Channel>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Channel_Name.");
return Channel_Name(static_cast<Channel>(enum_t_value));
}
bool Channel_Parse(
const std::string& name, Channel* value);
enum CrostiniAppType : int {
CROSTINI_APP_TYPE_TERMINAL = 0,
CROSTINI_APP_TYPE_INTERACTIVE = 1,
CROSTINI_APP_TYPE_OTHER = 2
};
POLICY_PROTO_EXPORT bool CrostiniAppType_IsValid(int value);
constexpr CrostiniAppType CrostiniAppType_MIN = CROSTINI_APP_TYPE_TERMINAL;
constexpr CrostiniAppType CrostiniAppType_MAX = CROSTINI_APP_TYPE_OTHER;
constexpr int CrostiniAppType_ARRAYSIZE = CrostiniAppType_MAX + 1;

const std::string& CrostiniAppType_Name(CrostiniAppType value);
template<typename T>
inline const std::string& CrostiniAppType_Name(T enum_t_value) {
static_assert(::std::is_same<T, CrostiniAppType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CrostiniAppType_Name.");
return CrostiniAppType_Name(static_cast<CrostiniAppType>(enum_t_value));
}
bool CrostiniAppType_Parse(
const std::string& name, CrostiniAppType* value);
enum HashingAlgorithm : int {
HASHING_ALGORITHM_UNSPECIFIED = 0,
SHA1 = 1,
SHA256 = 2
};
POLICY_PROTO_EXPORT bool HashingAlgorithm_IsValid(int value);
constexpr HashingAlgorithm HashingAlgorithm_MIN = HASHING_ALGORITHM_UNSPECIFIED;
constexpr HashingAlgorithm HashingAlgorithm_MAX = SHA256;
constexpr int HashingAlgorithm_ARRAYSIZE = HashingAlgorithm_MAX + 1;

const std::string& HashingAlgorithm_Name(HashingAlgorithm value);
template<typename T>
inline const std::string& HashingAlgorithm_Name(T enum_t_value) {
static_assert(::std::is_same<T, HashingAlgorithm>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function HashingAlgorithm_Name.");
return HashingAlgorithm_Name(static_cast<HashingAlgorithm>(enum_t_value));
}
bool HashingAlgorithm_Parse(
const std::string& name, HashingAlgorithm* value);
enum SigningAlgorithm : int {
SIGNING_ALGORITHM_UNSPECIFIED = 0,
RSA_PKCS1_V1_5 = 1
};
POLICY_PROTO_EXPORT bool SigningAlgorithm_IsValid(int value);
constexpr SigningAlgorithm SigningAlgorithm_MIN = SIGNING_ALGORITHM_UNSPECIFIED;
constexpr SigningAlgorithm SigningAlgorithm_MAX = RSA_PKCS1_V1_5;
constexpr int SigningAlgorithm_ARRAYSIZE = SigningAlgorithm_MAX + 1;

const std::string& SigningAlgorithm_Name(SigningAlgorithm value);
template<typename T>
inline const std::string& SigningAlgorithm_Name(T enum_t_value) {
static_assert(::std::is_same<T, SigningAlgorithm>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function SigningAlgorithm_Name.");
return SigningAlgorithm_Name(static_cast<SigningAlgorithm>(enum_t_value));
}
bool SigningAlgorithm_Parse(
const std::string& name, SigningAlgorithm* value);
// ===================================================================

class POLICY_PROTO_EXPORT LicenseType :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LicenseType) */ {
public:
LicenseType();
virtual ~LicenseType();

LicenseType(const LicenseType& from);
LicenseType(LicenseType&& from) noexcept
: LicenseType() {
*this = ::std::move(from);
}

inline LicenseType& operator=(const LicenseType& from) {
CopyFrom(from);
return *this;
}
inline LicenseType& operator=(LicenseType&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const LicenseType& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const LicenseType* internal_default_instance() {
return reinterpret_cast<const LicenseType*>(
&_LicenseType_default_instance_);
}
static constexpr int kIndexInFileMessages =
0;

friend void swap(LicenseType& a, LicenseType& b) {
a.Swap(&b);
}
inline void Swap(LicenseType* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline LicenseType* New() const final {
return CreateMaybeMessage<LicenseType>(nullptr);
}

LicenseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<LicenseType>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const LicenseType& from);
void MergeFrom(const LicenseType& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LicenseType* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.LicenseType";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef LicenseType_LicenseTypeEnum LicenseTypeEnum;
static constexpr LicenseTypeEnum UNDEFINED =
LicenseType_LicenseTypeEnum_UNDEFINED;
static constexpr LicenseTypeEnum CDM_PERPETUAL =
LicenseType_LicenseTypeEnum_CDM_PERPETUAL;
static constexpr LicenseTypeEnum CDM_ANNUAL =
LicenseType_LicenseTypeEnum_CDM_ANNUAL;
static constexpr LicenseTypeEnum KIOSK =
LicenseType_LicenseTypeEnum_KIOSK;
static inline bool LicenseTypeEnum_IsValid(int value) {
return LicenseType_LicenseTypeEnum_IsValid(value);
}
static constexpr LicenseTypeEnum LicenseTypeEnum_MIN =
LicenseType_LicenseTypeEnum_LicenseTypeEnum_MIN;
static constexpr LicenseTypeEnum LicenseTypeEnum_MAX =
LicenseType_LicenseTypeEnum_LicenseTypeEnum_MAX;
static constexpr int LicenseTypeEnum_ARRAYSIZE =
LicenseType_LicenseTypeEnum_LicenseTypeEnum_ARRAYSIZE;
template<typename T>
static inline const std::string& LicenseTypeEnum_Name(T enum_t_value) {
static_assert(::std::is_same<T, LicenseTypeEnum>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function LicenseTypeEnum_Name.");
return LicenseType_LicenseTypeEnum_Name(enum_t_value);
}
static inline bool LicenseTypeEnum_Parse(const std::string& name,
LicenseTypeEnum* value) {
return LicenseType_LicenseTypeEnum_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kLicenseTypeDeprecatedFieldNumber = 1,
};
// optional .enterprise_management.LicenseType.LicenseTypeEnum license_type_deprecated = 1 [deprecated = true];
PROTOBUF_DEPRECATED bool has_license_type_deprecated() const;
PROTOBUF_DEPRECATED void clear_license_type_deprecated();
PROTOBUF_DEPRECATED ::enterprise_management::LicenseType_LicenseTypeEnum license_type_deprecated() const;
PROTOBUF_DEPRECATED void set_license_type_deprecated(::enterprise_management::LicenseType_LicenseTypeEnum value);

// @@protoc_insertion_point(class_scope:enterprise_management.LicenseType)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int license_type_deprecated_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SignedData :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SignedData) */ {
public:
SignedData();
virtual ~SignedData();

SignedData(const SignedData& from);
SignedData(SignedData&& from) noexcept
: SignedData() {
*this = ::std::move(from);
}

inline SignedData& operator=(const SignedData& from) {
CopyFrom(from);
return *this;
}
inline SignedData& operator=(SignedData&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SignedData& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SignedData* internal_default_instance() {
return reinterpret_cast<const SignedData*>(
&_SignedData_default_instance_);
}
static constexpr int kIndexInFileMessages =
1;

friend void swap(SignedData& a, SignedData& b) {
a.Swap(&b);
}
inline void Swap(SignedData* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SignedData* New() const final {
return CreateMaybeMessage<SignedData>(nullptr);
}

SignedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SignedData>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SignedData& from);
void MergeFrom(const SignedData& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SignedData* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.SignedData";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kDataFieldNumber = 1,
kSignatureFieldNumber = 2,
kExtraDataBytesFieldNumber = 3,
};
// optional bytes data = 1;
bool has_data() const;
void clear_data();
const std::string& data() const;
void set_data(const std::string& value);
void set_data(std::string&& value);
void set_data(const char* value);
void set_data(const void* value, size_t size);
std::string* mutable_data();
std::string* release_data();
void set_allocated_data(std::string* data);

// optional bytes signature = 2;
bool has_signature() const;
void clear_signature();
const std::string& signature() const;
void set_signature(const std::string& value);
void set_signature(std::string&& value);
void set_signature(const char* value);
void set_signature(const void* value, size_t size);
std::string* mutable_signature();
std::string* release_signature();
void set_allocated_signature(std::string* signature);

// optional int32 extra_data_bytes = 3;
bool has_extra_data_bytes() const;
void clear_extra_data_bytes();
::PROTOBUF_NAMESPACE_ID::int32 extra_data_bytes() const;
void set_extra_data_bytes(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.SignedData)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
::PROTOBUF_NAMESPACE_ID::int32 extra_data_bytes_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRegisterRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterRequest) */ {
public:
DeviceRegisterRequest();
virtual ~DeviceRegisterRequest();

DeviceRegisterRequest(const DeviceRegisterRequest& from);
DeviceRegisterRequest(DeviceRegisterRequest&& from) noexcept
: DeviceRegisterRequest() {
*this = ::std::move(from);
}

inline DeviceRegisterRequest& operator=(const DeviceRegisterRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceRegisterRequest& operator=(DeviceRegisterRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceRegisterRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceRegisterRequest* internal_default_instance() {
return reinterpret_cast<const DeviceRegisterRequest*>(
&_DeviceRegisterRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
2;

friend void swap(DeviceRegisterRequest& a, DeviceRegisterRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceRegisterRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceRegisterRequest* New() const final {
return CreateMaybeMessage<DeviceRegisterRequest>(nullptr);
}

DeviceRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceRegisterRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceRegisterRequest& from);
void MergeFrom(const DeviceRegisterRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceRegisterRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceRegisterRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceRegisterRequest_Type Type;
static constexpr Type TT =
DeviceRegisterRequest_Type_TT;
static constexpr Type USER =
DeviceRegisterRequest_Type_USER;
static constexpr Type DEVICE =
DeviceRegisterRequest_Type_DEVICE;
static constexpr Type BROWSER =
DeviceRegisterRequest_Type_BROWSER;
static constexpr Type ANDROID_BROWSER =
DeviceRegisterRequest_Type_ANDROID_BROWSER;
static inline bool Type_IsValid(int value) {
return DeviceRegisterRequest_Type_IsValid(value);
}
static constexpr Type Type_MIN =
DeviceRegisterRequest_Type_Type_MIN;
static constexpr Type Type_MAX =
DeviceRegisterRequest_Type_Type_MAX;
static constexpr int Type_ARRAYSIZE =
DeviceRegisterRequest_Type_Type_ARRAYSIZE;
template<typename T>
static inline const std::string& Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Type_Name.");
return DeviceRegisterRequest_Type_Name(enum_t_value);
}
static inline bool Type_Parse(const std::string& name,
Type* value) {
return DeviceRegisterRequest_Type_Parse(name, value);
}

typedef DeviceRegisterRequest_Flavor Flavor;
static constexpr Flavor FLAVOR_ENROLLMENT_MANUAL =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL;
static constexpr Flavor FLAVOR_ENROLLMENT_MANUAL_RENEW =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL_RENEW;
static constexpr Flavor FLAVOR_ENROLLMENT_LOCAL_FORCED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_FORCED;
static constexpr Flavor FLAVOR_ENROLLMENT_LOCAL_ADVERTISED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_ADVERTISED;
static constexpr Flavor FLAVOR_ENROLLMENT_SERVER_FORCED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_FORCED;
static constexpr Flavor FLAVOR_ENROLLMENT_SERVER_ADVERTISED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_ADVERTISED;
static constexpr Flavor FLAVOR_ENROLLMENT_RECOVERY =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_RECOVERY;
static constexpr Flavor FLAVOR_USER_REGISTRATION =
DeviceRegisterRequest_Flavor_FLAVOR_USER_REGISTRATION;
static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION;
static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED;
static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED;
static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK;
static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_USB_ENROLLMENT =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_USB_ENROLLMENT;
static constexpr Flavor FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED;
static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED;
static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK =
DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK;
static inline bool Flavor_IsValid(int value) {
return DeviceRegisterRequest_Flavor_IsValid(value);
}
static constexpr Flavor Flavor_MIN =
DeviceRegisterRequest_Flavor_Flavor_MIN;
static constexpr Flavor Flavor_MAX =
DeviceRegisterRequest_Flavor_Flavor_MAX;
static constexpr int Flavor_ARRAYSIZE =
DeviceRegisterRequest_Flavor_Flavor_ARRAYSIZE;
template<typename T>
static inline const std::string& Flavor_Name(T enum_t_value) {
static_assert(::std::is_same<T, Flavor>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Flavor_Name.");
return DeviceRegisterRequest_Flavor_Name(enum_t_value);
}
static inline bool Flavor_Parse(const std::string& name,
Flavor* value) {
return DeviceRegisterRequest_Flavor_Parse(name, value);
}

typedef DeviceRegisterRequest_Lifetime Lifetime;
static constexpr Lifetime LIFETIME_UNDEFINED =
DeviceRegisterRequest_Lifetime_LIFETIME_UNDEFINED;
static constexpr Lifetime LIFETIME_INDEFINITE =
DeviceRegisterRequest_Lifetime_LIFETIME_INDEFINITE;
static constexpr Lifetime LIFETIME_EPHEMERAL_USER =
DeviceRegisterRequest_Lifetime_LIFETIME_EPHEMERAL_USER;
static inline bool Lifetime_IsValid(int value) {
return DeviceRegisterRequest_Lifetime_IsValid(value);
}
static constexpr Lifetime Lifetime_MIN =
DeviceRegisterRequest_Lifetime_Lifetime_MIN;
static constexpr Lifetime Lifetime_MAX =
DeviceRegisterRequest_Lifetime_Lifetime_MAX;
static constexpr int Lifetime_ARRAYSIZE =
DeviceRegisterRequest_Lifetime_Lifetime_ARRAYSIZE;
template<typename T>
static inline const std::string& Lifetime_Name(T enum_t_value) {
static_assert(::std::is_same<T, Lifetime>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Lifetime_Name.");
return DeviceRegisterRequest_Lifetime_Name(enum_t_value);
}
static inline bool Lifetime_Parse(const std::string& name,
Lifetime* value) {
return DeviceRegisterRequest_Lifetime_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kMachineIdFieldNumber = 3,
kMachineModelFieldNumber = 4,
kRequisitionFieldNumber = 6,
kServerBackedStateKeyFieldNumber = 7,
kBrandCodeFieldNumber = 12,
kReregistrationDmTokenFieldNumber = 13,
kEthernetMacAddressFieldNumber = 14,
kDockMacAddressFieldNumber = 15,
kManufactureDateFieldNumber = 16,
kExpectedEnrollmentDomainFieldNumber = 17,
kLicenseTypeFieldNumber = 9,
kDeviceRegisterIdentificationFieldNumber = 18,
kReregisterFieldNumber = 1,
kTypeFieldNumber = 2,
kFlavorFieldNumber = 8,
kLifetimeFieldNumber = 11,
};
// optional string machine_id = 3;
bool has_machine_id() const;
void clear_machine_id();
const std::string& machine_id() const;
void set_machine_id(const std::string& value);
void set_machine_id(std::string&& value);
void set_machine_id(const char* value);
void set_machine_id(const char* value, size_t size);
std::string* mutable_machine_id();
std::string* release_machine_id();
void set_allocated_machine_id(std::string* machine_id);

// optional string machine_model = 4;
bool has_machine_model() const;
void clear_machine_model();
const std::string& machine_model() const;
void set_machine_model(const std::string& value);
void set_machine_model(std::string&& value);
void set_machine_model(const char* value);
void set_machine_model(const char* value, size_t size);
std::string* mutable_machine_model();
std::string* release_machine_model();
void set_allocated_machine_model(std::string* machine_model);

// optional string requisition = 6;
bool has_requisition() const;
void clear_requisition();
const std::string& requisition() const;
void set_requisition(const std::string& value);
void set_requisition(std::string&& value);
void set_requisition(const char* value);
void set_requisition(const char* value, size_t size);
std::string* mutable_requisition();
std::string* release_requisition();
void set_allocated_requisition(std::string* requisition);

// optional bytes server_backed_state_key = 7;
bool has_server_backed_state_key() const;
void clear_server_backed_state_key();
const std::string& server_backed_state_key() const;
void set_server_backed_state_key(const std::string& value);
void set_server_backed_state_key(std::string&& value);
void set_server_backed_state_key(const char* value);
void set_server_backed_state_key(const void* value, size_t size);
std::string* mutable_server_backed_state_key();
std::string* release_server_backed_state_key();
void set_allocated_server_backed_state_key(std::string* server_backed_state_key);

// optional string brand_code = 12;
bool has_brand_code() const;
void clear_brand_code();
const std::string& brand_code() const;
void set_brand_code(const std::string& value);
void set_brand_code(std::string&& value);
void set_brand_code(const char* value);
void set_brand_code(const char* value, size_t size);
std::string* mutable_brand_code();
std::string* release_brand_code();
void set_allocated_brand_code(std::string* brand_code);

// optional string reregistration_dm_token = 13;
bool has_reregistration_dm_token() const;
void clear_reregistration_dm_token();
const std::string& reregistration_dm_token() const;
void set_reregistration_dm_token(const std::string& value);
void set_reregistration_dm_token(std::string&& value);
void set_reregistration_dm_token(const char* value);
void set_reregistration_dm_token(const char* value, size_t size);
std::string* mutable_reregistration_dm_token();
std::string* release_reregistration_dm_token();
void set_allocated_reregistration_dm_token(std::string* reregistration_dm_token);

// optional string ethernet_mac_address = 14;
bool has_ethernet_mac_address() const;
void clear_ethernet_mac_address();
const std::string& ethernet_mac_address() const;
void set_ethernet_mac_address(const std::string& value);
void set_ethernet_mac_address(std::string&& value);
void set_ethernet_mac_address(const char* value);
void set_ethernet_mac_address(const char* value, size_t size);
std::string* mutable_ethernet_mac_address();
std::string* release_ethernet_mac_address();
void set_allocated_ethernet_mac_address(std::string* ethernet_mac_address);

// optional string dock_mac_address = 15;
bool has_dock_mac_address() const;
void clear_dock_mac_address();
const std::string& dock_mac_address() const;
void set_dock_mac_address(const std::string& value);
void set_dock_mac_address(std::string&& value);
void set_dock_mac_address(const char* value);
void set_dock_mac_address(const char* value, size_t size);
std::string* mutable_dock_mac_address();
std::string* release_dock_mac_address();
void set_allocated_dock_mac_address(std::string* dock_mac_address);

// optional string manufacture_date = 16;
bool has_manufacture_date() const;
void clear_manufacture_date();
const std::string& manufacture_date() const;
void set_manufacture_date(const std::string& value);
void set_manufacture_date(std::string&& value);
void set_manufacture_date(const char* value);
void set_manufacture_date(const char* value, size_t size);
std::string* mutable_manufacture_date();
std::string* release_manufacture_date();
void set_allocated_manufacture_date(std::string* manufacture_date);

// optional string expected_enrollment_domain = 17;
bool has_expected_enrollment_domain() const;
void clear_expected_enrollment_domain();
const std::string& expected_enrollment_domain() const;
void set_expected_enrollment_domain(const std::string& value);
void set_expected_enrollment_domain(std::string&& value);
void set_expected_enrollment_domain(const char* value);
void set_expected_enrollment_domain(const char* value, size_t size);
std::string* mutable_expected_enrollment_domain();
std::string* release_expected_enrollment_domain();
void set_allocated_expected_enrollment_domain(std::string* expected_enrollment_domain);

// optional .enterprise_management.LicenseType license_type = 9;
bool has_license_type() const;
void clear_license_type();
const ::enterprise_management::LicenseType& license_type() const;
::enterprise_management::LicenseType* release_license_type();
::enterprise_management::LicenseType* mutable_license_type();
void set_allocated_license_type(::enterprise_management::LicenseType* license_type);

// optional .enterprise_management.DeviceRegisterIdentification device_register_identification = 18;
bool has_device_register_identification() const;
void clear_device_register_identification();
const ::enterprise_management::DeviceRegisterIdentification& device_register_identification() const;
::enterprise_management::DeviceRegisterIdentification* release_device_register_identification();
::enterprise_management::DeviceRegisterIdentification* mutable_device_register_identification();
void set_allocated_device_register_identification(::enterprise_management::DeviceRegisterIdentification* device_register_identification);

// optional bool reregister = 1;
bool has_reregister() const;
void clear_reregister();
bool reregister() const;
void set_reregister(bool value);

// optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
bool has_type() const;
void clear_type();
::enterprise_management::DeviceRegisterRequest_Type type() const;
void set_type(::enterprise_management::DeviceRegisterRequest_Type value);

// optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
bool has_flavor() const;
void clear_flavor();
::enterprise_management::DeviceRegisterRequest_Flavor flavor() const;
void set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value);

// optional .enterprise_management.DeviceRegisterRequest.Lifetime lifetime = 11 [default = LIFETIME_INDEFINITE];
bool has_lifetime() const;
void clear_lifetime();
::enterprise_management::DeviceRegisterRequest_Lifetime lifetime() const;
void set_lifetime(::enterprise_management::DeviceRegisterRequest_Lifetime value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_model_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requisition_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_backed_state_key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_code_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reregistration_dm_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ethernet_mac_address_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dock_mac_address_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacture_date_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expected_enrollment_domain_;
::enterprise_management::LicenseType* license_type_;
::enterprise_management::DeviceRegisterIdentification* device_register_identification_;
bool reregister_;
int type_;
int flavor_;
int lifetime_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRegisterIdentification :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterIdentification) */ {
public:
DeviceRegisterIdentification();
virtual ~DeviceRegisterIdentification();

DeviceRegisterIdentification(const DeviceRegisterIdentification& from);
DeviceRegisterIdentification(DeviceRegisterIdentification&& from) noexcept
: DeviceRegisterIdentification() {
*this = ::std::move(from);
}

inline DeviceRegisterIdentification& operator=(const DeviceRegisterIdentification& from) {
CopyFrom(from);
return *this;
}
inline DeviceRegisterIdentification& operator=(DeviceRegisterIdentification&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceRegisterIdentification& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceRegisterIdentification* internal_default_instance() {
return reinterpret_cast<const DeviceRegisterIdentification*>(
&_DeviceRegisterIdentification_default_instance_);
}
static constexpr int kIndexInFileMessages =
3;

friend void swap(DeviceRegisterIdentification& a, DeviceRegisterIdentification& b) {
a.Swap(&b);
}
inline void Swap(DeviceRegisterIdentification* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceRegisterIdentification* New() const final {
return CreateMaybeMessage<DeviceRegisterIdentification>(nullptr);
}

DeviceRegisterIdentification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceRegisterIdentification>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceRegisterIdentification& from);
void MergeFrom(const DeviceRegisterIdentification& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceRegisterIdentification* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceRegisterIdentification";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAttestedDeviceIdFieldNumber = 1,
};
// optional string attested_device_id = 1;
bool has_attested_device_id() const;
void clear_attested_device_id();
const std::string& attested_device_id() const;
void set_attested_device_id(const std::string& value);
void set_attested_device_id(std::string&& value);
void set_attested_device_id(const char* value);
void set_attested_device_id(const char* value, size_t size);
std::string* mutable_attested_device_id();
std::string* release_attested_device_id();
void set_allocated_attested_device_id(std::string* attested_device_id);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterIdentification)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attested_device_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRegisterResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterResponse) */ {
public:
DeviceRegisterResponse();
virtual ~DeviceRegisterResponse();

DeviceRegisterResponse(const DeviceRegisterResponse& from);
DeviceRegisterResponse(DeviceRegisterResponse&& from) noexcept
: DeviceRegisterResponse() {
*this = ::std::move(from);
}

inline DeviceRegisterResponse& operator=(const DeviceRegisterResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceRegisterResponse& operator=(DeviceRegisterResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceRegisterResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceRegisterResponse* internal_default_instance() {
return reinterpret_cast<const DeviceRegisterResponse*>(
&_DeviceRegisterResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
4;

friend void swap(DeviceRegisterResponse& a, DeviceRegisterResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceRegisterResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceRegisterResponse* New() const final {
return CreateMaybeMessage<DeviceRegisterResponse>(nullptr);
}

DeviceRegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceRegisterResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceRegisterResponse& from);
void MergeFrom(const DeviceRegisterResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceRegisterResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceRegisterResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceRegisterResponse_DeviceMode DeviceMode;
static constexpr DeviceMode ENTERPRISE =
DeviceRegisterResponse_DeviceMode_ENTERPRISE;
static constexpr DeviceMode RETAIL_DEPRECATED =
DeviceRegisterResponse_DeviceMode_RETAIL_DEPRECATED;
static constexpr DeviceMode CHROME_AD =
DeviceRegisterResponse_DeviceMode_CHROME_AD;
static constexpr DeviceMode DEMO =
DeviceRegisterResponse_DeviceMode_DEMO;
static inline bool DeviceMode_IsValid(int value) {
return DeviceRegisterResponse_DeviceMode_IsValid(value);
}
static constexpr DeviceMode DeviceMode_MIN =
DeviceRegisterResponse_DeviceMode_DeviceMode_MIN;
static constexpr DeviceMode DeviceMode_MAX =
DeviceRegisterResponse_DeviceMode_DeviceMode_MAX;
static constexpr int DeviceMode_ARRAYSIZE =
DeviceRegisterResponse_DeviceMode_DeviceMode_ARRAYSIZE;
template<typename T>
static inline const std::string& DeviceMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceMode_Name.");
return DeviceRegisterResponse_DeviceMode_Name(enum_t_value);
}
static inline bool DeviceMode_Parse(const std::string& name,
DeviceMode* value) {
return DeviceRegisterResponse_DeviceMode_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kUserAffiliationIdsFieldNumber = 5,
kDeviceManagementTokenFieldNumber = 1,
kMachineNameFieldNumber = 2,
kConfigurationSeedFieldNumber = 4,
kDirectoryApiIdFieldNumber = 6,
kEnrollmentTypeFieldNumber = 3,
};
// repeated string user_affiliation_ids = 5;
int user_affiliation_ids_size() const;
void clear_user_affiliation_ids();
const std::string& user_affiliation_ids(int index) const;
std::string* mutable_user_affiliation_ids(int index);
void set_user_affiliation_ids(int index, const std::string& value);
void set_user_affiliation_ids(int index, std::string&& value);
void set_user_affiliation_ids(int index, const char* value);
void set_user_affiliation_ids(int index, const char* value, size_t size);
std::string* add_user_affiliation_ids();
void add_user_affiliation_ids(const std::string& value);
void add_user_affiliation_ids(std::string&& value);
void add_user_affiliation_ids(const char* value);
void add_user_affiliation_ids(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_affiliation_ids() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_affiliation_ids();

// required string device_management_token = 1;
bool has_device_management_token() const;
void clear_device_management_token();
const std::string& device_management_token() const;
void set_device_management_token(const std::string& value);
void set_device_management_token(std::string&& value);
void set_device_management_token(const char* value);
void set_device_management_token(const char* value, size_t size);
std::string* mutable_device_management_token();
std::string* release_device_management_token();
void set_allocated_device_management_token(std::string* device_management_token);

// optional string machine_name = 2;
bool has_machine_name() const;
void clear_machine_name();
const std::string& machine_name() const;
void set_machine_name(const std::string& value);
void set_machine_name(std::string&& value);
void set_machine_name(const char* value);
void set_machine_name(const char* value, size_t size);
std::string* mutable_machine_name();
std::string* release_machine_name();
void set_allocated_machine_name(std::string* machine_name);

// optional string configuration_seed = 4;
bool has_configuration_seed() const;
void clear_configuration_seed();
const std::string& configuration_seed() const;
void set_configuration_seed(const std::string& value);
void set_configuration_seed(std::string&& value);
void set_configuration_seed(const char* value);
void set_configuration_seed(const char* value, size_t size);
std::string* mutable_configuration_seed();
std::string* release_configuration_seed();
void set_allocated_configuration_seed(std::string* configuration_seed);

// optional string directory_api_id = 6;
bool has_directory_api_id() const;
void clear_directory_api_id();
const std::string& directory_api_id() const;
void set_directory_api_id(const std::string& value);
void set_directory_api_id(std::string&& value);
void set_directory_api_id(const char* value);
void set_directory_api_id(const char* value, size_t size);
std::string* mutable_directory_api_id();
std::string* release_directory_api_id();
void set_allocated_directory_api_id(std::string* directory_api_id);

// optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
bool has_enrollment_type() const;
void clear_enrollment_type();
::enterprise_management::DeviceRegisterResponse_DeviceMode enrollment_type() const;
void set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_affiliation_ids_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_management_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_seed_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_api_id_;
int enrollment_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceUnregisterRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUnregisterRequest) */ {
public:
DeviceUnregisterRequest();
virtual ~DeviceUnregisterRequest();

DeviceUnregisterRequest(const DeviceUnregisterRequest& from);
DeviceUnregisterRequest(DeviceUnregisterRequest&& from) noexcept
: DeviceUnregisterRequest() {
*this = ::std::move(from);
}

inline DeviceUnregisterRequest& operator=(const DeviceUnregisterRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceUnregisterRequest& operator=(DeviceUnregisterRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceUnregisterRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceUnregisterRequest* internal_default_instance() {
return reinterpret_cast<const DeviceUnregisterRequest*>(
&_DeviceUnregisterRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
5;

friend void swap(DeviceUnregisterRequest& a, DeviceUnregisterRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceUnregisterRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceUnregisterRequest* New() const final {
return CreateMaybeMessage<DeviceUnregisterRequest>(nullptr);
}

DeviceUnregisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceUnregisterRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceUnregisterRequest& from);
void MergeFrom(const DeviceUnregisterRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceUnregisterRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceUnregisterRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceUnregisterRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceUnregisterResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUnregisterResponse) */ {
public:
DeviceUnregisterResponse();
virtual ~DeviceUnregisterResponse();

DeviceUnregisterResponse(const DeviceUnregisterResponse& from);
DeviceUnregisterResponse(DeviceUnregisterResponse&& from) noexcept
: DeviceUnregisterResponse() {
*this = ::std::move(from);
}

inline DeviceUnregisterResponse& operator=(const DeviceUnregisterResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceUnregisterResponse& operator=(DeviceUnregisterResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceUnregisterResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceUnregisterResponse* internal_default_instance() {
return reinterpret_cast<const DeviceUnregisterResponse*>(
&_DeviceUnregisterResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
6;

friend void swap(DeviceUnregisterResponse& a, DeviceUnregisterResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceUnregisterResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceUnregisterResponse* New() const final {
return CreateMaybeMessage<DeviceUnregisterResponse>(nullptr);
}

DeviceUnregisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceUnregisterResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceUnregisterResponse& from);
void MergeFrom(const DeviceUnregisterResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceUnregisterResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceUnregisterResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceUnregisterResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceCertUploadRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceCertUploadRequest) */ {
public:
DeviceCertUploadRequest();
virtual ~DeviceCertUploadRequest();

DeviceCertUploadRequest(const DeviceCertUploadRequest& from);
DeviceCertUploadRequest(DeviceCertUploadRequest&& from) noexcept
: DeviceCertUploadRequest() {
*this = ::std::move(from);
}

inline DeviceCertUploadRequest& operator=(const DeviceCertUploadRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceCertUploadRequest& operator=(DeviceCertUploadRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceCertUploadRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceCertUploadRequest* internal_default_instance() {
return reinterpret_cast<const DeviceCertUploadRequest*>(
&_DeviceCertUploadRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
7;

friend void swap(DeviceCertUploadRequest& a, DeviceCertUploadRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceCertUploadRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceCertUploadRequest* New() const final {
return CreateMaybeMessage<DeviceCertUploadRequest>(nullptr);
}

DeviceCertUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceCertUploadRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceCertUploadRequest& from);
void MergeFrom(const DeviceCertUploadRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceCertUploadRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceCertUploadRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceCertUploadRequest_CertificateType CertificateType;
static constexpr CertificateType CERTIFICATE_TYPE_UNSPECIFIED =
DeviceCertUploadRequest_CertificateType_CERTIFICATE_TYPE_UNSPECIFIED;
static constexpr CertificateType ENTERPRISE_MACHINE_CERTIFICATE =
DeviceCertUploadRequest_CertificateType_ENTERPRISE_MACHINE_CERTIFICATE;
static constexpr CertificateType ENTERPRISE_ENROLLMENT_CERTIFICATE =
DeviceCertUploadRequest_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
static inline bool CertificateType_IsValid(int value) {
return DeviceCertUploadRequest_CertificateType_IsValid(value);
}
static constexpr CertificateType CertificateType_MIN =
DeviceCertUploadRequest_CertificateType_CertificateType_MIN;
static constexpr CertificateType CertificateType_MAX =
DeviceCertUploadRequest_CertificateType_CertificateType_MAX;
static constexpr int CertificateType_ARRAYSIZE =
DeviceCertUploadRequest_CertificateType_CertificateType_ARRAYSIZE;
template<typename T>
static inline const std::string& CertificateType_Name(T enum_t_value) {
static_assert(::std::is_same<T, CertificateType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CertificateType_Name.");
return DeviceCertUploadRequest_CertificateType_Name(enum_t_value);
}
static inline bool CertificateType_Parse(const std::string& name,
CertificateType* value) {
return DeviceCertUploadRequest_CertificateType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kDeviceCertificateFieldNumber = 1,
kEnrollmentIdFieldNumber = 3,
kCertificateTypeFieldNumber = 2,
};
// optional bytes device_certificate = 1;
bool has_device_certificate() const;
void clear_device_certificate();
const std::string& device_certificate() const;
void set_device_certificate(const std::string& value);
void set_device_certificate(std::string&& value);
void set_device_certificate(const char* value);
void set_device_certificate(const void* value, size_t size);
std::string* mutable_device_certificate();
std::string* release_device_certificate();
void set_allocated_device_certificate(std::string* device_certificate);

// optional bytes enrollment_id = 3;
bool has_enrollment_id() const;
void clear_enrollment_id();
const std::string& enrollment_id() const;
void set_enrollment_id(const std::string& value);
void set_enrollment_id(std::string&& value);
void set_enrollment_id(const char* value);
void set_enrollment_id(const void* value, size_t size);
std::string* mutable_enrollment_id();
std::string* release_enrollment_id();
void set_allocated_enrollment_id(std::string* enrollment_id);

// optional .enterprise_management.DeviceCertUploadRequest.CertificateType certificate_type = 2;
bool has_certificate_type() const;
void clear_certificate_type();
::enterprise_management::DeviceCertUploadRequest_CertificateType certificate_type() const;
void set_certificate_type(::enterprise_management::DeviceCertUploadRequest_CertificateType value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceCertUploadRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_certificate_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollment_id_;
int certificate_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceCertUploadResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceCertUploadResponse) */ {
public:
DeviceCertUploadResponse();
virtual ~DeviceCertUploadResponse();

DeviceCertUploadResponse(const DeviceCertUploadResponse& from);
DeviceCertUploadResponse(DeviceCertUploadResponse&& from) noexcept
: DeviceCertUploadResponse() {
*this = ::std::move(from);
}

inline DeviceCertUploadResponse& operator=(const DeviceCertUploadResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceCertUploadResponse& operator=(DeviceCertUploadResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceCertUploadResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceCertUploadResponse* internal_default_instance() {
return reinterpret_cast<const DeviceCertUploadResponse*>(
&_DeviceCertUploadResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
8;

friend void swap(DeviceCertUploadResponse& a, DeviceCertUploadResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceCertUploadResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceCertUploadResponse* New() const final {
return CreateMaybeMessage<DeviceCertUploadResponse>(nullptr);
}

DeviceCertUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceCertUploadResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceCertUploadResponse& from);
void MergeFrom(const DeviceCertUploadResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceCertUploadResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceCertUploadResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceCertUploadResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceServiceApiAccessRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceServiceApiAccessRequest) */ {
public:
DeviceServiceApiAccessRequest();
virtual ~DeviceServiceApiAccessRequest();

DeviceServiceApiAccessRequest(const DeviceServiceApiAccessRequest& from);
DeviceServiceApiAccessRequest(DeviceServiceApiAccessRequest&& from) noexcept
: DeviceServiceApiAccessRequest() {
*this = ::std::move(from);
}

inline DeviceServiceApiAccessRequest& operator=(const DeviceServiceApiAccessRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceServiceApiAccessRequest& operator=(DeviceServiceApiAccessRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceServiceApiAccessRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceServiceApiAccessRequest* internal_default_instance() {
return reinterpret_cast<const DeviceServiceApiAccessRequest*>(
&_DeviceServiceApiAccessRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
9;

friend void swap(DeviceServiceApiAccessRequest& a, DeviceServiceApiAccessRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceServiceApiAccessRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceServiceApiAccessRequest* New() const final {
return CreateMaybeMessage<DeviceServiceApiAccessRequest>(nullptr);
}

DeviceServiceApiAccessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceServiceApiAccessRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceServiceApiAccessRequest& from);
void MergeFrom(const DeviceServiceApiAccessRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceServiceApiAccessRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceServiceApiAccessRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceServiceApiAccessRequest_DeviceType DeviceType;
static constexpr DeviceType CHROME_OS =
DeviceServiceApiAccessRequest_DeviceType_CHROME_OS;
static constexpr DeviceType ANDROID_OS =
DeviceServiceApiAccessRequest_DeviceType_ANDROID_OS;
static constexpr DeviceType CHROME_OS_DEMO_MODE =
DeviceServiceApiAccessRequest_DeviceType_CHROME_OS_DEMO_MODE;
static constexpr DeviceType CHROME_BROWSER =
DeviceServiceApiAccessRequest_DeviceType_CHROME_BROWSER;
static inline bool DeviceType_IsValid(int value) {
return DeviceServiceApiAccessRequest_DeviceType_IsValid(value);
}
static constexpr DeviceType DeviceType_MIN =
DeviceServiceApiAccessRequest_DeviceType_DeviceType_MIN;
static constexpr DeviceType DeviceType_MAX =
DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX;
static constexpr int DeviceType_ARRAYSIZE =
DeviceServiceApiAccessRequest_DeviceType_DeviceType_ARRAYSIZE;
template<typename T>
static inline const std::string& DeviceType_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceType_Name.");
return DeviceServiceApiAccessRequest_DeviceType_Name(enum_t_value);
}
static inline bool DeviceType_Parse(const std::string& name,
DeviceType* value) {
return DeviceServiceApiAccessRequest_DeviceType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kAuthScopesFieldNumber = 1,
kOauth2ClientIdFieldNumber = 2,
kDeviceTypeFieldNumber = 3,
};
// repeated string auth_scopes = 1;
int auth_scopes_size() const;
void clear_auth_scopes();
const std::string& auth_scopes(int index) const;
std::string* mutable_auth_scopes(int index);
void set_auth_scopes(int index, const std::string& value);
void set_auth_scopes(int index, std::string&& value);
void set_auth_scopes(int index, const char* value);
void set_auth_scopes(int index, const char* value, size_t size);
std::string* add_auth_scopes();
void add_auth_scopes(const std::string& value);
void add_auth_scopes(std::string&& value);
void add_auth_scopes(const char* value);
void add_auth_scopes(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& auth_scopes() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_auth_scopes();

// optional string oauth2_client_id = 2;
bool has_oauth2_client_id() const;
void clear_oauth2_client_id();
const std::string& oauth2_client_id() const;
void set_oauth2_client_id(const std::string& value);
void set_oauth2_client_id(std::string&& value);
void set_oauth2_client_id(const char* value);
void set_oauth2_client_id(const char* value, size_t size);
std::string* mutable_oauth2_client_id();
std::string* release_oauth2_client_id();
void set_allocated_oauth2_client_id(std::string* oauth2_client_id);

// optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
bool has_device_type() const;
void clear_device_type();
::enterprise_management::DeviceServiceApiAccessRequest_DeviceType device_type() const;
void set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceServiceApiAccessRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> auth_scopes_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oauth2_client_id_;
int device_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceServiceApiAccessResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceServiceApiAccessResponse) */ {
public:
DeviceServiceApiAccessResponse();
virtual ~DeviceServiceApiAccessResponse();

DeviceServiceApiAccessResponse(const DeviceServiceApiAccessResponse& from);
DeviceServiceApiAccessResponse(DeviceServiceApiAccessResponse&& from) noexcept
: DeviceServiceApiAccessResponse() {
*this = ::std::move(from);
}

inline DeviceServiceApiAccessResponse& operator=(const DeviceServiceApiAccessResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceServiceApiAccessResponse& operator=(DeviceServiceApiAccessResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceServiceApiAccessResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceServiceApiAccessResponse* internal_default_instance() {
return reinterpret_cast<const DeviceServiceApiAccessResponse*>(
&_DeviceServiceApiAccessResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
10;

friend void swap(DeviceServiceApiAccessResponse& a, DeviceServiceApiAccessResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceServiceApiAccessResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceServiceApiAccessResponse* New() const final {
return CreateMaybeMessage<DeviceServiceApiAccessResponse>(nullptr);
}

DeviceServiceApiAccessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceServiceApiAccessResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceServiceApiAccessResponse& from);
void MergeFrom(const DeviceServiceApiAccessResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceServiceApiAccessResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceServiceApiAccessResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAuthCodeFieldNumber = 1,
};
// optional string auth_code = 1;
bool has_auth_code() const;
void clear_auth_code();
const std::string& auth_code() const;
void set_auth_code(const std::string& value);
void set_auth_code(std::string&& value);
void set_auth_code(const char* value);
void set_auth_code(const char* value, size_t size);
std::string* mutable_auth_code();
std::string* release_auth_code();
void set_allocated_auth_code(std::string* auth_code);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceServiceApiAccessResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_code_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyFetchRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyFetchRequest) */ {
public:
PolicyFetchRequest();
virtual ~PolicyFetchRequest();

PolicyFetchRequest(const PolicyFetchRequest& from);
PolicyFetchRequest(PolicyFetchRequest&& from) noexcept
: PolicyFetchRequest() {
*this = ::std::move(from);
}

inline PolicyFetchRequest& operator=(const PolicyFetchRequest& from) {
CopyFrom(from);
return *this;
}
inline PolicyFetchRequest& operator=(PolicyFetchRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PolicyFetchRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PolicyFetchRequest* internal_default_instance() {
return reinterpret_cast<const PolicyFetchRequest*>(
&_PolicyFetchRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
11;

friend void swap(PolicyFetchRequest& a, PolicyFetchRequest& b) {
a.Swap(&b);
}
inline void Swap(PolicyFetchRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PolicyFetchRequest* New() const final {
return CreateMaybeMessage<PolicyFetchRequest>(nullptr);
}

PolicyFetchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PolicyFetchRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PolicyFetchRequest& from);
void MergeFrom(const PolicyFetchRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PolicyFetchRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PolicyFetchRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef PolicyFetchRequest_SignatureType SignatureType;
static constexpr SignatureType NONE =
PolicyFetchRequest_SignatureType_NONE;
static constexpr SignatureType SHA1_RSA =
PolicyFetchRequest_SignatureType_SHA1_RSA;
static constexpr SignatureType SHA256_RSA =
PolicyFetchRequest_SignatureType_SHA256_RSA;
static inline bool SignatureType_IsValid(int value) {
return PolicyFetchRequest_SignatureType_IsValid(value);
}
static constexpr SignatureType SignatureType_MIN =
PolicyFetchRequest_SignatureType_SignatureType_MIN;
static constexpr SignatureType SignatureType_MAX =
PolicyFetchRequest_SignatureType_SignatureType_MAX;
static constexpr int SignatureType_ARRAYSIZE =
PolicyFetchRequest_SignatureType_SignatureType_ARRAYSIZE;
template<typename T>
static inline const std::string& SignatureType_Name(T enum_t_value) {
static_assert(::std::is_same<T, SignatureType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function SignatureType_Name.");
return PolicyFetchRequest_SignatureType_Name(enum_t_value);
}
static inline bool SignatureType_Parse(const std::string& name,
SignatureType* value) {
return PolicyFetchRequest_SignatureType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPolicyTypeFieldNumber = 1,
kSettingsEntityIdFieldNumber = 6,
kInvalidationPayloadFieldNumber = 8,
kVerificationKeyHashFieldNumber = 9,
kPolicyInvalidationInfoFieldNumber = 10,
kDeviceDmTokenFieldNumber = 12,
kTimestampFieldNumber = 2,
kSignatureTypeFieldNumber = 3,
kPublicKeyVersionFieldNumber = 4,
kInvalidationVersionFieldNumber = 7,
kInvalidationTopicsOnlyFieldNumber = 11,
};
// optional string policy_type = 1;
bool has_policy_type() const;
void clear_policy_type();
const std::string& policy_type() const;
void set_policy_type(const std::string& value);
void set_policy_type(std::string&& value);
void set_policy_type(const char* value);
void set_policy_type(const char* value, size_t size);
std::string* mutable_policy_type();
std::string* release_policy_type();
void set_allocated_policy_type(std::string* policy_type);

// optional string settings_entity_id = 6;
bool has_settings_entity_id() const;
void clear_settings_entity_id();
const std::string& settings_entity_id() const;
void set_settings_entity_id(const std::string& value);
void set_settings_entity_id(std::string&& value);
void set_settings_entity_id(const char* value);
void set_settings_entity_id(const char* value, size_t size);
std::string* mutable_settings_entity_id();
std::string* release_settings_entity_id();
void set_allocated_settings_entity_id(std::string* settings_entity_id);

// optional bytes invalidation_payload = 8;
bool has_invalidation_payload() const;
void clear_invalidation_payload();
const std::string& invalidation_payload() const;
void set_invalidation_payload(const std::string& value);
void set_invalidation_payload(std::string&& value);
void set_invalidation_payload(const char* value);
void set_invalidation_payload(const void* value, size_t size);
std::string* mutable_invalidation_payload();
std::string* release_invalidation_payload();
void set_allocated_invalidation_payload(std::string* invalidation_payload);

// optional string verification_key_hash = 9;
bool has_verification_key_hash() const;
void clear_verification_key_hash();
const std::string& verification_key_hash() const;
void set_verification_key_hash(const std::string& value);
void set_verification_key_hash(std::string&& value);
void set_verification_key_hash(const char* value);
void set_verification_key_hash(const char* value, size_t size);
std::string* mutable_verification_key_hash();
std::string* release_verification_key_hash();
void set_allocated_verification_key_hash(std::string* verification_key_hash);

// optional string policy_invalidation_info = 10;
bool has_policy_invalidation_info() const;
void clear_policy_invalidation_info();
const std::string& policy_invalidation_info() const;
void set_policy_invalidation_info(const std::string& value);
void set_policy_invalidation_info(std::string&& value);
void set_policy_invalidation_info(const char* value);
void set_policy_invalidation_info(const char* value, size_t size);
std::string* mutable_policy_invalidation_info();
std::string* release_policy_invalidation_info();
void set_allocated_policy_invalidation_info(std::string* policy_invalidation_info);

// optional string device_dm_token = 12;
bool has_device_dm_token() const;
void clear_device_dm_token();
const std::string& device_dm_token() const;
void set_device_dm_token(const std::string& value);
void set_device_dm_token(std::string&& value);
void set_device_dm_token(const char* value);
void set_device_dm_token(const char* value, size_t size);
std::string* mutable_device_dm_token();
std::string* release_device_dm_token();
void set_allocated_device_dm_token(std::string* device_dm_token);

// optional int64 timestamp = 2;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
bool has_signature_type() const;
void clear_signature_type();
::enterprise_management::PolicyFetchRequest_SignatureType signature_type() const;
void set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);

// optional int32 public_key_version = 4;
bool has_public_key_version() const;
void clear_public_key_version();
::PROTOBUF_NAMESPACE_ID::int32 public_key_version() const;
void set_public_key_version(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 invalidation_version = 7;
bool has_invalidation_version() const;
void clear_invalidation_version();
::PROTOBUF_NAMESPACE_ID::int64 invalidation_version() const;
void set_invalidation_version(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional bool invalidation_topics_only = 11;
bool has_invalidation_topics_only() const;
void clear_invalidation_topics_only();
bool invalidation_topics_only() const;
void set_invalidation_topics_only(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settings_entity_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidation_payload_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_key_hash_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_invalidation_info_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_dm_token_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
int signature_type_;
::PROTOBUF_NAMESPACE_ID::int32 public_key_version_;
::PROTOBUF_NAMESPACE_ID::int64 invalidation_version_;
bool invalidation_topics_only_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DisabledState :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DisabledState) */ {
public:
DisabledState();
virtual ~DisabledState();

DisabledState(const DisabledState& from);
DisabledState(DisabledState&& from) noexcept
: DisabledState() {
*this = ::std::move(from);
}

inline DisabledState& operator=(const DisabledState& from) {
CopyFrom(from);
return *this;
}
inline DisabledState& operator=(DisabledState&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DisabledState& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DisabledState* internal_default_instance() {
return reinterpret_cast<const DisabledState*>(
&_DisabledState_default_instance_);
}
static constexpr int kIndexInFileMessages =
12;

friend void swap(DisabledState& a, DisabledState& b) {
a.Swap(&b);
}
inline void Swap(DisabledState* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DisabledState* New() const final {
return CreateMaybeMessage<DisabledState>(nullptr);
}

DisabledState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DisabledState>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DisabledState& from);
void MergeFrom(const DisabledState& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DisabledState* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DisabledState";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kMessageFieldNumber = 1,
};
// optional string message = 1;
bool has_message() const;
void clear_message();
const std::string& message() const;
void set_message(const std::string& value);
void set_message(std::string&& value);
void set_message(const char* value);
void set_message(const char* value, size_t size);
std::string* mutable_message();
std::string* release_message();
void set_allocated_message(std::string* message);

// @@protoc_insertion_point(class_scope:enterprise_management.DisabledState)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceState :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceState) */ {
public:
DeviceState();
virtual ~DeviceState();

DeviceState(const DeviceState& from);
DeviceState(DeviceState&& from) noexcept
: DeviceState() {
*this = ::std::move(from);
}

inline DeviceState& operator=(const DeviceState& from) {
CopyFrom(from);
return *this;
}
inline DeviceState& operator=(DeviceState&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceState& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceState* internal_default_instance() {
return reinterpret_cast<const DeviceState*>(
&_DeviceState_default_instance_);
}
static constexpr int kIndexInFileMessages =
13;

friend void swap(DeviceState& a, DeviceState& b) {
a.Swap(&b);
}
inline void Swap(DeviceState* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceState* New() const final {
return CreateMaybeMessage<DeviceState>(nullptr);
}

DeviceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceState>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceState& from);
void MergeFrom(const DeviceState& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceState* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceState";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceState_DeviceMode DeviceMode;
static constexpr DeviceMode DEVICE_MODE_NORMAL =
DeviceState_DeviceMode_DEVICE_MODE_NORMAL;
static constexpr DeviceMode DEVICE_MODE_DISABLED =
DeviceState_DeviceMode_DEVICE_MODE_DISABLED;
static inline bool DeviceMode_IsValid(int value) {
return DeviceState_DeviceMode_IsValid(value);
}
static constexpr DeviceMode DeviceMode_MIN =
DeviceState_DeviceMode_DeviceMode_MIN;
static constexpr DeviceMode DeviceMode_MAX =
DeviceState_DeviceMode_DeviceMode_MAX;
static constexpr int DeviceMode_ARRAYSIZE =
DeviceState_DeviceMode_DeviceMode_ARRAYSIZE;
template<typename T>
static inline const std::string& DeviceMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, DeviceMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function DeviceMode_Name.");
return DeviceState_DeviceMode_Name(enum_t_value);
}
static inline bool DeviceMode_Parse(const std::string& name,
DeviceMode* value) {
return DeviceState_DeviceMode_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kDisabledStateFieldNumber = 2,
kDeviceModeFieldNumber = 1,
};
// optional .enterprise_management.DisabledState disabled_state = 2;
bool has_disabled_state() const;
void clear_disabled_state();
const ::enterprise_management::DisabledState& disabled_state() const;
::enterprise_management::DisabledState* release_disabled_state();
::enterprise_management::DisabledState* mutable_disabled_state();
void set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state);

// optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
bool has_device_mode() const;
void clear_device_mode();
::enterprise_management::DeviceState_DeviceMode device_mode() const;
void set_device_mode(::enterprise_management::DeviceState_DeviceMode value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceState)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::enterprise_management::DisabledState* disabled_state_;
int device_mode_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CustomerLogo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CustomerLogo) */ {
public:
CustomerLogo();
virtual ~CustomerLogo();

CustomerLogo(const CustomerLogo& from);
CustomerLogo(CustomerLogo&& from) noexcept
: CustomerLogo() {
*this = ::std::move(from);
}

inline CustomerLogo& operator=(const CustomerLogo& from) {
CopyFrom(from);
return *this;
}
inline CustomerLogo& operator=(CustomerLogo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CustomerLogo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CustomerLogo* internal_default_instance() {
return reinterpret_cast<const CustomerLogo*>(
&_CustomerLogo_default_instance_);
}
static constexpr int kIndexInFileMessages =
14;

friend void swap(CustomerLogo& a, CustomerLogo& b) {
a.Swap(&b);
}
inline void Swap(CustomerLogo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CustomerLogo* New() const final {
return CreateMaybeMessage<CustomerLogo>(nullptr);
}

CustomerLogo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CustomerLogo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CustomerLogo& from);
void MergeFrom(const CustomerLogo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CustomerLogo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CustomerLogo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kLogoUrlFieldNumber = 1,
};
// optional string logo_url = 1;
bool has_logo_url() const;
void clear_logo_url();
const std::string& logo_url() const;
void set_logo_url(const std::string& value);
void set_logo_url(std::string&& value);
void set_logo_url(const char* value);
void set_logo_url(const char* value, size_t size);
std::string* mutable_logo_url();
std::string* release_logo_url();
void set_allocated_logo_url(std::string* logo_url);

// @@protoc_insertion_point(class_scope:enterprise_management.CustomerLogo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_url_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyData :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyData) */ {
public:
PolicyData();
virtual ~PolicyData();

PolicyData(const PolicyData& from);
PolicyData(PolicyData&& from) noexcept
: PolicyData() {
*this = ::std::move(from);
}

inline PolicyData& operator=(const PolicyData& from) {
CopyFrom(from);
return *this;
}
inline PolicyData& operator=(PolicyData&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PolicyData& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PolicyData* internal_default_instance() {
return reinterpret_cast<const PolicyData*>(
&_PolicyData_default_instance_);
}
static constexpr int kIndexInFileMessages =
15;

friend void swap(PolicyData& a, PolicyData& b) {
a.Swap(&b);
}
inline void Swap(PolicyData* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PolicyData* New() const final {
return CreateMaybeMessage<PolicyData>(nullptr);
}

PolicyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PolicyData>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PolicyData& from);
void MergeFrom(const PolicyData& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PolicyData* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PolicyData";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef PolicyData_AssociationState AssociationState;
static constexpr AssociationState ACTIVE =
PolicyData_AssociationState_ACTIVE;
static constexpr AssociationState UNMANAGED =
PolicyData_AssociationState_UNMANAGED;
static constexpr AssociationState DEPROVISIONED =
PolicyData_AssociationState_DEPROVISIONED;
static inline bool AssociationState_IsValid(int value) {
return PolicyData_AssociationState_IsValid(value);
}
static constexpr AssociationState AssociationState_MIN =
PolicyData_AssociationState_AssociationState_MIN;
static constexpr AssociationState AssociationState_MAX =
PolicyData_AssociationState_AssociationState_MAX;
static constexpr int AssociationState_ARRAYSIZE =
PolicyData_AssociationState_AssociationState_ARRAYSIZE;
template<typename T>
static inline const std::string& AssociationState_Name(T enum_t_value) {
static_assert(::std::is_same<T, AssociationState>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AssociationState_Name.");
return PolicyData_AssociationState_Name(enum_t_value);
}
static inline bool AssociationState_Parse(const std::string& name,
AssociationState* value) {
return PolicyData_AssociationState_Parse(name, value);
}

typedef PolicyData_ManagementMode ManagementMode;
static constexpr ManagementMode LOCAL_OWNER =
PolicyData_ManagementMode_LOCAL_OWNER;
static constexpr ManagementMode ENTERPRISE_MANAGED =
PolicyData_ManagementMode_ENTERPRISE_MANAGED;
static constexpr ManagementMode OBSOLETE_CONSUMER_MANAGED =
PolicyData_ManagementMode_OBSOLETE_CONSUMER_MANAGED;
static inline bool ManagementMode_IsValid(int value) {
return PolicyData_ManagementMode_IsValid(value);
}
static constexpr ManagementMode ManagementMode_MIN =
PolicyData_ManagementMode_ManagementMode_MIN;
static constexpr ManagementMode ManagementMode_MAX =
PolicyData_ManagementMode_ManagementMode_MAX;
static constexpr int ManagementMode_ARRAYSIZE =
PolicyData_ManagementMode_ManagementMode_ARRAYSIZE;
template<typename T>
static inline const std::string& ManagementMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, ManagementMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ManagementMode_Name.");
return PolicyData_ManagementMode_Name(enum_t_value);
}
static inline bool ManagementMode_Parse(const std::string& name,
ManagementMode* value) {
return PolicyData_ManagementMode_Parse(name, value);
}

typedef PolicyData_MarketSegment MarketSegment;
static constexpr MarketSegment MARKET_SEGMENT_UNSPECIFIED =
PolicyData_MarketSegment_MARKET_SEGMENT_UNSPECIFIED;
static constexpr MarketSegment ENROLLED_EDUCATION =
PolicyData_MarketSegment_ENROLLED_EDUCATION;
static constexpr MarketSegment ENROLLED_ENTERPRISE =
PolicyData_MarketSegment_ENROLLED_ENTERPRISE;
static inline bool MarketSegment_IsValid(int value) {
return PolicyData_MarketSegment_IsValid(value);
}
static constexpr MarketSegment MarketSegment_MIN =
PolicyData_MarketSegment_MarketSegment_MIN;
static constexpr MarketSegment MarketSegment_MAX =
PolicyData_MarketSegment_MarketSegment_MAX;
static constexpr int MarketSegment_ARRAYSIZE =
PolicyData_MarketSegment_MarketSegment_ARRAYSIZE;
template<typename T>
static inline const std::string& MarketSegment_Name(T enum_t_value) {
static_assert(::std::is_same<T, MarketSegment>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function MarketSegment_Name.");
return PolicyData_MarketSegment_Name(enum_t_value);
}
static inline bool MarketSegment_Parse(const std::string& name,
MarketSegment* value) {
return PolicyData_MarketSegment_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kDeviceAffiliationIdsFieldNumber = 23,
kUserAffiliationIdsFieldNumber = 24,
kPolicyTypeFieldNumber = 1,
kRequestTokenFieldNumber = 3,
kPolicyValueFieldNumber = 4,
kMachineNameFieldNumber = 5,
kUsernameFieldNumber = 7,
kDeviceIdFieldNumber = 8,
kSettingsEntityIdFieldNumber = 11,
kServiceAccountIdentityFieldNumber = 12,
kInvalidationNameFieldNumber = 14,
kPolicyTokenFieldNumber = 15,
kCommandInvalidationNameFieldNumber = 19,
kAnnotatedLocationFieldNumber = 20,
kAnnotatedAssetIdFieldNumber = 21,
kDirectoryApiIdFieldNumber = 22,
kDisplayDomainFieldNumber = 25,
kPolicyInvalidationTopicFieldNumber = 26,
kCommandInvalidationTopicFieldNumber = 27,
kGaiaIdFieldNumber = 29,
kChangePasswordUriFieldNumber = 32,
kObfuscatedCustomerIdFieldNumber = 34,
kDeviceStateFieldNumber = 17,
kCustomerLogoFieldNumber = 31,
kClientActionRequiredFieldNumber = 33,
kTimestampFieldNumber = 2,
kPublicKeyVersionFieldNumber = 6,
kStateFieldNumber = 9,
kInvalidationSourceFieldNumber = 13,
kManagementModeFieldNumber = 16,
kCommandInvalidationSourceFieldNumber = 18,
kEnrollmentIdNeededFieldNumber = 28,
kMarketSegmentFieldNumber = 30,
};
// repeated string device_affiliation_ids = 23;
int device_affiliation_ids_size() const;
void clear_device_affiliation_ids();
const std::string& device_affiliation_ids(int index) const;
std::string* mutable_device_affiliation_ids(int index);
void set_device_affiliation_ids(int index, const std::string& value);
void set_device_affiliation_ids(int index, std::string&& value);
void set_device_affiliation_ids(int index, const char* value);
void set_device_affiliation_ids(int index, const char* value, size_t size);
std::string* add_device_affiliation_ids();
void add_device_affiliation_ids(const std::string& value);
void add_device_affiliation_ids(std::string&& value);
void add_device_affiliation_ids(const char* value);
void add_device_affiliation_ids(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_affiliation_ids() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_affiliation_ids();

// repeated string user_affiliation_ids = 24;
int user_affiliation_ids_size() const;
void clear_user_affiliation_ids();
const std::string& user_affiliation_ids(int index) const;
std::string* mutable_user_affiliation_ids(int index);
void set_user_affiliation_ids(int index, const std::string& value);
void set_user_affiliation_ids(int index, std::string&& value);
void set_user_affiliation_ids(int index, const char* value);
void set_user_affiliation_ids(int index, const char* value, size_t size);
std::string* add_user_affiliation_ids();
void add_user_affiliation_ids(const std::string& value);
void add_user_affiliation_ids(std::string&& value);
void add_user_affiliation_ids(const char* value);
void add_user_affiliation_ids(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_affiliation_ids() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_affiliation_ids();

// optional string policy_type = 1;
bool has_policy_type() const;
void clear_policy_type();
const std::string& policy_type() const;
void set_policy_type(const std::string& value);
void set_policy_type(std::string&& value);
void set_policy_type(const char* value);
void set_policy_type(const char* value, size_t size);
std::string* mutable_policy_type();
std::string* release_policy_type();
void set_allocated_policy_type(std::string* policy_type);

// optional string request_token = 3;
bool has_request_token() const;
void clear_request_token();
const std::string& request_token() const;
void set_request_token(const std::string& value);
void set_request_token(std::string&& value);
void set_request_token(const char* value);
void set_request_token(const char* value, size_t size);
std::string* mutable_request_token();
std::string* release_request_token();
void set_allocated_request_token(std::string* request_token);

// optional bytes policy_value = 4;
bool has_policy_value() const;
void clear_policy_value();
const std::string& policy_value() const;
void set_policy_value(const std::string& value);
void set_policy_value(std::string&& value);
void set_policy_value(const char* value);
void set_policy_value(const void* value, size_t size);
std::string* mutable_policy_value();
std::string* release_policy_value();
void set_allocated_policy_value(std::string* policy_value);

// optional string machine_name = 5;
bool has_machine_name() const;
void clear_machine_name();
const std::string& machine_name() const;
void set_machine_name(const std::string& value);
void set_machine_name(std::string&& value);
void set_machine_name(const char* value);
void set_machine_name(const char* value, size_t size);
std::string* mutable_machine_name();
std::string* release_machine_name();
void set_allocated_machine_name(std::string* machine_name);

// optional string username = 7;
bool has_username() const;
void clear_username();
const std::string& username() const;
void set_username(const std::string& value);
void set_username(std::string&& value);
void set_username(const char* value);
void set_username(const char* value, size_t size);
std::string* mutable_username();
std::string* release_username();
void set_allocated_username(std::string* username);

// optional string device_id = 8;
bool has_device_id() const;
void clear_device_id();
const std::string& device_id() const;
void set_device_id(const std::string& value);
void set_device_id(std::string&& value);
void set_device_id(const char* value);
void set_device_id(const char* value, size_t size);
std::string* mutable_device_id();
std::string* release_device_id();
void set_allocated_device_id(std::string* device_id);

// optional string settings_entity_id = 11;
bool has_settings_entity_id() const;
void clear_settings_entity_id();
const std::string& settings_entity_id() const;
void set_settings_entity_id(const std::string& value);
void set_settings_entity_id(std::string&& value);
void set_settings_entity_id(const char* value);
void set_settings_entity_id(const char* value, size_t size);
std::string* mutable_settings_entity_id();
std::string* release_settings_entity_id();
void set_allocated_settings_entity_id(std::string* settings_entity_id);

// optional string service_account_identity = 12;
bool has_service_account_identity() const;
void clear_service_account_identity();
const std::string& service_account_identity() const;
void set_service_account_identity(const std::string& value);
void set_service_account_identity(std::string&& value);
void set_service_account_identity(const char* value);
void set_service_account_identity(const char* value, size_t size);
std::string* mutable_service_account_identity();
std::string* release_service_account_identity();
void set_allocated_service_account_identity(std::string* service_account_identity);

// optional bytes invalidation_name = 14;
bool has_invalidation_name() const;
void clear_invalidation_name();
const std::string& invalidation_name() const;
void set_invalidation_name(const std::string& value);
void set_invalidation_name(std::string&& value);
void set_invalidation_name(const char* value);
void set_invalidation_name(const void* value, size_t size);
std::string* mutable_invalidation_name();
std::string* release_invalidation_name();
void set_allocated_invalidation_name(std::string* invalidation_name);

// optional string policy_token = 15;
bool has_policy_token() const;
void clear_policy_token();
const std::string& policy_token() const;
void set_policy_token(const std::string& value);
void set_policy_token(std::string&& value);
void set_policy_token(const char* value);
void set_policy_token(const char* value, size_t size);
std::string* mutable_policy_token();
std::string* release_policy_token();
void set_allocated_policy_token(std::string* policy_token);

// optional bytes command_invalidation_name = 19;
bool has_command_invalidation_name() const;
void clear_command_invalidation_name();
const std::string& command_invalidation_name() const;
void set_command_invalidation_name(const std::string& value);
void set_command_invalidation_name(std::string&& value);
void set_command_invalidation_name(const char* value);
void set_command_invalidation_name(const void* value, size_t size);
std::string* mutable_command_invalidation_name();
std::string* release_command_invalidation_name();
void set_allocated_command_invalidation_name(std::string* command_invalidation_name);

// optional string annotated_location = 20;
bool has_annotated_location() const;
void clear_annotated_location();
const std::string& annotated_location() const;
void set_annotated_location(const std::string& value);
void set_annotated_location(std::string&& value);
void set_annotated_location(const char* value);
void set_annotated_location(const char* value, size_t size);
std::string* mutable_annotated_location();
std::string* release_annotated_location();
void set_allocated_annotated_location(std::string* annotated_location);

// optional string annotated_asset_id = 21;
bool has_annotated_asset_id() const;
void clear_annotated_asset_id();
const std::string& annotated_asset_id() const;
void set_annotated_asset_id(const std::string& value);
void set_annotated_asset_id(std::string&& value);
void set_annotated_asset_id(const char* value);
void set_annotated_asset_id(const char* value, size_t size);
std::string* mutable_annotated_asset_id();
std::string* release_annotated_asset_id();
void set_allocated_annotated_asset_id(std::string* annotated_asset_id);

// optional string directory_api_id = 22;
bool has_directory_api_id() const;
void clear_directory_api_id();
const std::string& directory_api_id() const;
void set_directory_api_id(const std::string& value);
void set_directory_api_id(std::string&& value);
void set_directory_api_id(const char* value);
void set_directory_api_id(const char* value, size_t size);
std::string* mutable_directory_api_id();
std::string* release_directory_api_id();
void set_allocated_directory_api_id(std::string* directory_api_id);

// optional string display_domain = 25;
bool has_display_domain() const;
void clear_display_domain();
const std::string& display_domain() const;
void set_display_domain(const std::string& value);
void set_display_domain(std::string&& value);
void set_display_domain(const char* value);
void set_display_domain(const char* value, size_t size);
std::string* mutable_display_domain();
std::string* release_display_domain();
void set_allocated_display_domain(std::string* display_domain);

// optional string policy_invalidation_topic = 26;
bool has_policy_invalidation_topic() const;
void clear_policy_invalidation_topic();
const std::string& policy_invalidation_topic() const;
void set_policy_invalidation_topic(const std::string& value);
void set_policy_invalidation_topic(std::string&& value);
void set_policy_invalidation_topic(const char* value);
void set_policy_invalidation_topic(const char* value, size_t size);
std::string* mutable_policy_invalidation_topic();
std::string* release_policy_invalidation_topic();
void set_allocated_policy_invalidation_topic(std::string* policy_invalidation_topic);

// optional string command_invalidation_topic = 27;
bool has_command_invalidation_topic() const;
void clear_command_invalidation_topic();
const std::string& command_invalidation_topic() const;
void set_command_invalidation_topic(const std::string& value);
void set_command_invalidation_topic(std::string&& value);
void set_command_invalidation_topic(const char* value);
void set_command_invalidation_topic(const char* value, size_t size);
std::string* mutable_command_invalidation_topic();
std::string* release_command_invalidation_topic();
void set_allocated_command_invalidation_topic(std::string* command_invalidation_topic);

// optional string gaia_id = 29;
bool has_gaia_id() const;
void clear_gaia_id();
const std::string& gaia_id() const;
void set_gaia_id(const std::string& value);
void set_gaia_id(std::string&& value);
void set_gaia_id(const char* value);
void set_gaia_id(const char* value, size_t size);
std::string* mutable_gaia_id();
std::string* release_gaia_id();
void set_allocated_gaia_id(std::string* gaia_id);

// optional string change_password_uri = 32;
bool has_change_password_uri() const;
void clear_change_password_uri();
const std::string& change_password_uri() const;
void set_change_password_uri(const std::string& value);
void set_change_password_uri(std::string&& value);
void set_change_password_uri(const char* value);
void set_change_password_uri(const char* value, size_t size);
std::string* mutable_change_password_uri();
std::string* release_change_password_uri();
void set_allocated_change_password_uri(std::string* change_password_uri);

// optional string obfuscated_customer_id = 34;
bool has_obfuscated_customer_id() const;
void clear_obfuscated_customer_id();
const std::string& obfuscated_customer_id() const;
void set_obfuscated_customer_id(const std::string& value);
void set_obfuscated_customer_id(std::string&& value);
void set_obfuscated_customer_id(const char* value);
void set_obfuscated_customer_id(const char* value, size_t size);
std::string* mutable_obfuscated_customer_id();
std::string* release_obfuscated_customer_id();
void set_allocated_obfuscated_customer_id(std::string* obfuscated_customer_id);

// optional .enterprise_management.DeviceState device_state = 17;
bool has_device_state() const;
void clear_device_state();
const ::enterprise_management::DeviceState& device_state() const;
::enterprise_management::DeviceState* release_device_state();
::enterprise_management::DeviceState* mutable_device_state();
void set_allocated_device_state(::enterprise_management::DeviceState* device_state);

// optional .enterprise_management.CustomerLogo customer_logo = 31;
bool has_customer_logo() const;
void clear_customer_logo();
const ::enterprise_management::CustomerLogo& customer_logo() const;
::enterprise_management::CustomerLogo* release_customer_logo();
::enterprise_management::CustomerLogo* mutable_customer_logo();
void set_allocated_customer_logo(::enterprise_management::CustomerLogo* customer_logo);

// optional .enterprise_management.ClientActionRequired client_action_required = 33;
bool has_client_action_required() const;
void clear_client_action_required();
const ::enterprise_management::ClientActionRequired& client_action_required() const;
::enterprise_management::ClientActionRequired* release_client_action_required();
::enterprise_management::ClientActionRequired* mutable_client_action_required();
void set_allocated_client_action_required(::enterprise_management::ClientActionRequired* client_action_required);

// optional int64 timestamp = 2;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 public_key_version = 6;
bool has_public_key_version() const;
void clear_public_key_version();
::PROTOBUF_NAMESPACE_ID::int32 public_key_version() const;
void set_public_key_version(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
bool has_state() const;
void clear_state();
::enterprise_management::PolicyData_AssociationState state() const;
void set_state(::enterprise_management::PolicyData_AssociationState value);

// optional int32 invalidation_source = 13;
bool has_invalidation_source() const;
void clear_invalidation_source();
::PROTOBUF_NAMESPACE_ID::int32 invalidation_source() const;
void set_invalidation_source(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
bool has_management_mode() const;
void clear_management_mode();
::enterprise_management::PolicyData_ManagementMode management_mode() const;
void set_management_mode(::enterprise_management::PolicyData_ManagementMode value);

// optional int32 command_invalidation_source = 18;
bool has_command_invalidation_source() const;
void clear_command_invalidation_source();
::PROTOBUF_NAMESPACE_ID::int32 command_invalidation_source() const;
void set_command_invalidation_source(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional bool enrollment_id_needed = 28;
bool has_enrollment_id_needed() const;
void clear_enrollment_id_needed();
bool enrollment_id_needed() const;
void set_enrollment_id_needed(bool value);

// optional .enterprise_management.PolicyData.MarketSegment market_segment = 30;
bool has_market_segment() const;
void clear_market_segment();
::enterprise_management::PolicyData_MarketSegment market_segment() const;
void set_market_segment(::enterprise_management::PolicyData_MarketSegment value);

// @@protoc_insertion_point(class_scope:enterprise_management.PolicyData)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_affiliation_ids_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_affiliation_ids_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_value_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settings_entity_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_account_identity_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidation_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_invalidation_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr annotated_location_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr annotated_asset_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_api_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_domain_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_invalidation_topic_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_invalidation_topic_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr change_password_uri_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obfuscated_customer_id_;
::enterprise_management::DeviceState* device_state_;
::enterprise_management::CustomerLogo* customer_logo_;
::enterprise_management::ClientActionRequired* client_action_required_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
::PROTOBUF_NAMESPACE_ID::int32 public_key_version_;
int state_;
::PROTOBUF_NAMESPACE_ID::int32 invalidation_source_;
int management_mode_;
::PROTOBUF_NAMESPACE_ID::int32 command_invalidation_source_;
bool enrollment_id_needed_;
int market_segment_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ClientActionRequired :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ClientActionRequired) */ {
public:
ClientActionRequired();
virtual ~ClientActionRequired();

ClientActionRequired(const ClientActionRequired& from);
ClientActionRequired(ClientActionRequired&& from) noexcept
: ClientActionRequired() {
*this = ::std::move(from);
}

inline ClientActionRequired& operator=(const ClientActionRequired& from) {
CopyFrom(from);
return *this;
}
inline ClientActionRequired& operator=(ClientActionRequired&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ClientActionRequired& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ClientActionRequired* internal_default_instance() {
return reinterpret_cast<const ClientActionRequired*>(
&_ClientActionRequired_default_instance_);
}
static constexpr int kIndexInFileMessages =
16;

friend void swap(ClientActionRequired& a, ClientActionRequired& b) {
a.Swap(&b);
}
inline void Swap(ClientActionRequired* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ClientActionRequired* New() const final {
return CreateMaybeMessage<ClientActionRequired>(nullptr);
}

ClientActionRequired* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ClientActionRequired>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ClientActionRequired& from);
void MergeFrom(const ClientActionRequired& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ClientActionRequired* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ClientActionRequired";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kEnrollmentCertificateNeededFieldNumber = 1,
};
// optional bool enrollment_certificate_needed = 1;
bool has_enrollment_certificate_needed() const;
void clear_enrollment_certificate_needed();
bool enrollment_certificate_needed() const;
void set_enrollment_certificate_needed(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.ClientActionRequired)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
bool enrollment_certificate_needed_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyFetchResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyFetchResponse) */ {
public:
PolicyFetchResponse();
virtual ~PolicyFetchResponse();

PolicyFetchResponse(const PolicyFetchResponse& from);
PolicyFetchResponse(PolicyFetchResponse&& from) noexcept
: PolicyFetchResponse() {
*this = ::std::move(from);
}

inline PolicyFetchResponse& operator=(const PolicyFetchResponse& from) {
CopyFrom(from);
return *this;
}
inline PolicyFetchResponse& operator=(PolicyFetchResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PolicyFetchResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PolicyFetchResponse* internal_default_instance() {
return reinterpret_cast<const PolicyFetchResponse*>(
&_PolicyFetchResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
17;

friend void swap(PolicyFetchResponse& a, PolicyFetchResponse& b) {
a.Swap(&b);
}
inline void Swap(PolicyFetchResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PolicyFetchResponse* New() const final {
return CreateMaybeMessage<PolicyFetchResponse>(nullptr);
}

PolicyFetchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PolicyFetchResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PolicyFetchResponse& from);
void MergeFrom(const PolicyFetchResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PolicyFetchResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PolicyFetchResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kErrorMessageFieldNumber = 2,
kPolicyDataFieldNumber = 3,
kPolicyDataSignatureFieldNumber = 4,
kNewPublicKeyFieldNumber = 5,
kNewPublicKeySignatureFieldNumber = 6,
kNewPublicKeyVerificationSignatureDeprecatedFieldNumber = 7,
kNewPublicKeyVerificationDataFieldNumber = 8,
kNewPublicKeyVerificationDataSignatureFieldNumber = 9,
kPolicyTypeFieldNumber = 10,
kErrorCodeFieldNumber = 1,
kPolicyDataSignatureTypeFieldNumber = 11,
};
// optional string error_message = 2;
bool has_error_message() const;
void clear_error_message();
const std::string& error_message() const;
void set_error_message(const std::string& value);
void set_error_message(std::string&& value);
void set_error_message(const char* value);
void set_error_message(const char* value, size_t size);
std::string* mutable_error_message();
std::string* release_error_message();
void set_allocated_error_message(std::string* error_message);

// optional bytes policy_data = 3;
bool has_policy_data() const;
void clear_policy_data();
const std::string& policy_data() const;
void set_policy_data(const std::string& value);
void set_policy_data(std::string&& value);
void set_policy_data(const char* value);
void set_policy_data(const void* value, size_t size);
std::string* mutable_policy_data();
std::string* release_policy_data();
void set_allocated_policy_data(std::string* policy_data);

// optional bytes policy_data_signature = 4;
bool has_policy_data_signature() const;
void clear_policy_data_signature();
const std::string& policy_data_signature() const;
void set_policy_data_signature(const std::string& value);
void set_policy_data_signature(std::string&& value);
void set_policy_data_signature(const char* value);
void set_policy_data_signature(const void* value, size_t size);
std::string* mutable_policy_data_signature();
std::string* release_policy_data_signature();
void set_allocated_policy_data_signature(std::string* policy_data_signature);

// optional bytes new_public_key = 5;
bool has_new_public_key() const;
void clear_new_public_key();
const std::string& new_public_key() const;
void set_new_public_key(const std::string& value);
void set_new_public_key(std::string&& value);
void set_new_public_key(const char* value);
void set_new_public_key(const void* value, size_t size);
std::string* mutable_new_public_key();
std::string* release_new_public_key();
void set_allocated_new_public_key(std::string* new_public_key);

// optional bytes new_public_key_signature = 6;
bool has_new_public_key_signature() const;
void clear_new_public_key_signature();
const std::string& new_public_key_signature() const;
void set_new_public_key_signature(const std::string& value);
void set_new_public_key_signature(std::string&& value);
void set_new_public_key_signature(const char* value);
void set_new_public_key_signature(const void* value, size_t size);
std::string* mutable_new_public_key_signature();
std::string* release_new_public_key_signature();
void set_allocated_new_public_key_signature(std::string* new_public_key_signature);

// optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
PROTOBUF_DEPRECATED bool has_new_public_key_verification_signature_deprecated() const;
PROTOBUF_DEPRECATED void clear_new_public_key_verification_signature_deprecated();
PROTOBUF_DEPRECATED const std::string& new_public_key_verification_signature_deprecated() const;
PROTOBUF_DEPRECATED void set_new_public_key_verification_signature_deprecated(const std::string& value);
PROTOBUF_DEPRECATED void set_new_public_key_verification_signature_deprecated(std::string&& value);
PROTOBUF_DEPRECATED void set_new_public_key_verification_signature_deprecated(const char* value);
PROTOBUF_DEPRECATED void set_new_public_key_verification_signature_deprecated(const void* value, size_t size);
PROTOBUF_DEPRECATED std::string* mutable_new_public_key_verification_signature_deprecated();
PROTOBUF_DEPRECATED std::string* release_new_public_key_verification_signature_deprecated();
PROTOBUF_DEPRECATED void set_allocated_new_public_key_verification_signature_deprecated(std::string* new_public_key_verification_signature_deprecated);

// optional bytes new_public_key_verification_data = 8;
bool has_new_public_key_verification_data() const;
void clear_new_public_key_verification_data();
const std::string& new_public_key_verification_data() const;
void set_new_public_key_verification_data(const std::string& value);
void set_new_public_key_verification_data(std::string&& value);
void set_new_public_key_verification_data(const char* value);
void set_new_public_key_verification_data(const void* value, size_t size);
std::string* mutable_new_public_key_verification_data();
std::string* release_new_public_key_verification_data();
void set_allocated_new_public_key_verification_data(std::string* new_public_key_verification_data);

// optional bytes new_public_key_verification_data_signature = 9;
bool has_new_public_key_verification_data_signature() const;
void clear_new_public_key_verification_data_signature();
const std::string& new_public_key_verification_data_signature() const;
void set_new_public_key_verification_data_signature(const std::string& value);
void set_new_public_key_verification_data_signature(std::string&& value);
void set_new_public_key_verification_data_signature(const char* value);
void set_new_public_key_verification_data_signature(const void* value, size_t size);
std::string* mutable_new_public_key_verification_data_signature();
std::string* release_new_public_key_verification_data_signature();
void set_allocated_new_public_key_verification_data_signature(std::string* new_public_key_verification_data_signature);

// optional string policy_type = 10 [deprecated = true];
PROTOBUF_DEPRECATED bool has_policy_type() const;
PROTOBUF_DEPRECATED void clear_policy_type();
PROTOBUF_DEPRECATED const std::string& policy_type() const;
PROTOBUF_DEPRECATED void set_policy_type(const std::string& value);
PROTOBUF_DEPRECATED void set_policy_type(std::string&& value);
PROTOBUF_DEPRECATED void set_policy_type(const char* value);
PROTOBUF_DEPRECATED void set_policy_type(const char* value, size_t size);
PROTOBUF_DEPRECATED std::string* mutable_policy_type();
PROTOBUF_DEPRECATED std::string* release_policy_type();
PROTOBUF_DEPRECATED void set_allocated_policy_type(std::string* policy_type);

// optional int32 error_code = 1;
bool has_error_code() const;
void clear_error_code();
::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional .enterprise_management.PolicyFetchRequest.SignatureType policy_data_signature_type = 11;
bool has_policy_data_signature_type() const;
void clear_policy_data_signature_type();
::enterprise_management::PolicyFetchRequest_SignatureType policy_data_signature_type() const;
void set_policy_data_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);

// @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_data_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_data_signature_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_signature_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_verification_signature_deprecated_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_verification_data_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_verification_data_signature_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
::PROTOBUF_NAMESPACE_ID::int32 error_code_;
int policy_data_signature_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DEPRECATEDPolicyPublicKeyAndDomain :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain) */ {
public:
DEPRECATEDPolicyPublicKeyAndDomain();
virtual ~DEPRECATEDPolicyPublicKeyAndDomain();

DEPRECATEDPolicyPublicKeyAndDomain(const DEPRECATEDPolicyPublicKeyAndDomain& from);
DEPRECATEDPolicyPublicKeyAndDomain(DEPRECATEDPolicyPublicKeyAndDomain&& from) noexcept
: DEPRECATEDPolicyPublicKeyAndDomain() {
*this = ::std::move(from);
}

inline DEPRECATEDPolicyPublicKeyAndDomain& operator=(const DEPRECATEDPolicyPublicKeyAndDomain& from) {
CopyFrom(from);
return *this;
}
inline DEPRECATEDPolicyPublicKeyAndDomain& operator=(DEPRECATEDPolicyPublicKeyAndDomain&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DEPRECATEDPolicyPublicKeyAndDomain& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DEPRECATEDPolicyPublicKeyAndDomain* internal_default_instance() {
return reinterpret_cast<const DEPRECATEDPolicyPublicKeyAndDomain*>(
&_DEPRECATEDPolicyPublicKeyAndDomain_default_instance_);
}
static constexpr int kIndexInFileMessages =
18;

friend void swap(DEPRECATEDPolicyPublicKeyAndDomain& a, DEPRECATEDPolicyPublicKeyAndDomain& b) {
a.Swap(&b);
}
inline void Swap(DEPRECATEDPolicyPublicKeyAndDomain* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DEPRECATEDPolicyPublicKeyAndDomain* New() const final {
return CreateMaybeMessage<DEPRECATEDPolicyPublicKeyAndDomain>(nullptr);
}

DEPRECATEDPolicyPublicKeyAndDomain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DEPRECATEDPolicyPublicKeyAndDomain>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from);
void MergeFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DEPRECATEDPolicyPublicKeyAndDomain* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNewPublicKeyFieldNumber = 1,
kDomainFieldNumber = 2,
};
// optional bytes new_public_key = 1;
bool has_new_public_key() const;
void clear_new_public_key();
const std::string& new_public_key() const;
void set_new_public_key(const std::string& value);
void set_new_public_key(std::string&& value);
void set_new_public_key(const char* value);
void set_new_public_key(const void* value, size_t size);
std::string* mutable_new_public_key();
std::string* release_new_public_key();
void set_allocated_new_public_key(std::string* new_public_key);

// optional string domain = 2;
bool has_domain() const;
void clear_domain();
const std::string& domain() const;
void set_domain(const std::string& value);
void set_domain(std::string&& value);
void set_domain(const char* value);
void set_domain(const char* value, size_t size);
std::string* mutable_domain();
std::string* release_domain();
void set_allocated_domain(std::string* domain);

// @@protoc_insertion_point(class_scope:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PublicKeyVerificationData :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PublicKeyVerificationData) */ {
public:
PublicKeyVerificationData();
virtual ~PublicKeyVerificationData();

PublicKeyVerificationData(const PublicKeyVerificationData& from);
PublicKeyVerificationData(PublicKeyVerificationData&& from) noexcept
: PublicKeyVerificationData() {
*this = ::std::move(from);
}

inline PublicKeyVerificationData& operator=(const PublicKeyVerificationData& from) {
CopyFrom(from);
return *this;
}
inline PublicKeyVerificationData& operator=(PublicKeyVerificationData&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PublicKeyVerificationData& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PublicKeyVerificationData* internal_default_instance() {
return reinterpret_cast<const PublicKeyVerificationData*>(
&_PublicKeyVerificationData_default_instance_);
}
static constexpr int kIndexInFileMessages =
19;

friend void swap(PublicKeyVerificationData& a, PublicKeyVerificationData& b) {
a.Swap(&b);
}
inline void Swap(PublicKeyVerificationData* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PublicKeyVerificationData* New() const final {
return CreateMaybeMessage<PublicKeyVerificationData>(nullptr);
}

PublicKeyVerificationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PublicKeyVerificationData>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PublicKeyVerificationData& from);
void MergeFrom(const PublicKeyVerificationData& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PublicKeyVerificationData* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PublicKeyVerificationData";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNewPublicKeyFieldNumber = 1,
kDomainFieldNumber = 2,
kNewPublicKeyVersionFieldNumber = 3,
};
// optional bytes new_public_key = 1;
bool has_new_public_key() const;
void clear_new_public_key();
const std::string& new_public_key() const;
void set_new_public_key(const std::string& value);
void set_new_public_key(std::string&& value);
void set_new_public_key(const char* value);
void set_new_public_key(const void* value, size_t size);
std::string* mutable_new_public_key();
std::string* release_new_public_key();
void set_allocated_new_public_key(std::string* new_public_key);

// optional string domain = 2;
bool has_domain() const;
void clear_domain();
const std::string& domain() const;
void set_domain(const std::string& value);
void set_domain(std::string&& value);
void set_domain(const char* value);
void set_domain(const char* value, size_t size);
std::string* mutable_domain();
std::string* release_domain();
void set_allocated_domain(std::string* domain);

// optional int32 new_public_key_version = 3;
bool has_new_public_key_version() const;
void clear_new_public_key_version();
::PROTOBUF_NAMESPACE_ID::int32 new_public_key_version() const;
void set_new_public_key_version(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.PublicKeyVerificationData)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
::PROTOBUF_NAMESPACE_ID::int32 new_public_key_version_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePolicyRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePolicyRequest) */ {
public:
DevicePolicyRequest();
virtual ~DevicePolicyRequest();

DevicePolicyRequest(const DevicePolicyRequest& from);
DevicePolicyRequest(DevicePolicyRequest&& from) noexcept
: DevicePolicyRequest() {
*this = ::std::move(from);
}

inline DevicePolicyRequest& operator=(const DevicePolicyRequest& from) {
CopyFrom(from);
return *this;
}
inline DevicePolicyRequest& operator=(DevicePolicyRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DevicePolicyRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DevicePolicyRequest* internal_default_instance() {
return reinterpret_cast<const DevicePolicyRequest*>(
&_DevicePolicyRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
20;

friend void swap(DevicePolicyRequest& a, DevicePolicyRequest& b) {
a.Swap(&b);
}
inline void Swap(DevicePolicyRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DevicePolicyRequest* New() const final {
return CreateMaybeMessage<DevicePolicyRequest>(nullptr);
}

DevicePolicyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DevicePolicyRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DevicePolicyRequest& from);
void MergeFrom(const DevicePolicyRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DevicePolicyRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DevicePolicyRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kRequestsFieldNumber = 3,
};
// repeated .enterprise_management.PolicyFetchRequest requests = 3;
int requests_size() const;
void clear_requests();
::enterprise_management::PolicyFetchRequest* mutable_requests(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >*
mutable_requests();
const ::enterprise_management::PolicyFetchRequest& requests(int index) const;
::enterprise_management::PolicyFetchRequest* add_requests();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >&
requests() const;

// @@protoc_insertion_point(class_scope:enterprise_management.DevicePolicyRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest > requests_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePolicyResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePolicyResponse) */ {
public:
DevicePolicyResponse();
virtual ~DevicePolicyResponse();

DevicePolicyResponse(const DevicePolicyResponse& from);
DevicePolicyResponse(DevicePolicyResponse&& from) noexcept
: DevicePolicyResponse() {
*this = ::std::move(from);
}

inline DevicePolicyResponse& operator=(const DevicePolicyResponse& from) {
CopyFrom(from);
return *this;
}
inline DevicePolicyResponse& operator=(DevicePolicyResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DevicePolicyResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DevicePolicyResponse* internal_default_instance() {
return reinterpret_cast<const DevicePolicyResponse*>(
&_DevicePolicyResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
21;

friend void swap(DevicePolicyResponse& a, DevicePolicyResponse& b) {
a.Swap(&b);
}
inline void Swap(DevicePolicyResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DevicePolicyResponse* New() const final {
return CreateMaybeMessage<DevicePolicyResponse>(nullptr);
}

DevicePolicyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DevicePolicyResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DevicePolicyResponse& from);
void MergeFrom(const DevicePolicyResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DevicePolicyResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DevicePolicyResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kResponsesFieldNumber = 3,
};
// repeated .enterprise_management.PolicyFetchResponse responses = 3;
int responses_size() const;
void clear_responses();
::enterprise_management::PolicyFetchResponse* mutable_responses(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >*
mutable_responses();
const ::enterprise_management::PolicyFetchResponse& responses(int index) const;
::enterprise_management::PolicyFetchResponse* add_responses();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >&
responses() const;

// @@protoc_insertion_point(class_scope:enterprise_management.DevicePolicyResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse > responses_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT TimePeriod :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TimePeriod) */ {
public:
TimePeriod();
virtual ~TimePeriod();

TimePeriod(const TimePeriod& from);
TimePeriod(TimePeriod&& from) noexcept
: TimePeriod() {
*this = ::std::move(from);
}

inline TimePeriod& operator=(const TimePeriod& from) {
CopyFrom(from);
return *this;
}
inline TimePeriod& operator=(TimePeriod&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const TimePeriod& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const TimePeriod* internal_default_instance() {
return reinterpret_cast<const TimePeriod*>(
&_TimePeriod_default_instance_);
}
static constexpr int kIndexInFileMessages =
22;

friend void swap(TimePeriod& a, TimePeriod& b) {
a.Swap(&b);
}
inline void Swap(TimePeriod* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline TimePeriod* New() const final {
return CreateMaybeMessage<TimePeriod>(nullptr);
}

TimePeriod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<TimePeriod>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const TimePeriod& from);
void MergeFrom(const TimePeriod& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TimePeriod* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.TimePeriod";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kStartTimestampFieldNumber = 1,
kEndTimestampFieldNumber = 2,
};
// optional int64 start_timestamp = 1;
bool has_start_timestamp() const;
void clear_start_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 start_timestamp() const;
void set_start_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 end_timestamp = 2;
bool has_end_timestamp() const;
void clear_end_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 end_timestamp() const;
void set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.TimePeriod)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 start_timestamp_;
::PROTOBUF_NAMESPACE_ID::int64 end_timestamp_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveTimePeriod :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveTimePeriod) */ {
public:
ActiveTimePeriod();
virtual ~ActiveTimePeriod();

ActiveTimePeriod(const ActiveTimePeriod& from);
ActiveTimePeriod(ActiveTimePeriod&& from) noexcept
: ActiveTimePeriod() {
*this = ::std::move(from);
}

inline ActiveTimePeriod& operator=(const ActiveTimePeriod& from) {
CopyFrom(from);
return *this;
}
inline ActiveTimePeriod& operator=(ActiveTimePeriod&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ActiveTimePeriod& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ActiveTimePeriod* internal_default_instance() {
return reinterpret_cast<const ActiveTimePeriod*>(
&_ActiveTimePeriod_default_instance_);
}
static constexpr int kIndexInFileMessages =
23;

friend void swap(ActiveTimePeriod& a, ActiveTimePeriod& b) {
a.Swap(&b);
}
inline void Swap(ActiveTimePeriod* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ActiveTimePeriod* New() const final {
return CreateMaybeMessage<ActiveTimePeriod>(nullptr);
}

ActiveTimePeriod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ActiveTimePeriod>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ActiveTimePeriod& from);
void MergeFrom(const ActiveTimePeriod& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ActiveTimePeriod* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ActiveTimePeriod";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kUserEmailFieldNumber = 3,
kTimePeriodFieldNumber = 1,
kActiveDurationFieldNumber = 2,
};
// optional string user_email = 3;
bool has_user_email() const;
void clear_user_email();
const std::string& user_email() const;
void set_user_email(const std::string& value);
void set_user_email(std::string&& value);
void set_user_email(const char* value);
void set_user_email(const char* value, size_t size);
std::string* mutable_user_email();
std::string* release_user_email();
void set_allocated_user_email(std::string* user_email);

// optional .enterprise_management.TimePeriod time_period = 1;
bool has_time_period() const;
void clear_time_period();
const ::enterprise_management::TimePeriod& time_period() const;
::enterprise_management::TimePeriod* release_time_period();
::enterprise_management::TimePeriod* mutable_time_period();
void set_allocated_time_period(::enterprise_management::TimePeriod* time_period);

// optional int32 active_duration = 2;
bool has_active_duration() const;
void clear_active_duration();
::PROTOBUF_NAMESPACE_ID::int32 active_duration() const;
void set_active_duration(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.ActiveTimePeriod)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_email_;
::enterprise_management::TimePeriod* time_period_;
::PROTOBUF_NAMESPACE_ID::int32 active_duration_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT NetworkInterface :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.NetworkInterface) */ {
public:
NetworkInterface();
virtual ~NetworkInterface();

NetworkInterface(const NetworkInterface& from);
NetworkInterface(NetworkInterface&& from) noexcept
: NetworkInterface() {
*this = ::std::move(from);
}

inline NetworkInterface& operator=(const NetworkInterface& from) {
CopyFrom(from);
return *this;
}
inline NetworkInterface& operator=(NetworkInterface&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const NetworkInterface& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const NetworkInterface* internal_default_instance() {
return reinterpret_cast<const NetworkInterface*>(
&_NetworkInterface_default_instance_);
}
static constexpr int kIndexInFileMessages =
24;

friend void swap(NetworkInterface& a, NetworkInterface& b) {
a.Swap(&b);
}
inline void Swap(NetworkInterface* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline NetworkInterface* New() const final {
return CreateMaybeMessage<NetworkInterface>(nullptr);
}

NetworkInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<NetworkInterface>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const NetworkInterface& from);
void MergeFrom(const NetworkInterface& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(NetworkInterface* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.NetworkInterface";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef NetworkInterface_NetworkDeviceType NetworkDeviceType;
static constexpr NetworkDeviceType TYPE_ETHERNET =
NetworkInterface_NetworkDeviceType_TYPE_ETHERNET;
static constexpr NetworkDeviceType TYPE_WIFI =
NetworkInterface_NetworkDeviceType_TYPE_WIFI;
static constexpr NetworkDeviceType TYPE_BLUETOOTH =
NetworkInterface_NetworkDeviceType_TYPE_BLUETOOTH;
static constexpr NetworkDeviceType TYPE_CELLULAR =
NetworkInterface_NetworkDeviceType_TYPE_CELLULAR;
static inline bool NetworkDeviceType_IsValid(int value) {
return NetworkInterface_NetworkDeviceType_IsValid(value);
}
static constexpr NetworkDeviceType NetworkDeviceType_MIN =
NetworkInterface_NetworkDeviceType_NetworkDeviceType_MIN;
static constexpr NetworkDeviceType NetworkDeviceType_MAX =
NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX;
static constexpr int NetworkDeviceType_ARRAYSIZE =
NetworkInterface_NetworkDeviceType_NetworkDeviceType_ARRAYSIZE;
template<typename T>
static inline const std::string& NetworkDeviceType_Name(T enum_t_value) {
static_assert(::std::is_same<T, NetworkDeviceType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function NetworkDeviceType_Name.");
return NetworkInterface_NetworkDeviceType_Name(enum_t_value);
}
static inline bool NetworkDeviceType_Parse(const std::string& name,
NetworkDeviceType* value) {
return NetworkInterface_NetworkDeviceType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kMacAddressFieldNumber = 2,
kMeidFieldNumber = 3,
kImeiFieldNumber = 4,
kDevicePathFieldNumber = 5,
kTypeFieldNumber = 1,
};
// optional string mac_address = 2;
bool has_mac_address() const;
void clear_mac_address();
const std::string& mac_address() const;
void set_mac_address(const std::string& value);
void set_mac_address(std::string&& value);
void set_mac_address(const char* value);
void set_mac_address(const char* value, size_t size);
std::string* mutable_mac_address();
std::string* release_mac_address();
void set_allocated_mac_address(std::string* mac_address);

// optional string meid = 3;
bool has_meid() const;
void clear_meid();
const std::string& meid() const;
void set_meid(const std::string& value);
void set_meid(std::string&& value);
void set_meid(const char* value);
void set_meid(const char* value, size_t size);
std::string* mutable_meid();
std::string* release_meid();
void set_allocated_meid(std::string* meid);

// optional string imei = 4;
bool has_imei() const;
void clear_imei();
const std::string& imei() const;
void set_imei(const std::string& value);
void set_imei(std::string&& value);
void set_imei(const char* value);
void set_imei(const char* value, size_t size);
std::string* mutable_imei();
std::string* release_imei();
void set_allocated_imei(std::string* imei);

// optional string device_path = 5;
bool has_device_path() const;
void clear_device_path();
const std::string& device_path() const;
void set_device_path(const std::string& value);
void set_device_path(std::string&& value);
void set_device_path(const char* value);
void set_device_path(const char* value, size_t size);
std::string* mutable_device_path();
std::string* release_device_path();
void set_allocated_device_path(std::string* device_path);

// optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
bool has_type() const;
void clear_type();
::enterprise_management::NetworkInterface_NetworkDeviceType type() const;
void set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value);

// @@protoc_insertion_point(class_scope:enterprise_management.NetworkInterface)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meid_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imei_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_path_;
int type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT NetworkState :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.NetworkState) */ {
public:
NetworkState();
virtual ~NetworkState();

NetworkState(const NetworkState& from);
NetworkState(NetworkState&& from) noexcept
: NetworkState() {
*this = ::std::move(from);
}

inline NetworkState& operator=(const NetworkState& from) {
CopyFrom(from);
return *this;
}
inline NetworkState& operator=(NetworkState&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const NetworkState& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const NetworkState* internal_default_instance() {
return reinterpret_cast<const NetworkState*>(
&_NetworkState_default_instance_);
}
static constexpr int kIndexInFileMessages =
25;

friend void swap(NetworkState& a, NetworkState& b) {
a.Swap(&b);
}
inline void Swap(NetworkState* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline NetworkState* New() const final {
return CreateMaybeMessage<NetworkState>(nullptr);
}

NetworkState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<NetworkState>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const NetworkState& from);
void MergeFrom(const NetworkState& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(NetworkState* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.NetworkState";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef NetworkState_ConnectionState ConnectionState;
static constexpr ConnectionState IDLE =
NetworkState_ConnectionState_IDLE;
static constexpr ConnectionState CARRIER =
NetworkState_ConnectionState_CARRIER;
static constexpr ConnectionState ASSOCIATION =
NetworkState_ConnectionState_ASSOCIATION;
static constexpr ConnectionState CONFIGURATION =
NetworkState_ConnectionState_CONFIGURATION;
static constexpr ConnectionState READY =
NetworkState_ConnectionState_READY;
static constexpr ConnectionState PORTAL =
NetworkState_ConnectionState_PORTAL;
static constexpr ConnectionState OFFLINE =
NetworkState_ConnectionState_OFFLINE;
static constexpr ConnectionState ONLINE =
NetworkState_ConnectionState_ONLINE;
static constexpr ConnectionState DISCONNECT =
NetworkState_ConnectionState_DISCONNECT;
static constexpr ConnectionState FAILURE =
NetworkState_ConnectionState_FAILURE;
static constexpr ConnectionState ACTIVATION_FAILURE =
NetworkState_ConnectionState_ACTIVATION_FAILURE;
static constexpr ConnectionState UNKNOWN =
NetworkState_ConnectionState_UNKNOWN;
static inline bool ConnectionState_IsValid(int value) {
return NetworkState_ConnectionState_IsValid(value);
}
static constexpr ConnectionState ConnectionState_MIN =
NetworkState_ConnectionState_ConnectionState_MIN;
static constexpr ConnectionState ConnectionState_MAX =
NetworkState_ConnectionState_ConnectionState_MAX;
static constexpr int ConnectionState_ARRAYSIZE =
NetworkState_ConnectionState_ConnectionState_ARRAYSIZE;
template<typename T>
static inline const std::string& ConnectionState_Name(T enum_t_value) {
static_assert(::std::is_same<T, ConnectionState>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ConnectionState_Name.");
return NetworkState_ConnectionState_Name(enum_t_value);
}
static inline bool ConnectionState_Parse(const std::string& name,
ConnectionState* value) {
return NetworkState_ConnectionState_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kDevicePathFieldNumber = 1,
kIpAddressFieldNumber = 4,
kGatewayFieldNumber = 5,
kConnectionStateFieldNumber = 2,
kSignalStrengthFieldNumber = 3,
};
// optional string device_path = 1;
bool has_device_path() const;
void clear_device_path();
const std::string& device_path() const;
void set_device_path(const std::string& value);
void set_device_path(std::string&& value);
void set_device_path(const char* value);
void set_device_path(const char* value, size_t size);
std::string* mutable_device_path();
std::string* release_device_path();
void set_allocated_device_path(std::string* device_path);

// optional string ip_address = 4;
bool has_ip_address() const;
void clear_ip_address();
const std::string& ip_address() const;
void set_ip_address(const std::string& value);
void set_ip_address(std::string&& value);
void set_ip_address(const char* value);
void set_ip_address(const char* value, size_t size);
std::string* mutable_ip_address();
std::string* release_ip_address();
void set_allocated_ip_address(std::string* ip_address);

// optional string gateway = 5;
bool has_gateway() const;
void clear_gateway();
const std::string& gateway() const;
void set_gateway(const std::string& value);
void set_gateway(std::string&& value);
void set_gateway(const char* value);
void set_gateway(const char* value, size_t size);
std::string* mutable_gateway();
std::string* release_gateway();
void set_allocated_gateway(std::string* gateway);

// optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
bool has_connection_state() const;
void clear_connection_state();
::enterprise_management::NetworkState_ConnectionState connection_state() const;
void set_connection_state(::enterprise_management::NetworkState_ConnectionState value);

// optional int32 signal_strength = 3;
bool has_signal_strength() const;
void clear_signal_strength();
::PROTOBUF_NAMESPACE_ID::int32 signal_strength() const;
void set_signal_strength(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.NetworkState)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_path_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
int connection_state_;
::PROTOBUF_NAMESPACE_ID::int32 signal_strength_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceUser :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUser) */ {
public:
DeviceUser();
virtual ~DeviceUser();

DeviceUser(const DeviceUser& from);
DeviceUser(DeviceUser&& from) noexcept
: DeviceUser() {
*this = ::std::move(from);
}

inline DeviceUser& operator=(const DeviceUser& from) {
CopyFrom(from);
return *this;
}
inline DeviceUser& operator=(DeviceUser&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceUser& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceUser* internal_default_instance() {
return reinterpret_cast<const DeviceUser*>(
&_DeviceUser_default_instance_);
}
static constexpr int kIndexInFileMessages =
26;

friend void swap(DeviceUser& a, DeviceUser& b) {
a.Swap(&b);
}
inline void Swap(DeviceUser* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceUser* New() const final {
return CreateMaybeMessage<DeviceUser>(nullptr);
}

DeviceUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceUser>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceUser& from);
void MergeFrom(const DeviceUser& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceUser* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceUser";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceUser_UserType UserType;
static constexpr UserType USER_TYPE_MANAGED =
DeviceUser_UserType_USER_TYPE_MANAGED;
static constexpr UserType USER_TYPE_UNMANAGED =
DeviceUser_UserType_USER_TYPE_UNMANAGED;
static inline bool UserType_IsValid(int value) {
return DeviceUser_UserType_IsValid(value);
}
static constexpr UserType UserType_MIN =
DeviceUser_UserType_UserType_MIN;
static constexpr UserType UserType_MAX =
DeviceUser_UserType_UserType_MAX;
static constexpr int UserType_ARRAYSIZE =
DeviceUser_UserType_UserType_ARRAYSIZE;
template<typename T>
static inline const std::string& UserType_Name(T enum_t_value) {
static_assert(::std::is_same<T, UserType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function UserType_Name.");
return DeviceUser_UserType_Name(enum_t_value);
}
static inline bool UserType_Parse(const std::string& name,
UserType* value) {
return DeviceUser_UserType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kEmailFieldNumber = 2,
kTypeFieldNumber = 1,
};
// optional string email = 2;
bool has_email() const;
void clear_email();
const std::string& email() const;
void set_email(const std::string& value);
void set_email(std::string&& value);
void set_email(const char* value);
void set_email(const char* value, size_t size);
std::string* mutable_email();
std::string* release_email();
void set_allocated_email(std::string* email);

// required .enterprise_management.DeviceUser.UserType type = 1;
bool has_type() const;
void clear_type();
::enterprise_management::DeviceUser_UserType type() const;
void set_type(::enterprise_management::DeviceUser_UserType value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceUser)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
int type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT VolumeInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.VolumeInfo) */ {
public:
VolumeInfo();
virtual ~VolumeInfo();

VolumeInfo(const VolumeInfo& from);
VolumeInfo(VolumeInfo&& from) noexcept
: VolumeInfo() {
*this = ::std::move(from);
}

inline VolumeInfo& operator=(const VolumeInfo& from) {
CopyFrom(from);
return *this;
}
inline VolumeInfo& operator=(VolumeInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const VolumeInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const VolumeInfo* internal_default_instance() {
return reinterpret_cast<const VolumeInfo*>(
&_VolumeInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
27;

friend void swap(VolumeInfo& a, VolumeInfo& b) {
a.Swap(&b);
}
inline void Swap(VolumeInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline VolumeInfo* New() const final {
return CreateMaybeMessage<VolumeInfo>(nullptr);
}

VolumeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<VolumeInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const VolumeInfo& from);
void MergeFrom(const VolumeInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(VolumeInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.VolumeInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kVolumeIdFieldNumber = 1,
kStorageTotalFieldNumber = 2,
kStorageFreeFieldNumber = 3,
};
// optional string volume_id = 1;
bool has_volume_id() const;
void clear_volume_id();
const std::string& volume_id() const;
void set_volume_id(const std::string& value);
void set_volume_id(std::string&& value);
void set_volume_id(const char* value);
void set_volume_id(const char* value, size_t size);
std::string* mutable_volume_id();
std::string* release_volume_id();
void set_allocated_volume_id(std::string* volume_id);

// optional int64 storage_total = 2;
bool has_storage_total() const;
void clear_storage_total();
::PROTOBUF_NAMESPACE_ID::int64 storage_total() const;
void set_storage_total(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 storage_free = 3;
bool has_storage_free() const;
void clear_storage_free();
::PROTOBUF_NAMESPACE_ID::int64 storage_free() const;
void set_storage_free(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.VolumeInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
::PROTOBUF_NAMESPACE_ID::int64 storage_total_;
::PROTOBUF_NAMESPACE_ID::int64 storage_free_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CpuUtilizationInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CpuUtilizationInfo) */ {
public:
CpuUtilizationInfo();
virtual ~CpuUtilizationInfo();

CpuUtilizationInfo(const CpuUtilizationInfo& from);
CpuUtilizationInfo(CpuUtilizationInfo&& from) noexcept
: CpuUtilizationInfo() {
*this = ::std::move(from);
}

inline CpuUtilizationInfo& operator=(const CpuUtilizationInfo& from) {
CopyFrom(from);
return *this;
}
inline CpuUtilizationInfo& operator=(CpuUtilizationInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CpuUtilizationInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CpuUtilizationInfo* internal_default_instance() {
return reinterpret_cast<const CpuUtilizationInfo*>(
&_CpuUtilizationInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
28;

friend void swap(CpuUtilizationInfo& a, CpuUtilizationInfo& b) {
a.Swap(&b);
}
inline void Swap(CpuUtilizationInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CpuUtilizationInfo* New() const final {
return CreateMaybeMessage<CpuUtilizationInfo>(nullptr);
}

CpuUtilizationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CpuUtilizationInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CpuUtilizationInfo& from);
void MergeFrom(const CpuUtilizationInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CpuUtilizationInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CpuUtilizationInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kTimestampFieldNumber = 2,
kCpuUtilizationPctFieldNumber = 1,
};
// optional int64 timestamp = 2;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 cpu_utilization_pct = 1;
bool has_cpu_utilization_pct() const;
void clear_cpu_utilization_pct();
::PROTOBUF_NAMESPACE_ID::int32 cpu_utilization_pct() const;
void set_cpu_utilization_pct(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.CpuUtilizationInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
::PROTOBUF_NAMESPACE_ID::int32 cpu_utilization_pct_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SystemFreeRamInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemFreeRamInfo) */ {
public:
SystemFreeRamInfo();
virtual ~SystemFreeRamInfo();

SystemFreeRamInfo(const SystemFreeRamInfo& from);
SystemFreeRamInfo(SystemFreeRamInfo&& from) noexcept
: SystemFreeRamInfo() {
*this = ::std::move(from);
}

inline SystemFreeRamInfo& operator=(const SystemFreeRamInfo& from) {
CopyFrom(from);
return *this;
}
inline SystemFreeRamInfo& operator=(SystemFreeRamInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SystemFreeRamInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SystemFreeRamInfo* internal_default_instance() {
return reinterpret_cast<const SystemFreeRamInfo*>(
&_SystemFreeRamInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
29;

friend void swap(SystemFreeRamInfo& a, SystemFreeRamInfo& b) {
a.Swap(&b);
}
inline void Swap(SystemFreeRamInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SystemFreeRamInfo* New() const final {
return CreateMaybeMessage<SystemFreeRamInfo>(nullptr);
}

SystemFreeRamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SystemFreeRamInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SystemFreeRamInfo& from);
void MergeFrom(const SystemFreeRamInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SystemFreeRamInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.SystemFreeRamInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSizeInBytesFieldNumber = 1,
kTimestampFieldNumber = 2,
};
// optional int64 size_in_bytes = 1;
bool has_size_in_bytes() const;
void clear_size_in_bytes();
::PROTOBUF_NAMESPACE_ID::int64 size_in_bytes() const;
void set_size_in_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 timestamp = 2;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.SystemFreeRamInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 size_in_bytes_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CPUTempInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CPUTempInfo) */ {
public:
CPUTempInfo();
virtual ~CPUTempInfo();

CPUTempInfo(const CPUTempInfo& from);
CPUTempInfo(CPUTempInfo&& from) noexcept
: CPUTempInfo() {
*this = ::std::move(from);
}

inline CPUTempInfo& operator=(const CPUTempInfo& from) {
CopyFrom(from);
return *this;
}
inline CPUTempInfo& operator=(CPUTempInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CPUTempInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CPUTempInfo* internal_default_instance() {
return reinterpret_cast<const CPUTempInfo*>(
&_CPUTempInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
30;

friend void swap(CPUTempInfo& a, CPUTempInfo& b) {
a.Swap(&b);
}
inline void Swap(CPUTempInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CPUTempInfo* New() const final {
return CreateMaybeMessage<CPUTempInfo>(nullptr);
}

CPUTempInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CPUTempInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CPUTempInfo& from);
void MergeFrom(const CPUTempInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CPUTempInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CPUTempInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kCpuLabelFieldNumber = 1,
kTimestampFieldNumber = 3,
kCpuTempFieldNumber = 2,
};
// optional string cpu_label = 1;
bool has_cpu_label() const;
void clear_cpu_label();
const std::string& cpu_label() const;
void set_cpu_label(const std::string& value);
void set_cpu_label(std::string&& value);
void set_cpu_label(const char* value);
void set_cpu_label(const char* value, size_t size);
std::string* mutable_cpu_label();
std::string* release_cpu_label();
void set_allocated_cpu_label(std::string* cpu_label);

// optional int64 timestamp = 3;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 cpu_temp = 2;
bool has_cpu_temp() const;
void clear_cpu_temp();
::PROTOBUF_NAMESPACE_ID::int32 cpu_temp() const;
void set_cpu_temp(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.CPUTempInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_label_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
::PROTOBUF_NAMESPACE_ID::int32 cpu_temp_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT StatefulPartitionInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StatefulPartitionInfo) */ {
public:
StatefulPartitionInfo();
virtual ~StatefulPartitionInfo();

StatefulPartitionInfo(const StatefulPartitionInfo& from);
StatefulPartitionInfo(StatefulPartitionInfo&& from) noexcept
: StatefulPartitionInfo() {
*this = ::std::move(from);
}

inline StatefulPartitionInfo& operator=(const StatefulPartitionInfo& from) {
CopyFrom(from);
return *this;
}
inline StatefulPartitionInfo& operator=(StatefulPartitionInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const StatefulPartitionInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const StatefulPartitionInfo* internal_default_instance() {
return reinterpret_cast<const StatefulPartitionInfo*>(
&_StatefulPartitionInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
31;

friend void swap(StatefulPartitionInfo& a, StatefulPartitionInfo& b) {
a.Swap(&b);
}
inline void Swap(StatefulPartitionInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline StatefulPartitionInfo* New() const final {
return CreateMaybeMessage<StatefulPartitionInfo>(nullptr);
}

StatefulPartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<StatefulPartitionInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const StatefulPartitionInfo& from);
void MergeFrom(const StatefulPartitionInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StatefulPartitionInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.StatefulPartitionInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAvailableSpaceFieldNumber = 1,
kTotalSpaceFieldNumber = 2,
};
// optional int64 available_space = 1;
bool has_available_space() const;
void clear_available_space();
::PROTOBUF_NAMESPACE_ID::int64 available_space() const;
void set_available_space(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 total_space = 2;
bool has_total_space() const;
void clear_total_space();
::PROTOBUF_NAMESPACE_ID::int64 total_space() const;
void set_total_space(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.StatefulPartitionInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 available_space_;
::PROTOBUF_NAMESPACE_ID::int64 total_space_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT BatterySample :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BatterySample) */ {
public:
BatterySample();
virtual ~BatterySample();

BatterySample(const BatterySample& from);
BatterySample(BatterySample&& from) noexcept
: BatterySample() {
*this = ::std::move(from);
}

inline BatterySample& operator=(const BatterySample& from) {
CopyFrom(from);
return *this;
}
inline BatterySample& operator=(BatterySample&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const BatterySample& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const BatterySample* internal_default_instance() {
return reinterpret_cast<const BatterySample*>(
&_BatterySample_default_instance_);
}
static constexpr int kIndexInFileMessages =
32;

friend void swap(BatterySample& a, BatterySample& b) {
a.Swap(&b);
}
inline void Swap(BatterySample* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline BatterySample* New() const final {
return CreateMaybeMessage<BatterySample>(nullptr);
}

BatterySample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<BatterySample>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const BatterySample& from);
void MergeFrom(const BatterySample& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BatterySample* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.BatterySample";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kStatusFieldNumber = 8,
kTimestampFieldNumber = 1,
kVoltageFieldNumber = 2,
kRemainingCapacityFieldNumber = 3,
kTemperatureFieldNumber = 4,
kDischargeRateFieldNumber = 5,
kCurrentFieldNumber = 7,
kChargeRateFieldNumber = 6,
};
// optional string status = 8;
bool has_status() const;
void clear_status();
const std::string& status() const;
void set_status(const std::string& value);
void set_status(std::string&& value);
void set_status(const char* value);
void set_status(const char* value, size_t size);
std::string* mutable_status();
std::string* release_status();
void set_allocated_status(std::string* status);

// optional int64 timestamp = 1;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 voltage = 2;
bool has_voltage() const;
void clear_voltage();
::PROTOBUF_NAMESPACE_ID::int64 voltage() const;
void set_voltage(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 remaining_capacity = 3;
bool has_remaining_capacity() const;
void clear_remaining_capacity();
::PROTOBUF_NAMESPACE_ID::int64 remaining_capacity() const;
void set_remaining_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 temperature = 4;
bool has_temperature() const;
void clear_temperature();
::PROTOBUF_NAMESPACE_ID::int32 temperature() const;
void set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 discharge_rate = 5;
bool has_discharge_rate() const;
void clear_discharge_rate();
::PROTOBUF_NAMESPACE_ID::int32 discharge_rate() const;
void set_discharge_rate(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 current = 7;
bool has_current() const;
void clear_current();
::PROTOBUF_NAMESPACE_ID::int64 current() const;
void set_current(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 charge_rate = 6;
bool has_charge_rate() const;
void clear_charge_rate();
::PROTOBUF_NAMESPACE_ID::int32 charge_rate() const;
void set_charge_rate(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.BatterySample)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
::PROTOBUF_NAMESPACE_ID::int64 voltage_;
::PROTOBUF_NAMESPACE_ID::int64 remaining_capacity_;
::PROTOBUF_NAMESPACE_ID::int32 temperature_;
::PROTOBUF_NAMESPACE_ID::int32 discharge_rate_;
::PROTOBUF_NAMESPACE_ID::int64 current_;
::PROTOBUF_NAMESPACE_ID::int32 charge_rate_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT BatteryInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BatteryInfo) */ {
public:
BatteryInfo();
virtual ~BatteryInfo();

BatteryInfo(const BatteryInfo& from);
BatteryInfo(BatteryInfo&& from) noexcept
: BatteryInfo() {
*this = ::std::move(from);
}

inline BatteryInfo& operator=(const BatteryInfo& from) {
CopyFrom(from);
return *this;
}
inline BatteryInfo& operator=(BatteryInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const BatteryInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const BatteryInfo* internal_default_instance() {
return reinterpret_cast<const BatteryInfo*>(
&_BatteryInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
33;

friend void swap(BatteryInfo& a, BatteryInfo& b) {
a.Swap(&b);
}
inline void Swap(BatteryInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline BatteryInfo* New() const final {
return CreateMaybeMessage<BatteryInfo>(nullptr);
}

BatteryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<BatteryInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const BatteryInfo& from);
void MergeFrom(const BatteryInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BatteryInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.BatteryInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSamplesFieldNumber = 7,
kSerialFieldNumber = 1,
kManufacturerFieldNumber = 2,
kBatteryHealthFieldNumber = 3,
kManufactureDateFieldNumber = 10,
kTechnologyFieldNumber = 11,
kDesignCapacityFieldNumber = 4,
kFullChargeCapacityFieldNumber = 5,
kCycleCountFieldNumber = 6,
kDesignMinVoltageFieldNumber = 9,
};
// repeated .enterprise_management.BatterySample samples = 7;
int samples_size() const;
void clear_samples();
::enterprise_management::BatterySample* mutable_samples(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >*
mutable_samples();
const ::enterprise_management::BatterySample& samples(int index) const;
::enterprise_management::BatterySample* add_samples();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >&
samples() const;

// optional string serial = 1;
bool has_serial() const;
void clear_serial();
const std::string& serial() const;
void set_serial(const std::string& value);
void set_serial(std::string&& value);
void set_serial(const char* value);
void set_serial(const char* value, size_t size);
std::string* mutable_serial();
std::string* release_serial();
void set_allocated_serial(std::string* serial);

// optional string manufacturer = 2;
bool has_manufacturer() const;
void clear_manufacturer();
const std::string& manufacturer() const;
void set_manufacturer(const std::string& value);
void set_manufacturer(std::string&& value);
void set_manufacturer(const char* value);
void set_manufacturer(const char* value, size_t size);
std::string* mutable_manufacturer();
std::string* release_manufacturer();
void set_allocated_manufacturer(std::string* manufacturer);

// optional string battery_health = 3;
bool has_battery_health() const;
void clear_battery_health();
const std::string& battery_health() const;
void set_battery_health(const std::string& value);
void set_battery_health(std::string&& value);
void set_battery_health(const char* value);
void set_battery_health(const char* value, size_t size);
std::string* mutable_battery_health();
std::string* release_battery_health();
void set_allocated_battery_health(std::string* battery_health);

// optional string manufacture_date = 10;
bool has_manufacture_date() const;
void clear_manufacture_date();
const std::string& manufacture_date() const;
void set_manufacture_date(const std::string& value);
void set_manufacture_date(std::string&& value);
void set_manufacture_date(const char* value);
void set_manufacture_date(const char* value, size_t size);
std::string* mutable_manufacture_date();
std::string* release_manufacture_date();
void set_allocated_manufacture_date(std::string* manufacture_date);

// optional string technology = 11;
bool has_technology() const;
void clear_technology();
const std::string& technology() const;
void set_technology(const std::string& value);
void set_technology(std::string&& value);
void set_technology(const char* value);
void set_technology(const char* value, size_t size);
std::string* mutable_technology();
std::string* release_technology();
void set_allocated_technology(std::string* technology);

// optional int64 design_capacity = 4;
bool has_design_capacity() const;
void clear_design_capacity();
::PROTOBUF_NAMESPACE_ID::int64 design_capacity() const;
void set_design_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 full_charge_capacity = 5;
bool has_full_charge_capacity() const;
void clear_full_charge_capacity();
::PROTOBUF_NAMESPACE_ID::int64 full_charge_capacity() const;
void set_full_charge_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 cycle_count = 6;
bool has_cycle_count() const;
void clear_cycle_count();
::PROTOBUF_NAMESPACE_ID::int32 cycle_count() const;
void set_cycle_count(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 design_min_voltage = 9;
bool has_design_min_voltage() const;
void clear_design_min_voltage();
::PROTOBUF_NAMESPACE_ID::int32 design_min_voltage() const;
void set_design_min_voltage(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.BatteryInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample > samples_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr battery_health_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacture_date_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr technology_;
::PROTOBUF_NAMESPACE_ID::int64 design_capacity_;
::PROTOBUF_NAMESPACE_ID::int64 full_charge_capacity_;
::PROTOBUF_NAMESPACE_ID::int32 cycle_count_;
::PROTOBUF_NAMESPACE_ID::int32 design_min_voltage_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PowerStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PowerStatus) */ {
public:
PowerStatus();
virtual ~PowerStatus();

PowerStatus(const PowerStatus& from);
PowerStatus(PowerStatus&& from) noexcept
: PowerStatus() {
*this = ::std::move(from);
}

inline PowerStatus& operator=(const PowerStatus& from) {
CopyFrom(from);
return *this;
}
inline PowerStatus& operator=(PowerStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PowerStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PowerStatus* internal_default_instance() {
return reinterpret_cast<const PowerStatus*>(
&_PowerStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
34;

friend void swap(PowerStatus& a, PowerStatus& b) {
a.Swap(&b);
}
inline void Swap(PowerStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PowerStatus* New() const final {
return CreateMaybeMessage<PowerStatus>(nullptr);
}

PowerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PowerStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PowerStatus& from);
void MergeFrom(const PowerStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PowerStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PowerStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef PowerStatus_PowerSource PowerSource;
static constexpr PowerSource POWER_UNKNOWN =
PowerStatus_PowerSource_POWER_UNKNOWN;
static constexpr PowerSource POWER_AC =
PowerStatus_PowerSource_POWER_AC;
static constexpr PowerSource POWER_BATTERY =
PowerStatus_PowerSource_POWER_BATTERY;
static inline bool PowerSource_IsValid(int value) {
return PowerStatus_PowerSource_IsValid(value);
}
static constexpr PowerSource PowerSource_MIN =
PowerStatus_PowerSource_PowerSource_MIN;
static constexpr PowerSource PowerSource_MAX =
PowerStatus_PowerSource_PowerSource_MAX;
static constexpr int PowerSource_ARRAYSIZE =
PowerStatus_PowerSource_PowerSource_ARRAYSIZE;
template<typename T>
static inline const std::string& PowerSource_Name(T enum_t_value) {
static_assert(::std::is_same<T, PowerSource>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PowerSource_Name.");
return PowerStatus_PowerSource_Name(enum_t_value);
}
static inline bool PowerSource_Parse(const std::string& name,
PowerSource* value) {
return PowerStatus_PowerSource_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kBatteriesFieldNumber = 2,
kPowerSourceFieldNumber = 1,
};
// repeated .enterprise_management.BatteryInfo batteries = 2;
int batteries_size() const;
void clear_batteries();
::enterprise_management::BatteryInfo* mutable_batteries(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >*
mutable_batteries();
const ::enterprise_management::BatteryInfo& batteries(int index) const;
::enterprise_management::BatteryInfo* add_batteries();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >&
batteries() const;

// optional .enterprise_management.PowerStatus.PowerSource power_source = 1;
bool has_power_source() const;
void clear_power_source();
::enterprise_management::PowerStatus_PowerSource power_source() const;
void set_power_source(::enterprise_management::PowerStatus_PowerSource value);

// @@protoc_insertion_point(class_scope:enterprise_management.PowerStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo > batteries_;
int power_source_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DiskLifetimeEstimation :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DiskLifetimeEstimation) */ {
public:
DiskLifetimeEstimation();
virtual ~DiskLifetimeEstimation();

DiskLifetimeEstimation(const DiskLifetimeEstimation& from);
DiskLifetimeEstimation(DiskLifetimeEstimation&& from) noexcept
: DiskLifetimeEstimation() {
*this = ::std::move(from);
}

inline DiskLifetimeEstimation& operator=(const DiskLifetimeEstimation& from) {
CopyFrom(from);
return *this;
}
inline DiskLifetimeEstimation& operator=(DiskLifetimeEstimation&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DiskLifetimeEstimation& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DiskLifetimeEstimation* internal_default_instance() {
return reinterpret_cast<const DiskLifetimeEstimation*>(
&_DiskLifetimeEstimation_default_instance_);
}
static constexpr int kIndexInFileMessages =
35;

friend void swap(DiskLifetimeEstimation& a, DiskLifetimeEstimation& b) {
a.Swap(&b);
}
inline void Swap(DiskLifetimeEstimation* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DiskLifetimeEstimation* New() const final {
return CreateMaybeMessage<DiskLifetimeEstimation>(nullptr);
}

DiskLifetimeEstimation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DiskLifetimeEstimation>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DiskLifetimeEstimation& from);
void MergeFrom(const DiskLifetimeEstimation& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DiskLifetimeEstimation* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DiskLifetimeEstimation";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSlcFieldNumber = 1,
kMlcFieldNumber = 2,
};
// optional int32 slc = 1;
bool has_slc() const;
void clear_slc();
::PROTOBUF_NAMESPACE_ID::int32 slc() const;
void set_slc(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 mlc = 2;
bool has_mlc() const;
void clear_mlc();
::PROTOBUF_NAMESPACE_ID::int32 mlc() const;
void set_mlc(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.DiskLifetimeEstimation)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int32 slc_;
::PROTOBUF_NAMESPACE_ID::int32 mlc_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DiskInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DiskInfo) */ {
public:
DiskInfo();
virtual ~DiskInfo();

DiskInfo(const DiskInfo& from);
DiskInfo(DiskInfo&& from) noexcept
: DiskInfo() {
*this = ::std::move(from);
}

inline DiskInfo& operator=(const DiskInfo& from) {
CopyFrom(from);
return *this;
}
inline DiskInfo& operator=(DiskInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DiskInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DiskInfo* internal_default_instance() {
return reinterpret_cast<const DiskInfo*>(
&_DiskInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
36;

friend void swap(DiskInfo& a, DiskInfo& b) {
a.Swap(&b);
}
inline void Swap(DiskInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DiskInfo* New() const final {
return CreateMaybeMessage<DiskInfo>(nullptr);
}

DiskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DiskInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DiskInfo& from);
void MergeFrom(const DiskInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DiskInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DiskInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kVolumesFieldNumber = 7,
kSerialFieldNumber = 1,
kManufacturerFieldNumber = 2,
kModelFieldNumber = 3,
kTypeFieldNumber = 5,
kHealthFieldNumber = 6,
kSizeFieldNumber = 4,
kBytesReadSinceLastBootFieldNumber = 8,
kBytesWrittenSinceLastBootFieldNumber = 9,
kReadTimeSecondsSinceLastBootFieldNumber = 10,
kWriteTimeSecondsSinceLastBootFieldNumber = 11,
kIoTimeSecondsSinceLastBootFieldNumber = 12,
kDiscardTimeSecondsSinceLastBootFieldNumber = 13,
};
// repeated string volumes = 7;
int volumes_size() const;
void clear_volumes();
const std::string& volumes(int index) const;
std::string* mutable_volumes(int index);
void set_volumes(int index, const std::string& value);
void set_volumes(int index, std::string&& value);
void set_volumes(int index, const char* value);
void set_volumes(int index, const char* value, size_t size);
std::string* add_volumes();
void add_volumes(const std::string& value);
void add_volumes(std::string&& value);
void add_volumes(const char* value);
void add_volumes(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& volumes() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_volumes();

// optional string serial = 1;
bool has_serial() const;
void clear_serial();
const std::string& serial() const;
void set_serial(const std::string& value);
void set_serial(std::string&& value);
void set_serial(const char* value);
void set_serial(const char* value, size_t size);
std::string* mutable_serial();
std::string* release_serial();
void set_allocated_serial(std::string* serial);

// optional string manufacturer = 2;
bool has_manufacturer() const;
void clear_manufacturer();
const std::string& manufacturer() const;
void set_manufacturer(const std::string& value);
void set_manufacturer(std::string&& value);
void set_manufacturer(const char* value);
void set_manufacturer(const char* value, size_t size);
std::string* mutable_manufacturer();
std::string* release_manufacturer();
void set_allocated_manufacturer(std::string* manufacturer);

// optional string model = 3;
bool has_model() const;
void clear_model();
const std::string& model() const;
void set_model(const std::string& value);
void set_model(std::string&& value);
void set_model(const char* value);
void set_model(const char* value, size_t size);
std::string* mutable_model();
std::string* release_model();
void set_allocated_model(std::string* model);

// optional string type = 5;
bool has_type() const;
void clear_type();
const std::string& type() const;
void set_type(const std::string& value);
void set_type(std::string&& value);
void set_type(const char* value);
void set_type(const char* value, size_t size);
std::string* mutable_type();
std::string* release_type();
void set_allocated_type(std::string* type);

// optional string health = 6;
bool has_health() const;
void clear_health();
const std::string& health() const;
void set_health(const std::string& value);
void set_health(std::string&& value);
void set_health(const char* value);
void set_health(const char* value, size_t size);
std::string* mutable_health();
std::string* release_health();
void set_allocated_health(std::string* health);

// optional int64 size = 4;
bool has_size() const;
void clear_size();
::PROTOBUF_NAMESPACE_ID::int64 size() const;
void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional uint64 bytes_read_since_last_boot = 8;
bool has_bytes_read_since_last_boot() const;
void clear_bytes_read_since_last_boot();
::PROTOBUF_NAMESPACE_ID::uint64 bytes_read_since_last_boot() const;
void set_bytes_read_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 bytes_written_since_last_boot = 9;
bool has_bytes_written_since_last_boot() const;
void clear_bytes_written_since_last_boot();
::PROTOBUF_NAMESPACE_ID::uint64 bytes_written_since_last_boot() const;
void set_bytes_written_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 read_time_seconds_since_last_boot = 10;
bool has_read_time_seconds_since_last_boot() const;
void clear_read_time_seconds_since_last_boot();
::PROTOBUF_NAMESPACE_ID::uint64 read_time_seconds_since_last_boot() const;
void set_read_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 write_time_seconds_since_last_boot = 11;
bool has_write_time_seconds_since_last_boot() const;
void clear_write_time_seconds_since_last_boot();
::PROTOBUF_NAMESPACE_ID::uint64 write_time_seconds_since_last_boot() const;
void set_write_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 io_time_seconds_since_last_boot = 12;
bool has_io_time_seconds_since_last_boot() const;
void clear_io_time_seconds_since_last_boot();
::PROTOBUF_NAMESPACE_ID::uint64 io_time_seconds_since_last_boot() const;
void set_io_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 discard_time_seconds_since_last_boot = 13;
bool has_discard_time_seconds_since_last_boot() const;
void clear_discard_time_seconds_since_last_boot();
::PROTOBUF_NAMESPACE_ID::uint64 discard_time_seconds_since_last_boot() const;
void set_discard_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.DiskInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> volumes_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr health_;
::PROTOBUF_NAMESPACE_ID::int64 size_;
::PROTOBUF_NAMESPACE_ID::uint64 bytes_read_since_last_boot_;
::PROTOBUF_NAMESPACE_ID::uint64 bytes_written_since_last_boot_;
::PROTOBUF_NAMESPACE_ID::uint64 read_time_seconds_since_last_boot_;
::PROTOBUF_NAMESPACE_ID::uint64 write_time_seconds_since_last_boot_;
::PROTOBUF_NAMESPACE_ID::uint64 io_time_seconds_since_last_boot_;
::PROTOBUF_NAMESPACE_ID::uint64 discard_time_seconds_since_last_boot_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT StorageStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StorageStatus) */ {
public:
StorageStatus();
virtual ~StorageStatus();

StorageStatus(const StorageStatus& from);
StorageStatus(StorageStatus&& from) noexcept
: StorageStatus() {
*this = ::std::move(from);
}

inline StorageStatus& operator=(const StorageStatus& from) {
CopyFrom(from);
return *this;
}
inline StorageStatus& operator=(StorageStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const StorageStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const StorageStatus* internal_default_instance() {
return reinterpret_cast<const StorageStatus*>(
&_StorageStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
37;

friend void swap(StorageStatus& a, StorageStatus& b) {
a.Swap(&b);
}
inline void Swap(StorageStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline StorageStatus* New() const final {
return CreateMaybeMessage<StorageStatus>(nullptr);
}

StorageStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<StorageStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const StorageStatus& from);
void MergeFrom(const StorageStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StorageStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.StorageStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kDisksFieldNumber = 1,
kLifetimeEstimationFieldNumber = 2,
};
// repeated .enterprise_management.DiskInfo disks = 1;
int disks_size() const;
void clear_disks();
::enterprise_management::DiskInfo* mutable_disks(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >*
mutable_disks();
const ::enterprise_management::DiskInfo& disks(int index) const;
::enterprise_management::DiskInfo* add_disks();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >&
disks() const;

// optional .enterprise_management.DiskLifetimeEstimation lifetime_estimation = 2;
bool has_lifetime_estimation() const;
void clear_lifetime_estimation();
const ::enterprise_management::DiskLifetimeEstimation& lifetime_estimation() const;
::enterprise_management::DiskLifetimeEstimation* release_lifetime_estimation();
::enterprise_management::DiskLifetimeEstimation* mutable_lifetime_estimation();
void set_allocated_lifetime_estimation(::enterprise_management::DiskLifetimeEstimation* lifetime_estimation);

// @@protoc_insertion_point(class_scope:enterprise_management.StorageStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo > disks_;
::enterprise_management::DiskLifetimeEstimation* lifetime_estimation_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ThermalSample :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ThermalSample) */ {
public:
ThermalSample();
virtual ~ThermalSample();

ThermalSample(const ThermalSample& from);
ThermalSample(ThermalSample&& from) noexcept
: ThermalSample() {
*this = ::std::move(from);
}

inline ThermalSample& operator=(const ThermalSample& from) {
CopyFrom(from);
return *this;
}
inline ThermalSample& operator=(ThermalSample&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ThermalSample& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ThermalSample* internal_default_instance() {
return reinterpret_cast<const ThermalSample*>(
&_ThermalSample_default_instance_);
}
static constexpr int kIndexInFileMessages =
38;

friend void swap(ThermalSample& a, ThermalSample& b) {
a.Swap(&b);
}
inline void Swap(ThermalSample* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ThermalSample* New() const final {
return CreateMaybeMessage<ThermalSample>(nullptr);
}

ThermalSample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ThermalSample>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ThermalSample& from);
void MergeFrom(const ThermalSample& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ThermalSample* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ThermalSample";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kTimestampFieldNumber = 1,
kTemperatureFieldNumber = 2,
};
// optional int64 timestamp = 1;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 temperature = 2;
bool has_temperature() const;
void clear_temperature();
::PROTOBUF_NAMESPACE_ID::int32 temperature() const;
void set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.ThermalSample)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
::PROTOBUF_NAMESPACE_ID::int32 temperature_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ThermalInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ThermalInfo) */ {
public:
ThermalInfo();
virtual ~ThermalInfo();

ThermalInfo(const ThermalInfo& from);
ThermalInfo(ThermalInfo&& from) noexcept
: ThermalInfo() {
*this = ::std::move(from);
}

inline ThermalInfo& operator=(const ThermalInfo& from) {
CopyFrom(from);
return *this;
}
inline ThermalInfo& operator=(ThermalInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ThermalInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ThermalInfo* internal_default_instance() {
return reinterpret_cast<const ThermalInfo*>(
&_ThermalInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
39;

friend void swap(ThermalInfo& a, ThermalInfo& b) {
a.Swap(&b);
}
inline void Swap(ThermalInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ThermalInfo* New() const final {
return CreateMaybeMessage<ThermalInfo>(nullptr);
}

ThermalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ThermalInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ThermalInfo& from);
void MergeFrom(const ThermalInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ThermalInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ThermalInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSamplesFieldNumber = 3,
kLabelFieldNumber = 1,
};
// repeated .enterprise_management.ThermalSample samples = 3;
int samples_size() const;
void clear_samples();
::enterprise_management::ThermalSample* mutable_samples(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >*
mutable_samples();
const ::enterprise_management::ThermalSample& samples(int index) const;
::enterprise_management::ThermalSample* add_samples();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >&
samples() const;

// optional string label = 1;
bool has_label() const;
void clear_label();
const std::string& label() const;
void set_label(const std::string& value);
void set_label(std::string&& value);
void set_label(const char* value);
void set_label(const char* value, size_t size);
std::string* mutable_label();
std::string* release_label();
void set_allocated_label(std::string* label);

// @@protoc_insertion_point(class_scope:enterprise_management.ThermalInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample > samples_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT BoardStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BoardStatus) */ {
public:
BoardStatus();
virtual ~BoardStatus();

BoardStatus(const BoardStatus& from);
BoardStatus(BoardStatus&& from) noexcept
: BoardStatus() {
*this = ::std::move(from);
}

inline BoardStatus& operator=(const BoardStatus& from) {
CopyFrom(from);
return *this;
}
inline BoardStatus& operator=(BoardStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const BoardStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const BoardStatus* internal_default_instance() {
return reinterpret_cast<const BoardStatus*>(
&_BoardStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
40;

friend void swap(BoardStatus& a, BoardStatus& b) {
a.Swap(&b);
}
inline void Swap(BoardStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline BoardStatus* New() const final {
return CreateMaybeMessage<BoardStatus>(nullptr);
}

BoardStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<BoardStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const BoardStatus& from);
void MergeFrom(const BoardStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BoardStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.BoardStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kThermalInfosFieldNumber = 1,
};
// repeated .enterprise_management.ThermalInfo thermal_infos = 1;
int thermal_infos_size() const;
void clear_thermal_infos();
::enterprise_management::ThermalInfo* mutable_thermal_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >*
mutable_thermal_infos();
const ::enterprise_management::ThermalInfo& thermal_infos(int index) const;
::enterprise_management::ThermalInfo* add_thermal_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >&
thermal_infos() const;

// @@protoc_insertion_point(class_scope:enterprise_management.BoardStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo > thermal_infos_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SystemStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemStatus) */ {
public:
SystemStatus();
virtual ~SystemStatus();

SystemStatus(const SystemStatus& from);
SystemStatus(SystemStatus&& from) noexcept
: SystemStatus() {
*this = ::std::move(from);
}

inline SystemStatus& operator=(const SystemStatus& from) {
CopyFrom(from);
return *this;
}
inline SystemStatus& operator=(SystemStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SystemStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SystemStatus* internal_default_instance() {
return reinterpret_cast<const SystemStatus*>(
&_SystemStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
41;

friend void swap(SystemStatus& a, SystemStatus& b) {
a.Swap(&b);
}
inline void Swap(SystemStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SystemStatus* New() const final {
return CreateMaybeMessage<SystemStatus>(nullptr);
}

SystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SystemStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SystemStatus& from);
void MergeFrom(const SystemStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SystemStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.SystemStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kVpdSkuNumberFieldNumber = 1,
};
// optional string vpd_sku_number = 1;
bool has_vpd_sku_number() const;
void clear_vpd_sku_number();
const std::string& vpd_sku_number() const;
void set_vpd_sku_number(const std::string& value);
void set_vpd_sku_number(std::string&& value);
void set_vpd_sku_number(const char* value);
void set_vpd_sku_number(const char* value, size_t size);
std::string* mutable_vpd_sku_number();
std::string* release_vpd_sku_number();
void set_allocated_vpd_sku_number(std::string* vpd_sku_number);

// @@protoc_insertion_point(class_scope:enterprise_management.SystemStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpd_sku_number_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CpuCStateInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CpuCStateInfo) */ {
public:
CpuCStateInfo();
virtual ~CpuCStateInfo();

CpuCStateInfo(const CpuCStateInfo& from);
CpuCStateInfo(CpuCStateInfo&& from) noexcept
: CpuCStateInfo() {
*this = ::std::move(from);
}

inline CpuCStateInfo& operator=(const CpuCStateInfo& from) {
CopyFrom(from);
return *this;
}
inline CpuCStateInfo& operator=(CpuCStateInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CpuCStateInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CpuCStateInfo* internal_default_instance() {
return reinterpret_cast<const CpuCStateInfo*>(
&_CpuCStateInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
42;

friend void swap(CpuCStateInfo& a, CpuCStateInfo& b) {
a.Swap(&b);
}
inline void Swap(CpuCStateInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CpuCStateInfo* New() const final {
return CreateMaybeMessage<CpuCStateInfo>(nullptr);
}

CpuCStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CpuCStateInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CpuCStateInfo& from);
void MergeFrom(const CpuCStateInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CpuCStateInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CpuCStateInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kTimeInStateSinceLastBootUsFieldNumber = 2,
};
// optional string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional uint64 time_in_state_since_last_boot_us = 2;
bool has_time_in_state_since_last_boot_us() const;
void clear_time_in_state_since_last_boot_us();
::PROTOBUF_NAMESPACE_ID::uint64 time_in_state_since_last_boot_us() const;
void set_time_in_state_since_last_boot_us(::PROTOBUF_NAMESPACE_ID::uint64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.CpuCStateInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::uint64 time_in_state_since_last_boot_us_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT LogicalCpuInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LogicalCpuInfo) */ {
public:
LogicalCpuInfo();
virtual ~LogicalCpuInfo();

LogicalCpuInfo(const LogicalCpuInfo& from);
LogicalCpuInfo(LogicalCpuInfo&& from) noexcept
: LogicalCpuInfo() {
*this = ::std::move(from);
}

inline LogicalCpuInfo& operator=(const LogicalCpuInfo& from) {
CopyFrom(from);
return *this;
}
inline LogicalCpuInfo& operator=(LogicalCpuInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const LogicalCpuInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const LogicalCpuInfo* internal_default_instance() {
return reinterpret_cast<const LogicalCpuInfo*>(
&_LogicalCpuInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
43;

friend void swap(LogicalCpuInfo& a, LogicalCpuInfo& b) {
a.Swap(&b);
}
inline void Swap(LogicalCpuInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline LogicalCpuInfo* New() const final {
return CreateMaybeMessage<LogicalCpuInfo>(nullptr);
}

LogicalCpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<LogicalCpuInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const LogicalCpuInfo& from);
void MergeFrom(const LogicalCpuInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LogicalCpuInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.LogicalCpuInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kCStatesFieldNumber = 4,
kScalingMaxFrequencyKhzFieldNumber = 1,
kScalingCurrentFrequencyKhzFieldNumber = 2,
kIdleTimeSecondsFieldNumber = 3,
};
// repeated .enterprise_management.CpuCStateInfo c_states = 4;
int c_states_size() const;
void clear_c_states();
::enterprise_management::CpuCStateInfo* mutable_c_states(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >*
mutable_c_states();
const ::enterprise_management::CpuCStateInfo& c_states(int index) const;
::enterprise_management::CpuCStateInfo* add_c_states();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >&
c_states() const;

// optional uint32 scaling_max_frequency_khz = 1;
bool has_scaling_max_frequency_khz() const;
void clear_scaling_max_frequency_khz();
::PROTOBUF_NAMESPACE_ID::uint32 scaling_max_frequency_khz() const;
void set_scaling_max_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 scaling_current_frequency_khz = 2;
bool has_scaling_current_frequency_khz() const;
void clear_scaling_current_frequency_khz();
::PROTOBUF_NAMESPACE_ID::uint32 scaling_current_frequency_khz() const;
void set_scaling_current_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 idle_time_seconds = 3;
bool has_idle_time_seconds() const;
void clear_idle_time_seconds();
::PROTOBUF_NAMESPACE_ID::uint32 idle_time_seconds() const;
void set_idle_time_seconds(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.LogicalCpuInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo > c_states_;
::PROTOBUF_NAMESPACE_ID::uint32 scaling_max_frequency_khz_;
::PROTOBUF_NAMESPACE_ID::uint32 scaling_current_frequency_khz_;
::PROTOBUF_NAMESPACE_ID::uint32 idle_time_seconds_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CpuInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CpuInfo) */ {
public:
CpuInfo();
virtual ~CpuInfo();

CpuInfo(const CpuInfo& from);
CpuInfo(CpuInfo&& from) noexcept
: CpuInfo() {
*this = ::std::move(from);
}

inline CpuInfo& operator=(const CpuInfo& from) {
CopyFrom(from);
return *this;
}
inline CpuInfo& operator=(CpuInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CpuInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CpuInfo* internal_default_instance() {
return reinterpret_cast<const CpuInfo*>(
&_CpuInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
44;

friend void swap(CpuInfo& a, CpuInfo& b) {
a.Swap(&b);
}
inline void Swap(CpuInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CpuInfo* New() const final {
return CreateMaybeMessage<CpuInfo>(nullptr);
}

CpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CpuInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CpuInfo& from);
void MergeFrom(const CpuInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CpuInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CpuInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef CpuInfo_Architecture Architecture;
static constexpr Architecture ARCHITECTURE_UNSPECIFIED =
CpuInfo_Architecture_ARCHITECTURE_UNSPECIFIED;
static constexpr Architecture X86_64 =
CpuInfo_Architecture_X86_64;
static constexpr Architecture AARCH64 =
CpuInfo_Architecture_AARCH64;
static constexpr Architecture ARMV7L =
CpuInfo_Architecture_ARMV7L;
static inline bool Architecture_IsValid(int value) {
return CpuInfo_Architecture_IsValid(value);
}
static constexpr Architecture Architecture_MIN =
CpuInfo_Architecture_Architecture_MIN;
static constexpr Architecture Architecture_MAX =
CpuInfo_Architecture_Architecture_MAX;
static constexpr int Architecture_ARRAYSIZE =
CpuInfo_Architecture_Architecture_ARRAYSIZE;
template<typename T>
static inline const std::string& Architecture_Name(T enum_t_value) {
static_assert(::std::is_same<T, Architecture>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Architecture_Name.");
return CpuInfo_Architecture_Name(enum_t_value);
}
static inline bool Architecture_Parse(const std::string& name,
Architecture* value) {
return CpuInfo_Architecture_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kLogicalCpusFieldNumber = 4,
kModelNameFieldNumber = 1,
kArchitectureFieldNumber = 2,
kMaxClockSpeedKhzFieldNumber = 3,
};
// repeated .enterprise_management.LogicalCpuInfo logical_cpus = 4;
int logical_cpus_size() const;
void clear_logical_cpus();
::enterprise_management::LogicalCpuInfo* mutable_logical_cpus(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >*
mutable_logical_cpus();
const ::enterprise_management::LogicalCpuInfo& logical_cpus(int index) const;
::enterprise_management::LogicalCpuInfo* add_logical_cpus();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >&
logical_cpus() const;

// optional string model_name = 1;
bool has_model_name() const;
void clear_model_name();
const std::string& model_name() const;
void set_model_name(const std::string& value);
void set_model_name(std::string&& value);
void set_model_name(const char* value);
void set_model_name(const char* value, size_t size);
std::string* mutable_model_name();
std::string* release_model_name();
void set_allocated_model_name(std::string* model_name);

// optional .enterprise_management.CpuInfo.Architecture architecture = 2;
bool has_architecture() const;
void clear_architecture();
::enterprise_management::CpuInfo_Architecture architecture() const;
void set_architecture(::enterprise_management::CpuInfo_Architecture value);

// optional uint32 max_clock_speed_khz = 3;
bool has_max_clock_speed_khz() const;
void clear_max_clock_speed_khz();
::PROTOBUF_NAMESPACE_ID::uint32 max_clock_speed_khz() const;
void set_max_clock_speed_khz(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.CpuInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo > logical_cpus_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
int architecture_;
::PROTOBUF_NAMESPACE_ID::uint32 max_clock_speed_khz_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT GlobalCpuInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GlobalCpuInfo) */ {
public:
GlobalCpuInfo();
virtual ~GlobalCpuInfo();

GlobalCpuInfo(const GlobalCpuInfo& from);
GlobalCpuInfo(GlobalCpuInfo&& from) noexcept
: GlobalCpuInfo() {
*this = ::std::move(from);
}

inline GlobalCpuInfo& operator=(const GlobalCpuInfo& from) {
CopyFrom(from);
return *this;
}
inline GlobalCpuInfo& operator=(GlobalCpuInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const GlobalCpuInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const GlobalCpuInfo* internal_default_instance() {
return reinterpret_cast<const GlobalCpuInfo*>(
&_GlobalCpuInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
45;

friend void swap(GlobalCpuInfo& a, GlobalCpuInfo& b) {
a.Swap(&b);
}
inline void Swap(GlobalCpuInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline GlobalCpuInfo* New() const final {
return CreateMaybeMessage<GlobalCpuInfo>(nullptr);
}

GlobalCpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<GlobalCpuInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const GlobalCpuInfo& from);
void MergeFrom(const GlobalCpuInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(GlobalCpuInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.GlobalCpuInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNumTotalThreadsFieldNumber = 1,
};
// optional uint32 num_total_threads = 1;
bool has_num_total_threads() const;
void clear_num_total_threads();
::PROTOBUF_NAMESPACE_ID::uint32 num_total_threads() const;
void set_num_total_threads(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.GlobalCpuInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::uint32 num_total_threads_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DisplayInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DisplayInfo) */ {
public:
DisplayInfo();
virtual ~DisplayInfo();

DisplayInfo(const DisplayInfo& from);
DisplayInfo(DisplayInfo&& from) noexcept
: DisplayInfo() {
*this = ::std::move(from);
}

inline DisplayInfo& operator=(const DisplayInfo& from) {
CopyFrom(from);
return *this;
}
inline DisplayInfo& operator=(DisplayInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DisplayInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DisplayInfo* internal_default_instance() {
return reinterpret_cast<const DisplayInfo*>(
&_DisplayInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
46;

friend void swap(DisplayInfo& a, DisplayInfo& b) {
a.Swap(&b);
}
inline void Swap(DisplayInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DisplayInfo* New() const final {
return CreateMaybeMessage<DisplayInfo>(nullptr);
}

DisplayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DisplayInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DisplayInfo& from);
void MergeFrom(const DisplayInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DisplayInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DisplayInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kResolutionWidthFieldNumber = 1,
kResolutionHeightFieldNumber = 2,
kRefreshRateFieldNumber = 3,
kIsInternalFieldNumber = 4,
};
// optional uint32 resolution_width = 1;
bool has_resolution_width() const;
void clear_resolution_width();
::PROTOBUF_NAMESPACE_ID::uint32 resolution_width() const;
void set_resolution_width(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 resolution_height = 2;
bool has_resolution_height() const;
void clear_resolution_height();
::PROTOBUF_NAMESPACE_ID::uint32 resolution_height() const;
void set_resolution_height(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 refresh_rate = 3;
bool has_refresh_rate() const;
void clear_refresh_rate();
::PROTOBUF_NAMESPACE_ID::uint32 refresh_rate() const;
void set_refresh_rate(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional bool is_internal = 4;
bool has_is_internal() const;
void clear_is_internal();
bool is_internal() const;
void set_is_internal(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.DisplayInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::uint32 resolution_width_;
::PROTOBUF_NAMESPACE_ID::uint32 resolution_height_;
::PROTOBUF_NAMESPACE_ID::uint32 refresh_rate_;
bool is_internal_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT GraphicsAdapterInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GraphicsAdapterInfo) */ {
public:
GraphicsAdapterInfo();
virtual ~GraphicsAdapterInfo();

GraphicsAdapterInfo(const GraphicsAdapterInfo& from);
GraphicsAdapterInfo(GraphicsAdapterInfo&& from) noexcept
: GraphicsAdapterInfo() {
*this = ::std::move(from);
}

inline GraphicsAdapterInfo& operator=(const GraphicsAdapterInfo& from) {
CopyFrom(from);
return *this;
}
inline GraphicsAdapterInfo& operator=(GraphicsAdapterInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const GraphicsAdapterInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const GraphicsAdapterInfo* internal_default_instance() {
return reinterpret_cast<const GraphicsAdapterInfo*>(
&_GraphicsAdapterInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
47;

friend void swap(GraphicsAdapterInfo& a, GraphicsAdapterInfo& b) {
a.Swap(&b);
}
inline void Swap(GraphicsAdapterInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline GraphicsAdapterInfo* New() const final {
return CreateMaybeMessage<GraphicsAdapterInfo>(nullptr);
}

GraphicsAdapterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<GraphicsAdapterInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const GraphicsAdapterInfo& from);
void MergeFrom(const GraphicsAdapterInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(GraphicsAdapterInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.GraphicsAdapterInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kDriverVersionFieldNumber = 2,
kDeviceIdFieldNumber = 3,
kSystemRamUsageFieldNumber = 4,
};
// optional string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional string driver_version = 2;
bool has_driver_version() const;
void clear_driver_version();
const std::string& driver_version() const;
void set_driver_version(const std::string& value);
void set_driver_version(std::string&& value);
void set_driver_version(const char* value);
void set_driver_version(const char* value, size_t size);
std::string* mutable_driver_version();
std::string* release_driver_version();
void set_allocated_driver_version(std::string* driver_version);

// optional uint64 device_id = 3;
bool has_device_id() const;
void clear_device_id();
::PROTOBUF_NAMESPACE_ID::uint64 device_id() const;
void set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 system_ram_usage = 4;
bool has_system_ram_usage() const;
void clear_system_ram_usage();
::PROTOBUF_NAMESPACE_ID::uint64 system_ram_usage() const;
void set_system_ram_usage(::PROTOBUF_NAMESPACE_ID::uint64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.GraphicsAdapterInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
::PROTOBUF_NAMESPACE_ID::uint64 device_id_;
::PROTOBUF_NAMESPACE_ID::uint64 system_ram_usage_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT GraphicsStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GraphicsStatus) */ {
public:
GraphicsStatus();
virtual ~GraphicsStatus();

GraphicsStatus(const GraphicsStatus& from);
GraphicsStatus(GraphicsStatus&& from) noexcept
: GraphicsStatus() {
*this = ::std::move(from);
}

inline GraphicsStatus& operator=(const GraphicsStatus& from) {
CopyFrom(from);
return *this;
}
inline GraphicsStatus& operator=(GraphicsStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const GraphicsStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const GraphicsStatus* internal_default_instance() {
return reinterpret_cast<const GraphicsStatus*>(
&_GraphicsStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
48;

friend void swap(GraphicsStatus& a, GraphicsStatus& b) {
a.Swap(&b);
}
inline void Swap(GraphicsStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline GraphicsStatus* New() const final {
return CreateMaybeMessage<GraphicsStatus>(nullptr);
}

GraphicsStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<GraphicsStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const GraphicsStatus& from);
void MergeFrom(const GraphicsStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(GraphicsStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.GraphicsStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kDisplaysFieldNumber = 2,
kAdapterFieldNumber = 1,
};
// repeated .enterprise_management.DisplayInfo displays = 2;
int displays_size() const;
void clear_displays();
::enterprise_management::DisplayInfo* mutable_displays(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >*
mutable_displays();
const ::enterprise_management::DisplayInfo& displays(int index) const;
::enterprise_management::DisplayInfo* add_displays();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >&
displays() const;

// optional .enterprise_management.GraphicsAdapterInfo adapter = 1;
bool has_adapter() const;
void clear_adapter();
const ::enterprise_management::GraphicsAdapterInfo& adapter() const;
::enterprise_management::GraphicsAdapterInfo* release_adapter();
::enterprise_management::GraphicsAdapterInfo* mutable_adapter();
void set_allocated_adapter(::enterprise_management::GraphicsAdapterInfo* adapter);

// @@protoc_insertion_point(class_scope:enterprise_management.GraphicsStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo > displays_;
::enterprise_management::GraphicsAdapterInfo* adapter_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CrashReportInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CrashReportInfo) */ {
public:
CrashReportInfo();
virtual ~CrashReportInfo();

CrashReportInfo(const CrashReportInfo& from);
CrashReportInfo(CrashReportInfo&& from) noexcept
: CrashReportInfo() {
*this = ::std::move(from);
}

inline CrashReportInfo& operator=(const CrashReportInfo& from) {
CopyFrom(from);
return *this;
}
inline CrashReportInfo& operator=(CrashReportInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CrashReportInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CrashReportInfo* internal_default_instance() {
return reinterpret_cast<const CrashReportInfo*>(
&_CrashReportInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
49;

friend void swap(CrashReportInfo& a, CrashReportInfo& b) {
a.Swap(&b);
}
inline void Swap(CrashReportInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CrashReportInfo* New() const final {
return CreateMaybeMessage<CrashReportInfo>(nullptr);
}

CrashReportInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CrashReportInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CrashReportInfo& from);
void MergeFrom(const CrashReportInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CrashReportInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CrashReportInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef CrashReportInfo_CrashReportUploadStatus CrashReportUploadStatus;
static constexpr CrashReportUploadStatus UPLOAD_STATUS_UNKNOWN =
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UNKNOWN;
static constexpr CrashReportUploadStatus UPLOAD_STATUS_NOT_UPLOADED =
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_NOT_UPLOADED;
static constexpr CrashReportUploadStatus UPLOAD_STATUS_PENDING =
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING;
static constexpr CrashReportUploadStatus UPLOAD_STATUS_PENDING_USER_REQUESTED =
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING_USER_REQUESTED;
static constexpr CrashReportUploadStatus UPLOAD_STATUS_UPLOADED =
CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UPLOADED;
static inline bool CrashReportUploadStatus_IsValid(int value) {
return CrashReportInfo_CrashReportUploadStatus_IsValid(value);
}
static constexpr CrashReportUploadStatus CrashReportUploadStatus_MIN =
CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MIN;
static constexpr CrashReportUploadStatus CrashReportUploadStatus_MAX =
CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MAX;
static constexpr int CrashReportUploadStatus_ARRAYSIZE =
CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_ARRAYSIZE;
template<typename T>
static inline const std::string& CrashReportUploadStatus_Name(T enum_t_value) {
static_assert(::std::is_same<T, CrashReportUploadStatus>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CrashReportUploadStatus_Name.");
return CrashReportInfo_CrashReportUploadStatus_Name(enum_t_value);
}
static inline bool CrashReportUploadStatus_Parse(const std::string& name,
CrashReportUploadStatus* value) {
return CrashReportInfo_CrashReportUploadStatus_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kRemoteIdFieldNumber = 1,
kCauseFieldNumber = 3,
kCaptureTimestampFieldNumber = 2,
kUploadStatusFieldNumber = 4,
};
// optional string remote_id = 1;
bool has_remote_id() const;
void clear_remote_id();
const std::string& remote_id() const;
void set_remote_id(const std::string& value);
void set_remote_id(std::string&& value);
void set_remote_id(const char* value);
void set_remote_id(const char* value, size_t size);
std::string* mutable_remote_id();
std::string* release_remote_id();
void set_allocated_remote_id(std::string* remote_id);

// optional string cause = 3;
bool has_cause() const;
void clear_cause();
const std::string& cause() const;
void set_cause(const std::string& value);
void set_cause(std::string&& value);
void set_cause(const char* value);
void set_cause(const char* value, size_t size);
std::string* mutable_cause();
std::string* release_cause();
void set_allocated_cause(std::string* cause);

// optional int64 capture_timestamp = 2;
bool has_capture_timestamp() const;
void clear_capture_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 capture_timestamp() const;
void set_capture_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.CrashReportInfo.CrashReportUploadStatus upload_status = 4;
bool has_upload_status() const;
void clear_upload_status();
::enterprise_management::CrashReportInfo_CrashReportUploadStatus upload_status() const;
void set_upload_status(::enterprise_management::CrashReportInfo_CrashReportUploadStatus value);

// @@protoc_insertion_point(class_scope:enterprise_management.CrashReportInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
::PROTOBUF_NAMESPACE_ID::int64 capture_timestamp_;
int upload_status_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT TimezoneInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TimezoneInfo) */ {
public:
TimezoneInfo();
virtual ~TimezoneInfo();

TimezoneInfo(const TimezoneInfo& from);
TimezoneInfo(TimezoneInfo&& from) noexcept
: TimezoneInfo() {
*this = ::std::move(from);
}

inline TimezoneInfo& operator=(const TimezoneInfo& from) {
CopyFrom(from);
return *this;
}
inline TimezoneInfo& operator=(TimezoneInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const TimezoneInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const TimezoneInfo* internal_default_instance() {
return reinterpret_cast<const TimezoneInfo*>(
&_TimezoneInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
50;

friend void swap(TimezoneInfo& a, TimezoneInfo& b) {
a.Swap(&b);
}
inline void Swap(TimezoneInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline TimezoneInfo* New() const final {
return CreateMaybeMessage<TimezoneInfo>(nullptr);
}

TimezoneInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<TimezoneInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const TimezoneInfo& from);
void MergeFrom(const TimezoneInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TimezoneInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.TimezoneInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kPosixFieldNumber = 1,
kRegionFieldNumber = 2,
};
// optional string posix = 1;
bool has_posix() const;
void clear_posix();
const std::string& posix() const;
void set_posix(const std::string& value);
void set_posix(std::string&& value);
void set_posix(const char* value);
void set_posix(const char* value, size_t size);
std::string* mutable_posix();
std::string* release_posix();
void set_allocated_posix(std::string* posix);

// optional string region = 2;
bool has_region() const;
void clear_region();
const std::string& region() const;
void set_region(const std::string& value);
void set_region(std::string&& value);
void set_region(const char* value);
void set_region(const char* value, size_t size);
std::string* mutable_region();
std::string* release_region();
void set_allocated_region(std::string* region);

// @@protoc_insertion_point(class_scope:enterprise_management.TimezoneInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr posix_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT MemoryInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.MemoryInfo) */ {
public:
MemoryInfo();
virtual ~MemoryInfo();

MemoryInfo(const MemoryInfo& from);
MemoryInfo(MemoryInfo&& from) noexcept
: MemoryInfo() {
*this = ::std::move(from);
}

inline MemoryInfo& operator=(const MemoryInfo& from) {
CopyFrom(from);
return *this;
}
inline MemoryInfo& operator=(MemoryInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const MemoryInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const MemoryInfo* internal_default_instance() {
return reinterpret_cast<const MemoryInfo*>(
&_MemoryInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
51;

friend void swap(MemoryInfo& a, MemoryInfo& b) {
a.Swap(&b);
}
inline void Swap(MemoryInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline MemoryInfo* New() const final {
return CreateMaybeMessage<MemoryInfo>(nullptr);
}

MemoryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<MemoryInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const MemoryInfo& from);
void MergeFrom(const MemoryInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(MemoryInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.MemoryInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kTotalMemoryKibFieldNumber = 1,
kFreeMemoryKibFieldNumber = 2,
kAvailableMemoryKibFieldNumber = 3,
kPageFaultsSinceLastBootFieldNumber = 4,
};
// optional uint32 total_memory_kib = 1;
bool has_total_memory_kib() const;
void clear_total_memory_kib();
::PROTOBUF_NAMESPACE_ID::uint32 total_memory_kib() const;
void set_total_memory_kib(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 free_memory_kib = 2;
bool has_free_memory_kib() const;
void clear_free_memory_kib();
::PROTOBUF_NAMESPACE_ID::uint32 free_memory_kib() const;
void set_free_memory_kib(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 available_memory_kib = 3;
bool has_available_memory_kib() const;
void clear_available_memory_kib();
::PROTOBUF_NAMESPACE_ID::uint32 available_memory_kib() const;
void set_available_memory_kib(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 page_faults_since_last_boot = 4;
bool has_page_faults_since_last_boot() const;
void clear_page_faults_since_last_boot();
::PROTOBUF_NAMESPACE_ID::uint32 page_faults_since_last_boot() const;
void set_page_faults_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.MemoryInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::uint32 total_memory_kib_;
::PROTOBUF_NAMESPACE_ID::uint32 free_memory_kib_;
::PROTOBUF_NAMESPACE_ID::uint32 available_memory_kib_;
::PROTOBUF_NAMESPACE_ID::uint32 page_faults_since_last_boot_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT BacklightInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BacklightInfo) */ {
public:
BacklightInfo();
virtual ~BacklightInfo();

BacklightInfo(const BacklightInfo& from);
BacklightInfo(BacklightInfo&& from) noexcept
: BacklightInfo() {
*this = ::std::move(from);
}

inline BacklightInfo& operator=(const BacklightInfo& from) {
CopyFrom(from);
return *this;
}
inline BacklightInfo& operator=(BacklightInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const BacklightInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const BacklightInfo* internal_default_instance() {
return reinterpret_cast<const BacklightInfo*>(
&_BacklightInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
52;

friend void swap(BacklightInfo& a, BacklightInfo& b) {
a.Swap(&b);
}
inline void Swap(BacklightInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline BacklightInfo* New() const final {
return CreateMaybeMessage<BacklightInfo>(nullptr);
}

BacklightInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<BacklightInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const BacklightInfo& from);
void MergeFrom(const BacklightInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BacklightInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.BacklightInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kPathFieldNumber = 1,
kMaxBrightnessFieldNumber = 2,
kBrightnessFieldNumber = 3,
};
// optional string path = 1;
bool has_path() const;
void clear_path();
const std::string& path() const;
void set_path(const std::string& value);
void set_path(std::string&& value);
void set_path(const char* value);
void set_path(const char* value, size_t size);
std::string* mutable_path();
std::string* release_path();
void set_allocated_path(std::string* path);

// optional uint32 max_brightness = 2;
bool has_max_brightness() const;
void clear_max_brightness();
::PROTOBUF_NAMESPACE_ID::uint32 max_brightness() const;
void set_max_brightness(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 brightness = 3;
bool has_brightness() const;
void clear_brightness();
::PROTOBUF_NAMESPACE_ID::uint32 brightness() const;
void set_brightness(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.BacklightInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
::PROTOBUF_NAMESPACE_ID::uint32 max_brightness_;
::PROTOBUF_NAMESPACE_ID::uint32 brightness_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT FanInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.FanInfo) */ {
public:
FanInfo();
virtual ~FanInfo();

FanInfo(const FanInfo& from);
FanInfo(FanInfo&& from) noexcept
: FanInfo() {
*this = ::std::move(from);
}

inline FanInfo& operator=(const FanInfo& from) {
CopyFrom(from);
return *this;
}
inline FanInfo& operator=(FanInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const FanInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const FanInfo* internal_default_instance() {
return reinterpret_cast<const FanInfo*>(
&_FanInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
53;

friend void swap(FanInfo& a, FanInfo& b) {
a.Swap(&b);
}
inline void Swap(FanInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline FanInfo* New() const final {
return CreateMaybeMessage<FanInfo>(nullptr);
}

FanInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<FanInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const FanInfo& from);
void MergeFrom(const FanInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(FanInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.FanInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSpeedRpmFieldNumber = 1,
};
// optional uint32 speed_rpm = 1;
bool has_speed_rpm() const;
void clear_speed_rpm();
::PROTOBUF_NAMESPACE_ID::uint32 speed_rpm() const;
void set_speed_rpm(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.FanInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::uint32 speed_rpm_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT BluetoothAdapterInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BluetoothAdapterInfo) */ {
public:
BluetoothAdapterInfo();
virtual ~BluetoothAdapterInfo();

BluetoothAdapterInfo(const BluetoothAdapterInfo& from);
BluetoothAdapterInfo(BluetoothAdapterInfo&& from) noexcept
: BluetoothAdapterInfo() {
*this = ::std::move(from);
}

inline BluetoothAdapterInfo& operator=(const BluetoothAdapterInfo& from) {
CopyFrom(from);
return *this;
}
inline BluetoothAdapterInfo& operator=(BluetoothAdapterInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const BluetoothAdapterInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const BluetoothAdapterInfo* internal_default_instance() {
return reinterpret_cast<const BluetoothAdapterInfo*>(
&_BluetoothAdapterInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
54;

friend void swap(BluetoothAdapterInfo& a, BluetoothAdapterInfo& b) {
a.Swap(&b);
}
inline void Swap(BluetoothAdapterInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline BluetoothAdapterInfo* New() const final {
return CreateMaybeMessage<BluetoothAdapterInfo>(nullptr);
}

BluetoothAdapterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<BluetoothAdapterInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const BluetoothAdapterInfo& from);
void MergeFrom(const BluetoothAdapterInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BluetoothAdapterInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.BluetoothAdapterInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kAddressFieldNumber = 2,
kPoweredFieldNumber = 3,
kNumConnectedDevicesFieldNumber = 4,
};
// optional string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional string address = 2;
bool has_address() const;
void clear_address();
const std::string& address() const;
void set_address(const std::string& value);
void set_address(std::string&& value);
void set_address(const char* value);
void set_address(const char* value, size_t size);
std::string* mutable_address();
std::string* release_address();
void set_allocated_address(std::string* address);

// optional bool powered = 3;
bool has_powered() const;
void clear_powered();
bool powered() const;
void set_powered(bool value);

// optional uint32 num_connected_devices = 4;
bool has_num_connected_devices() const;
void clear_num_connected_devices();
::PROTOBUF_NAMESPACE_ID::uint32 num_connected_devices() const;
void set_num_connected_devices(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.BluetoothAdapterInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
bool powered_;
::PROTOBUF_NAMESPACE_ID::uint32 num_connected_devices_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStatusReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStatusReportRequest) */ {
public:
DeviceStatusReportRequest();
virtual ~DeviceStatusReportRequest();

DeviceStatusReportRequest(const DeviceStatusReportRequest& from);
DeviceStatusReportRequest(DeviceStatusReportRequest&& from) noexcept
: DeviceStatusReportRequest() {
*this = ::std::move(from);
}

inline DeviceStatusReportRequest& operator=(const DeviceStatusReportRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceStatusReportRequest& operator=(DeviceStatusReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceStatusReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceStatusReportRequest* internal_default_instance() {
return reinterpret_cast<const DeviceStatusReportRequest*>(
&_DeviceStatusReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
55;

friend void swap(DeviceStatusReportRequest& a, DeviceStatusReportRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceStatusReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceStatusReportRequest* New() const final {
return CreateMaybeMessage<DeviceStatusReportRequest>(nullptr);
}

DeviceStatusReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceStatusReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceStatusReportRequest& from);
void MergeFrom(const DeviceStatusReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceStatusReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceStatusReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kActivePeriodsFieldNumber = 6,
kNetworkInterfacesFieldNumber = 8,
kUsersFieldNumber = 9,
kVolumeInfosFieldNumber = 10,
kNetworkStatesFieldNumber = 11,
kCpuUtilizationPctSamplesFieldNumber = 12,
kSystemRamFreeSamplesFieldNumber = 15,
kCpuTempInfosFieldNumber = 16,
kCpuUtilizationInfosFieldNumber = 30,
kSystemRamFreeInfosFieldNumber = 31,
kCpuInfoFieldNumber = 32,
kCrashReportInfosFieldNumber = 34,
kBacklightInfoFieldNumber = 37,
kFanInfoFieldNumber = 38,
kBluetoothAdapterInfoFieldNumber = 40,
kOsVersionFieldNumber = 1,
kFirmwareVersionFieldNumber = 2,
kBootModeFieldNumber = 3,
kBrowserVersionFieldNumber = 5,
kOsUpdateStatusFieldNumber = 17,
kRunningKioskAppFieldNumber = 18,
kTpmVersionInfoFieldNumber = 21,
kTpmStatusInfoFieldNumber = 23,
kPowerStatusFieldNumber = 25,
kStorageStatusFieldNumber = 26,
kBoardStatusFieldNumber = 27,
kSystemStatusFieldNumber = 28,
kStatefulPartitionInfoFieldNumber = 29,
kGraphicsStatusFieldNumber = 33,
kTimezoneInfoFieldNumber = 35,
kMemoryInfoFieldNumber = 36,
kGlobalCpuInfoFieldNumber = 39,
kSystemRamTotalFieldNumber = 14,
kSoundVolumeFieldNumber = 19,
kChannelFieldNumber = 22,
kWriteProtectSwitchFieldNumber = 24,
};
// repeated .enterprise_management.ActiveTimePeriod active_periods = 6;
int active_periods_size() const;
void clear_active_periods();
::enterprise_management::ActiveTimePeriod* mutable_active_periods(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >*
mutable_active_periods();
const ::enterprise_management::ActiveTimePeriod& active_periods(int index) const;
::enterprise_management::ActiveTimePeriod* add_active_periods();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >&
active_periods() const;

// repeated .enterprise_management.NetworkInterface network_interfaces = 8;
int network_interfaces_size() const;
void clear_network_interfaces();
::enterprise_management::NetworkInterface* mutable_network_interfaces(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >*
mutable_network_interfaces();
const ::enterprise_management::NetworkInterface& network_interfaces(int index) const;
::enterprise_management::NetworkInterface* add_network_interfaces();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >&
network_interfaces() const;

// repeated .enterprise_management.DeviceUser users = 9;
int users_size() const;
void clear_users();
::enterprise_management::DeviceUser* mutable_users(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >*
mutable_users();
const ::enterprise_management::DeviceUser& users(int index) const;
::enterprise_management::DeviceUser* add_users();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >&
users() const;

// repeated .enterprise_management.VolumeInfo volume_infos = 10;
int volume_infos_size() const;
void clear_volume_infos();
::enterprise_management::VolumeInfo* mutable_volume_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
mutable_volume_infos();
const ::enterprise_management::VolumeInfo& volume_infos(int index) const;
::enterprise_management::VolumeInfo* add_volume_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
volume_infos() const;

// repeated .enterprise_management.NetworkState network_states = 11;
int network_states_size() const;
void clear_network_states();
::enterprise_management::NetworkState* mutable_network_states(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >*
mutable_network_states();
const ::enterprise_management::NetworkState& network_states(int index) const;
::enterprise_management::NetworkState* add_network_states();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >&
network_states() const;

// repeated int32 cpu_utilization_pct_samples = 12;
int cpu_utilization_pct_samples_size() const;
void clear_cpu_utilization_pct_samples();
::PROTOBUF_NAMESPACE_ID::int32 cpu_utilization_pct_samples(int index) const;
void set_cpu_utilization_pct_samples(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
void add_cpu_utilization_pct_samples(::PROTOBUF_NAMESPACE_ID::int32 value);
const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
cpu_utilization_pct_samples() const;
::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
mutable_cpu_utilization_pct_samples();

// repeated int64 system_ram_free_samples = 15;
int system_ram_free_samples_size() const;
void clear_system_ram_free_samples();
::PROTOBUF_NAMESPACE_ID::int64 system_ram_free_samples(int index) const;
void set_system_ram_free_samples(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
void add_system_ram_free_samples(::PROTOBUF_NAMESPACE_ID::int64 value);
const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
system_ram_free_samples() const;
::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
mutable_system_ram_free_samples();

// repeated .enterprise_management.CPUTempInfo cpu_temp_infos = 16;
int cpu_temp_infos_size() const;
void clear_cpu_temp_infos();
::enterprise_management::CPUTempInfo* mutable_cpu_temp_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >*
mutable_cpu_temp_infos();
const ::enterprise_management::CPUTempInfo& cpu_temp_infos(int index) const;
::enterprise_management::CPUTempInfo* add_cpu_temp_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >&
cpu_temp_infos() const;

// repeated .enterprise_management.CpuUtilizationInfo cpu_utilization_infos = 30;
int cpu_utilization_infos_size() const;
void clear_cpu_utilization_infos();
::enterprise_management::CpuUtilizationInfo* mutable_cpu_utilization_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >*
mutable_cpu_utilization_infos();
const ::enterprise_management::CpuUtilizationInfo& cpu_utilization_infos(int index) const;
::enterprise_management::CpuUtilizationInfo* add_cpu_utilization_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >&
cpu_utilization_infos() const;

// repeated .enterprise_management.SystemFreeRamInfo system_ram_free_infos = 31;
int system_ram_free_infos_size() const;
void clear_system_ram_free_infos();
::enterprise_management::SystemFreeRamInfo* mutable_system_ram_free_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >*
mutable_system_ram_free_infos();
const ::enterprise_management::SystemFreeRamInfo& system_ram_free_infos(int index) const;
::enterprise_management::SystemFreeRamInfo* add_system_ram_free_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >&
system_ram_free_infos() const;

// repeated .enterprise_management.CpuInfo cpu_info = 32;
int cpu_info_size() const;
void clear_cpu_info();
::enterprise_management::CpuInfo* mutable_cpu_info(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >*
mutable_cpu_info();
const ::enterprise_management::CpuInfo& cpu_info(int index) const;
::enterprise_management::CpuInfo* add_cpu_info();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >&
cpu_info() const;

// repeated .enterprise_management.CrashReportInfo crash_report_infos = 34;
int crash_report_infos_size() const;
void clear_crash_report_infos();
::enterprise_management::CrashReportInfo* mutable_crash_report_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >*
mutable_crash_report_infos();
const ::enterprise_management::CrashReportInfo& crash_report_infos(int index) const;
::enterprise_management::CrashReportInfo* add_crash_report_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >&
crash_report_infos() const;

// repeated .enterprise_management.BacklightInfo backlight_info = 37;
int backlight_info_size() const;
void clear_backlight_info();
::enterprise_management::BacklightInfo* mutable_backlight_info(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >*
mutable_backlight_info();
const ::enterprise_management::BacklightInfo& backlight_info(int index) const;
::enterprise_management::BacklightInfo* add_backlight_info();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >&
backlight_info() const;

// repeated .enterprise_management.FanInfo fan_info = 38;
int fan_info_size() const;
void clear_fan_info();
::enterprise_management::FanInfo* mutable_fan_info(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >*
mutable_fan_info();
const ::enterprise_management::FanInfo& fan_info(int index) const;
::enterprise_management::FanInfo* add_fan_info();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >&
fan_info() const;

// repeated .enterprise_management.BluetoothAdapterInfo bluetooth_adapter_info = 40;
int bluetooth_adapter_info_size() const;
void clear_bluetooth_adapter_info();
::enterprise_management::BluetoothAdapterInfo* mutable_bluetooth_adapter_info(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >*
mutable_bluetooth_adapter_info();
const ::enterprise_management::BluetoothAdapterInfo& bluetooth_adapter_info(int index) const;
::enterprise_management::BluetoothAdapterInfo* add_bluetooth_adapter_info();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >&
bluetooth_adapter_info() const;

// optional string os_version = 1;
bool has_os_version() const;
void clear_os_version();
const std::string& os_version() const;
void set_os_version(const std::string& value);
void set_os_version(std::string&& value);
void set_os_version(const char* value);
void set_os_version(const char* value, size_t size);
std::string* mutable_os_version();
std::string* release_os_version();
void set_allocated_os_version(std::string* os_version);

// optional string firmware_version = 2;
bool has_firmware_version() const;
void clear_firmware_version();
const std::string& firmware_version() const;
void set_firmware_version(const std::string& value);
void set_firmware_version(std::string&& value);
void set_firmware_version(const char* value);
void set_firmware_version(const char* value, size_t size);
std::string* mutable_firmware_version();
std::string* release_firmware_version();
void set_allocated_firmware_version(std::string* firmware_version);

// optional string boot_mode = 3;
bool has_boot_mode() const;
void clear_boot_mode();
const std::string& boot_mode() const;
void set_boot_mode(const std::string& value);
void set_boot_mode(std::string&& value);
void set_boot_mode(const char* value);
void set_boot_mode(const char* value, size_t size);
std::string* mutable_boot_mode();
std::string* release_boot_mode();
void set_allocated_boot_mode(std::string* boot_mode);

// optional string browser_version = 5;
bool has_browser_version() const;
void clear_browser_version();
const std::string& browser_version() const;
void set_browser_version(const std::string& value);
void set_browser_version(std::string&& value);
void set_browser_version(const char* value);
void set_browser_version(const char* value, size_t size);
std::string* mutable_browser_version();
std::string* release_browser_version();
void set_allocated_browser_version(std::string* browser_version);

// optional .enterprise_management.OsUpdateStatus os_update_status = 17;
bool has_os_update_status() const;
void clear_os_update_status();
const ::enterprise_management::OsUpdateStatus& os_update_status() const;
::enterprise_management::OsUpdateStatus* release_os_update_status();
::enterprise_management::OsUpdateStatus* mutable_os_update_status();
void set_allocated_os_update_status(::enterprise_management::OsUpdateStatus* os_update_status);

// optional .enterprise_management.AppStatus running_kiosk_app = 18;
bool has_running_kiosk_app() const;
void clear_running_kiosk_app();
const ::enterprise_management::AppStatus& running_kiosk_app() const;
::enterprise_management::AppStatus* release_running_kiosk_app();
::enterprise_management::AppStatus* mutable_running_kiosk_app();
void set_allocated_running_kiosk_app(::enterprise_management::AppStatus* running_kiosk_app);

// optional .enterprise_management.TpmVersionInfo tpm_version_info = 21;
bool has_tpm_version_info() const;
void clear_tpm_version_info();
const ::enterprise_management::TpmVersionInfo& tpm_version_info() const;
::enterprise_management::TpmVersionInfo* release_tpm_version_info();
::enterprise_management::TpmVersionInfo* mutable_tpm_version_info();
void set_allocated_tpm_version_info(::enterprise_management::TpmVersionInfo* tpm_version_info);

// optional .enterprise_management.TpmStatusInfo tpm_status_info = 23;
bool has_tpm_status_info() const;
void clear_tpm_status_info();
const ::enterprise_management::TpmStatusInfo& tpm_status_info() const;
::enterprise_management::TpmStatusInfo* release_tpm_status_info();
::enterprise_management::TpmStatusInfo* mutable_tpm_status_info();
void set_allocated_tpm_status_info(::enterprise_management::TpmStatusInfo* tpm_status_info);

// optional .enterprise_management.PowerStatus power_status = 25;
bool has_power_status() const;
void clear_power_status();
const ::enterprise_management::PowerStatus& power_status() const;
::enterprise_management::PowerStatus* release_power_status();
::enterprise_management::PowerStatus* mutable_power_status();
void set_allocated_power_status(::enterprise_management::PowerStatus* power_status);

// optional .enterprise_management.StorageStatus storage_status = 26;
bool has_storage_status() const;
void clear_storage_status();
const ::enterprise_management::StorageStatus& storage_status() const;
::enterprise_management::StorageStatus* release_storage_status();
::enterprise_management::StorageStatus* mutable_storage_status();
void set_allocated_storage_status(::enterprise_management::StorageStatus* storage_status);

// optional .enterprise_management.BoardStatus board_status = 27;
bool has_board_status() const;
void clear_board_status();
const ::enterprise_management::BoardStatus& board_status() const;
::enterprise_management::BoardStatus* release_board_status();
::enterprise_management::BoardStatus* mutable_board_status();
void set_allocated_board_status(::enterprise_management::BoardStatus* board_status);

// optional .enterprise_management.SystemStatus system_status = 28;
bool has_system_status() const;
void clear_system_status();
const ::enterprise_management::SystemStatus& system_status() const;
::enterprise_management::SystemStatus* release_system_status();
::enterprise_management::SystemStatus* mutable_system_status();
void set_allocated_system_status(::enterprise_management::SystemStatus* system_status);

// optional .enterprise_management.StatefulPartitionInfo stateful_partition_info = 29;
bool has_stateful_partition_info() const;
void clear_stateful_partition_info();
const ::enterprise_management::StatefulPartitionInfo& stateful_partition_info() const;
::enterprise_management::StatefulPartitionInfo* release_stateful_partition_info();
::enterprise_management::StatefulPartitionInfo* mutable_stateful_partition_info();
void set_allocated_stateful_partition_info(::enterprise_management::StatefulPartitionInfo* stateful_partition_info);

// optional .enterprise_management.GraphicsStatus graphics_status = 33;
bool has_graphics_status() const;
void clear_graphics_status();
const ::enterprise_management::GraphicsStatus& graphics_status() const;
::enterprise_management::GraphicsStatus* release_graphics_status();
::enterprise_management::GraphicsStatus* mutable_graphics_status();
void set_allocated_graphics_status(::enterprise_management::GraphicsStatus* graphics_status);

// optional .enterprise_management.TimezoneInfo timezone_info = 35;
bool has_timezone_info() const;
void clear_timezone_info();
const ::enterprise_management::TimezoneInfo& timezone_info() const;
::enterprise_management::TimezoneInfo* release_timezone_info();
::enterprise_management::TimezoneInfo* mutable_timezone_info();
void set_allocated_timezone_info(::enterprise_management::TimezoneInfo* timezone_info);

// optional .enterprise_management.MemoryInfo memory_info = 36;
bool has_memory_info() const;
void clear_memory_info();
const ::enterprise_management::MemoryInfo& memory_info() const;
::enterprise_management::MemoryInfo* release_memory_info();
::enterprise_management::MemoryInfo* mutable_memory_info();
void set_allocated_memory_info(::enterprise_management::MemoryInfo* memory_info);

// optional .enterprise_management.GlobalCpuInfo global_cpu_info = 39;
bool has_global_cpu_info() const;
void clear_global_cpu_info();
const ::enterprise_management::GlobalCpuInfo& global_cpu_info() const;
::enterprise_management::GlobalCpuInfo* release_global_cpu_info();
::enterprise_management::GlobalCpuInfo* mutable_global_cpu_info();
void set_allocated_global_cpu_info(::enterprise_management::GlobalCpuInfo* global_cpu_info);

// optional int64 system_ram_total = 14;
bool has_system_ram_total() const;
void clear_system_ram_total();
::PROTOBUF_NAMESPACE_ID::int64 system_ram_total() const;
void set_system_ram_total(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 sound_volume = 19;
bool has_sound_volume() const;
void clear_sound_volume();
::PROTOBUF_NAMESPACE_ID::int32 sound_volume() const;
void set_sound_volume(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional .enterprise_management.Channel channel = 22;
bool has_channel() const;
void clear_channel();
::enterprise_management::Channel channel() const;
void set_channel(::enterprise_management::Channel value);

// optional bool write_protect_switch = 24;
bool has_write_protect_switch() const;
void clear_write_protect_switch();
bool write_protect_switch() const;
void set_write_protect_switch(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceStatusReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod > active_periods_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface > network_interfaces_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser > users_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo > volume_infos_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState > network_states_;
::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > cpu_utilization_pct_samples_;
::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > system_ram_free_samples_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo > cpu_temp_infos_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo > cpu_utilization_infos_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo > system_ram_free_infos_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo > cpu_info_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo > crash_report_infos_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo > backlight_info_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo > fan_info_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo > bluetooth_adapter_info_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boot_mode_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_version_;
::enterprise_management::OsUpdateStatus* os_update_status_;
::enterprise_management::AppStatus* running_kiosk_app_;
::enterprise_management::TpmVersionInfo* tpm_version_info_;
::enterprise_management::TpmStatusInfo* tpm_status_info_;
::enterprise_management::PowerStatus* power_status_;
::enterprise_management::StorageStatus* storage_status_;
::enterprise_management::BoardStatus* board_status_;
::enterprise_management::SystemStatus* system_status_;
::enterprise_management::StatefulPartitionInfo* stateful_partition_info_;
::enterprise_management::GraphicsStatus* graphics_status_;
::enterprise_management::TimezoneInfo* timezone_info_;
::enterprise_management::MemoryInfo* memory_info_;
::enterprise_management::GlobalCpuInfo* global_cpu_info_;
::PROTOBUF_NAMESPACE_ID::int64 system_ram_total_;
::PROTOBUF_NAMESPACE_ID::int32 sound_volume_;
int channel_;
bool write_protect_switch_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT OsUpdateStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OsUpdateStatus) */ {
public:
OsUpdateStatus();
virtual ~OsUpdateStatus();

OsUpdateStatus(const OsUpdateStatus& from);
OsUpdateStatus(OsUpdateStatus&& from) noexcept
: OsUpdateStatus() {
*this = ::std::move(from);
}

inline OsUpdateStatus& operator=(const OsUpdateStatus& from) {
CopyFrom(from);
return *this;
}
inline OsUpdateStatus& operator=(OsUpdateStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const OsUpdateStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const OsUpdateStatus* internal_default_instance() {
return reinterpret_cast<const OsUpdateStatus*>(
&_OsUpdateStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
56;

friend void swap(OsUpdateStatus& a, OsUpdateStatus& b) {
a.Swap(&b);
}
inline void Swap(OsUpdateStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline OsUpdateStatus* New() const final {
return CreateMaybeMessage<OsUpdateStatus>(nullptr);
}

OsUpdateStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<OsUpdateStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const OsUpdateStatus& from);
void MergeFrom(const OsUpdateStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(OsUpdateStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.OsUpdateStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef OsUpdateStatus_UpdateStatus UpdateStatus;
static constexpr UpdateStatus OS_UP_TO_DATE =
OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE;
static constexpr UpdateStatus OS_IMAGE_DOWNLOAD_NOT_STARTED =
OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_NOT_STARTED;
static constexpr UpdateStatus OS_IMAGE_DOWNLOAD_IN_PROGRESS =
OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_IN_PROGRESS;
static constexpr UpdateStatus OS_UPDATE_NEED_REBOOT =
OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT;
static inline bool UpdateStatus_IsValid(int value) {
return OsUpdateStatus_UpdateStatus_IsValid(value);
}
static constexpr UpdateStatus UpdateStatus_MIN =
OsUpdateStatus_UpdateStatus_UpdateStatus_MIN;
static constexpr UpdateStatus UpdateStatus_MAX =
OsUpdateStatus_UpdateStatus_UpdateStatus_MAX;
static constexpr int UpdateStatus_ARRAYSIZE =
OsUpdateStatus_UpdateStatus_UpdateStatus_ARRAYSIZE;
template<typename T>
static inline const std::string& UpdateStatus_Name(T enum_t_value) {
static_assert(::std::is_same<T, UpdateStatus>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function UpdateStatus_Name.");
return OsUpdateStatus_UpdateStatus_Name(enum_t_value);
}
static inline bool UpdateStatus_Parse(const std::string& name,
UpdateStatus* value) {
return OsUpdateStatus_UpdateStatus_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kNewPlatformVersionFieldNumber = 2,
kNewRequiredPlatformVersionFieldNumber = 3,
kLastCheckedTimestampFieldNumber = 4,
kLastRebootTimestampFieldNumber = 5,
kUpdateStatusFieldNumber = 1,
};
// optional string new_platform_version = 2;
bool has_new_platform_version() const;
void clear_new_platform_version();
const std::string& new_platform_version() const;
void set_new_platform_version(const std::string& value);
void set_new_platform_version(std::string&& value);
void set_new_platform_version(const char* value);
void set_new_platform_version(const char* value, size_t size);
std::string* mutable_new_platform_version();
std::string* release_new_platform_version();
void set_allocated_new_platform_version(std::string* new_platform_version);

// optional string new_required_platform_version = 3;
bool has_new_required_platform_version() const;
void clear_new_required_platform_version();
const std::string& new_required_platform_version() const;
void set_new_required_platform_version(const std::string& value);
void set_new_required_platform_version(std::string&& value);
void set_new_required_platform_version(const char* value);
void set_new_required_platform_version(const char* value, size_t size);
std::string* mutable_new_required_platform_version();
std::string* release_new_required_platform_version();
void set_allocated_new_required_platform_version(std::string* new_required_platform_version);

// optional int64 last_checked_timestamp = 4;
bool has_last_checked_timestamp() const;
void clear_last_checked_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 last_checked_timestamp() const;
void set_last_checked_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 last_reboot_timestamp = 5;
bool has_last_reboot_timestamp() const;
void clear_last_reboot_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 last_reboot_timestamp() const;
void set_last_reboot_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
bool has_update_status() const;
void clear_update_status();
::enterprise_management::OsUpdateStatus_UpdateStatus update_status() const;
void set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value);

// @@protoc_insertion_point(class_scope:enterprise_management.OsUpdateStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_platform_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_required_platform_version_;
::PROTOBUF_NAMESPACE_ID::int64 last_checked_timestamp_;
::PROTOBUF_NAMESPACE_ID::int64 last_reboot_timestamp_;
int update_status_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppStatus) */ {
public:
AppStatus();
virtual ~AppStatus();

AppStatus(const AppStatus& from);
AppStatus(AppStatus&& from) noexcept
: AppStatus() {
*this = ::std::move(from);
}

inline AppStatus& operator=(const AppStatus& from) {
CopyFrom(from);
return *this;
}
inline AppStatus& operator=(AppStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppStatus* internal_default_instance() {
return reinterpret_cast<const AppStatus*>(
&_AppStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
57;

friend void swap(AppStatus& a, AppStatus& b) {
a.Swap(&b);
}
inline void Swap(AppStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppStatus* New() const final {
return CreateMaybeMessage<AppStatus>(nullptr);
}

AppStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppStatus& from);
void MergeFrom(const AppStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AppStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAppIdFieldNumber = 1,
kExtensionVersionFieldNumber = 2,
kStatusFieldNumber = 3,
kRequiredPlatformVersionFieldNumber = 5,
kErrorFieldNumber = 4,
};
// optional string app_id = 1;
bool has_app_id() const;
void clear_app_id();
const std::string& app_id() const;
void set_app_id(const std::string& value);
void set_app_id(std::string&& value);
void set_app_id(const char* value);
void set_app_id(const char* value, size_t size);
std::string* mutable_app_id();
std::string* release_app_id();
void set_allocated_app_id(std::string* app_id);

// optional string extension_version = 2;
bool has_extension_version() const;
void clear_extension_version();
const std::string& extension_version() const;
void set_extension_version(const std::string& value);
void set_extension_version(std::string&& value);
void set_extension_version(const char* value);
void set_extension_version(const char* value, size_t size);
std::string* mutable_extension_version();
std::string* release_extension_version();
void set_allocated_extension_version(std::string* extension_version);

// optional string status = 3;
bool has_status() const;
void clear_status();
const std::string& status() const;
void set_status(const std::string& value);
void set_status(std::string&& value);
void set_status(const char* value);
void set_status(const char* value, size_t size);
std::string* mutable_status();
std::string* release_status();
void set_allocated_status(std::string* status);

// optional string required_platform_version = 5;
bool has_required_platform_version() const;
void clear_required_platform_version();
const std::string& required_platform_version() const;
void set_required_platform_version(const std::string& value);
void set_required_platform_version(std::string&& value);
void set_required_platform_version(const char* value);
void set_required_platform_version(const char* value, size_t size);
std::string* mutable_required_platform_version();
std::string* release_required_platform_version();
void set_allocated_required_platform_version(std::string* required_platform_version);

// optional bool error = 4;
bool has_error() const;
void clear_error();
bool error() const;
void set_error(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.AppStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_platform_version_;
bool error_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInfo) */ {
public:
AppInfo();
virtual ~AppInfo();

AppInfo(const AppInfo& from);
AppInfo(AppInfo&& from) noexcept
: AppInfo() {
*this = ::std::move(from);
}

inline AppInfo& operator=(const AppInfo& from) {
CopyFrom(from);
return *this;
}
inline AppInfo& operator=(AppInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppInfo* internal_default_instance() {
return reinterpret_cast<const AppInfo*>(
&_AppInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
58;

friend void swap(AppInfo& a, AppInfo& b) {
a.Swap(&b);
}
inline void Swap(AppInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppInfo* New() const final {
return CreateMaybeMessage<AppInfo>(nullptr);
}

AppInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppInfo& from);
void MergeFrom(const AppInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AppInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef AppInfo_AppType AppType;
static constexpr AppType TYPE_UNKNOWN =
AppInfo_AppType_TYPE_UNKNOWN;
static constexpr AppType TYPE_ARC =
AppInfo_AppType_TYPE_ARC;
static constexpr AppType TYPE_BUILTIN =
AppInfo_AppType_TYPE_BUILTIN;
static constexpr AppType TYPE_CROSTINI =
AppInfo_AppType_TYPE_CROSTINI;
static constexpr AppType TYPE_EXTENSION =
AppInfo_AppType_TYPE_EXTENSION;
static constexpr AppType TYPE_WEB =
AppInfo_AppType_TYPE_WEB;
static constexpr AppType TYPE_PLUGINVM =
AppInfo_AppType_TYPE_PLUGINVM;
static inline bool AppType_IsValid(int value) {
return AppInfo_AppType_IsValid(value);
}
static constexpr AppType AppType_MIN =
AppInfo_AppType_AppType_MIN;
static constexpr AppType AppType_MAX =
AppInfo_AppType_AppType_MAX;
static constexpr int AppType_ARRAYSIZE =
AppInfo_AppType_AppType_ARRAYSIZE;
template<typename T>
static inline const std::string& AppType_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppType_Name.");
return AppInfo_AppType_Name(enum_t_value);
}
static inline bool AppType_Parse(const std::string& name,
AppType* value) {
return AppInfo_AppType_Parse(name, value);
}

typedef AppInfo_Status Status;
static constexpr Status STATUS_UNKNOWN =
AppInfo_Status_STATUS_UNKNOWN;
static constexpr Status STATUS_INSTALLED =
AppInfo_Status_STATUS_INSTALLED;
static constexpr Status STATUS_DISABLED =
AppInfo_Status_STATUS_DISABLED;
static constexpr Status STATUS_UNINSTALLED =
AppInfo_Status_STATUS_UNINSTALLED;
static inline bool Status_IsValid(int value) {
return AppInfo_Status_IsValid(value);
}
static constexpr Status Status_MIN =
AppInfo_Status_Status_MIN;
static constexpr Status Status_MAX =
AppInfo_Status_Status_MAX;
static constexpr int Status_ARRAYSIZE =
AppInfo_Status_Status_ARRAYSIZE;
template<typename T>
static inline const std::string& Status_Name(T enum_t_value) {
static_assert(::std::is_same<T, Status>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Status_Name.");
return AppInfo_Status_Name(enum_t_value);
}
static inline bool Status_Parse(const std::string& name,
Status* value) {
return AppInfo_Status_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kActiveTimePeriodsFieldNumber = 8,
kAppIdFieldNumber = 1,
kAppNameFieldNumber = 3,
kVersionFieldNumber = 7,
kAppTypeFieldNumber = 2,
kStatusFieldNumber = 4,
kInstallTimeFieldNumber = 5,
};
// repeated .enterprise_management.TimePeriod active_time_periods = 8;
int active_time_periods_size() const;
void clear_active_time_periods();
::enterprise_management::TimePeriod* mutable_active_time_periods(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
mutable_active_time_periods();
const ::enterprise_management::TimePeriod& active_time_periods(int index) const;
::enterprise_management::TimePeriod* add_active_time_periods();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
active_time_periods() const;

// optional string app_id = 1;
bool has_app_id() const;
void clear_app_id();
const std::string& app_id() const;
void set_app_id(const std::string& value);
void set_app_id(std::string&& value);
void set_app_id(const char* value);
void set_app_id(const char* value, size_t size);
std::string* mutable_app_id();
std::string* release_app_id();
void set_allocated_app_id(std::string* app_id);

// optional string app_name = 3;
bool has_app_name() const;
void clear_app_name();
const std::string& app_name() const;
void set_app_name(const std::string& value);
void set_app_name(std::string&& value);
void set_app_name(const char* value);
void set_app_name(const char* value, size_t size);
std::string* mutable_app_name();
std::string* release_app_name();
void set_allocated_app_name(std::string* app_name);

// optional string version = 7;
bool has_version() const;
void clear_version();
const std::string& version() const;
void set_version(const std::string& value);
void set_version(std::string&& value);
void set_version(const char* value);
void set_version(const char* value, size_t size);
std::string* mutable_version();
std::string* release_version();
void set_allocated_version(std::string* version);

// optional .enterprise_management.AppInfo.AppType app_type = 2;
bool has_app_type() const;
void clear_app_type();
::enterprise_management::AppInfo_AppType app_type() const;
void set_app_type(::enterprise_management::AppInfo_AppType value);

// optional .enterprise_management.AppInfo.Status status = 4;
bool has_status() const;
void clear_status();
::enterprise_management::AppInfo_Status status() const;
void set_status(::enterprise_management::AppInfo_Status value);

// optional int64 install_time = 5;
bool has_install_time() const;
void clear_install_time();
::PROTOBUF_NAMESPACE_ID::int64 install_time() const;
void set_install_time(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.AppInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod > active_time_periods_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
int app_type_;
int status_;
::PROTOBUF_NAMESPACE_ID::int64 install_time_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AndroidAppPermission :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AndroidAppPermission) */ {
public:
AndroidAppPermission();
virtual ~AndroidAppPermission();

AndroidAppPermission(const AndroidAppPermission& from);
AndroidAppPermission(AndroidAppPermission&& from) noexcept
: AndroidAppPermission() {
*this = ::std::move(from);
}

inline AndroidAppPermission& operator=(const AndroidAppPermission& from) {
CopyFrom(from);
return *this;
}
inline AndroidAppPermission& operator=(AndroidAppPermission&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AndroidAppPermission& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AndroidAppPermission* internal_default_instance() {
return reinterpret_cast<const AndroidAppPermission*>(
&_AndroidAppPermission_default_instance_);
}
static constexpr int kIndexInFileMessages =
59;

friend void swap(AndroidAppPermission& a, AndroidAppPermission& b) {
a.Swap(&b);
}
inline void Swap(AndroidAppPermission* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AndroidAppPermission* New() const final {
return CreateMaybeMessage<AndroidAppPermission>(nullptr);
}

AndroidAppPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AndroidAppPermission>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AndroidAppPermission& from);
void MergeFrom(const AndroidAppPermission& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AndroidAppPermission* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AndroidAppPermission";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kGrantedFieldNumber = 2,
kManagedFieldNumber = 3,
};
// optional string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional bool granted = 2;
bool has_granted() const;
void clear_granted();
bool granted() const;
void set_granted(bool value);

// optional bool managed = 3;
bool has_managed() const;
void clear_managed();
bool managed() const;
void set_managed(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.AndroidAppPermission)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
bool granted_;
bool managed_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AndroidAppInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AndroidAppInfo) */ {
public:
AndroidAppInfo();
virtual ~AndroidAppInfo();

AndroidAppInfo(const AndroidAppInfo& from);
AndroidAppInfo(AndroidAppInfo&& from) noexcept
: AndroidAppInfo() {
*this = ::std::move(from);
}

inline AndroidAppInfo& operator=(const AndroidAppInfo& from) {
CopyFrom(from);
return *this;
}
inline AndroidAppInfo& operator=(AndroidAppInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AndroidAppInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AndroidAppInfo* internal_default_instance() {
return reinterpret_cast<const AndroidAppInfo*>(
&_AndroidAppInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
60;

friend void swap(AndroidAppInfo& a, AndroidAppInfo& b) {
a.Swap(&b);
}
inline void Swap(AndroidAppInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AndroidAppInfo* New() const final {
return CreateMaybeMessage<AndroidAppInfo>(nullptr);
}

AndroidAppInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AndroidAppInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AndroidAppInfo& from);
void MergeFrom(const AndroidAppInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AndroidAppInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AndroidAppInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef AndroidAppInfo_AndroidAppStatus AndroidAppStatus;
static constexpr AndroidAppStatus STATUS_UNKNOWN =
AndroidAppInfo_AndroidAppStatus_STATUS_UNKNOWN;
static constexpr AndroidAppStatus STATUS_ENABLED =
AndroidAppInfo_AndroidAppStatus_STATUS_ENABLED;
static constexpr AndroidAppStatus STATUS_SUSPENDED =
AndroidAppInfo_AndroidAppStatus_STATUS_SUSPENDED;
static constexpr AndroidAppStatus STATUS_DISABLED =
AndroidAppInfo_AndroidAppStatus_STATUS_DISABLED;
static inline bool AndroidAppStatus_IsValid(int value) {
return AndroidAppInfo_AndroidAppStatus_IsValid(value);
}
static constexpr AndroidAppStatus AndroidAppStatus_MIN =
AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MIN;
static constexpr AndroidAppStatus AndroidAppStatus_MAX =
AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MAX;
static constexpr int AndroidAppStatus_ARRAYSIZE =
AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_ARRAYSIZE;
template<typename T>
static inline const std::string& AndroidAppStatus_Name(T enum_t_value) {
static_assert(::std::is_same<T, AndroidAppStatus>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AndroidAppStatus_Name.");
return AndroidAppInfo_AndroidAppStatus_Name(enum_t_value);
}
static inline bool AndroidAppStatus_Parse(const std::string& name,
AndroidAppStatus* value) {
return AndroidAppInfo_AndroidAppStatus_Parse(name, value);
}

typedef AndroidAppInfo_InstalledSource InstalledSource;
static constexpr InstalledSource SOURCE_UNKNOWN =
AndroidAppInfo_InstalledSource_SOURCE_UNKNOWN;
static constexpr InstalledSource SOURCE_BY_ADMIN =
AndroidAppInfo_InstalledSource_SOURCE_BY_ADMIN;
static constexpr InstalledSource SOURCE_BY_USER =
AndroidAppInfo_InstalledSource_SOURCE_BY_USER;
static constexpr InstalledSource SOURCE_NOT_INSTALLED =
AndroidAppInfo_InstalledSource_SOURCE_NOT_INSTALLED;
static inline bool InstalledSource_IsValid(int value) {
return AndroidAppInfo_InstalledSource_IsValid(value);
}
static constexpr InstalledSource InstalledSource_MIN =
AndroidAppInfo_InstalledSource_InstalledSource_MIN;
static constexpr InstalledSource InstalledSource_MAX =
AndroidAppInfo_InstalledSource_InstalledSource_MAX;
static constexpr int InstalledSource_ARRAYSIZE =
AndroidAppInfo_InstalledSource_InstalledSource_ARRAYSIZE;
template<typename T>
static inline const std::string& InstalledSource_Name(T enum_t_value) {
static_assert(::std::is_same<T, InstalledSource>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function InstalledSource_Name.");
return AndroidAppInfo_InstalledSource_Name(enum_t_value);
}
static inline bool InstalledSource_Parse(const std::string& name,
InstalledSource* value) {
return AndroidAppInfo_InstalledSource_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPermissionsFieldNumber = 7,
kAppIdFieldNumber = 1,
kAppNameFieldNumber = 2,
kPackageNameFieldNumber = 3,
kStatusFieldNumber = 4,
kInstalledSourceFieldNumber = 5,
kVersionFieldNumber = 6,
};
// repeated .enterprise_management.AndroidAppPermission permissions = 7;
int permissions_size() const;
void clear_permissions();
::enterprise_management::AndroidAppPermission* mutable_permissions(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >*
mutable_permissions();
const ::enterprise_management::AndroidAppPermission& permissions(int index) const;
::enterprise_management::AndroidAppPermission* add_permissions();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >&
permissions() const;

// optional string app_id = 1;
bool has_app_id() const;
void clear_app_id();
const std::string& app_id() const;
void set_app_id(const std::string& value);
void set_app_id(std::string&& value);
void set_app_id(const char* value);
void set_app_id(const char* value, size_t size);
std::string* mutable_app_id();
std::string* release_app_id();
void set_allocated_app_id(std::string* app_id);

// optional string app_name = 2;
bool has_app_name() const;
void clear_app_name();
const std::string& app_name() const;
void set_app_name(const std::string& value);
void set_app_name(std::string&& value);
void set_app_name(const char* value);
void set_app_name(const char* value, size_t size);
std::string* mutable_app_name();
std::string* release_app_name();
void set_allocated_app_name(std::string* app_name);

// optional string package_name = 3;
bool has_package_name() const;
void clear_package_name();
const std::string& package_name() const;
void set_package_name(const std::string& value);
void set_package_name(std::string&& value);
void set_package_name(const char* value);
void set_package_name(const char* value, size_t size);
std::string* mutable_package_name();
std::string* release_package_name();
void set_allocated_package_name(std::string* package_name);

// optional .enterprise_management.AndroidAppInfo.AndroidAppStatus status = 4;
bool has_status() const;
void clear_status();
::enterprise_management::AndroidAppInfo_AndroidAppStatus status() const;
void set_status(::enterprise_management::AndroidAppInfo_AndroidAppStatus value);

// optional .enterprise_management.AndroidAppInfo.InstalledSource installed_source = 5;
bool has_installed_source() const;
void clear_installed_source();
::enterprise_management::AndroidAppInfo_InstalledSource installed_source() const;
void set_installed_source(::enterprise_management::AndroidAppInfo_InstalledSource value);

// optional int32 version = 6;
bool has_version() const;
void clear_version();
::PROTOBUF_NAMESPACE_ID::int32 version() const;
void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.AndroidAppInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission > permissions_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
int status_;
int installed_source_;
::PROTOBUF_NAMESPACE_ID::int32 version_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChromeUserProfileReport :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeUserProfileReport) */ {
public:
ChromeUserProfileReport();
virtual ~ChromeUserProfileReport();

ChromeUserProfileReport(const ChromeUserProfileReport& from);
ChromeUserProfileReport(ChromeUserProfileReport&& from) noexcept
: ChromeUserProfileReport() {
*this = ::std::move(from);
}

inline ChromeUserProfileReport& operator=(const ChromeUserProfileReport& from) {
CopyFrom(from);
return *this;
}
inline ChromeUserProfileReport& operator=(ChromeUserProfileReport&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChromeUserProfileReport& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChromeUserProfileReport* internal_default_instance() {
return reinterpret_cast<const ChromeUserProfileReport*>(
&_ChromeUserProfileReport_default_instance_);
}
static constexpr int kIndexInFileMessages =
61;

friend void swap(ChromeUserProfileReport& a, ChromeUserProfileReport& b) {
a.Swap(&b);
}
inline void Swap(ChromeUserProfileReport* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChromeUserProfileReport* New() const final {
return CreateMaybeMessage<ChromeUserProfileReport>(nullptr);
}

ChromeUserProfileReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChromeUserProfileReport>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChromeUserProfileReport& from);
void MergeFrom(const ChromeUserProfileReport& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChromeUserProfileReport* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChromeUserProfileReport";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kExtensionRequestsFieldNumber = 10,
kIdFieldNumber = 1,
kChromeSignedInUserFieldNumber = 2,
kExtensionDataFieldNumber = 3,
kPluginsFieldNumber = 4,
kPolicyDataFieldNumber = 5,
kNameFieldNumber = 9,
kPolicyFetchedTimestampFieldNumber = 6,
kSafeBrowsingWarningsFieldNumber = 7,
kSafeBrowsingWarningsClickThroughFieldNumber = 8,
};
// repeated .enterprise_management.ExtensionRequest extension_requests = 10;
int extension_requests_size() const;
void clear_extension_requests();
::enterprise_management::ExtensionRequest* mutable_extension_requests(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
mutable_extension_requests();
const ::enterprise_management::ExtensionRequest& extension_requests(int index) const;
::enterprise_management::ExtensionRequest* add_extension_requests();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
extension_requests() const;

// optional string id = 1;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// optional string chrome_signed_in_user = 2;
bool has_chrome_signed_in_user() const;
void clear_chrome_signed_in_user();
const std::string& chrome_signed_in_user() const;
void set_chrome_signed_in_user(const std::string& value);
void set_chrome_signed_in_user(std::string&& value);
void set_chrome_signed_in_user(const char* value);
void set_chrome_signed_in_user(const char* value, size_t size);
std::string* mutable_chrome_signed_in_user();
std::string* release_chrome_signed_in_user();
void set_allocated_chrome_signed_in_user(std::string* chrome_signed_in_user);

// optional string extension_data = 3;
bool has_extension_data() const;
void clear_extension_data();
const std::string& extension_data() const;
void set_extension_data(const std::string& value);
void set_extension_data(std::string&& value);
void set_extension_data(const char* value);
void set_extension_data(const char* value, size_t size);
std::string* mutable_extension_data();
std::string* release_extension_data();
void set_allocated_extension_data(std::string* extension_data);

// optional string plugins = 4;
bool has_plugins() const;
void clear_plugins();
const std::string& plugins() const;
void set_plugins(const std::string& value);
void set_plugins(std::string&& value);
void set_plugins(const char* value);
void set_plugins(const char* value, size_t size);
std::string* mutable_plugins();
std::string* release_plugins();
void set_allocated_plugins(std::string* plugins);

// optional string policy_data = 5;
bool has_policy_data() const;
void clear_policy_data();
const std::string& policy_data() const;
void set_policy_data(const std::string& value);
void set_policy_data(std::string&& value);
void set_policy_data(const char* value);
void set_policy_data(const char* value, size_t size);
std::string* mutable_policy_data();
std::string* release_policy_data();
void set_allocated_policy_data(std::string* policy_data);

// optional string name = 9;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional int64 policy_fetched_timestamp = 6;
bool has_policy_fetched_timestamp() const;
void clear_policy_fetched_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 policy_fetched_timestamp() const;
void set_policy_fetched_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional uint64 safe_browsing_warnings = 7;
bool has_safe_browsing_warnings() const;
void clear_safe_browsing_warnings();
::PROTOBUF_NAMESPACE_ID::uint64 safe_browsing_warnings() const;
void set_safe_browsing_warnings(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 safe_browsing_warnings_click_through = 8;
bool has_safe_browsing_warnings_click_through() const;
void clear_safe_browsing_warnings_click_through();
::PROTOBUF_NAMESPACE_ID::uint64 safe_browsing_warnings_click_through() const;
void set_safe_browsing_warnings_click_through(::PROTOBUF_NAMESPACE_ID::uint64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.ChromeUserProfileReport)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest > extension_requests_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_signed_in_user_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_data_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugins_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_data_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::int64 policy_fetched_timestamp_;
::PROTOBUF_NAMESPACE_ID::uint64 safe_browsing_warnings_;
::PROTOBUF_NAMESPACE_ID::uint64 safe_browsing_warnings_click_through_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChromeSignedInUser :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeSignedInUser) */ {
public:
ChromeSignedInUser();
virtual ~ChromeSignedInUser();

ChromeSignedInUser(const ChromeSignedInUser& from);
ChromeSignedInUser(ChromeSignedInUser&& from) noexcept
: ChromeSignedInUser() {
*this = ::std::move(from);
}

inline ChromeSignedInUser& operator=(const ChromeSignedInUser& from) {
CopyFrom(from);
return *this;
}
inline ChromeSignedInUser& operator=(ChromeSignedInUser&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChromeSignedInUser& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChromeSignedInUser* internal_default_instance() {
return reinterpret_cast<const ChromeSignedInUser*>(
&_ChromeSignedInUser_default_instance_);
}
static constexpr int kIndexInFileMessages =
62;

friend void swap(ChromeSignedInUser& a, ChromeSignedInUser& b) {
a.Swap(&b);
}
inline void Swap(ChromeSignedInUser* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChromeSignedInUser* New() const final {
return CreateMaybeMessage<ChromeSignedInUser>(nullptr);
}

ChromeSignedInUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChromeSignedInUser>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChromeSignedInUser& from);
void MergeFrom(const ChromeSignedInUser& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChromeSignedInUser* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChromeSignedInUser";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kEmailFieldNumber = 1,
kObfudscatedGaiaIdFieldNumber = 2,
};
// optional string email = 1;
bool has_email() const;
void clear_email();
const std::string& email() const;
void set_email(const std::string& value);
void set_email(std::string&& value);
void set_email(const char* value);
void set_email(const char* value, size_t size);
std::string* mutable_email();
std::string* release_email();
void set_allocated_email(std::string* email);

// optional string obfudscated_gaia_id = 2;
bool has_obfudscated_gaia_id() const;
void clear_obfudscated_gaia_id();
const std::string& obfudscated_gaia_id() const;
void set_obfudscated_gaia_id(const std::string& value);
void set_obfudscated_gaia_id(std::string&& value);
void set_obfudscated_gaia_id(const char* value);
void set_obfudscated_gaia_id(const char* value, size_t size);
std::string* mutable_obfudscated_gaia_id();
std::string* release_obfudscated_gaia_id();
void set_allocated_obfudscated_gaia_id(std::string* obfudscated_gaia_id);

// @@protoc_insertion_point(class_scope:enterprise_management.ChromeSignedInUser)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obfudscated_gaia_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ExtensionRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionRequest) */ {
public:
ExtensionRequest();
virtual ~ExtensionRequest();

ExtensionRequest(const ExtensionRequest& from);
ExtensionRequest(ExtensionRequest&& from) noexcept
: ExtensionRequest() {
*this = ::std::move(from);
}

inline ExtensionRequest& operator=(const ExtensionRequest& from) {
CopyFrom(from);
return *this;
}
inline ExtensionRequest& operator=(ExtensionRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ExtensionRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ExtensionRequest* internal_default_instance() {
return reinterpret_cast<const ExtensionRequest*>(
&_ExtensionRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
63;

friend void swap(ExtensionRequest& a, ExtensionRequest& b) {
a.Swap(&b);
}
inline void Swap(ExtensionRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ExtensionRequest* New() const final {
return CreateMaybeMessage<ExtensionRequest>(nullptr);
}

ExtensionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ExtensionRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ExtensionRequest& from);
void MergeFrom(const ExtensionRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ExtensionRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ExtensionRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kIdFieldNumber = 1,
kRequestTimestampFieldNumber = 2,
};
// optional string id = 1;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// optional int64 request_timestamp = 2;
bool has_request_timestamp() const;
void clear_request_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 request_timestamp() const;
void set_request_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.ExtensionRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::int64 request_timestamp_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT Extension :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.Extension) */ {
public:
Extension();
virtual ~Extension();

Extension(const Extension& from);
Extension(Extension&& from) noexcept
: Extension() {
*this = ::std::move(from);
}

inline Extension& operator=(const Extension& from) {
CopyFrom(from);
return *this;
}
inline Extension& operator=(Extension&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Extension& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Extension* internal_default_instance() {
return reinterpret_cast<const Extension*>(
&_Extension_default_instance_);
}
static constexpr int kIndexInFileMessages =
64;

friend void swap(Extension& a, Extension& b) {
a.Swap(&b);
}
inline void Swap(Extension* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Extension* New() const final {
return CreateMaybeMessage<Extension>(nullptr);
}

Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Extension>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Extension& from);
void MergeFrom(const Extension& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Extension* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.Extension";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef Extension_ExtensionType ExtensionType;
static constexpr ExtensionType TYPE_UNKNOWN =
Extension_ExtensionType_TYPE_UNKNOWN;
static constexpr ExtensionType TYPE_EXTENSION =
Extension_ExtensionType_TYPE_EXTENSION;
static constexpr ExtensionType TYPE_HOSTED_APP =
Extension_ExtensionType_TYPE_HOSTED_APP;
static constexpr ExtensionType TYPE_PACKAGED_APP =
Extension_ExtensionType_TYPE_PACKAGED_APP;
static constexpr ExtensionType TYPE_LEGACY_PACKAGED_APP =
Extension_ExtensionType_TYPE_LEGACY_PACKAGED_APP;
static constexpr ExtensionType TYPE_THEME =
Extension_ExtensionType_TYPE_THEME;
static constexpr ExtensionType TYPE_USER_SCRIPT =
Extension_ExtensionType_TYPE_USER_SCRIPT;
static constexpr ExtensionType TYPE_PLATFORM_APP =
Extension_ExtensionType_TYPE_PLATFORM_APP;
static constexpr ExtensionType TYPE_LOGIN_SCREEN_EXTENSION =
Extension_ExtensionType_TYPE_LOGIN_SCREEN_EXTENSION;
static inline bool ExtensionType_IsValid(int value) {
return Extension_ExtensionType_IsValid(value);
}
static constexpr ExtensionType ExtensionType_MIN =
Extension_ExtensionType_ExtensionType_MIN;
static constexpr ExtensionType ExtensionType_MAX =
Extension_ExtensionType_ExtensionType_MAX;
static constexpr int ExtensionType_ARRAYSIZE =
Extension_ExtensionType_ExtensionType_ARRAYSIZE;
template<typename T>
static inline const std::string& ExtensionType_Name(T enum_t_value) {
static_assert(::std::is_same<T, ExtensionType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ExtensionType_Name.");
return Extension_ExtensionType_Name(enum_t_value);
}
static inline bool ExtensionType_Parse(const std::string& name,
ExtensionType* value) {
return Extension_ExtensionType_Parse(name, value);
}

typedef Extension_InstallType InstallType;
static constexpr InstallType TYPE_NORMAL =
Extension_InstallType_TYPE_NORMAL;
static constexpr InstallType TYPE_DEVELOPMENT =
Extension_InstallType_TYPE_DEVELOPMENT;
static constexpr InstallType TYPE_SIDELOAD =
Extension_InstallType_TYPE_SIDELOAD;
static constexpr InstallType TYPE_ADMIN =
Extension_InstallType_TYPE_ADMIN;
static constexpr InstallType TYPE_OTHER =
Extension_InstallType_TYPE_OTHER;
static inline bool InstallType_IsValid(int value) {
return Extension_InstallType_IsValid(value);
}
static constexpr InstallType InstallType_MIN =
Extension_InstallType_InstallType_MIN;
static constexpr InstallType InstallType_MAX =
Extension_InstallType_InstallType_MAX;
static constexpr int InstallType_ARRAYSIZE =
Extension_InstallType_InstallType_ARRAYSIZE;
template<typename T>
static inline const std::string& InstallType_Name(T enum_t_value) {
static_assert(::std::is_same<T, InstallType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function InstallType_Name.");
return Extension_InstallType_Name(enum_t_value);
}
static inline bool InstallType_Parse(const std::string& name,
InstallType* value) {
return Extension_InstallType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPermissionsFieldNumber = 10,
kHostPermissionsFieldNumber = 11,
kIdFieldNumber = 1,
kVersionFieldNumber = 2,
kNameFieldNumber = 3,
kDescriptionFieldNumber = 4,
kHomepageUrlFieldNumber = 6,
kAppTypeFieldNumber = 5,
kInstallTypeFieldNumber = 8,
kEnabledFieldNumber = 9,
kFromWebstoreFieldNumber = 13,
};
// repeated string permissions = 10;
int permissions_size() const;
void clear_permissions();
const std::string& permissions(int index) const;
std::string* mutable_permissions(int index);
void set_permissions(int index, const std::string& value);
void set_permissions(int index, std::string&& value);
void set_permissions(int index, const char* value);
void set_permissions(int index, const char* value, size_t size);
std::string* add_permissions();
void add_permissions(const std::string& value);
void add_permissions(std::string&& value);
void add_permissions(const char* value);
void add_permissions(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& permissions() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_permissions();

// repeated string host_permissions = 11;
int host_permissions_size() const;
void clear_host_permissions();
const std::string& host_permissions(int index) const;
std::string* mutable_host_permissions(int index);
void set_host_permissions(int index, const std::string& value);
void set_host_permissions(int index, std::string&& value);
void set_host_permissions(int index, const char* value);
void set_host_permissions(int index, const char* value, size_t size);
std::string* add_host_permissions();
void add_host_permissions(const std::string& value);
void add_host_permissions(std::string&& value);
void add_host_permissions(const char* value);
void add_host_permissions(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& host_permissions() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_host_permissions();

// optional string id = 1;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// optional string version = 2;
bool has_version() const;
void clear_version();
const std::string& version() const;
void set_version(const std::string& value);
void set_version(std::string&& value);
void set_version(const char* value);
void set_version(const char* value, size_t size);
std::string* mutable_version();
std::string* release_version();
void set_allocated_version(std::string* version);

// optional string name = 3;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional string description = 4;
bool has_description() const;
void clear_description();
const std::string& description() const;
void set_description(const std::string& value);
void set_description(std::string&& value);
void set_description(const char* value);
void set_description(const char* value, size_t size);
std::string* mutable_description();
std::string* release_description();
void set_allocated_description(std::string* description);

// optional string homepage_url = 6;
bool has_homepage_url() const;
void clear_homepage_url();
const std::string& homepage_url() const;
void set_homepage_url(const std::string& value);
void set_homepage_url(std::string&& value);
void set_homepage_url(const char* value);
void set_homepage_url(const char* value, size_t size);
std::string* mutable_homepage_url();
std::string* release_homepage_url();
void set_allocated_homepage_url(std::string* homepage_url);

// optional .enterprise_management.Extension.ExtensionType app_type = 5;
bool has_app_type() const;
void clear_app_type();
::enterprise_management::Extension_ExtensionType app_type() const;
void set_app_type(::enterprise_management::Extension_ExtensionType value);

// optional .enterprise_management.Extension.InstallType install_type = 8;
bool has_install_type() const;
void clear_install_type();
::enterprise_management::Extension_InstallType install_type() const;
void set_install_type(::enterprise_management::Extension_InstallType value);

// optional bool enabled = 9;
bool has_enabled() const;
void clear_enabled();
bool enabled() const;
void set_enabled(bool value);

// optional bool from_webstore = 13;
bool has_from_webstore() const;
void clear_from_webstore();
bool from_webstore() const;
void set_from_webstore(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.Extension)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> permissions_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> host_permissions_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homepage_url_;
int app_type_;
int install_type_;
bool enabled_;
bool from_webstore_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT Plugin :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.Plugin) */ {
public:
Plugin();
virtual ~Plugin();

Plugin(const Plugin& from);
Plugin(Plugin&& from) noexcept
: Plugin() {
*this = ::std::move(from);
}

inline Plugin& operator=(const Plugin& from) {
CopyFrom(from);
return *this;
}
inline Plugin& operator=(Plugin&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Plugin& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Plugin* internal_default_instance() {
return reinterpret_cast<const Plugin*>(
&_Plugin_default_instance_);
}
static constexpr int kIndexInFileMessages =
65;

friend void swap(Plugin& a, Plugin& b) {
a.Swap(&b);
}
inline void Swap(Plugin* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Plugin* New() const final {
return CreateMaybeMessage<Plugin>(nullptr);
}

Plugin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Plugin>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Plugin& from);
void MergeFrom(const Plugin& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Plugin* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.Plugin";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kVersionFieldNumber = 2,
kFilenameFieldNumber = 3,
kDescriptionFieldNumber = 4,
};
// optional string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional string version = 2;
bool has_version() const;
void clear_version();
const std::string& version() const;
void set_version(const std::string& value);
void set_version(std::string&& value);
void set_version(const char* value);
void set_version(const char* value, size_t size);
std::string* mutable_version();
std::string* release_version();
void set_allocated_version(std::string* version);

// optional string filename = 3;
bool has_filename() const;
void clear_filename();
const std::string& filename() const;
void set_filename(const std::string& value);
void set_filename(std::string&& value);
void set_filename(const char* value);
void set_filename(const char* value, size_t size);
std::string* mutable_filename();
std::string* release_filename();
void set_allocated_filename(std::string* filename);

// optional string description = 4;
bool has_description() const;
void clear_description();
const std::string& description() const;
void set_description(const std::string& value);
void set_description(std::string&& value);
void set_description(const char* value);
void set_description(const char* value, size_t size);
std::string* mutable_description();
std::string* release_description();
void set_allocated_description(std::string* description);

// @@protoc_insertion_point(class_scope:enterprise_management.Plugin)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT Policy :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.Policy) */ {
public:
Policy();
virtual ~Policy();

Policy(const Policy& from);
Policy(Policy&& from) noexcept
: Policy() {
*this = ::std::move(from);
}

inline Policy& operator=(const Policy& from) {
CopyFrom(from);
return *this;
}
inline Policy& operator=(Policy&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Policy& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Policy* internal_default_instance() {
return reinterpret_cast<const Policy*>(
&_Policy_default_instance_);
}
static constexpr int kIndexInFileMessages =
66;

friend void swap(Policy& a, Policy& b) {
a.Swap(&b);
}
inline void Swap(Policy* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Policy* New() const final {
return CreateMaybeMessage<Policy>(nullptr);
}

Policy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Policy>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Policy& from);
void MergeFrom(const Policy& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Policy* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.Policy";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef Policy_PolicyLevel PolicyLevel;
static constexpr PolicyLevel LEVEL_UNKNOWN =
Policy_PolicyLevel_LEVEL_UNKNOWN;
static constexpr PolicyLevel LEVEL_RECOMMENDED =
Policy_PolicyLevel_LEVEL_RECOMMENDED;
static constexpr PolicyLevel LEVEL_MANDATORY =
Policy_PolicyLevel_LEVEL_MANDATORY;
static inline bool PolicyLevel_IsValid(int value) {
return Policy_PolicyLevel_IsValid(value);
}
static constexpr PolicyLevel PolicyLevel_MIN =
Policy_PolicyLevel_PolicyLevel_MIN;
static constexpr PolicyLevel PolicyLevel_MAX =
Policy_PolicyLevel_PolicyLevel_MAX;
static constexpr int PolicyLevel_ARRAYSIZE =
Policy_PolicyLevel_PolicyLevel_ARRAYSIZE;
template<typename T>
static inline const std::string& PolicyLevel_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyLevel>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyLevel_Name.");
return Policy_PolicyLevel_Name(enum_t_value);
}
static inline bool PolicyLevel_Parse(const std::string& name,
PolicyLevel* value) {
return Policy_PolicyLevel_Parse(name, value);
}

typedef Policy_PolicyScope PolicyScope;
static constexpr PolicyScope SCOPE_UNKNOWN =
Policy_PolicyScope_SCOPE_UNKNOWN;
static constexpr PolicyScope SCOPE_USER =
Policy_PolicyScope_SCOPE_USER;
static constexpr PolicyScope SCOPE_MACHINE =
Policy_PolicyScope_SCOPE_MACHINE;
static inline bool PolicyScope_IsValid(int value) {
return Policy_PolicyScope_IsValid(value);
}
static constexpr PolicyScope PolicyScope_MIN =
Policy_PolicyScope_PolicyScope_MIN;
static constexpr PolicyScope PolicyScope_MAX =
Policy_PolicyScope_PolicyScope_MAX;
static constexpr int PolicyScope_ARRAYSIZE =
Policy_PolicyScope_PolicyScope_ARRAYSIZE;
template<typename T>
static inline const std::string& PolicyScope_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicyScope>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicyScope_Name.");
return Policy_PolicyScope_Name(enum_t_value);
}
static inline bool PolicyScope_Parse(const std::string& name,
PolicyScope* value) {
return Policy_PolicyScope_Parse(name, value);
}

typedef Policy_PolicySource PolicySource;
static constexpr PolicySource SOURCE_UNKNOWN =
Policy_PolicySource_SOURCE_UNKNOWN;
static constexpr PolicySource SOURCE_ENTERPRISE_DEFAULT =
Policy_PolicySource_SOURCE_ENTERPRISE_DEFAULT;
static constexpr PolicySource SOURCE_CLOUD =
Policy_PolicySource_SOURCE_CLOUD;
static constexpr PolicySource SOURCE_ACTIVE_DIRECTORY =
Policy_PolicySource_SOURCE_ACTIVE_DIRECTORY;
static constexpr PolicySource SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE =
Policy_PolicySource_SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE;
static constexpr PolicySource SOURCE_PLATFORM =
Policy_PolicySource_SOURCE_PLATFORM;
static constexpr PolicySource SOURCE_PRIORITY_CLOUD =
Policy_PolicySource_SOURCE_PRIORITY_CLOUD;
static constexpr PolicySource SOURCE_MERGED =
Policy_PolicySource_SOURCE_MERGED;
static inline bool PolicySource_IsValid(int value) {
return Policy_PolicySource_IsValid(value);
}
static constexpr PolicySource PolicySource_MIN =
Policy_PolicySource_PolicySource_MIN;
static constexpr PolicySource PolicySource_MAX =
Policy_PolicySource_PolicySource_MAX;
static constexpr int PolicySource_ARRAYSIZE =
Policy_PolicySource_PolicySource_ARRAYSIZE;
template<typename T>
static inline const std::string& PolicySource_Name(T enum_t_value) {
static_assert(::std::is_same<T, PolicySource>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function PolicySource_Name.");
return Policy_PolicySource_Name(enum_t_value);
}
static inline bool PolicySource_Parse(const std::string& name,
PolicySource* value) {
return Policy_PolicySource_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kValueFieldNumber = 5,
kErrorFieldNumber = 6,
kLevelFieldNumber = 2,
kScopeFieldNumber = 3,
kSourceFieldNumber = 4,
};
// optional string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional string value = 5;
bool has_value() const;
void clear_value();
const std::string& value() const;
void set_value(const std::string& value);
void set_value(std::string&& value);
void set_value(const char* value);
void set_value(const char* value, size_t size);
std::string* mutable_value();
std::string* release_value();
void set_allocated_value(std::string* value);

// optional string error = 6;
bool has_error() const;
void clear_error();
const std::string& error() const;
void set_error(const std::string& value);
void set_error(std::string&& value);
void set_error(const char* value);
void set_error(const char* value, size_t size);
std::string* mutable_error();
std::string* release_error();
void set_allocated_error(std::string* error);

// optional .enterprise_management.Policy.PolicyLevel level = 2;
bool has_level() const;
void clear_level();
::enterprise_management::Policy_PolicyLevel level() const;
void set_level(::enterprise_management::Policy_PolicyLevel value);

// optional .enterprise_management.Policy.PolicyScope scope = 3;
bool has_scope() const;
void clear_scope();
::enterprise_management::Policy_PolicyScope scope() const;
void set_scope(::enterprise_management::Policy_PolicyScope value);

// optional .enterprise_management.Policy.PolicySource source = 4;
bool has_source() const;
void clear_source();
::enterprise_management::Policy_PolicySource source() const;
void set_source(::enterprise_management::Policy_PolicySource value);

// @@protoc_insertion_point(class_scope:enterprise_management.Policy)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
int level_;
int scope_;
int source_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ExtensionPolicy :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionPolicy) */ {
public:
ExtensionPolicy();
virtual ~ExtensionPolicy();

ExtensionPolicy(const ExtensionPolicy& from);
ExtensionPolicy(ExtensionPolicy&& from) noexcept
: ExtensionPolicy() {
*this = ::std::move(from);
}

inline ExtensionPolicy& operator=(const ExtensionPolicy& from) {
CopyFrom(from);
return *this;
}
inline ExtensionPolicy& operator=(ExtensionPolicy&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ExtensionPolicy& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ExtensionPolicy* internal_default_instance() {
return reinterpret_cast<const ExtensionPolicy*>(
&_ExtensionPolicy_default_instance_);
}
static constexpr int kIndexInFileMessages =
67;

friend void swap(ExtensionPolicy& a, ExtensionPolicy& b) {
a.Swap(&b);
}
inline void Swap(ExtensionPolicy* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ExtensionPolicy* New() const final {
return CreateMaybeMessage<ExtensionPolicy>(nullptr);
}

ExtensionPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ExtensionPolicy>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ExtensionPolicy& from);
void MergeFrom(const ExtensionPolicy& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ExtensionPolicy* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ExtensionPolicy";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kPoliciesFieldNumber = 2,
kExtensionIdFieldNumber = 1,
};
// repeated .enterprise_management.Policy policies = 2;
int policies_size() const;
void clear_policies();
::enterprise_management::Policy* mutable_policies(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
mutable_policies();
const ::enterprise_management::Policy& policies(int index) const;
::enterprise_management::Policy* add_policies();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
policies() const;

// optional string extension_id = 1;
bool has_extension_id() const;
void clear_extension_id();
const std::string& extension_id() const;
void set_extension_id(const std::string& value);
void set_extension_id(std::string&& value);
void set_extension_id(const char* value);
void set_extension_id(const char* value, size_t size);
std::string* mutable_extension_id();
std::string* release_extension_id();
void set_allocated_extension_id(std::string* extension_id);

// @@protoc_insertion_point(class_scope:enterprise_management.ExtensionPolicy)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy > policies_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyFetchTimestamp :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyFetchTimestamp) */ {
public:
PolicyFetchTimestamp();
virtual ~PolicyFetchTimestamp();

PolicyFetchTimestamp(const PolicyFetchTimestamp& from);
PolicyFetchTimestamp(PolicyFetchTimestamp&& from) noexcept
: PolicyFetchTimestamp() {
*this = ::std::move(from);
}

inline PolicyFetchTimestamp& operator=(const PolicyFetchTimestamp& from) {
CopyFrom(from);
return *this;
}
inline PolicyFetchTimestamp& operator=(PolicyFetchTimestamp&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PolicyFetchTimestamp& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PolicyFetchTimestamp* internal_default_instance() {
return reinterpret_cast<const PolicyFetchTimestamp*>(
&_PolicyFetchTimestamp_default_instance_);
}
static constexpr int kIndexInFileMessages =
68;

friend void swap(PolicyFetchTimestamp& a, PolicyFetchTimestamp& b) {
a.Swap(&b);
}
inline void Swap(PolicyFetchTimestamp* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PolicyFetchTimestamp* New() const final {
return CreateMaybeMessage<PolicyFetchTimestamp>(nullptr);
}

PolicyFetchTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PolicyFetchTimestamp>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PolicyFetchTimestamp& from);
void MergeFrom(const PolicyFetchTimestamp& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PolicyFetchTimestamp* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PolicyFetchTimestamp";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kTypeFieldNumber = 1,
kTimestampFieldNumber = 2,
};
// optional string type = 1;
bool has_type() const;
void clear_type();
const std::string& type() const;
void set_type(const std::string& value);
void set_type(std::string&& value);
void set_type(const char* value);
void set_type(const char* value, size_t size);
std::string* mutable_type();
std::string* release_type();
void set_allocated_type(std::string* type);

// optional int64 timestamp = 2;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchTimestamp)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChromeUserProfileInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeUserProfileInfo) */ {
public:
ChromeUserProfileInfo();
virtual ~ChromeUserProfileInfo();

ChromeUserProfileInfo(const ChromeUserProfileInfo& from);
ChromeUserProfileInfo(ChromeUserProfileInfo&& from) noexcept
: ChromeUserProfileInfo() {
*this = ::std::move(from);
}

inline ChromeUserProfileInfo& operator=(const ChromeUserProfileInfo& from) {
CopyFrom(from);
return *this;
}
inline ChromeUserProfileInfo& operator=(ChromeUserProfileInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChromeUserProfileInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChromeUserProfileInfo* internal_default_instance() {
return reinterpret_cast<const ChromeUserProfileInfo*>(
&_ChromeUserProfileInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
69;

friend void swap(ChromeUserProfileInfo& a, ChromeUserProfileInfo& b) {
a.Swap(&b);
}
inline void Swap(ChromeUserProfileInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChromeUserProfileInfo* New() const final {
return CreateMaybeMessage<ChromeUserProfileInfo>(nullptr);
}

ChromeUserProfileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChromeUserProfileInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChromeUserProfileInfo& from);
void MergeFrom(const ChromeUserProfileInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChromeUserProfileInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChromeUserProfileInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kExtensionsFieldNumber = 5,
kChromePoliciesFieldNumber = 7,
kExtensionPoliciesFieldNumber = 8,
kPolicyFetchedTimestampsFieldNumber = 9,
kExtensionRequestsFieldNumber = 10,
kIdFieldNumber = 1,
kNameFieldNumber = 2,
kChromeSignedInUserFieldNumber = 4,
kIsFullReportFieldNumber = 3,
};
// repeated .enterprise_management.Extension extensions = 5;
int extensions_size() const;
void clear_extensions();
::enterprise_management::Extension* mutable_extensions(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >*
mutable_extensions();
const ::enterprise_management::Extension& extensions(int index) const;
::enterprise_management::Extension* add_extensions();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >&
extensions() const;

// repeated .enterprise_management.Policy chrome_policies = 7;
int chrome_policies_size() const;
void clear_chrome_policies();
::enterprise_management::Policy* mutable_chrome_policies(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
mutable_chrome_policies();
const ::enterprise_management::Policy& chrome_policies(int index) const;
::enterprise_management::Policy* add_chrome_policies();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
chrome_policies() const;

// repeated .enterprise_management.ExtensionPolicy extension_policies = 8;
int extension_policies_size() const;
void clear_extension_policies();
::enterprise_management::ExtensionPolicy* mutable_extension_policies(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >*
mutable_extension_policies();
const ::enterprise_management::ExtensionPolicy& extension_policies(int index) const;
::enterprise_management::ExtensionPolicy* add_extension_policies();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >&
extension_policies() const;

// repeated .enterprise_management.PolicyFetchTimestamp policy_fetched_timestamps = 9;
int policy_fetched_timestamps_size() const;
void clear_policy_fetched_timestamps();
::enterprise_management::PolicyFetchTimestamp* mutable_policy_fetched_timestamps(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >*
mutable_policy_fetched_timestamps();
const ::enterprise_management::PolicyFetchTimestamp& policy_fetched_timestamps(int index) const;
::enterprise_management::PolicyFetchTimestamp* add_policy_fetched_timestamps();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >&
policy_fetched_timestamps() const;

// repeated .enterprise_management.ExtensionRequest extension_requests = 10;
int extension_requests_size() const;
void clear_extension_requests();
::enterprise_management::ExtensionRequest* mutable_extension_requests(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
mutable_extension_requests();
const ::enterprise_management::ExtensionRequest& extension_requests(int index) const;
::enterprise_management::ExtensionRequest* add_extension_requests();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
extension_requests() const;

// optional string id = 1;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// optional string name = 2;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional .enterprise_management.ChromeSignedInUser chrome_signed_in_user = 4;
bool has_chrome_signed_in_user() const;
void clear_chrome_signed_in_user();
const ::enterprise_management::ChromeSignedInUser& chrome_signed_in_user() const;
::enterprise_management::ChromeSignedInUser* release_chrome_signed_in_user();
::enterprise_management::ChromeSignedInUser* mutable_chrome_signed_in_user();
void set_allocated_chrome_signed_in_user(::enterprise_management::ChromeSignedInUser* chrome_signed_in_user);

// optional bool is_full_report = 3;
bool has_is_full_report() const;
void clear_is_full_report();
bool is_full_report() const;
void set_is_full_report(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.ChromeUserProfileInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension > extensions_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy > chrome_policies_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy > extension_policies_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp > policy_fetched_timestamps_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest > extension_requests_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::enterprise_management::ChromeSignedInUser* chrome_signed_in_user_;
bool is_full_report_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT BrowserReport :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BrowserReport) */ {
public:
BrowserReport();
virtual ~BrowserReport();

BrowserReport(const BrowserReport& from);
BrowserReport(BrowserReport&& from) noexcept
: BrowserReport() {
*this = ::std::move(from);
}

inline BrowserReport& operator=(const BrowserReport& from) {
CopyFrom(from);
return *this;
}
inline BrowserReport& operator=(BrowserReport&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const BrowserReport& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const BrowserReport* internal_default_instance() {
return reinterpret_cast<const BrowserReport*>(
&_BrowserReport_default_instance_);
}
static constexpr int kIndexInFileMessages =
70;

friend void swap(BrowserReport& a, BrowserReport& b) {
a.Swap(&b);
}
inline void Swap(BrowserReport* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline BrowserReport* New() const final {
return CreateMaybeMessage<BrowserReport>(nullptr);
}

BrowserReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<BrowserReport>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const BrowserReport& from);
void MergeFrom(const BrowserReport& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BrowserReport* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.BrowserReport";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kChromeUserProfileReportsFieldNumber = 4,
kChromeUserProfileInfosFieldNumber = 6,
kPluginsFieldNumber = 7,
kBrowserVersionFieldNumber = 1,
kExecutablePathFieldNumber = 3,
kInstalledBrowserVersionFieldNumber = 8,
kChannelFieldNumber = 2,
};
// repeated .enterprise_management.ChromeUserProfileReport chrome_user_profile_reports = 4;
int chrome_user_profile_reports_size() const;
void clear_chrome_user_profile_reports();
::enterprise_management::ChromeUserProfileReport* mutable_chrome_user_profile_reports(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >*
mutable_chrome_user_profile_reports();
const ::enterprise_management::ChromeUserProfileReport& chrome_user_profile_reports(int index) const;
::enterprise_management::ChromeUserProfileReport* add_chrome_user_profile_reports();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >&
chrome_user_profile_reports() const;

// repeated .enterprise_management.ChromeUserProfileInfo chrome_user_profile_infos = 6;
int chrome_user_profile_infos_size() const;
void clear_chrome_user_profile_infos();
::enterprise_management::ChromeUserProfileInfo* mutable_chrome_user_profile_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >*
mutable_chrome_user_profile_infos();
const ::enterprise_management::ChromeUserProfileInfo& chrome_user_profile_infos(int index) const;
::enterprise_management::ChromeUserProfileInfo* add_chrome_user_profile_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >&
chrome_user_profile_infos() const;

// repeated .enterprise_management.Plugin plugins = 7;
int plugins_size() const;
void clear_plugins();
::enterprise_management::Plugin* mutable_plugins(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >*
mutable_plugins();
const ::enterprise_management::Plugin& plugins(int index) const;
::enterprise_management::Plugin* add_plugins();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >&
plugins() const;

// optional string browser_version = 1;
bool has_browser_version() const;
void clear_browser_version();
const std::string& browser_version() const;
void set_browser_version(const std::string& value);
void set_browser_version(std::string&& value);
void set_browser_version(const char* value);
void set_browser_version(const char* value, size_t size);
std::string* mutable_browser_version();
std::string* release_browser_version();
void set_allocated_browser_version(std::string* browser_version);

// optional string executable_path = 3;
bool has_executable_path() const;
void clear_executable_path();
const std::string& executable_path() const;
void set_executable_path(const std::string& value);
void set_executable_path(std::string&& value);
void set_executable_path(const char* value);
void set_executable_path(const char* value, size_t size);
std::string* mutable_executable_path();
std::string* release_executable_path();
void set_allocated_executable_path(std::string* executable_path);

// optional string installed_browser_version = 8;
bool has_installed_browser_version() const;
void clear_installed_browser_version();
const std::string& installed_browser_version() const;
void set_installed_browser_version(const std::string& value);
void set_installed_browser_version(std::string&& value);
void set_installed_browser_version(const char* value);
void set_installed_browser_version(const char* value, size_t size);
std::string* mutable_installed_browser_version();
std::string* release_installed_browser_version();
void set_allocated_installed_browser_version(std::string* installed_browser_version);

// optional .enterprise_management.Channel channel = 2;
bool has_channel() const;
void clear_channel();
::enterprise_management::Channel channel() const;
void set_channel(::enterprise_management::Channel value);

// @@protoc_insertion_point(class_scope:enterprise_management.BrowserReport)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport > chrome_user_profile_reports_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo > chrome_user_profile_infos_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin > plugins_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr executable_path_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installed_browser_version_;
int channel_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT OSReport :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OSReport) */ {
public:
OSReport();
virtual ~OSReport();

OSReport(const OSReport& from);
OSReport(OSReport&& from) noexcept
: OSReport() {
*this = ::std::move(from);
}

inline OSReport& operator=(const OSReport& from) {
CopyFrom(from);
return *this;
}
inline OSReport& operator=(OSReport&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const OSReport& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const OSReport* internal_default_instance() {
return reinterpret_cast<const OSReport*>(
&_OSReport_default_instance_);
}
static constexpr int kIndexInFileMessages =
71;

friend void swap(OSReport& a, OSReport& b) {
a.Swap(&b);
}
inline void Swap(OSReport* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline OSReport* New() const final {
return CreateMaybeMessage<OSReport>(nullptr);
}

OSReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<OSReport>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const OSReport& from);
void MergeFrom(const OSReport& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(OSReport* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.OSReport";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kArchFieldNumber = 2,
kVersionFieldNumber = 3,
};
// optional string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// optional string arch = 2;
bool has_arch() const;
void clear_arch();
const std::string& arch() const;
void set_arch(const std::string& value);
void set_arch(std::string&& value);
void set_arch(const char* value);
void set_arch(const char* value, size_t size);
std::string* mutable_arch();
std::string* release_arch();
void set_allocated_arch(std::string* arch);

// optional string version = 3;
bool has_version() const;
void clear_version();
const std::string& version() const;
void set_version(const std::string& value);
void set_version(std::string&& value);
void set_version(const char* value);
void set_version(const char* value, size_t size);
std::string* mutable_version();
std::string* release_version();
void set_allocated_version(std::string* version);

// @@protoc_insertion_point(class_scope:enterprise_management.OSReport)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arch_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChromeDesktopReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeDesktopReportRequest) */ {
public:
ChromeDesktopReportRequest();
virtual ~ChromeDesktopReportRequest();

ChromeDesktopReportRequest(const ChromeDesktopReportRequest& from);
ChromeDesktopReportRequest(ChromeDesktopReportRequest&& from) noexcept
: ChromeDesktopReportRequest() {
*this = ::std::move(from);
}

inline ChromeDesktopReportRequest& operator=(const ChromeDesktopReportRequest& from) {
CopyFrom(from);
return *this;
}
inline ChromeDesktopReportRequest& operator=(ChromeDesktopReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChromeDesktopReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChromeDesktopReportRequest* internal_default_instance() {
return reinterpret_cast<const ChromeDesktopReportRequest*>(
&_ChromeDesktopReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
72;

friend void swap(ChromeDesktopReportRequest& a, ChromeDesktopReportRequest& b) {
a.Swap(&b);
}
inline void Swap(ChromeDesktopReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChromeDesktopReportRequest* New() const final {
return CreateMaybeMessage<ChromeDesktopReportRequest>(nullptr);
}

ChromeDesktopReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChromeDesktopReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChromeDesktopReportRequest& from);
void MergeFrom(const ChromeDesktopReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChromeDesktopReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChromeDesktopReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kMachineNameFieldNumber = 1,
kOsInfoFieldNumber = 2,
kOsUserFieldNumber = 3,
kSerialNumberFieldNumber = 5,
kComputerNameFieldNumber = 6,
kOsUserNameFieldNumber = 8,
kBrowserReportFieldNumber = 4,
kOsReportFieldNumber = 7,
};
// optional string machine_name = 1;
bool has_machine_name() const;
void clear_machine_name();
const std::string& machine_name() const;
void set_machine_name(const std::string& value);
void set_machine_name(std::string&& value);
void set_machine_name(const char* value);
void set_machine_name(const char* value, size_t size);
std::string* mutable_machine_name();
std::string* release_machine_name();
void set_allocated_machine_name(std::string* machine_name);

// optional string os_info = 2;
bool has_os_info() const;
void clear_os_info();
const std::string& os_info() const;
void set_os_info(const std::string& value);
void set_os_info(std::string&& value);
void set_os_info(const char* value);
void set_os_info(const char* value, size_t size);
std::string* mutable_os_info();
std::string* release_os_info();
void set_allocated_os_info(std::string* os_info);

// optional string os_user = 3;
bool has_os_user() const;
void clear_os_user();
const std::string& os_user() const;
void set_os_user(const std::string& value);
void set_os_user(std::string&& value);
void set_os_user(const char* value);
void set_os_user(const char* value, size_t size);
std::string* mutable_os_user();
std::string* release_os_user();
void set_allocated_os_user(std::string* os_user);

// optional string serial_number = 5;
bool has_serial_number() const;
void clear_serial_number();
const std::string& serial_number() const;
void set_serial_number(const std::string& value);
void set_serial_number(std::string&& value);
void set_serial_number(const char* value);
void set_serial_number(const char* value, size_t size);
std::string* mutable_serial_number();
std::string* release_serial_number();
void set_allocated_serial_number(std::string* serial_number);

// optional string computer_name = 6;
bool has_computer_name() const;
void clear_computer_name();
const std::string& computer_name() const;
void set_computer_name(const std::string& value);
void set_computer_name(std::string&& value);
void set_computer_name(const char* value);
void set_computer_name(const char* value, size_t size);
std::string* mutable_computer_name();
std::string* release_computer_name();
void set_allocated_computer_name(std::string* computer_name);

// optional string os_user_name = 8;
bool has_os_user_name() const;
void clear_os_user_name();
const std::string& os_user_name() const;
void set_os_user_name(const std::string& value);
void set_os_user_name(std::string&& value);
void set_os_user_name(const char* value);
void set_os_user_name(const char* value, size_t size);
std::string* mutable_os_user_name();
std::string* release_os_user_name();
void set_allocated_os_user_name(std::string* os_user_name);

// optional .enterprise_management.BrowserReport browser_report = 4;
bool has_browser_report() const;
void clear_browser_report();
const ::enterprise_management::BrowserReport& browser_report() const;
::enterprise_management::BrowserReport* release_browser_report();
::enterprise_management::BrowserReport* mutable_browser_report();
void set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report);

// optional .enterprise_management.OSReport os_report = 7;
bool has_os_report() const;
void clear_os_report();
const ::enterprise_management::OSReport& os_report() const;
::enterprise_management::OSReport* release_os_report();
::enterprise_management::OSReport* mutable_os_report();
void set_allocated_os_report(::enterprise_management::OSReport* os_report);

// @@protoc_insertion_point(class_scope:enterprise_management.ChromeDesktopReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_info_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_user_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr computer_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_user_name_;
::enterprise_management::BrowserReport* browser_report_;
::enterprise_management::OSReport* os_report_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChromeOsUserReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeOsUserReportRequest) */ {
public:
ChromeOsUserReportRequest();
virtual ~ChromeOsUserReportRequest();

ChromeOsUserReportRequest(const ChromeOsUserReportRequest& from);
ChromeOsUserReportRequest(ChromeOsUserReportRequest&& from) noexcept
: ChromeOsUserReportRequest() {
*this = ::std::move(from);
}

inline ChromeOsUserReportRequest& operator=(const ChromeOsUserReportRequest& from) {
CopyFrom(from);
return *this;
}
inline ChromeOsUserReportRequest& operator=(ChromeOsUserReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChromeOsUserReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChromeOsUserReportRequest* internal_default_instance() {
return reinterpret_cast<const ChromeOsUserReportRequest*>(
&_ChromeOsUserReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
73;

friend void swap(ChromeOsUserReportRequest& a, ChromeOsUserReportRequest& b) {
a.Swap(&b);
}
inline void Swap(ChromeOsUserReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChromeOsUserReportRequest* New() const final {
return CreateMaybeMessage<ChromeOsUserReportRequest>(nullptr);
}

ChromeOsUserReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChromeOsUserReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChromeOsUserReportRequest& from);
void MergeFrom(const ChromeOsUserReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChromeOsUserReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChromeOsUserReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAndroidAppInfosFieldNumber = 2,
kBrowserReportFieldNumber = 1,
};
// repeated .enterprise_management.AndroidAppInfo android_app_infos = 2;
int android_app_infos_size() const;
void clear_android_app_infos();
::enterprise_management::AndroidAppInfo* mutable_android_app_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >*
mutable_android_app_infos();
const ::enterprise_management::AndroidAppInfo& android_app_infos(int index) const;
::enterprise_management::AndroidAppInfo* add_android_app_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >&
android_app_infos() const;

// optional .enterprise_management.BrowserReport browser_report = 1;
bool has_browser_report() const;
void clear_browser_report();
const ::enterprise_management::BrowserReport& browser_report() const;
::enterprise_management::BrowserReport* release_browser_report();
::enterprise_management::BrowserReport* mutable_browser_report();
void set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report);

// @@protoc_insertion_point(class_scope:enterprise_management.ChromeOsUserReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo > android_app_infos_;
::enterprise_management::BrowserReport* browser_report_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyValueValidationIssue :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyValueValidationIssue) */ {
public:
PolicyValueValidationIssue();
virtual ~PolicyValueValidationIssue();

PolicyValueValidationIssue(const PolicyValueValidationIssue& from);
PolicyValueValidationIssue(PolicyValueValidationIssue&& from) noexcept
: PolicyValueValidationIssue() {
*this = ::std::move(from);
}

inline PolicyValueValidationIssue& operator=(const PolicyValueValidationIssue& from) {
CopyFrom(from);
return *this;
}
inline PolicyValueValidationIssue& operator=(PolicyValueValidationIssue&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PolicyValueValidationIssue& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PolicyValueValidationIssue* internal_default_instance() {
return reinterpret_cast<const PolicyValueValidationIssue*>(
&_PolicyValueValidationIssue_default_instance_);
}
static constexpr int kIndexInFileMessages =
74;

friend void swap(PolicyValueValidationIssue& a, PolicyValueValidationIssue& b) {
a.Swap(&b);
}
inline void Swap(PolicyValueValidationIssue* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PolicyValueValidationIssue* New() const final {
return CreateMaybeMessage<PolicyValueValidationIssue>(nullptr);
}

PolicyValueValidationIssue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PolicyValueValidationIssue>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PolicyValueValidationIssue& from);
void MergeFrom(const PolicyValueValidationIssue& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PolicyValueValidationIssue* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PolicyValueValidationIssue";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef PolicyValueValidationIssue_ValueValidationIssueSeverity ValueValidationIssueSeverity;
static constexpr ValueValidationIssueSeverity VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED =
PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED;
static constexpr ValueValidationIssueSeverity VALUE_VALIDATION_ISSUE_SEVERITY_WARNING =
PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_WARNING;
static constexpr ValueValidationIssueSeverity VALUE_VALIDATION_ISSUE_SEVERITY_ERROR =
PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_ERROR;
static inline bool ValueValidationIssueSeverity_IsValid(int value) {
return PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(value);
}
static constexpr ValueValidationIssueSeverity ValueValidationIssueSeverity_MIN =
PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MIN;
static constexpr ValueValidationIssueSeverity ValueValidationIssueSeverity_MAX =
PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MAX;
static constexpr int ValueValidationIssueSeverity_ARRAYSIZE =
PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_ARRAYSIZE;
template<typename T>
static inline const std::string& ValueValidationIssueSeverity_Name(T enum_t_value) {
static_assert(::std::is_same<T, ValueValidationIssueSeverity>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ValueValidationIssueSeverity_Name.");
return PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(enum_t_value);
}
static inline bool ValueValidationIssueSeverity_Parse(const std::string& name,
ValueValidationIssueSeverity* value) {
return PolicyValueValidationIssue_ValueValidationIssueSeverity_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPolicyNameFieldNumber = 1,
kDebugMessageFieldNumber = 3,
kSeverityFieldNumber = 2,
};
// optional string policy_name = 1;
bool has_policy_name() const;
void clear_policy_name();
const std::string& policy_name() const;
void set_policy_name(const std::string& value);
void set_policy_name(std::string&& value);
void set_policy_name(const char* value);
void set_policy_name(const char* value, size_t size);
std::string* mutable_policy_name();
std::string* release_policy_name();
void set_allocated_policy_name(std::string* policy_name);

// optional string debug_message = 3;
bool has_debug_message() const;
void clear_debug_message();
const std::string& debug_message() const;
void set_debug_message(const std::string& value);
void set_debug_message(std::string&& value);
void set_debug_message(const char* value);
void set_debug_message(const char* value, size_t size);
std::string* mutable_debug_message();
std::string* release_debug_message();
void set_allocated_debug_message(std::string* debug_message);

// optional .enterprise_management.PolicyValueValidationIssue.ValueValidationIssueSeverity severity = 2;
bool has_severity() const;
void clear_severity();
::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity severity() const;
void set_severity(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity value);

// @@protoc_insertion_point(class_scope:enterprise_management.PolicyValueValidationIssue)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_message_;
int severity_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyValidationReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyValidationReportRequest) */ {
public:
PolicyValidationReportRequest();
virtual ~PolicyValidationReportRequest();

PolicyValidationReportRequest(const PolicyValidationReportRequest& from);
PolicyValidationReportRequest(PolicyValidationReportRequest&& from) noexcept
: PolicyValidationReportRequest() {
*this = ::std::move(from);
}

inline PolicyValidationReportRequest& operator=(const PolicyValidationReportRequest& from) {
CopyFrom(from);
return *this;
}
inline PolicyValidationReportRequest& operator=(PolicyValidationReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PolicyValidationReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PolicyValidationReportRequest* internal_default_instance() {
return reinterpret_cast<const PolicyValidationReportRequest*>(
&_PolicyValidationReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
75;

friend void swap(PolicyValidationReportRequest& a, PolicyValidationReportRequest& b) {
a.Swap(&b);
}
inline void Swap(PolicyValidationReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PolicyValidationReportRequest* New() const final {
return CreateMaybeMessage<PolicyValidationReportRequest>(nullptr);
}

PolicyValidationReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PolicyValidationReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PolicyValidationReportRequest& from);
void MergeFrom(const PolicyValidationReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PolicyValidationReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PolicyValidationReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef PolicyValidationReportRequest_ValidationResultType ValidationResultType;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_SUCCESS =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_SUCCESS;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_SIGNATURE =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_SIGNATURE;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_TIMESTAMP =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_TIMESTAMP;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_DM_TOKEN =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DM_TOKEN;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_DEVICE_ID =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DEVICE_ID;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_USER =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_USER;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_VALUE_WARNING =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_WARNING;
static constexpr ValidationResultType VALIDATION_RESULT_TYPE_VALUE_ERROR =
PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_ERROR;
static inline bool ValidationResultType_IsValid(int value) {
return PolicyValidationReportRequest_ValidationResultType_IsValid(value);
}
static constexpr ValidationResultType ValidationResultType_MIN =
PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MIN;
static constexpr ValidationResultType ValidationResultType_MAX =
PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MAX;
static constexpr int ValidationResultType_ARRAYSIZE =
PolicyValidationReportRequest_ValidationResultType_ValidationResultType_ARRAYSIZE;
template<typename T>
static inline const std::string& ValidationResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, ValidationResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ValidationResultType_Name.");
return PolicyValidationReportRequest_ValidationResultType_Name(enum_t_value);
}
static inline bool ValidationResultType_Parse(const std::string& name,
ValidationResultType* value) {
return PolicyValidationReportRequest_ValidationResultType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPolicyValueValidationIssuesFieldNumber = 4,
kPolicyTypeFieldNumber = 1,
kPolicyTokenFieldNumber = 2,
kValidationResultTypeFieldNumber = 3,
};
// repeated .enterprise_management.PolicyValueValidationIssue policy_value_validation_issues = 4;
int policy_value_validation_issues_size() const;
void clear_policy_value_validation_issues();
::enterprise_management::PolicyValueValidationIssue* mutable_policy_value_validation_issues(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >*
mutable_policy_value_validation_issues();
const ::enterprise_management::PolicyValueValidationIssue& policy_value_validation_issues(int index) const;
::enterprise_management::PolicyValueValidationIssue* add_policy_value_validation_issues();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >&
policy_value_validation_issues() const;

// optional string policy_type = 1;
bool has_policy_type() const;
void clear_policy_type();
const std::string& policy_type() const;
void set_policy_type(const std::string& value);
void set_policy_type(std::string&& value);
void set_policy_type(const char* value);
void set_policy_type(const char* value, size_t size);
std::string* mutable_policy_type();
std::string* release_policy_type();
void set_allocated_policy_type(std::string* policy_type);

// optional string policy_token = 2;
bool has_policy_token() const;
void clear_policy_token();
const std::string& policy_token() const;
void set_policy_token(const std::string& value);
void set_policy_token(std::string&& value);
void set_policy_token(const char* value);
void set_policy_token(const char* value, size_t size);
std::string* mutable_policy_token();
std::string* release_policy_token();
void set_allocated_policy_token(std::string* policy_token);

// optional .enterprise_management.PolicyValidationReportRequest.ValidationResultType validation_result_type = 3;
bool has_validation_result_type() const;
void clear_validation_result_type();
::enterprise_management::PolicyValidationReportRequest_ValidationResultType validation_result_type() const;
void set_validation_result_type(::enterprise_management::PolicyValidationReportRequest_ValidationResultType value);

// @@protoc_insertion_point(class_scope:enterprise_management.PolicyValidationReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue > policy_value_validation_issues_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_token_;
int validation_result_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyValidationReportResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyValidationReportResponse) */ {
public:
PolicyValidationReportResponse();
virtual ~PolicyValidationReportResponse();

PolicyValidationReportResponse(const PolicyValidationReportResponse& from);
PolicyValidationReportResponse(PolicyValidationReportResponse&& from) noexcept
: PolicyValidationReportResponse() {
*this = ::std::move(from);
}

inline PolicyValidationReportResponse& operator=(const PolicyValidationReportResponse& from) {
CopyFrom(from);
return *this;
}
inline PolicyValidationReportResponse& operator=(PolicyValidationReportResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PolicyValidationReportResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PolicyValidationReportResponse* internal_default_instance() {
return reinterpret_cast<const PolicyValidationReportResponse*>(
&_PolicyValidationReportResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
76;

friend void swap(PolicyValidationReportResponse& a, PolicyValidationReportResponse& b) {
a.Swap(&b);
}
inline void Swap(PolicyValidationReportResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PolicyValidationReportResponse* New() const final {
return CreateMaybeMessage<PolicyValidationReportResponse>(nullptr);
}

PolicyValidationReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PolicyValidationReportResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PolicyValidationReportResponse& from);
void MergeFrom(const PolicyValidationReportResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PolicyValidationReportResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PolicyValidationReportResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.PolicyValidationReportResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AndroidStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AndroidStatus) */ {
public:
AndroidStatus();
virtual ~AndroidStatus();

AndroidStatus(const AndroidStatus& from);
AndroidStatus(AndroidStatus&& from) noexcept
: AndroidStatus() {
*this = ::std::move(from);
}

inline AndroidStatus& operator=(const AndroidStatus& from) {
CopyFrom(from);
return *this;
}
inline AndroidStatus& operator=(AndroidStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AndroidStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AndroidStatus* internal_default_instance() {
return reinterpret_cast<const AndroidStatus*>(
&_AndroidStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
77;

friend void swap(AndroidStatus& a, AndroidStatus& b) {
a.Swap(&b);
}
inline void Swap(AndroidStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AndroidStatus* New() const final {
return CreateMaybeMessage<AndroidStatus>(nullptr);
}

AndroidStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AndroidStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AndroidStatus& from);
void MergeFrom(const AndroidStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AndroidStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AndroidStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kStatusPayloadFieldNumber = 1,
kDroidGuardInfoFieldNumber = 2,
};
// optional string status_payload = 1;
bool has_status_payload() const;
void clear_status_payload();
const std::string& status_payload() const;
void set_status_payload(const std::string& value);
void set_status_payload(std::string&& value);
void set_status_payload(const char* value);
void set_status_payload(const char* value, size_t size);
std::string* mutable_status_payload();
std::string* release_status_payload();
void set_allocated_status_payload(std::string* status_payload);

// optional string droid_guard_info = 2;
bool has_droid_guard_info() const;
void clear_droid_guard_info();
const std::string& droid_guard_info() const;
void set_droid_guard_info(const std::string& value);
void set_droid_guard_info(std::string&& value);
void set_droid_guard_info(const char* value);
void set_droid_guard_info(const char* value, size_t size);
std::string* mutable_droid_guard_info();
std::string* release_droid_guard_info();
void set_allocated_droid_guard_info(std::string* droid_guard_info);

// @@protoc_insertion_point(class_scope:enterprise_management.AndroidStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_payload_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr droid_guard_info_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CrostiniApp :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CrostiniApp) */ {
public:
CrostiniApp();
virtual ~CrostiniApp();

CrostiniApp(const CrostiniApp& from);
CrostiniApp(CrostiniApp&& from) noexcept
: CrostiniApp() {
*this = ::std::move(from);
}

inline CrostiniApp& operator=(const CrostiniApp& from) {
CopyFrom(from);
return *this;
}
inline CrostiniApp& operator=(CrostiniApp&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CrostiniApp& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CrostiniApp* internal_default_instance() {
return reinterpret_cast<const CrostiniApp*>(
&_CrostiniApp_default_instance_);
}
static constexpr int kIndexInFileMessages =
78;

friend void swap(CrostiniApp& a, CrostiniApp& b) {
a.Swap(&b);
}
inline void Swap(CrostiniApp* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CrostiniApp* New() const final {
return CreateMaybeMessage<CrostiniApp>(nullptr);
}

CrostiniApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CrostiniApp>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CrostiniApp& from);
void MergeFrom(const CrostiniApp& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CrostiniApp* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CrostiniApp";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAppNameFieldNumber = 1,
kPackageNameFieldNumber = 4,
kPackageVersionFieldNumber = 5,
kPackageHashFieldNumber = 6,
kLastLaunchTimeWindowStartTimestampFieldNumber = 3,
kAppTypeFieldNumber = 2,
};
// optional string app_name = 1;
bool has_app_name() const;
void clear_app_name();
const std::string& app_name() const;
void set_app_name(const std::string& value);
void set_app_name(std::string&& value);
void set_app_name(const char* value);
void set_app_name(const char* value, size_t size);
std::string* mutable_app_name();
std::string* release_app_name();
void set_allocated_app_name(std::string* app_name);

// optional string package_name = 4;
bool has_package_name() const;
void clear_package_name();
const std::string& package_name() const;
void set_package_name(const std::string& value);
void set_package_name(std::string&& value);
void set_package_name(const char* value);
void set_package_name(const char* value, size_t size);
std::string* mutable_package_name();
std::string* release_package_name();
void set_allocated_package_name(std::string* package_name);

// optional string package_version = 5;
bool has_package_version() const;
void clear_package_version();
const std::string& package_version() const;
void set_package_version(const std::string& value);
void set_package_version(std::string&& value);
void set_package_version(const char* value);
void set_package_version(const char* value, size_t size);
std::string* mutable_package_version();
std::string* release_package_version();
void set_allocated_package_version(std::string* package_version);

// optional string package_hash = 6;
bool has_package_hash() const;
void clear_package_hash();
const std::string& package_hash() const;
void set_package_hash(const std::string& value);
void set_package_hash(std::string&& value);
void set_package_hash(const char* value);
void set_package_hash(const char* value, size_t size);
std::string* mutable_package_hash();
std::string* release_package_hash();
void set_allocated_package_hash(std::string* package_hash);

// optional int64 last_launch_time_window_start_timestamp = 3;
bool has_last_launch_time_window_start_timestamp() const;
void clear_last_launch_time_window_start_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 last_launch_time_window_start_timestamp() const;
void set_last_launch_time_window_start_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.CrostiniAppType app_type = 2;
bool has_app_type() const;
void clear_app_type();
::enterprise_management::CrostiniAppType app_type() const;
void set_app_type(::enterprise_management::CrostiniAppType value);

// @@protoc_insertion_point(class_scope:enterprise_management.CrostiniApp)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_hash_;
::PROTOBUF_NAMESPACE_ID::int64 last_launch_time_window_start_timestamp_;
int app_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CrostiniStatus :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CrostiniStatus) */ {
public:
CrostiniStatus();
virtual ~CrostiniStatus();

CrostiniStatus(const CrostiniStatus& from);
CrostiniStatus(CrostiniStatus&& from) noexcept
: CrostiniStatus() {
*this = ::std::move(from);
}

inline CrostiniStatus& operator=(const CrostiniStatus& from) {
CopyFrom(from);
return *this;
}
inline CrostiniStatus& operator=(CrostiniStatus&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CrostiniStatus& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CrostiniStatus* internal_default_instance() {
return reinterpret_cast<const CrostiniStatus*>(
&_CrostiniStatus_default_instance_);
}
static constexpr int kIndexInFileMessages =
79;

friend void swap(CrostiniStatus& a, CrostiniStatus& b) {
a.Swap(&b);
}
inline void Swap(CrostiniStatus* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CrostiniStatus* New() const final {
return CreateMaybeMessage<CrostiniStatus>(nullptr);
}

CrostiniStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CrostiniStatus>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CrostiniStatus& from);
void MergeFrom(const CrostiniStatus& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CrostiniStatus* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CrostiniStatus";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kInstalledAppsFieldNumber = 4,
kLastLaunchVmImageVersionFieldNumber = 2,
kLastLaunchVmKernelVersionFieldNumber = 3,
kLastLaunchTimeWindowStartTimestampFieldNumber = 1,
};
// repeated .enterprise_management.CrostiniApp installed_apps = 4;
int installed_apps_size() const;
void clear_installed_apps();
::enterprise_management::CrostiniApp* mutable_installed_apps(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >*
mutable_installed_apps();
const ::enterprise_management::CrostiniApp& installed_apps(int index) const;
::enterprise_management::CrostiniApp* add_installed_apps();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >&
installed_apps() const;

// optional string last_launch_vm_image_version = 2;
bool has_last_launch_vm_image_version() const;
void clear_last_launch_vm_image_version();
const std::string& last_launch_vm_image_version() const;
void set_last_launch_vm_image_version(const std::string& value);
void set_last_launch_vm_image_version(std::string&& value);
void set_last_launch_vm_image_version(const char* value);
void set_last_launch_vm_image_version(const char* value, size_t size);
std::string* mutable_last_launch_vm_image_version();
std::string* release_last_launch_vm_image_version();
void set_allocated_last_launch_vm_image_version(std::string* last_launch_vm_image_version);

// optional string last_launch_vm_kernel_version = 3;
bool has_last_launch_vm_kernel_version() const;
void clear_last_launch_vm_kernel_version();
const std::string& last_launch_vm_kernel_version() const;
void set_last_launch_vm_kernel_version(const std::string& value);
void set_last_launch_vm_kernel_version(std::string&& value);
void set_last_launch_vm_kernel_version(const char* value);
void set_last_launch_vm_kernel_version(const char* value, size_t size);
std::string* mutable_last_launch_vm_kernel_version();
std::string* release_last_launch_vm_kernel_version();
void set_allocated_last_launch_vm_kernel_version(std::string* last_launch_vm_kernel_version);

// optional int64 last_launch_time_window_start_timestamp = 1;
bool has_last_launch_time_window_start_timestamp() const;
void clear_last_launch_time_window_start_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 last_launch_time_window_start_timestamp() const;
void set_last_launch_time_window_start_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.CrostiniStatus)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp > installed_apps_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_launch_vm_image_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_launch_vm_kernel_version_;
::PROTOBUF_NAMESPACE_ID::int64 last_launch_time_window_start_timestamp_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SessionStatusReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SessionStatusReportRequest) */ {
public:
SessionStatusReportRequest();
virtual ~SessionStatusReportRequest();

SessionStatusReportRequest(const SessionStatusReportRequest& from);
SessionStatusReportRequest(SessionStatusReportRequest&& from) noexcept
: SessionStatusReportRequest() {
*this = ::std::move(from);
}

inline SessionStatusReportRequest& operator=(const SessionStatusReportRequest& from) {
CopyFrom(from);
return *this;
}
inline SessionStatusReportRequest& operator=(SessionStatusReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SessionStatusReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SessionStatusReportRequest* internal_default_instance() {
return reinterpret_cast<const SessionStatusReportRequest*>(
&_SessionStatusReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
80;

friend void swap(SessionStatusReportRequest& a, SessionStatusReportRequest& b) {
a.Swap(&b);
}
inline void Swap(SessionStatusReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SessionStatusReportRequest* New() const final {
return CreateMaybeMessage<SessionStatusReportRequest>(nullptr);
}

SessionStatusReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SessionStatusReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SessionStatusReportRequest& from);
void MergeFrom(const SessionStatusReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SessionStatusReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.SessionStatusReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kInstalledAppsFieldNumber = 5,
kAppInfosFieldNumber = 11,
kDeviceLocalAccountIdFieldNumber = 4,
kUserDmTokenFieldNumber = 8,
kTimeZoneFieldNumber = 9,
kAndroidStatusFieldNumber = 7,
kCrostiniStatusFieldNumber = 10,
};
// repeated .enterprise_management.AppStatus installed_apps = 5;
int installed_apps_size() const;
void clear_installed_apps();
::enterprise_management::AppStatus* mutable_installed_apps(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >*
mutable_installed_apps();
const ::enterprise_management::AppStatus& installed_apps(int index) const;
::enterprise_management::AppStatus* add_installed_apps();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >&
installed_apps() const;

// repeated .enterprise_management.AppInfo app_infos = 11;
int app_infos_size() const;
void clear_app_infos();
::enterprise_management::AppInfo* mutable_app_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >*
mutable_app_infos();
const ::enterprise_management::AppInfo& app_infos(int index) const;
::enterprise_management::AppInfo* add_app_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >&
app_infos() const;

// optional string device_local_account_id = 4;
bool has_device_local_account_id() const;
void clear_device_local_account_id();
const std::string& device_local_account_id() const;
void set_device_local_account_id(const std::string& value);
void set_device_local_account_id(std::string&& value);
void set_device_local_account_id(const char* value);
void set_device_local_account_id(const char* value, size_t size);
std::string* mutable_device_local_account_id();
std::string* release_device_local_account_id();
void set_allocated_device_local_account_id(std::string* device_local_account_id);

// optional string user_dm_token = 8;
bool has_user_dm_token() const;
void clear_user_dm_token();
const std::string& user_dm_token() const;
void set_user_dm_token(const std::string& value);
void set_user_dm_token(std::string&& value);
void set_user_dm_token(const char* value);
void set_user_dm_token(const char* value, size_t size);
std::string* mutable_user_dm_token();
std::string* release_user_dm_token();
void set_allocated_user_dm_token(std::string* user_dm_token);

// optional string time_zone = 9;
bool has_time_zone() const;
void clear_time_zone();
const std::string& time_zone() const;
void set_time_zone(const std::string& value);
void set_time_zone(std::string&& value);
void set_time_zone(const char* value);
void set_time_zone(const char* value, size_t size);
std::string* mutable_time_zone();
std::string* release_time_zone();
void set_allocated_time_zone(std::string* time_zone);

// optional .enterprise_management.AndroidStatus android_status = 7;
bool has_android_status() const;
void clear_android_status();
const ::enterprise_management::AndroidStatus& android_status() const;
::enterprise_management::AndroidStatus* release_android_status();
::enterprise_management::AndroidStatus* mutable_android_status();
void set_allocated_android_status(::enterprise_management::AndroidStatus* android_status);

// optional .enterprise_management.CrostiniStatus crostini_status = 10;
bool has_crostini_status() const;
void clear_crostini_status();
const ::enterprise_management::CrostiniStatus& crostini_status() const;
::enterprise_management::CrostiniStatus* release_crostini_status();
::enterprise_management::CrostiniStatus* mutable_crostini_status();
void set_allocated_crostini_status(::enterprise_management::CrostiniStatus* crostini_status);

// @@protoc_insertion_point(class_scope:enterprise_management.SessionStatusReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus > installed_apps_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo > app_infos_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_local_account_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_dm_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
::enterprise_management::AndroidStatus* android_status_;
::enterprise_management::CrostiniStatus* crostini_status_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStatusReportResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStatusReportResponse) */ {
public:
DeviceStatusReportResponse();
virtual ~DeviceStatusReportResponse();

DeviceStatusReportResponse(const DeviceStatusReportResponse& from);
DeviceStatusReportResponse(DeviceStatusReportResponse&& from) noexcept
: DeviceStatusReportResponse() {
*this = ::std::move(from);
}

inline DeviceStatusReportResponse& operator=(const DeviceStatusReportResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceStatusReportResponse& operator=(DeviceStatusReportResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceStatusReportResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceStatusReportResponse* internal_default_instance() {
return reinterpret_cast<const DeviceStatusReportResponse*>(
&_DeviceStatusReportResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
81;

friend void swap(DeviceStatusReportResponse& a, DeviceStatusReportResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceStatusReportResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceStatusReportResponse* New() const final {
return CreateMaybeMessage<DeviceStatusReportResponse>(nullptr);
}

DeviceStatusReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceStatusReportResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceStatusReportResponse& from);
void MergeFrom(const DeviceStatusReportResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceStatusReportResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceStatusReportResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kErrorMessageFieldNumber = 2,
kErrorCodeFieldNumber = 1,
};
// optional string error_message = 2;
bool has_error_message() const;
void clear_error_message();
const std::string& error_message() const;
void set_error_message(const std::string& value);
void set_error_message(std::string&& value);
void set_error_message(const char* value);
void set_error_message(const char* value, size_t size);
std::string* mutable_error_message();
std::string* release_error_message();
void set_allocated_error_message(std::string* error_message);

// optional int32 error_code = 1;
bool has_error_code() const;
void clear_error_code();
::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceStatusReportResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
::PROTOBUF_NAMESPACE_ID::int32 error_code_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChromeDesktopReportResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeDesktopReportResponse) */ {
public:
ChromeDesktopReportResponse();
virtual ~ChromeDesktopReportResponse();

ChromeDesktopReportResponse(const ChromeDesktopReportResponse& from);
ChromeDesktopReportResponse(ChromeDesktopReportResponse&& from) noexcept
: ChromeDesktopReportResponse() {
*this = ::std::move(from);
}

inline ChromeDesktopReportResponse& operator=(const ChromeDesktopReportResponse& from) {
CopyFrom(from);
return *this;
}
inline ChromeDesktopReportResponse& operator=(ChromeDesktopReportResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChromeDesktopReportResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChromeDesktopReportResponse* internal_default_instance() {
return reinterpret_cast<const ChromeDesktopReportResponse*>(
&_ChromeDesktopReportResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
82;

friend void swap(ChromeDesktopReportResponse& a, ChromeDesktopReportResponse& b) {
a.Swap(&b);
}
inline void Swap(ChromeDesktopReportResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChromeDesktopReportResponse* New() const final {
return CreateMaybeMessage<ChromeDesktopReportResponse>(nullptr);
}

ChromeDesktopReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChromeDesktopReportResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChromeDesktopReportResponse& from);
void MergeFrom(const ChromeDesktopReportResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChromeDesktopReportResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChromeDesktopReportResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.ChromeDesktopReportResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChromeOsUserReportResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeOsUserReportResponse) */ {
public:
ChromeOsUserReportResponse();
virtual ~ChromeOsUserReportResponse();

ChromeOsUserReportResponse(const ChromeOsUserReportResponse& from);
ChromeOsUserReportResponse(ChromeOsUserReportResponse&& from) noexcept
: ChromeOsUserReportResponse() {
*this = ::std::move(from);
}

inline ChromeOsUserReportResponse& operator=(const ChromeOsUserReportResponse& from) {
CopyFrom(from);
return *this;
}
inline ChromeOsUserReportResponse& operator=(ChromeOsUserReportResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChromeOsUserReportResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChromeOsUserReportResponse* internal_default_instance() {
return reinterpret_cast<const ChromeOsUserReportResponse*>(
&_ChromeOsUserReportResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
83;

friend void swap(ChromeOsUserReportResponse& a, ChromeOsUserReportResponse& b) {
a.Swap(&b);
}
inline void Swap(ChromeOsUserReportResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChromeOsUserReportResponse* New() const final {
return CreateMaybeMessage<ChromeOsUserReportResponse>(nullptr);
}

ChromeOsUserReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChromeOsUserReportResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChromeOsUserReportResponse& from);
void MergeFrom(const ChromeOsUserReportResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChromeOsUserReportResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChromeOsUserReportResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.ChromeOsUserReportResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SessionStatusReportResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SessionStatusReportResponse) */ {
public:
SessionStatusReportResponse();
virtual ~SessionStatusReportResponse();

SessionStatusReportResponse(const SessionStatusReportResponse& from);
SessionStatusReportResponse(SessionStatusReportResponse&& from) noexcept
: SessionStatusReportResponse() {
*this = ::std::move(from);
}

inline SessionStatusReportResponse& operator=(const SessionStatusReportResponse& from) {
CopyFrom(from);
return *this;
}
inline SessionStatusReportResponse& operator=(SessionStatusReportResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SessionStatusReportResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SessionStatusReportResponse* internal_default_instance() {
return reinterpret_cast<const SessionStatusReportResponse*>(
&_SessionStatusReportResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
84;

friend void swap(SessionStatusReportResponse& a, SessionStatusReportResponse& b) {
a.Swap(&b);
}
inline void Swap(SessionStatusReportResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SessionStatusReportResponse* New() const final {
return CreateMaybeMessage<SessionStatusReportResponse>(nullptr);
}

SessionStatusReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SessionStatusReportResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SessionStatusReportResponse& from);
void MergeFrom(const SessionStatusReportResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SessionStatusReportResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.SessionStatusReportResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kErrorMessageFieldNumber = 2,
kErrorCodeFieldNumber = 1,
};
// optional string error_message = 2;
bool has_error_message() const;
void clear_error_message();
const std::string& error_message() const;
void set_error_message(const std::string& value);
void set_error_message(std::string&& value);
void set_error_message(const char* value);
void set_error_message(const char* value, size_t size);
std::string* mutable_error_message();
std::string* release_error_message();
void set_allocated_error_message(std::string* error_message);

// optional int32 error_code = 1;
bool has_error_code() const;
void clear_error_code();
::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.SessionStatusReportResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
::PROTOBUF_NAMESPACE_ID::int32 error_code_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAutoEnrollmentRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAutoEnrollmentRequest) */ {
public:
DeviceAutoEnrollmentRequest();
virtual ~DeviceAutoEnrollmentRequest();

DeviceAutoEnrollmentRequest(const DeviceAutoEnrollmentRequest& from);
DeviceAutoEnrollmentRequest(DeviceAutoEnrollmentRequest&& from) noexcept
: DeviceAutoEnrollmentRequest() {
*this = ::std::move(from);
}

inline DeviceAutoEnrollmentRequest& operator=(const DeviceAutoEnrollmentRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceAutoEnrollmentRequest& operator=(DeviceAutoEnrollmentRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceAutoEnrollmentRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceAutoEnrollmentRequest* internal_default_instance() {
return reinterpret_cast<const DeviceAutoEnrollmentRequest*>(
&_DeviceAutoEnrollmentRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
85;

friend void swap(DeviceAutoEnrollmentRequest& a, DeviceAutoEnrollmentRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceAutoEnrollmentRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceAutoEnrollmentRequest* New() const final {
return CreateMaybeMessage<DeviceAutoEnrollmentRequest>(nullptr);
}

DeviceAutoEnrollmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceAutoEnrollmentRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceAutoEnrollmentRequest& from);
void MergeFrom(const DeviceAutoEnrollmentRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceAutoEnrollmentRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceAutoEnrollmentRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceAutoEnrollmentRequest_EnrollmentCheckType EnrollmentCheckType;
static constexpr EnrollmentCheckType ENROLLMENT_CHECK_TYPE_UNSPECIFIED =
DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_UNSPECIFIED;
static constexpr EnrollmentCheckType ENROLLMENT_CHECK_TYPE_FRE =
DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FRE;
static constexpr EnrollmentCheckType ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT =
DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT;
static inline bool EnrollmentCheckType_IsValid(int value) {
return DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(value);
}
static constexpr EnrollmentCheckType EnrollmentCheckType_MIN =
DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MIN;
static constexpr EnrollmentCheckType EnrollmentCheckType_MAX =
DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MAX;
static constexpr int EnrollmentCheckType_ARRAYSIZE =
DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_ARRAYSIZE;
template<typename T>
static inline const std::string& EnrollmentCheckType_Name(T enum_t_value) {
static_assert(::std::is_same<T, EnrollmentCheckType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function EnrollmentCheckType_Name.");
return DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(enum_t_value);
}
static inline bool EnrollmentCheckType_Parse(const std::string& name,
EnrollmentCheckType* value) {
return DeviceAutoEnrollmentRequest_EnrollmentCheckType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kRemainderFieldNumber = 1,
kModulusFieldNumber = 2,
kEnrollmentCheckTypeFieldNumber = 3,
};
// optional int64 remainder = 1;
bool has_remainder() const;
void clear_remainder();
::PROTOBUF_NAMESPACE_ID::int64 remainder() const;
void set_remainder(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 modulus = 2;
bool has_modulus() const;
void clear_modulus();
::PROTOBUF_NAMESPACE_ID::int64 modulus() const;
void set_modulus(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.DeviceAutoEnrollmentRequest.EnrollmentCheckType enrollment_check_type = 3 [default = ENROLLMENT_CHECK_TYPE_FRE];
bool has_enrollment_check_type() const;
void clear_enrollment_check_type();
::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType enrollment_check_type() const;
void set_enrollment_check_type(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceAutoEnrollmentRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 remainder_;
::PROTOBUF_NAMESPACE_ID::int64 modulus_;
int enrollment_check_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAutoEnrollmentResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAutoEnrollmentResponse) */ {
public:
DeviceAutoEnrollmentResponse();
virtual ~DeviceAutoEnrollmentResponse();

DeviceAutoEnrollmentResponse(const DeviceAutoEnrollmentResponse& from);
DeviceAutoEnrollmentResponse(DeviceAutoEnrollmentResponse&& from) noexcept
: DeviceAutoEnrollmentResponse() {
*this = ::std::move(from);
}

inline DeviceAutoEnrollmentResponse& operator=(const DeviceAutoEnrollmentResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceAutoEnrollmentResponse& operator=(DeviceAutoEnrollmentResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceAutoEnrollmentResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceAutoEnrollmentResponse* internal_default_instance() {
return reinterpret_cast<const DeviceAutoEnrollmentResponse*>(
&_DeviceAutoEnrollmentResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
86;

friend void swap(DeviceAutoEnrollmentResponse& a, DeviceAutoEnrollmentResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceAutoEnrollmentResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceAutoEnrollmentResponse* New() const final {
return CreateMaybeMessage<DeviceAutoEnrollmentResponse>(nullptr);
}

DeviceAutoEnrollmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceAutoEnrollmentResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceAutoEnrollmentResponse& from);
void MergeFrom(const DeviceAutoEnrollmentResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceAutoEnrollmentResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceAutoEnrollmentResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kHashesFieldNumber = 2,
kExpectedModulusFieldNumber = 1,
};
// repeated bytes hashes = 2;
int hashes_size() const;
void clear_hashes();
const std::string& hashes(int index) const;
std::string* mutable_hashes(int index);
void set_hashes(int index, const std::string& value);
void set_hashes(int index, std::string&& value);
void set_hashes(int index, const char* value);
void set_hashes(int index, const void* value, size_t size);
std::string* add_hashes();
void add_hashes(const std::string& value);
void add_hashes(std::string&& value);
void add_hashes(const char* value);
void add_hashes(const void* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();

// optional int64 expected_modulus = 1;
bool has_expected_modulus() const;
void clear_expected_modulus();
::PROTOBUF_NAMESPACE_ID::int64 expected_modulus() const;
void set_expected_modulus(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceAutoEnrollmentResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
::PROTOBUF_NAMESPACE_ID::int64 expected_modulus_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStateRetrievalRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateRetrievalRequest) */ {
public:
DeviceStateRetrievalRequest();
virtual ~DeviceStateRetrievalRequest();

DeviceStateRetrievalRequest(const DeviceStateRetrievalRequest& from);
DeviceStateRetrievalRequest(DeviceStateRetrievalRequest&& from) noexcept
: DeviceStateRetrievalRequest() {
*this = ::std::move(from);
}

inline DeviceStateRetrievalRequest& operator=(const DeviceStateRetrievalRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceStateRetrievalRequest& operator=(DeviceStateRetrievalRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceStateRetrievalRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceStateRetrievalRequest* internal_default_instance() {
return reinterpret_cast<const DeviceStateRetrievalRequest*>(
&_DeviceStateRetrievalRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
87;

friend void swap(DeviceStateRetrievalRequest& a, DeviceStateRetrievalRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceStateRetrievalRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceStateRetrievalRequest* New() const final {
return CreateMaybeMessage<DeviceStateRetrievalRequest>(nullptr);
}

DeviceStateRetrievalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceStateRetrievalRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceStateRetrievalRequest& from);
void MergeFrom(const DeviceStateRetrievalRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceStateRetrievalRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceStateRetrievalRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kServerBackedStateKeyFieldNumber = 1,
};
// optional bytes server_backed_state_key = 1;
bool has_server_backed_state_key() const;
void clear_server_backed_state_key();
const std::string& server_backed_state_key() const;
void set_server_backed_state_key(const std::string& value);
void set_server_backed_state_key(std::string&& value);
void set_server_backed_state_key(const char* value);
void set_server_backed_state_key(const void* value, size_t size);
std::string* mutable_server_backed_state_key();
std::string* release_server_backed_state_key();
void set_allocated_server_backed_state_key(std::string* server_backed_state_key);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_backed_state_key_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStateKeyUpdateRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateKeyUpdateRequest) */ {
public:
DeviceStateKeyUpdateRequest();
virtual ~DeviceStateKeyUpdateRequest();

DeviceStateKeyUpdateRequest(const DeviceStateKeyUpdateRequest& from);
DeviceStateKeyUpdateRequest(DeviceStateKeyUpdateRequest&& from) noexcept
: DeviceStateKeyUpdateRequest() {
*this = ::std::move(from);
}

inline DeviceStateKeyUpdateRequest& operator=(const DeviceStateKeyUpdateRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceStateKeyUpdateRequest& operator=(DeviceStateKeyUpdateRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceStateKeyUpdateRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceStateKeyUpdateRequest* internal_default_instance() {
return reinterpret_cast<const DeviceStateKeyUpdateRequest*>(
&_DeviceStateKeyUpdateRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
88;

friend void swap(DeviceStateKeyUpdateRequest& a, DeviceStateKeyUpdateRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceStateKeyUpdateRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceStateKeyUpdateRequest* New() const final {
return CreateMaybeMessage<DeviceStateKeyUpdateRequest>(nullptr);
}

DeviceStateKeyUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceStateKeyUpdateRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceStateKeyUpdateRequest& from);
void MergeFrom(const DeviceStateKeyUpdateRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceStateKeyUpdateRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceStateKeyUpdateRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kServerBackedStateKeysFieldNumber = 1,
};
// repeated bytes server_backed_state_keys = 1;
int server_backed_state_keys_size() const;
void clear_server_backed_state_keys();
const std::string& server_backed_state_keys(int index) const;
std::string* mutable_server_backed_state_keys(int index);
void set_server_backed_state_keys(int index, const std::string& value);
void set_server_backed_state_keys(int index, std::string&& value);
void set_server_backed_state_keys(int index, const char* value);
void set_server_backed_state_keys(int index, const void* value, size_t size);
std::string* add_server_backed_state_keys();
void add_server_backed_state_keys(const std::string& value);
void add_server_backed_state_keys(std::string&& value);
void add_server_backed_state_keys(const char* value);
void add_server_backed_state_keys(const void* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& server_backed_state_keys() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_server_backed_state_keys();

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateKeyUpdateRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> server_backed_state_keys_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStateRetrievalResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateRetrievalResponse) */ {
public:
DeviceStateRetrievalResponse();
virtual ~DeviceStateRetrievalResponse();

DeviceStateRetrievalResponse(const DeviceStateRetrievalResponse& from);
DeviceStateRetrievalResponse(DeviceStateRetrievalResponse&& from) noexcept
: DeviceStateRetrievalResponse() {
*this = ::std::move(from);
}

inline DeviceStateRetrievalResponse& operator=(const DeviceStateRetrievalResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceStateRetrievalResponse& operator=(DeviceStateRetrievalResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceStateRetrievalResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceStateRetrievalResponse* internal_default_instance() {
return reinterpret_cast<const DeviceStateRetrievalResponse*>(
&_DeviceStateRetrievalResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
89;

friend void swap(DeviceStateRetrievalResponse& a, DeviceStateRetrievalResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceStateRetrievalResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceStateRetrievalResponse* New() const final {
return CreateMaybeMessage<DeviceStateRetrievalResponse>(nullptr);
}

DeviceStateRetrievalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceStateRetrievalResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceStateRetrievalResponse& from);
void MergeFrom(const DeviceStateRetrievalResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceStateRetrievalResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceStateRetrievalResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceStateRetrievalResponse_RestoreMode RestoreMode;
static constexpr RestoreMode RESTORE_MODE_NONE =
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE;
static constexpr RestoreMode RESTORE_MODE_REENROLLMENT_REQUESTED =
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_REQUESTED;
static constexpr RestoreMode RESTORE_MODE_REENROLLMENT_ENFORCED =
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ENFORCED;
static constexpr RestoreMode RESTORE_MODE_DISABLED =
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_DISABLED;
static constexpr RestoreMode RESTORE_MODE_REENROLLMENT_ZERO_TOUCH =
DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ZERO_TOUCH;
static inline bool RestoreMode_IsValid(int value) {
return DeviceStateRetrievalResponse_RestoreMode_IsValid(value);
}
static constexpr RestoreMode RestoreMode_MIN =
DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MIN;
static constexpr RestoreMode RestoreMode_MAX =
DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX;
static constexpr int RestoreMode_ARRAYSIZE =
DeviceStateRetrievalResponse_RestoreMode_RestoreMode_ARRAYSIZE;
template<typename T>
static inline const std::string& RestoreMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, RestoreMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function RestoreMode_Name.");
return DeviceStateRetrievalResponse_RestoreMode_Name(enum_t_value);
}
static inline bool RestoreMode_Parse(const std::string& name,
RestoreMode* value) {
return DeviceStateRetrievalResponse_RestoreMode_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kManagementDomainFieldNumber = 2,
kDisabledStateFieldNumber = 3,
kRestoreModeFieldNumber = 1,
};
// optional string management_domain = 2;
bool has_management_domain() const;
void clear_management_domain();
const std::string& management_domain() const;
void set_management_domain(const std::string& value);
void set_management_domain(std::string&& value);
void set_management_domain(const char* value);
void set_management_domain(const char* value, size_t size);
std::string* mutable_management_domain();
std::string* release_management_domain();
void set_allocated_management_domain(std::string* management_domain);

// optional .enterprise_management.DisabledState disabled_state = 3;
bool has_disabled_state() const;
void clear_disabled_state();
const ::enterprise_management::DisabledState& disabled_state() const;
::enterprise_management::DisabledState* release_disabled_state();
::enterprise_management::DisabledState* mutable_disabled_state();
void set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state);

// optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
bool has_restore_mode() const;
void clear_restore_mode();
::enterprise_management::DeviceStateRetrievalResponse_RestoreMode restore_mode() const;
void set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr management_domain_;
::enterprise_management::DisabledState* disabled_state_;
int restore_mode_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceInitialEnrollmentStateRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceInitialEnrollmentStateRequest) */ {
public:
DeviceInitialEnrollmentStateRequest();
virtual ~DeviceInitialEnrollmentStateRequest();

DeviceInitialEnrollmentStateRequest(const DeviceInitialEnrollmentStateRequest& from);
DeviceInitialEnrollmentStateRequest(DeviceInitialEnrollmentStateRequest&& from) noexcept
: DeviceInitialEnrollmentStateRequest() {
*this = ::std::move(from);
}

inline DeviceInitialEnrollmentStateRequest& operator=(const DeviceInitialEnrollmentStateRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceInitialEnrollmentStateRequest& operator=(DeviceInitialEnrollmentStateRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceInitialEnrollmentStateRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceInitialEnrollmentStateRequest* internal_default_instance() {
return reinterpret_cast<const DeviceInitialEnrollmentStateRequest*>(
&_DeviceInitialEnrollmentStateRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
90;

friend void swap(DeviceInitialEnrollmentStateRequest& a, DeviceInitialEnrollmentStateRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceInitialEnrollmentStateRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceInitialEnrollmentStateRequest* New() const final {
return CreateMaybeMessage<DeviceInitialEnrollmentStateRequest>(nullptr);
}

DeviceInitialEnrollmentStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceInitialEnrollmentStateRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceInitialEnrollmentStateRequest& from);
void MergeFrom(const DeviceInitialEnrollmentStateRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceInitialEnrollmentStateRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceInitialEnrollmentStateRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSerialNumberFieldNumber = 1,
kBrandCodeFieldNumber = 2,
};
// optional string serial_number = 1;
bool has_serial_number() const;
void clear_serial_number();
const std::string& serial_number() const;
void set_serial_number(const std::string& value);
void set_serial_number(std::string&& value);
void set_serial_number(const char* value);
void set_serial_number(const char* value, size_t size);
std::string* mutable_serial_number();
std::string* release_serial_number();
void set_allocated_serial_number(std::string* serial_number);

// optional string brand_code = 2;
bool has_brand_code() const;
void clear_brand_code();
const std::string& brand_code() const;
void set_brand_code(const std::string& value);
void set_brand_code(std::string&& value);
void set_brand_code(const char* value);
void set_brand_code(const char* value, size_t size);
std::string* mutable_brand_code();
std::string* release_brand_code();
void set_allocated_brand_code(std::string* brand_code);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceInitialEnrollmentStateRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_code_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceInitialEnrollmentStateResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceInitialEnrollmentStateResponse) */ {
public:
DeviceInitialEnrollmentStateResponse();
virtual ~DeviceInitialEnrollmentStateResponse();

DeviceInitialEnrollmentStateResponse(const DeviceInitialEnrollmentStateResponse& from);
DeviceInitialEnrollmentStateResponse(DeviceInitialEnrollmentStateResponse&& from) noexcept
: DeviceInitialEnrollmentStateResponse() {
*this = ::std::move(from);
}

inline DeviceInitialEnrollmentStateResponse& operator=(const DeviceInitialEnrollmentStateResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceInitialEnrollmentStateResponse& operator=(DeviceInitialEnrollmentStateResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceInitialEnrollmentStateResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceInitialEnrollmentStateResponse* internal_default_instance() {
return reinterpret_cast<const DeviceInitialEnrollmentStateResponse*>(
&_DeviceInitialEnrollmentStateResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
91;

friend void swap(DeviceInitialEnrollmentStateResponse& a, DeviceInitialEnrollmentStateResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceInitialEnrollmentStateResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceInitialEnrollmentStateResponse* New() const final {
return CreateMaybeMessage<DeviceInitialEnrollmentStateResponse>(nullptr);
}

DeviceInitialEnrollmentStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceInitialEnrollmentStateResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceInitialEnrollmentStateResponse& from);
void MergeFrom(const DeviceInitialEnrollmentStateResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceInitialEnrollmentStateResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceInitialEnrollmentStateResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode InitialEnrollmentMode;
static constexpr InitialEnrollmentMode INITIAL_ENROLLMENT_MODE_NONE =
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_NONE;
static constexpr InitialEnrollmentMode INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED =
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED;
static constexpr InitialEnrollmentMode INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED =
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED;
static inline bool InitialEnrollmentMode_IsValid(int value) {
return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(value);
}
static constexpr InitialEnrollmentMode InitialEnrollmentMode_MIN =
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MIN;
static constexpr InitialEnrollmentMode InitialEnrollmentMode_MAX =
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MAX;
static constexpr int InitialEnrollmentMode_ARRAYSIZE =
DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_ARRAYSIZE;
template<typename T>
static inline const std::string& InitialEnrollmentMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, InitialEnrollmentMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function InitialEnrollmentMode_Name.");
return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(enum_t_value);
}
static inline bool InitialEnrollmentMode_Parse(const std::string& name,
InitialEnrollmentMode* value) {
return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kManagementDomainFieldNumber = 2,
kInitialEnrollmentModeFieldNumber = 1,
kIsLicensePackagedWithDeviceFieldNumber = 3,
};
// optional string management_domain = 2;
bool has_management_domain() const;
void clear_management_domain();
const std::string& management_domain() const;
void set_management_domain(const std::string& value);
void set_management_domain(std::string&& value);
void set_management_domain(const char* value);
void set_management_domain(const char* value, size_t size);
std::string* mutable_management_domain();
std::string* release_management_domain();
void set_allocated_management_domain(std::string* management_domain);

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse.InitialEnrollmentMode initial_enrollment_mode = 1 [default = INITIAL_ENROLLMENT_MODE_NONE];
bool has_initial_enrollment_mode() const;
void clear_initial_enrollment_mode();
::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode initial_enrollment_mode() const;
void set_initial_enrollment_mode(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value);

// optional bool is_license_packaged_with_device = 3;
bool has_is_license_packaged_with_device() const;
void clear_is_license_packaged_with_device();
bool is_license_packaged_with_device() const;
void set_is_license_packaged_with_device(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceInitialEnrollmentStateResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr management_domain_;
int initial_enrollment_mode_;
bool is_license_packaged_with_device_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePairingRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePairingRequest) */ {
public:
DevicePairingRequest();
virtual ~DevicePairingRequest();

DevicePairingRequest(const DevicePairingRequest& from);
DevicePairingRequest(DevicePairingRequest&& from) noexcept
: DevicePairingRequest() {
*this = ::std::move(from);
}

inline DevicePairingRequest& operator=(const DevicePairingRequest& from) {
CopyFrom(from);
return *this;
}
inline DevicePairingRequest& operator=(DevicePairingRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DevicePairingRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DevicePairingRequest* internal_default_instance() {
return reinterpret_cast<const DevicePairingRequest*>(
&_DevicePairingRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
92;

friend void swap(DevicePairingRequest& a, DevicePairingRequest& b) {
a.Swap(&b);
}
inline void Swap(DevicePairingRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DevicePairingRequest* New() const final {
return CreateMaybeMessage<DevicePairingRequest>(nullptr);
}

DevicePairingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DevicePairingRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DevicePairingRequest& from);
void MergeFrom(const DevicePairingRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DevicePairingRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DevicePairingRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kHostDeviceIdFieldNumber = 1,
kControllerDeviceIdFieldNumber = 2,
};
// optional string host_device_id = 1;
bool has_host_device_id() const;
void clear_host_device_id();
const std::string& host_device_id() const;
void set_host_device_id(const std::string& value);
void set_host_device_id(std::string&& value);
void set_host_device_id(const char* value);
void set_host_device_id(const char* value, size_t size);
std::string* mutable_host_device_id();
std::string* release_host_device_id();
void set_allocated_host_device_id(std::string* host_device_id);

// optional string controller_device_id = 2;
bool has_controller_device_id() const;
void clear_controller_device_id();
const std::string& controller_device_id() const;
void set_controller_device_id(const std::string& value);
void set_controller_device_id(std::string&& value);
void set_controller_device_id(const char* value);
void set_controller_device_id(const char* value, size_t size);
std::string* mutable_controller_device_id();
std::string* release_controller_device_id();
void set_allocated_controller_device_id(std::string* controller_device_id);

// @@protoc_insertion_point(class_scope:enterprise_management.DevicePairingRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_device_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_device_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePairingResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePairingResponse) */ {
public:
DevicePairingResponse();
virtual ~DevicePairingResponse();

DevicePairingResponse(const DevicePairingResponse& from);
DevicePairingResponse(DevicePairingResponse&& from) noexcept
: DevicePairingResponse() {
*this = ::std::move(from);
}

inline DevicePairingResponse& operator=(const DevicePairingResponse& from) {
CopyFrom(from);
return *this;
}
inline DevicePairingResponse& operator=(DevicePairingResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DevicePairingResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DevicePairingResponse* internal_default_instance() {
return reinterpret_cast<const DevicePairingResponse*>(
&_DevicePairingResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
93;

friend void swap(DevicePairingResponse& a, DevicePairingResponse& b) {
a.Swap(&b);
}
inline void Swap(DevicePairingResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DevicePairingResponse* New() const final {
return CreateMaybeMessage<DevicePairingResponse>(nullptr);
}

DevicePairingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DevicePairingResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DevicePairingResponse& from);
void MergeFrom(const DevicePairingResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DevicePairingResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DevicePairingResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DevicePairingResponse_StatusCode StatusCode;
static constexpr StatusCode SUCCESS =
DevicePairingResponse_StatusCode_SUCCESS;
static constexpr StatusCode FAILED =
DevicePairingResponse_StatusCode_FAILED;
static constexpr StatusCode HOST_DEVICE_NOT_FOUND =
DevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND;
static constexpr StatusCode CONTROLLER_DEVICE_NOT_FOUND =
DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND;
static constexpr StatusCode HOST_DEVICE_DEPROVISIONED =
DevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED;
static constexpr StatusCode CONTROLLER_DEVICE_DEPROVISIONED =
DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
static inline bool StatusCode_IsValid(int value) {
return DevicePairingResponse_StatusCode_IsValid(value);
}
static constexpr StatusCode StatusCode_MIN =
DevicePairingResponse_StatusCode_StatusCode_MIN;
static constexpr StatusCode StatusCode_MAX =
DevicePairingResponse_StatusCode_StatusCode_MAX;
static constexpr int StatusCode_ARRAYSIZE =
DevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE;
template<typename T>
static inline const std::string& StatusCode_Name(T enum_t_value) {
static_assert(::std::is_same<T, StatusCode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function StatusCode_Name.");
return DevicePairingResponse_StatusCode_Name(enum_t_value);
}
static inline bool StatusCode_Parse(const std::string& name,
StatusCode* value) {
return DevicePairingResponse_StatusCode_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kStatusCodeFieldNumber = 1,
};
// optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
bool has_status_code() const;
void clear_status_code();
::enterprise_management::DevicePairingResponse_StatusCode status_code() const;
void set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value);

// @@protoc_insertion_point(class_scope:enterprise_management.DevicePairingResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int status_code_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckDevicePairingRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDevicePairingRequest) */ {
public:
CheckDevicePairingRequest();
virtual ~CheckDevicePairingRequest();

CheckDevicePairingRequest(const CheckDevicePairingRequest& from);
CheckDevicePairingRequest(CheckDevicePairingRequest&& from) noexcept
: CheckDevicePairingRequest() {
*this = ::std::move(from);
}

inline CheckDevicePairingRequest& operator=(const CheckDevicePairingRequest& from) {
CopyFrom(from);
return *this;
}
inline CheckDevicePairingRequest& operator=(CheckDevicePairingRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CheckDevicePairingRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CheckDevicePairingRequest* internal_default_instance() {
return reinterpret_cast<const CheckDevicePairingRequest*>(
&_CheckDevicePairingRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
94;

friend void swap(CheckDevicePairingRequest& a, CheckDevicePairingRequest& b) {
a.Swap(&b);
}
inline void Swap(CheckDevicePairingRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CheckDevicePairingRequest* New() const final {
return CreateMaybeMessage<CheckDevicePairingRequest>(nullptr);
}

CheckDevicePairingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CheckDevicePairingRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CheckDevicePairingRequest& from);
void MergeFrom(const CheckDevicePairingRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CheckDevicePairingRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CheckDevicePairingRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kHostDeviceIdFieldNumber = 1,
kControllerDeviceIdFieldNumber = 2,
};
// optional string host_device_id = 1;
bool has_host_device_id() const;
void clear_host_device_id();
const std::string& host_device_id() const;
void set_host_device_id(const std::string& value);
void set_host_device_id(std::string&& value);
void set_host_device_id(const char* value);
void set_host_device_id(const char* value, size_t size);
std::string* mutable_host_device_id();
std::string* release_host_device_id();
void set_allocated_host_device_id(std::string* host_device_id);

// optional string controller_device_id = 2;
bool has_controller_device_id() const;
void clear_controller_device_id();
const std::string& controller_device_id() const;
void set_controller_device_id(const std::string& value);
void set_controller_device_id(std::string&& value);
void set_controller_device_id(const char* value);
void set_controller_device_id(const char* value, size_t size);
std::string* mutable_controller_device_id();
std::string* release_controller_device_id();
void set_allocated_controller_device_id(std::string* controller_device_id);

// @@protoc_insertion_point(class_scope:enterprise_management.CheckDevicePairingRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_device_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_device_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckDevicePairingResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDevicePairingResponse) */ {
public:
CheckDevicePairingResponse();
virtual ~CheckDevicePairingResponse();

CheckDevicePairingResponse(const CheckDevicePairingResponse& from);
CheckDevicePairingResponse(CheckDevicePairingResponse&& from) noexcept
: CheckDevicePairingResponse() {
*this = ::std::move(from);
}

inline CheckDevicePairingResponse& operator=(const CheckDevicePairingResponse& from) {
CopyFrom(from);
return *this;
}
inline CheckDevicePairingResponse& operator=(CheckDevicePairingResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CheckDevicePairingResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CheckDevicePairingResponse* internal_default_instance() {
return reinterpret_cast<const CheckDevicePairingResponse*>(
&_CheckDevicePairingResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
95;

friend void swap(CheckDevicePairingResponse& a, CheckDevicePairingResponse& b) {
a.Swap(&b);
}
inline void Swap(CheckDevicePairingResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CheckDevicePairingResponse* New() const final {
return CreateMaybeMessage<CheckDevicePairingResponse>(nullptr);
}

CheckDevicePairingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CheckDevicePairingResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CheckDevicePairingResponse& from);
void MergeFrom(const CheckDevicePairingResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CheckDevicePairingResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CheckDevicePairingResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef CheckDevicePairingResponse_StatusCode StatusCode;
static constexpr StatusCode PAIRED =
CheckDevicePairingResponse_StatusCode_PAIRED;
static constexpr StatusCode NOT_PAIRED =
CheckDevicePairingResponse_StatusCode_NOT_PAIRED;
static constexpr StatusCode HOST_DEVICE_NOT_FOUND =
CheckDevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND;
static constexpr StatusCode CONTROLLER_DEVICE_NOT_FOUND =
CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND;
static constexpr StatusCode HOST_DEVICE_DEPROVISIONED =
CheckDevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED;
static constexpr StatusCode CONTROLLER_DEVICE_DEPROVISIONED =
CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
static constexpr StatusCode INVALID_CONTROLLER_DEVICE_IDENTITY =
CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY;
static inline bool StatusCode_IsValid(int value) {
return CheckDevicePairingResponse_StatusCode_IsValid(value);
}
static constexpr StatusCode StatusCode_MIN =
CheckDevicePairingResponse_StatusCode_StatusCode_MIN;
static constexpr StatusCode StatusCode_MAX =
CheckDevicePairingResponse_StatusCode_StatusCode_MAX;
static constexpr int StatusCode_ARRAYSIZE =
CheckDevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE;
template<typename T>
static inline const std::string& StatusCode_Name(T enum_t_value) {
static_assert(::std::is_same<T, StatusCode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function StatusCode_Name.");
return CheckDevicePairingResponse_StatusCode_Name(enum_t_value);
}
static inline bool StatusCode_Parse(const std::string& name,
StatusCode* value) {
return CheckDevicePairingResponse_StatusCode_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kStatusCodeFieldNumber = 1,
};
// optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
bool has_status_code() const;
void clear_status_code();
::enterprise_management::CheckDevicePairingResponse_StatusCode status_code() const;
void set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value);

// @@protoc_insertion_point(class_scope:enterprise_management.CheckDevicePairingResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int status_code_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RemoteCommand :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RemoteCommand) */ {
public:
RemoteCommand();
virtual ~RemoteCommand();

RemoteCommand(const RemoteCommand& from);
RemoteCommand(RemoteCommand&& from) noexcept
: RemoteCommand() {
*this = ::std::move(from);
}

inline RemoteCommand& operator=(const RemoteCommand& from) {
CopyFrom(from);
return *this;
}
inline RemoteCommand& operator=(RemoteCommand&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const RemoteCommand& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const RemoteCommand* internal_default_instance() {
return reinterpret_cast<const RemoteCommand*>(
&_RemoteCommand_default_instance_);
}
static constexpr int kIndexInFileMessages =
96;

friend void swap(RemoteCommand& a, RemoteCommand& b) {
a.Swap(&b);
}
inline void Swap(RemoteCommand* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline RemoteCommand* New() const final {
return CreateMaybeMessage<RemoteCommand>(nullptr);
}

RemoteCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<RemoteCommand>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const RemoteCommand& from);
void MergeFrom(const RemoteCommand& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RemoteCommand* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.RemoteCommand";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef RemoteCommand_Type Type;
static constexpr Type COMMAND_ECHO_TEST =
RemoteCommand_Type_COMMAND_ECHO_TEST;
static constexpr Type DEVICE_REBOOT =
RemoteCommand_Type_DEVICE_REBOOT;
static constexpr Type DEVICE_SCREENSHOT =
RemoteCommand_Type_DEVICE_SCREENSHOT;
static constexpr Type DEVICE_SET_VOLUME =
RemoteCommand_Type_DEVICE_SET_VOLUME;
static constexpr Type DEVICE_FETCH_STATUS =
RemoteCommand_Type_DEVICE_FETCH_STATUS;
static constexpr Type USER_ARC_COMMAND =
RemoteCommand_Type_USER_ARC_COMMAND;
static constexpr Type DEVICE_WIPE_USERS =
RemoteCommand_Type_DEVICE_WIPE_USERS;
static constexpr Type DEVICE_START_CRD_SESSION =
RemoteCommand_Type_DEVICE_START_CRD_SESSION;
static constexpr Type DEVICE_REMOTE_POWERWASH =
RemoteCommand_Type_DEVICE_REMOTE_POWERWASH;
static constexpr Type DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE =
RemoteCommand_Type_DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE;
static constexpr Type DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES =
RemoteCommand_Type_DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES;
static constexpr Type DEVICE_RUN_DIAGNOSTIC_ROUTINE =
RemoteCommand_Type_DEVICE_RUN_DIAGNOSTIC_ROUTINE;
static constexpr Type DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE =
RemoteCommand_Type_DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE;
static inline bool Type_IsValid(int value) {
return RemoteCommand_Type_IsValid(value);
}
static constexpr Type Type_MIN =
RemoteCommand_Type_Type_MIN;
static constexpr Type Type_MAX =
RemoteCommand_Type_Type_MAX;
static constexpr int Type_ARRAYSIZE =
RemoteCommand_Type_Type_ARRAYSIZE;
template<typename T>
static inline const std::string& Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Type_Name.");
return RemoteCommand_Type_Name(enum_t_value);
}
static inline bool Type_Parse(const std::string& name,
Type* value) {
return RemoteCommand_Type_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPayloadFieldNumber = 4,
kTargetDeviceIdFieldNumber = 5,
kCommandIdFieldNumber = 2,
kAgeOfCommandFieldNumber = 3,
kTypeFieldNumber = 1,
};
// optional string payload = 4;
bool has_payload() const;
void clear_payload();
const std::string& payload() const;
void set_payload(const std::string& value);
void set_payload(std::string&& value);
void set_payload(const char* value);
void set_payload(const char* value, size_t size);
std::string* mutable_payload();
std::string* release_payload();
void set_allocated_payload(std::string* payload);

// optional string target_device_id = 5;
bool has_target_device_id() const;
void clear_target_device_id();
const std::string& target_device_id() const;
void set_target_device_id(const std::string& value);
void set_target_device_id(std::string&& value);
void set_target_device_id(const char* value);
void set_target_device_id(const char* value, size_t size);
std::string* mutable_target_device_id();
std::string* release_target_device_id();
void set_allocated_target_device_id(std::string* target_device_id);

// optional int64 command_id = 2;
bool has_command_id() const;
void clear_command_id();
::PROTOBUF_NAMESPACE_ID::int64 command_id() const;
void set_command_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 age_of_command = 3;
bool has_age_of_command() const;
void clear_age_of_command();
::PROTOBUF_NAMESPACE_ID::int64 age_of_command() const;
void set_age_of_command(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.RemoteCommand.Type type = 1;
bool has_type() const;
void clear_type();
::enterprise_management::RemoteCommand_Type type() const;
void set_type(::enterprise_management::RemoteCommand_Type value);

// @@protoc_insertion_point(class_scope:enterprise_management.RemoteCommand)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_device_id_;
::PROTOBUF_NAMESPACE_ID::int64 command_id_;
::PROTOBUF_NAMESPACE_ID::int64 age_of_command_;
int type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RemoteCommandResult :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RemoteCommandResult) */ {
public:
RemoteCommandResult();
virtual ~RemoteCommandResult();

RemoteCommandResult(const RemoteCommandResult& from);
RemoteCommandResult(RemoteCommandResult&& from) noexcept
: RemoteCommandResult() {
*this = ::std::move(from);
}

inline RemoteCommandResult& operator=(const RemoteCommandResult& from) {
CopyFrom(from);
return *this;
}
inline RemoteCommandResult& operator=(RemoteCommandResult&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const RemoteCommandResult& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const RemoteCommandResult* internal_default_instance() {
return reinterpret_cast<const RemoteCommandResult*>(
&_RemoteCommandResult_default_instance_);
}
static constexpr int kIndexInFileMessages =
97;

friend void swap(RemoteCommandResult& a, RemoteCommandResult& b) {
a.Swap(&b);
}
inline void Swap(RemoteCommandResult* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline RemoteCommandResult* New() const final {
return CreateMaybeMessage<RemoteCommandResult>(nullptr);
}

RemoteCommandResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<RemoteCommandResult>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const RemoteCommandResult& from);
void MergeFrom(const RemoteCommandResult& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RemoteCommandResult* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.RemoteCommandResult";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef RemoteCommandResult_ResultType ResultType;
static constexpr ResultType RESULT_IGNORED =
RemoteCommandResult_ResultType_RESULT_IGNORED;
static constexpr ResultType RESULT_FAILURE =
RemoteCommandResult_ResultType_RESULT_FAILURE;
static constexpr ResultType RESULT_SUCCESS =
RemoteCommandResult_ResultType_RESULT_SUCCESS;
static inline bool ResultType_IsValid(int value) {
return RemoteCommandResult_ResultType_IsValid(value);
}
static constexpr ResultType ResultType_MIN =
RemoteCommandResult_ResultType_ResultType_MIN;
static constexpr ResultType ResultType_MAX =
RemoteCommandResult_ResultType_ResultType_MAX;
static constexpr int ResultType_ARRAYSIZE =
RemoteCommandResult_ResultType_ResultType_ARRAYSIZE;
template<typename T>
static inline const std::string& ResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, ResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ResultType_Name.");
return RemoteCommandResult_ResultType_Name(enum_t_value);
}
static inline bool ResultType_Parse(const std::string& name,
ResultType* value) {
return RemoteCommandResult_ResultType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPayloadFieldNumber = 4,
kCommandIdFieldNumber = 2,
kTimestampFieldNumber = 3,
kResultFieldNumber = 1,
};
// optional string payload = 4;
bool has_payload() const;
void clear_payload();
const std::string& payload() const;
void set_payload(const std::string& value);
void set_payload(std::string&& value);
void set_payload(const char* value);
void set_payload(const char* value, size_t size);
std::string* mutable_payload();
std::string* release_payload();
void set_allocated_payload(std::string* payload);

// optional int64 command_id = 2;
bool has_command_id() const;
void clear_command_id();
::PROTOBUF_NAMESPACE_ID::int64 command_id() const;
void set_command_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 timestamp = 3;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
bool has_result() const;
void clear_result();
::enterprise_management::RemoteCommandResult_ResultType result() const;
void set_result(::enterprise_management::RemoteCommandResult_ResultType value);

// @@protoc_insertion_point(class_scope:enterprise_management.RemoteCommandResult)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
::PROTOBUF_NAMESPACE_ID::int64 command_id_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
int result_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRemoteCommandRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRemoteCommandRequest) */ {
public:
DeviceRemoteCommandRequest();
virtual ~DeviceRemoteCommandRequest();

DeviceRemoteCommandRequest(const DeviceRemoteCommandRequest& from);
DeviceRemoteCommandRequest(DeviceRemoteCommandRequest&& from) noexcept
: DeviceRemoteCommandRequest() {
*this = ::std::move(from);
}

inline DeviceRemoteCommandRequest& operator=(const DeviceRemoteCommandRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceRemoteCommandRequest& operator=(DeviceRemoteCommandRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceRemoteCommandRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceRemoteCommandRequest* internal_default_instance() {
return reinterpret_cast<const DeviceRemoteCommandRequest*>(
&_DeviceRemoteCommandRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
98;

friend void swap(DeviceRemoteCommandRequest& a, DeviceRemoteCommandRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceRemoteCommandRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceRemoteCommandRequest* New() const final {
return CreateMaybeMessage<DeviceRemoteCommandRequest>(nullptr);
}

DeviceRemoteCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceRemoteCommandRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceRemoteCommandRequest& from);
void MergeFrom(const DeviceRemoteCommandRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceRemoteCommandRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceRemoteCommandRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kCommandResultsFieldNumber = 2,
kLastCommandUniqueIdFieldNumber = 1,
kSendSecureCommandsFieldNumber = 3,
kSignatureTypeFieldNumber = 4,
};
// repeated .enterprise_management.RemoteCommandResult command_results = 2;
int command_results_size() const;
void clear_command_results();
::enterprise_management::RemoteCommandResult* mutable_command_results(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >*
mutable_command_results();
const ::enterprise_management::RemoteCommandResult& command_results(int index) const;
::enterprise_management::RemoteCommandResult* add_command_results();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >&
command_results() const;

// optional int64 last_command_unique_id = 1;
bool has_last_command_unique_id() const;
void clear_last_command_unique_id();
::PROTOBUF_NAMESPACE_ID::int64 last_command_unique_id() const;
void set_last_command_unique_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional bool send_secure_commands = 3;
bool has_send_secure_commands() const;
void clear_send_secure_commands();
bool send_secure_commands() const;
void set_send_secure_commands(bool value);

// optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 4;
bool has_signature_type() const;
void clear_signature_type();
::enterprise_management::PolicyFetchRequest_SignatureType signature_type() const;
void set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceRemoteCommandRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult > command_results_;
::PROTOBUF_NAMESPACE_ID::int64 last_command_unique_id_;
bool send_secure_commands_;
int signature_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRemoteCommandResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRemoteCommandResponse) */ {
public:
DeviceRemoteCommandResponse();
virtual ~DeviceRemoteCommandResponse();

DeviceRemoteCommandResponse(const DeviceRemoteCommandResponse& from);
DeviceRemoteCommandResponse(DeviceRemoteCommandResponse&& from) noexcept
: DeviceRemoteCommandResponse() {
*this = ::std::move(from);
}

inline DeviceRemoteCommandResponse& operator=(const DeviceRemoteCommandResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceRemoteCommandResponse& operator=(DeviceRemoteCommandResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceRemoteCommandResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceRemoteCommandResponse* internal_default_instance() {
return reinterpret_cast<const DeviceRemoteCommandResponse*>(
&_DeviceRemoteCommandResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
99;

friend void swap(DeviceRemoteCommandResponse& a, DeviceRemoteCommandResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceRemoteCommandResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceRemoteCommandResponse* New() const final {
return CreateMaybeMessage<DeviceRemoteCommandResponse>(nullptr);
}

DeviceRemoteCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceRemoteCommandResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceRemoteCommandResponse& from);
void MergeFrom(const DeviceRemoteCommandResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceRemoteCommandResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceRemoteCommandResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kCommandsFieldNumber = 1,
kSecureCommandsFieldNumber = 2,
};
// repeated .enterprise_management.RemoteCommand commands = 1;
int commands_size() const;
void clear_commands();
::enterprise_management::RemoteCommand* mutable_commands(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >*
mutable_commands();
const ::enterprise_management::RemoteCommand& commands(int index) const;
::enterprise_management::RemoteCommand* add_commands();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >&
commands() const;

// repeated .enterprise_management.SignedData secure_commands = 2;
int secure_commands_size() const;
void clear_secure_commands();
::enterprise_management::SignedData* mutable_secure_commands(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >*
mutable_secure_commands();
const ::enterprise_management::SignedData& secure_commands(int index) const;
::enterprise_management::SignedData* add_secure_commands();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >&
secure_commands() const;

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceRemoteCommandResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand > commands_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData > secure_commands_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdatePermissionRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdatePermissionRequest) */ {
public:
DeviceAttributeUpdatePermissionRequest();
virtual ~DeviceAttributeUpdatePermissionRequest();

DeviceAttributeUpdatePermissionRequest(const DeviceAttributeUpdatePermissionRequest& from);
DeviceAttributeUpdatePermissionRequest(DeviceAttributeUpdatePermissionRequest&& from) noexcept
: DeviceAttributeUpdatePermissionRequest() {
*this = ::std::move(from);
}

inline DeviceAttributeUpdatePermissionRequest& operator=(const DeviceAttributeUpdatePermissionRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceAttributeUpdatePermissionRequest& operator=(DeviceAttributeUpdatePermissionRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceAttributeUpdatePermissionRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceAttributeUpdatePermissionRequest* internal_default_instance() {
return reinterpret_cast<const DeviceAttributeUpdatePermissionRequest*>(
&_DeviceAttributeUpdatePermissionRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
100;

friend void swap(DeviceAttributeUpdatePermissionRequest& a, DeviceAttributeUpdatePermissionRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceAttributeUpdatePermissionRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceAttributeUpdatePermissionRequest* New() const final {
return CreateMaybeMessage<DeviceAttributeUpdatePermissionRequest>(nullptr);
}

DeviceAttributeUpdatePermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceAttributeUpdatePermissionRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceAttributeUpdatePermissionRequest& from);
void MergeFrom(const DeviceAttributeUpdatePermissionRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceAttributeUpdatePermissionRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceAttributeUpdatePermissionRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdatePermissionRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdatePermissionResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdatePermissionResponse) */ {
public:
DeviceAttributeUpdatePermissionResponse();
virtual ~DeviceAttributeUpdatePermissionResponse();

DeviceAttributeUpdatePermissionResponse(const DeviceAttributeUpdatePermissionResponse& from);
DeviceAttributeUpdatePermissionResponse(DeviceAttributeUpdatePermissionResponse&& from) noexcept
: DeviceAttributeUpdatePermissionResponse() {
*this = ::std::move(from);
}

inline DeviceAttributeUpdatePermissionResponse& operator=(const DeviceAttributeUpdatePermissionResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceAttributeUpdatePermissionResponse& operator=(DeviceAttributeUpdatePermissionResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceAttributeUpdatePermissionResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceAttributeUpdatePermissionResponse* internal_default_instance() {
return reinterpret_cast<const DeviceAttributeUpdatePermissionResponse*>(
&_DeviceAttributeUpdatePermissionResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
101;

friend void swap(DeviceAttributeUpdatePermissionResponse& a, DeviceAttributeUpdatePermissionResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceAttributeUpdatePermissionResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceAttributeUpdatePermissionResponse* New() const final {
return CreateMaybeMessage<DeviceAttributeUpdatePermissionResponse>(nullptr);
}

DeviceAttributeUpdatePermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceAttributeUpdatePermissionResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceAttributeUpdatePermissionResponse& from);
void MergeFrom(const DeviceAttributeUpdatePermissionResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceAttributeUpdatePermissionResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceAttributeUpdatePermissionResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceAttributeUpdatePermissionResponse_ResultType ResultType;
static constexpr ResultType ATTRIBUTE_UPDATE_DISALLOWED =
DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED;
static constexpr ResultType ATTRIBUTE_UPDATE_ALLOWED =
DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED;
static inline bool ResultType_IsValid(int value) {
return DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(value);
}
static constexpr ResultType ResultType_MIN =
DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MIN;
static constexpr ResultType ResultType_MAX =
DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX;
static constexpr int ResultType_ARRAYSIZE =
DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_ARRAYSIZE;
template<typename T>
static inline const std::string& ResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, ResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ResultType_Name.");
return DeviceAttributeUpdatePermissionResponse_ResultType_Name(enum_t_value);
}
static inline bool ResultType_Parse(const std::string& name,
ResultType* value) {
return DeviceAttributeUpdatePermissionResponse_ResultType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kResultFieldNumber = 1,
};
// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
bool has_result() const;
void clear_result();
::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType result() const;
void set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdatePermissionResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int result_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdateRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdateRequest) */ {
public:
DeviceAttributeUpdateRequest();
virtual ~DeviceAttributeUpdateRequest();

DeviceAttributeUpdateRequest(const DeviceAttributeUpdateRequest& from);
DeviceAttributeUpdateRequest(DeviceAttributeUpdateRequest&& from) noexcept
: DeviceAttributeUpdateRequest() {
*this = ::std::move(from);
}

inline DeviceAttributeUpdateRequest& operator=(const DeviceAttributeUpdateRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceAttributeUpdateRequest& operator=(DeviceAttributeUpdateRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceAttributeUpdateRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceAttributeUpdateRequest* internal_default_instance() {
return reinterpret_cast<const DeviceAttributeUpdateRequest*>(
&_DeviceAttributeUpdateRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
102;

friend void swap(DeviceAttributeUpdateRequest& a, DeviceAttributeUpdateRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceAttributeUpdateRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceAttributeUpdateRequest* New() const final {
return CreateMaybeMessage<DeviceAttributeUpdateRequest>(nullptr);
}

DeviceAttributeUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceAttributeUpdateRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceAttributeUpdateRequest& from);
void MergeFrom(const DeviceAttributeUpdateRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceAttributeUpdateRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceAttributeUpdateRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAssetIdFieldNumber = 1,
kLocationFieldNumber = 2,
};
// optional string asset_id = 1;
bool has_asset_id() const;
void clear_asset_id();
const std::string& asset_id() const;
void set_asset_id(const std::string& value);
void set_asset_id(std::string&& value);
void set_asset_id(const char* value);
void set_asset_id(const char* value, size_t size);
std::string* mutable_asset_id();
std::string* release_asset_id();
void set_allocated_asset_id(std::string* asset_id);

// optional string location = 2;
bool has_location() const;
void clear_location();
const std::string& location() const;
void set_location(const std::string& value);
void set_location(std::string&& value);
void set_location(const char* value);
void set_location(const char* value, size_t size);
std::string* mutable_location();
std::string* release_location();
void set_allocated_location(std::string* location);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdateRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdateResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdateResponse) */ {
public:
DeviceAttributeUpdateResponse();
virtual ~DeviceAttributeUpdateResponse();

DeviceAttributeUpdateResponse(const DeviceAttributeUpdateResponse& from);
DeviceAttributeUpdateResponse(DeviceAttributeUpdateResponse&& from) noexcept
: DeviceAttributeUpdateResponse() {
*this = ::std::move(from);
}

inline DeviceAttributeUpdateResponse& operator=(const DeviceAttributeUpdateResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceAttributeUpdateResponse& operator=(DeviceAttributeUpdateResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceAttributeUpdateResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceAttributeUpdateResponse* internal_default_instance() {
return reinterpret_cast<const DeviceAttributeUpdateResponse*>(
&_DeviceAttributeUpdateResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
103;

friend void swap(DeviceAttributeUpdateResponse& a, DeviceAttributeUpdateResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceAttributeUpdateResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceAttributeUpdateResponse* New() const final {
return CreateMaybeMessage<DeviceAttributeUpdateResponse>(nullptr);
}

DeviceAttributeUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceAttributeUpdateResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceAttributeUpdateResponse& from);
void MergeFrom(const DeviceAttributeUpdateResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceAttributeUpdateResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceAttributeUpdateResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef DeviceAttributeUpdateResponse_ResultType ResultType;
static constexpr ResultType ATTRIBUTE_UPDATE_ERROR =
DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR;
static constexpr ResultType ATTRIBUTE_UPDATE_SUCCESS =
DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS;
static inline bool ResultType_IsValid(int value) {
return DeviceAttributeUpdateResponse_ResultType_IsValid(value);
}
static constexpr ResultType ResultType_MIN =
DeviceAttributeUpdateResponse_ResultType_ResultType_MIN;
static constexpr ResultType ResultType_MAX =
DeviceAttributeUpdateResponse_ResultType_ResultType_MAX;
static constexpr int ResultType_ARRAYSIZE =
DeviceAttributeUpdateResponse_ResultType_ResultType_ARRAYSIZE;
template<typename T>
static inline const std::string& ResultType_Name(T enum_t_value) {
static_assert(::std::is_same<T, ResultType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ResultType_Name.");
return DeviceAttributeUpdateResponse_ResultType_Name(enum_t_value);
}
static inline bool ResultType_Parse(const std::string& name,
ResultType* value) {
return DeviceAttributeUpdateResponse_ResultType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kResultFieldNumber = 1,
};
// optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
bool has_result() const;
void clear_result();
::enterprise_management::DeviceAttributeUpdateResponse_ResultType result() const;
void set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdateResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int result_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT GcmIdUpdateRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GcmIdUpdateRequest) */ {
public:
GcmIdUpdateRequest();
virtual ~GcmIdUpdateRequest();

GcmIdUpdateRequest(const GcmIdUpdateRequest& from);
GcmIdUpdateRequest(GcmIdUpdateRequest&& from) noexcept
: GcmIdUpdateRequest() {
*this = ::std::move(from);
}

inline GcmIdUpdateRequest& operator=(const GcmIdUpdateRequest& from) {
CopyFrom(from);
return *this;
}
inline GcmIdUpdateRequest& operator=(GcmIdUpdateRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const GcmIdUpdateRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const GcmIdUpdateRequest* internal_default_instance() {
return reinterpret_cast<const GcmIdUpdateRequest*>(
&_GcmIdUpdateRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
104;

friend void swap(GcmIdUpdateRequest& a, GcmIdUpdateRequest& b) {
a.Swap(&b);
}
inline void Swap(GcmIdUpdateRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline GcmIdUpdateRequest* New() const final {
return CreateMaybeMessage<GcmIdUpdateRequest>(nullptr);
}

GcmIdUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<GcmIdUpdateRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const GcmIdUpdateRequest& from);
void MergeFrom(const GcmIdUpdateRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(GcmIdUpdateRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.GcmIdUpdateRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kGcmIdFieldNumber = 1,
};
// optional string gcm_id = 1;
bool has_gcm_id() const;
void clear_gcm_id();
const std::string& gcm_id() const;
void set_gcm_id(const std::string& value);
void set_gcm_id(std::string&& value);
void set_gcm_id(const char* value);
void set_gcm_id(const char* value, size_t size);
std::string* mutable_gcm_id();
std::string* release_gcm_id();
void set_allocated_gcm_id(std::string* gcm_id);

// @@protoc_insertion_point(class_scope:enterprise_management.GcmIdUpdateRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gcm_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT GcmIdUpdateResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GcmIdUpdateResponse) */ {
public:
GcmIdUpdateResponse();
virtual ~GcmIdUpdateResponse();

GcmIdUpdateResponse(const GcmIdUpdateResponse& from);
GcmIdUpdateResponse(GcmIdUpdateResponse&& from) noexcept
: GcmIdUpdateResponse() {
*this = ::std::move(from);
}

inline GcmIdUpdateResponse& operator=(const GcmIdUpdateResponse& from) {
CopyFrom(from);
return *this;
}
inline GcmIdUpdateResponse& operator=(GcmIdUpdateResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const GcmIdUpdateResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const GcmIdUpdateResponse* internal_default_instance() {
return reinterpret_cast<const GcmIdUpdateResponse*>(
&_GcmIdUpdateResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
105;

friend void swap(GcmIdUpdateResponse& a, GcmIdUpdateResponse& b) {
a.Swap(&b);
}
inline void Swap(GcmIdUpdateResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline GcmIdUpdateResponse* New() const final {
return CreateMaybeMessage<GcmIdUpdateResponse>(nullptr);
}

GcmIdUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<GcmIdUpdateResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const GcmIdUpdateResponse& from);
void MergeFrom(const GcmIdUpdateResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(GcmIdUpdateResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.GcmIdUpdateResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.GcmIdUpdateResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckAndroidManagementRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckAndroidManagementRequest) */ {
public:
CheckAndroidManagementRequest();
virtual ~CheckAndroidManagementRequest();

CheckAndroidManagementRequest(const CheckAndroidManagementRequest& from);
CheckAndroidManagementRequest(CheckAndroidManagementRequest&& from) noexcept
: CheckAndroidManagementRequest() {
*this = ::std::move(from);
}

inline CheckAndroidManagementRequest& operator=(const CheckAndroidManagementRequest& from) {
CopyFrom(from);
return *this;
}
inline CheckAndroidManagementRequest& operator=(CheckAndroidManagementRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CheckAndroidManagementRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CheckAndroidManagementRequest* internal_default_instance() {
return reinterpret_cast<const CheckAndroidManagementRequest*>(
&_CheckAndroidManagementRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
106;

friend void swap(CheckAndroidManagementRequest& a, CheckAndroidManagementRequest& b) {
a.Swap(&b);
}
inline void Swap(CheckAndroidManagementRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CheckAndroidManagementRequest* New() const final {
return CreateMaybeMessage<CheckAndroidManagementRequest>(nullptr);
}

CheckAndroidManagementRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CheckAndroidManagementRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CheckAndroidManagementRequest& from);
void MergeFrom(const CheckAndroidManagementRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CheckAndroidManagementRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CheckAndroidManagementRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.CheckAndroidManagementRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckAndroidManagementResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckAndroidManagementResponse) */ {
public:
CheckAndroidManagementResponse();
virtual ~CheckAndroidManagementResponse();

CheckAndroidManagementResponse(const CheckAndroidManagementResponse& from);
CheckAndroidManagementResponse(CheckAndroidManagementResponse&& from) noexcept
: CheckAndroidManagementResponse() {
*this = ::std::move(from);
}

inline CheckAndroidManagementResponse& operator=(const CheckAndroidManagementResponse& from) {
CopyFrom(from);
return *this;
}
inline CheckAndroidManagementResponse& operator=(CheckAndroidManagementResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CheckAndroidManagementResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CheckAndroidManagementResponse* internal_default_instance() {
return reinterpret_cast<const CheckAndroidManagementResponse*>(
&_CheckAndroidManagementResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
107;

friend void swap(CheckAndroidManagementResponse& a, CheckAndroidManagementResponse& b) {
a.Swap(&b);
}
inline void Swap(CheckAndroidManagementResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CheckAndroidManagementResponse* New() const final {
return CreateMaybeMessage<CheckAndroidManagementResponse>(nullptr);
}

CheckAndroidManagementResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CheckAndroidManagementResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CheckAndroidManagementResponse& from);
void MergeFrom(const CheckAndroidManagementResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CheckAndroidManagementResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CheckAndroidManagementResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.CheckAndroidManagementResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CertificateBasedDeviceRegisterRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertificateBasedDeviceRegisterRequest) */ {
public:
CertificateBasedDeviceRegisterRequest();
virtual ~CertificateBasedDeviceRegisterRequest();

CertificateBasedDeviceRegisterRequest(const CertificateBasedDeviceRegisterRequest& from);
CertificateBasedDeviceRegisterRequest(CertificateBasedDeviceRegisterRequest&& from) noexcept
: CertificateBasedDeviceRegisterRequest() {
*this = ::std::move(from);
}

inline CertificateBasedDeviceRegisterRequest& operator=(const CertificateBasedDeviceRegisterRequest& from) {
CopyFrom(from);
return *this;
}
inline CertificateBasedDeviceRegisterRequest& operator=(CertificateBasedDeviceRegisterRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CertificateBasedDeviceRegisterRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CertificateBasedDeviceRegisterRequest* internal_default_instance() {
return reinterpret_cast<const CertificateBasedDeviceRegisterRequest*>(
&_CertificateBasedDeviceRegisterRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
108;

friend void swap(CertificateBasedDeviceRegisterRequest& a, CertificateBasedDeviceRegisterRequest& b) {
a.Swap(&b);
}
inline void Swap(CertificateBasedDeviceRegisterRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CertificateBasedDeviceRegisterRequest* New() const final {
return CreateMaybeMessage<CertificateBasedDeviceRegisterRequest>(nullptr);
}

CertificateBasedDeviceRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CertificateBasedDeviceRegisterRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CertificateBasedDeviceRegisterRequest& from);
void MergeFrom(const CertificateBasedDeviceRegisterRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CertificateBasedDeviceRegisterRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CertificateBasedDeviceRegisterRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSignedRequestFieldNumber = 1,
};
// optional .enterprise_management.SignedData signed_request = 1;
bool has_signed_request() const;
void clear_signed_request();
const ::enterprise_management::SignedData& signed_request() const;
::enterprise_management::SignedData* release_signed_request();
::enterprise_management::SignedData* mutable_signed_request();
void set_allocated_signed_request(::enterprise_management::SignedData* signed_request);

// @@protoc_insertion_point(class_scope:enterprise_management.CertificateBasedDeviceRegisterRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::enterprise_management::SignedData* signed_request_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRegisterConfiguration :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterConfiguration) */ {
public:
DeviceRegisterConfiguration();
virtual ~DeviceRegisterConfiguration();

DeviceRegisterConfiguration(const DeviceRegisterConfiguration& from);
DeviceRegisterConfiguration(DeviceRegisterConfiguration&& from) noexcept
: DeviceRegisterConfiguration() {
*this = ::std::move(from);
}

inline DeviceRegisterConfiguration& operator=(const DeviceRegisterConfiguration& from) {
CopyFrom(from);
return *this;
}
inline DeviceRegisterConfiguration& operator=(DeviceRegisterConfiguration&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceRegisterConfiguration& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceRegisterConfiguration* internal_default_instance() {
return reinterpret_cast<const DeviceRegisterConfiguration*>(
&_DeviceRegisterConfiguration_default_instance_);
}
static constexpr int kIndexInFileMessages =
109;

friend void swap(DeviceRegisterConfiguration& a, DeviceRegisterConfiguration& b) {
a.Swap(&b);
}
inline void Swap(DeviceRegisterConfiguration* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceRegisterConfiguration* New() const final {
return CreateMaybeMessage<DeviceRegisterConfiguration>(nullptr);
}

DeviceRegisterConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceRegisterConfiguration>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceRegisterConfiguration& from);
void MergeFrom(const DeviceRegisterConfiguration& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceRegisterConfiguration* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceRegisterConfiguration";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kDeviceOwnerFieldNumber = 1,
};
// optional string device_owner = 1;
bool has_device_owner() const;
void clear_device_owner();
const std::string& device_owner() const;
void set_device_owner(const std::string& value);
void set_device_owner(std::string&& value);
void set_device_owner(const char* value);
void set_device_owner(const char* value, size_t size);
std::string* mutable_device_owner();
std::string* release_device_owner();
void set_allocated_device_owner(std::string* device_owner);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterConfiguration)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_owner_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CertificateBasedDeviceRegistrationData :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertificateBasedDeviceRegistrationData) */ {
public:
CertificateBasedDeviceRegistrationData();
virtual ~CertificateBasedDeviceRegistrationData();

CertificateBasedDeviceRegistrationData(const CertificateBasedDeviceRegistrationData& from);
CertificateBasedDeviceRegistrationData(CertificateBasedDeviceRegistrationData&& from) noexcept
: CertificateBasedDeviceRegistrationData() {
*this = ::std::move(from);
}

inline CertificateBasedDeviceRegistrationData& operator=(const CertificateBasedDeviceRegistrationData& from) {
CopyFrom(from);
return *this;
}
inline CertificateBasedDeviceRegistrationData& operator=(CertificateBasedDeviceRegistrationData&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CertificateBasedDeviceRegistrationData& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CertificateBasedDeviceRegistrationData* internal_default_instance() {
return reinterpret_cast<const CertificateBasedDeviceRegistrationData*>(
&_CertificateBasedDeviceRegistrationData_default_instance_);
}
static constexpr int kIndexInFileMessages =
110;

friend void swap(CertificateBasedDeviceRegistrationData& a, CertificateBasedDeviceRegistrationData& b) {
a.Swap(&b);
}
inline void Swap(CertificateBasedDeviceRegistrationData* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CertificateBasedDeviceRegistrationData* New() const final {
return CreateMaybeMessage<CertificateBasedDeviceRegistrationData>(nullptr);
}

CertificateBasedDeviceRegistrationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CertificateBasedDeviceRegistrationData>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CertificateBasedDeviceRegistrationData& from);
void MergeFrom(const CertificateBasedDeviceRegistrationData& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CertificateBasedDeviceRegistrationData* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CertificateBasedDeviceRegistrationData";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef CertificateBasedDeviceRegistrationData_CertificateType CertificateType;
static constexpr CertificateType UNKNOWN =
CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN;
static constexpr CertificateType ENTERPRISE_ENROLLMENT_CERTIFICATE =
CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
static inline bool CertificateType_IsValid(int value) {
return CertificateBasedDeviceRegistrationData_CertificateType_IsValid(value);
}
static constexpr CertificateType CertificateType_MIN =
CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MIN;
static constexpr CertificateType CertificateType_MAX =
CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX;
static constexpr int CertificateType_ARRAYSIZE =
CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_ARRAYSIZE;
template<typename T>
static inline const std::string& CertificateType_Name(T enum_t_value) {
static_assert(::std::is_same<T, CertificateType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function CertificateType_Name.");
return CertificateBasedDeviceRegistrationData_CertificateType_Name(enum_t_value);
}
static inline bool CertificateType_Parse(const std::string& name,
CertificateType* value) {
return CertificateBasedDeviceRegistrationData_CertificateType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kDeviceCertificateFieldNumber = 2,
kDeviceRegisterRequestFieldNumber = 3,
kDeviceRegisterConfigurationFieldNumber = 4,
kCertificateTypeFieldNumber = 1,
};
// optional bytes device_certificate = 2;
bool has_device_certificate() const;
void clear_device_certificate();
const std::string& device_certificate() const;
void set_device_certificate(const std::string& value);
void set_device_certificate(std::string&& value);
void set_device_certificate(const char* value);
void set_device_certificate(const void* value, size_t size);
std::string* mutable_device_certificate();
std::string* release_device_certificate();
void set_allocated_device_certificate(std::string* device_certificate);

// optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
bool has_device_register_request() const;
void clear_device_register_request();
const ::enterprise_management::DeviceRegisterRequest& device_register_request() const;
::enterprise_management::DeviceRegisterRequest* release_device_register_request();
::enterprise_management::DeviceRegisterRequest* mutable_device_register_request();
void set_allocated_device_register_request(::enterprise_management::DeviceRegisterRequest* device_register_request);

// optional .enterprise_management.DeviceRegisterConfiguration device_register_configuration = 4;
bool has_device_register_configuration() const;
void clear_device_register_configuration();
const ::enterprise_management::DeviceRegisterConfiguration& device_register_configuration() const;
::enterprise_management::DeviceRegisterConfiguration* release_device_register_configuration();
::enterprise_management::DeviceRegisterConfiguration* mutable_device_register_configuration();
void set_allocated_device_register_configuration(::enterprise_management::DeviceRegisterConfiguration* device_register_configuration);

// optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
bool has_certificate_type() const;
void clear_certificate_type();
::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType certificate_type() const;
void set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value);

// @@protoc_insertion_point(class_scope:enterprise_management.CertificateBasedDeviceRegistrationData)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_certificate_;
::enterprise_management::DeviceRegisterRequest* device_register_request_;
::enterprise_management::DeviceRegisterConfiguration* device_register_configuration_;
int certificate_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RegisterBrowserRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RegisterBrowserRequest) */ {
public:
RegisterBrowserRequest();
virtual ~RegisterBrowserRequest();

RegisterBrowserRequest(const RegisterBrowserRequest& from);
RegisterBrowserRequest(RegisterBrowserRequest&& from) noexcept
: RegisterBrowserRequest() {
*this = ::std::move(from);
}

inline RegisterBrowserRequest& operator=(const RegisterBrowserRequest& from) {
CopyFrom(from);
return *this;
}
inline RegisterBrowserRequest& operator=(RegisterBrowserRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const RegisterBrowserRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const RegisterBrowserRequest* internal_default_instance() {
return reinterpret_cast<const RegisterBrowserRequest*>(
&_RegisterBrowserRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
111;

friend void swap(RegisterBrowserRequest& a, RegisterBrowserRequest& b) {
a.Swap(&b);
}
inline void Swap(RegisterBrowserRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline RegisterBrowserRequest* New() const final {
return CreateMaybeMessage<RegisterBrowserRequest>(nullptr);
}

RegisterBrowserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<RegisterBrowserRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const RegisterBrowserRequest& from);
void MergeFrom(const RegisterBrowserRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RegisterBrowserRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.RegisterBrowserRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kMachineNameFieldNumber = 1,
kOsPlatformFieldNumber = 2,
kOsVersionFieldNumber = 3,
};
// optional string machine_name = 1;
bool has_machine_name() const;
void clear_machine_name();
const std::string& machine_name() const;
void set_machine_name(const std::string& value);
void set_machine_name(std::string&& value);
void set_machine_name(const char* value);
void set_machine_name(const char* value, size_t size);
std::string* mutable_machine_name();
std::string* release_machine_name();
void set_allocated_machine_name(std::string* machine_name);

// optional string os_platform = 2;
bool has_os_platform() const;
void clear_os_platform();
const std::string& os_platform() const;
void set_os_platform(const std::string& value);
void set_os_platform(std::string&& value);
void set_os_platform(const char* value);
void set_os_platform(const char* value, size_t size);
std::string* mutable_os_platform();
std::string* release_os_platform();
void set_allocated_os_platform(std::string* os_platform);

// optional string os_version = 3;
bool has_os_version() const;
void clear_os_version();
const std::string& os_version() const;
void set_os_version(const std::string& value);
void set_os_version(std::string&& value);
void set_os_version(const char* value);
void set_os_version(const char* value, size_t size);
std::string* mutable_os_version();
std::string* release_os_version();
void set_allocated_os_version(std::string* os_version);

// @@protoc_insertion_point(class_scope:enterprise_management.RegisterBrowserRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_platform_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveDirectoryEnrollPlayUserRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryEnrollPlayUserRequest) */ {
public:
ActiveDirectoryEnrollPlayUserRequest();
virtual ~ActiveDirectoryEnrollPlayUserRequest();

ActiveDirectoryEnrollPlayUserRequest(const ActiveDirectoryEnrollPlayUserRequest& from);
ActiveDirectoryEnrollPlayUserRequest(ActiveDirectoryEnrollPlayUserRequest&& from) noexcept
: ActiveDirectoryEnrollPlayUserRequest() {
*this = ::std::move(from);
}

inline ActiveDirectoryEnrollPlayUserRequest& operator=(const ActiveDirectoryEnrollPlayUserRequest& from) {
CopyFrom(from);
return *this;
}
inline ActiveDirectoryEnrollPlayUserRequest& operator=(ActiveDirectoryEnrollPlayUserRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ActiveDirectoryEnrollPlayUserRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ActiveDirectoryEnrollPlayUserRequest* internal_default_instance() {
return reinterpret_cast<const ActiveDirectoryEnrollPlayUserRequest*>(
&_ActiveDirectoryEnrollPlayUserRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
112;

friend void swap(ActiveDirectoryEnrollPlayUserRequest& a, ActiveDirectoryEnrollPlayUserRequest& b) {
a.Swap(&b);
}
inline void Swap(ActiveDirectoryEnrollPlayUserRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ActiveDirectoryEnrollPlayUserRequest* New() const final {
return CreateMaybeMessage<ActiveDirectoryEnrollPlayUserRequest>(nullptr);
}

ActiveDirectoryEnrollPlayUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ActiveDirectoryEnrollPlayUserRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ActiveDirectoryEnrollPlayUserRequest& from);
void MergeFrom(const ActiveDirectoryEnrollPlayUserRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ActiveDirectoryEnrollPlayUserRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ActiveDirectoryEnrollPlayUserRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAuthSessionIdFieldNumber = 1,
};
// optional string auth_session_id = 1;
bool has_auth_session_id() const;
void clear_auth_session_id();
const std::string& auth_session_id() const;
void set_auth_session_id(const std::string& value);
void set_auth_session_id(std::string&& value);
void set_auth_session_id(const char* value);
void set_auth_session_id(const char* value, size_t size);
std::string* mutable_auth_session_id();
std::string* release_auth_session_id();
void set_allocated_auth_session_id(std::string* auth_session_id);

// @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_session_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveDirectoryEnrollPlayUserResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryEnrollPlayUserResponse) */ {
public:
ActiveDirectoryEnrollPlayUserResponse();
virtual ~ActiveDirectoryEnrollPlayUserResponse();

ActiveDirectoryEnrollPlayUserResponse(const ActiveDirectoryEnrollPlayUserResponse& from);
ActiveDirectoryEnrollPlayUserResponse(ActiveDirectoryEnrollPlayUserResponse&& from) noexcept
: ActiveDirectoryEnrollPlayUserResponse() {
*this = ::std::move(from);
}

inline ActiveDirectoryEnrollPlayUserResponse& operator=(const ActiveDirectoryEnrollPlayUserResponse& from) {
CopyFrom(from);
return *this;
}
inline ActiveDirectoryEnrollPlayUserResponse& operator=(ActiveDirectoryEnrollPlayUserResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ActiveDirectoryEnrollPlayUserResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ActiveDirectoryEnrollPlayUserResponse* internal_default_instance() {
return reinterpret_cast<const ActiveDirectoryEnrollPlayUserResponse*>(
&_ActiveDirectoryEnrollPlayUserResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
113;

friend void swap(ActiveDirectoryEnrollPlayUserResponse& a, ActiveDirectoryEnrollPlayUserResponse& b) {
a.Swap(&b);
}
inline void Swap(ActiveDirectoryEnrollPlayUserResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ActiveDirectoryEnrollPlayUserResponse* New() const final {
return CreateMaybeMessage<ActiveDirectoryEnrollPlayUserResponse>(nullptr);
}

ActiveDirectoryEnrollPlayUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ActiveDirectoryEnrollPlayUserResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ActiveDirectoryEnrollPlayUserResponse& from);
void MergeFrom(const ActiveDirectoryEnrollPlayUserResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ActiveDirectoryEnrollPlayUserResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ActiveDirectoryEnrollPlayUserResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kEnrollmentTokenFieldNumber = 1,
kUserIdFieldNumber = 2,
kSamlParametersFieldNumber = 3,
};
// optional string enrollment_token = 1;
bool has_enrollment_token() const;
void clear_enrollment_token();
const std::string& enrollment_token() const;
void set_enrollment_token(const std::string& value);
void set_enrollment_token(std::string&& value);
void set_enrollment_token(const char* value);
void set_enrollment_token(const char* value, size_t size);
std::string* mutable_enrollment_token();
std::string* release_enrollment_token();
void set_allocated_enrollment_token(std::string* enrollment_token);

// optional string user_id = 2;
bool has_user_id() const;
void clear_user_id();
const std::string& user_id() const;
void set_user_id(const std::string& value);
void set_user_id(std::string&& value);
void set_user_id(const char* value);
void set_user_id(const char* value, size_t size);
std::string* mutable_user_id();
std::string* release_user_id();
void set_allocated_user_id(std::string* user_id);

// optional .enterprise_management.SamlParametersProto saml_parameters = 3;
bool has_saml_parameters() const;
void clear_saml_parameters();
const ::enterprise_management::SamlParametersProto& saml_parameters() const;
::enterprise_management::SamlParametersProto* release_saml_parameters();
::enterprise_management::SamlParametersProto* mutable_saml_parameters();
void set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters);

// @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollment_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
::enterprise_management::SamlParametersProto* saml_parameters_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SamlParametersProto :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SamlParametersProto) */ {
public:
SamlParametersProto();
virtual ~SamlParametersProto();

SamlParametersProto(const SamlParametersProto& from);
SamlParametersProto(SamlParametersProto&& from) noexcept
: SamlParametersProto() {
*this = ::std::move(from);
}

inline SamlParametersProto& operator=(const SamlParametersProto& from) {
CopyFrom(from);
return *this;
}
inline SamlParametersProto& operator=(SamlParametersProto&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SamlParametersProto& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SamlParametersProto* internal_default_instance() {
return reinterpret_cast<const SamlParametersProto*>(
&_SamlParametersProto_default_instance_);
}
static constexpr int kIndexInFileMessages =
114;

friend void swap(SamlParametersProto& a, SamlParametersProto& b) {
a.Swap(&b);
}
inline void Swap(SamlParametersProto* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SamlParametersProto* New() const final {
return CreateMaybeMessage<SamlParametersProto>(nullptr);
}

SamlParametersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SamlParametersProto>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SamlParametersProto& from);
void MergeFrom(const SamlParametersProto& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SamlParametersProto* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.SamlParametersProto";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAuthRedirectUrlFieldNumber = 1,
kAuthSessionIdFieldNumber = 2,
};
// optional string auth_redirect_url = 1;
bool has_auth_redirect_url() const;
void clear_auth_redirect_url();
const std::string& auth_redirect_url() const;
void set_auth_redirect_url(const std::string& value);
void set_auth_redirect_url(std::string&& value);
void set_auth_redirect_url(const char* value);
void set_auth_redirect_url(const char* value, size_t size);
std::string* mutable_auth_redirect_url();
std::string* release_auth_redirect_url();
void set_allocated_auth_redirect_url(std::string* auth_redirect_url);

// optional string auth_session_id = 2;
bool has_auth_session_id() const;
void clear_auth_session_id();
const std::string& auth_session_id() const;
void set_auth_session_id(const std::string& value);
void set_auth_session_id(std::string&& value);
void set_auth_session_id(const char* value);
void set_auth_session_id(const char* value, size_t size);
std::string* mutable_auth_session_id();
std::string* release_auth_session_id();
void set_allocated_auth_session_id(std::string* auth_session_id);

// @@protoc_insertion_point(class_scope:enterprise_management.SamlParametersProto)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_redirect_url_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_session_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PublicSamlUserRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PublicSamlUserRequest) */ {
public:
PublicSamlUserRequest();
virtual ~PublicSamlUserRequest();

PublicSamlUserRequest(const PublicSamlUserRequest& from);
PublicSamlUserRequest(PublicSamlUserRequest&& from) noexcept
: PublicSamlUserRequest() {
*this = ::std::move(from);
}

inline PublicSamlUserRequest& operator=(const PublicSamlUserRequest& from) {
CopyFrom(from);
return *this;
}
inline PublicSamlUserRequest& operator=(PublicSamlUserRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PublicSamlUserRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PublicSamlUserRequest* internal_default_instance() {
return reinterpret_cast<const PublicSamlUserRequest*>(
&_PublicSamlUserRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
115;

friend void swap(PublicSamlUserRequest& a, PublicSamlUserRequest& b) {
a.Swap(&b);
}
inline void Swap(PublicSamlUserRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PublicSamlUserRequest* New() const final {
return CreateMaybeMessage<PublicSamlUserRequest>(nullptr);
}

PublicSamlUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PublicSamlUserRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PublicSamlUserRequest& from);
void MergeFrom(const PublicSamlUserRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PublicSamlUserRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PublicSamlUserRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAccountIdFieldNumber = 1,
};
// optional string account_id = 1;
bool has_account_id() const;
void clear_account_id();
const std::string& account_id() const;
void set_account_id(const std::string& value);
void set_account_id(std::string&& value);
void set_account_id(const char* value);
void set_account_id(const char* value, size_t size);
std::string* mutable_account_id();
std::string* release_account_id();
void set_allocated_account_id(std::string* account_id);

// @@protoc_insertion_point(class_scope:enterprise_management.PublicSamlUserRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PublicSamlUserResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PublicSamlUserResponse) */ {
public:
PublicSamlUserResponse();
virtual ~PublicSamlUserResponse();

PublicSamlUserResponse(const PublicSamlUserResponse& from);
PublicSamlUserResponse(PublicSamlUserResponse&& from) noexcept
: PublicSamlUserResponse() {
*this = ::std::move(from);
}

inline PublicSamlUserResponse& operator=(const PublicSamlUserResponse& from) {
CopyFrom(from);
return *this;
}
inline PublicSamlUserResponse& operator=(PublicSamlUserResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const PublicSamlUserResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const PublicSamlUserResponse* internal_default_instance() {
return reinterpret_cast<const PublicSamlUserResponse*>(
&_PublicSamlUserResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
116;

friend void swap(PublicSamlUserResponse& a, PublicSamlUserResponse& b) {
a.Swap(&b);
}
inline void Swap(PublicSamlUserResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline PublicSamlUserResponse* New() const final {
return CreateMaybeMessage<PublicSamlUserResponse>(nullptr);
}

PublicSamlUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<PublicSamlUserResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const PublicSamlUserResponse& from);
void MergeFrom(const PublicSamlUserResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PublicSamlUserResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.PublicSamlUserResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSamlParametersFieldNumber = 1,
};
// optional .enterprise_management.SamlParametersProto saml_parameters = 1;
bool has_saml_parameters() const;
void clear_saml_parameters();
const ::enterprise_management::SamlParametersProto& saml_parameters() const;
::enterprise_management::SamlParametersProto* release_saml_parameters();
::enterprise_management::SamlParametersProto* mutable_saml_parameters();
void set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters);

// @@protoc_insertion_point(class_scope:enterprise_management.PublicSamlUserResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::enterprise_management::SamlParametersProto* saml_parameters_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveDirectoryPlayActivityRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryPlayActivityRequest) */ {
public:
ActiveDirectoryPlayActivityRequest();
virtual ~ActiveDirectoryPlayActivityRequest();

ActiveDirectoryPlayActivityRequest(const ActiveDirectoryPlayActivityRequest& from);
ActiveDirectoryPlayActivityRequest(ActiveDirectoryPlayActivityRequest&& from) noexcept
: ActiveDirectoryPlayActivityRequest() {
*this = ::std::move(from);
}

inline ActiveDirectoryPlayActivityRequest& operator=(const ActiveDirectoryPlayActivityRequest& from) {
CopyFrom(from);
return *this;
}
inline ActiveDirectoryPlayActivityRequest& operator=(ActiveDirectoryPlayActivityRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ActiveDirectoryPlayActivityRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ActiveDirectoryPlayActivityRequest* internal_default_instance() {
return reinterpret_cast<const ActiveDirectoryPlayActivityRequest*>(
&_ActiveDirectoryPlayActivityRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
117;

friend void swap(ActiveDirectoryPlayActivityRequest& a, ActiveDirectoryPlayActivityRequest& b) {
a.Swap(&b);
}
inline void Swap(ActiveDirectoryPlayActivityRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ActiveDirectoryPlayActivityRequest* New() const final {
return CreateMaybeMessage<ActiveDirectoryPlayActivityRequest>(nullptr);
}

ActiveDirectoryPlayActivityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ActiveDirectoryPlayActivityRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ActiveDirectoryPlayActivityRequest& from);
void MergeFrom(const ActiveDirectoryPlayActivityRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ActiveDirectoryPlayActivityRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ActiveDirectoryPlayActivityRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kUserIdFieldNumber = 1,
};
// optional string user_id = 1;
bool has_user_id() const;
void clear_user_id();
const std::string& user_id() const;
void set_user_id(const std::string& value);
void set_user_id(std::string&& value);
void set_user_id(const char* value);
void set_user_id(const char* value, size_t size);
std::string* mutable_user_id();
std::string* release_user_id();
void set_allocated_user_id(std::string* user_id);

// @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryPlayActivityRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveDirectoryPlayActivityResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryPlayActivityResponse) */ {
public:
ActiveDirectoryPlayActivityResponse();
virtual ~ActiveDirectoryPlayActivityResponse();

ActiveDirectoryPlayActivityResponse(const ActiveDirectoryPlayActivityResponse& from);
ActiveDirectoryPlayActivityResponse(ActiveDirectoryPlayActivityResponse&& from) noexcept
: ActiveDirectoryPlayActivityResponse() {
*this = ::std::move(from);
}

inline ActiveDirectoryPlayActivityResponse& operator=(const ActiveDirectoryPlayActivityResponse& from) {
CopyFrom(from);
return *this;
}
inline ActiveDirectoryPlayActivityResponse& operator=(ActiveDirectoryPlayActivityResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ActiveDirectoryPlayActivityResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ActiveDirectoryPlayActivityResponse* internal_default_instance() {
return reinterpret_cast<const ActiveDirectoryPlayActivityResponse*>(
&_ActiveDirectoryPlayActivityResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
118;

friend void swap(ActiveDirectoryPlayActivityResponse& a, ActiveDirectoryPlayActivityResponse& b) {
a.Swap(&b);
}
inline void Swap(ActiveDirectoryPlayActivityResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ActiveDirectoryPlayActivityResponse* New() const final {
return CreateMaybeMessage<ActiveDirectoryPlayActivityResponse>(nullptr);
}

ActiveDirectoryPlayActivityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ActiveDirectoryPlayActivityResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ActiveDirectoryPlayActivityResponse& from);
void MergeFrom(const ActiveDirectoryPlayActivityResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ActiveDirectoryPlayActivityResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ActiveDirectoryPlayActivityResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryPlayActivityResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckDeviceLicenseRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDeviceLicenseRequest) */ {
public:
CheckDeviceLicenseRequest();
virtual ~CheckDeviceLicenseRequest();

CheckDeviceLicenseRequest(const CheckDeviceLicenseRequest& from);
CheckDeviceLicenseRequest(CheckDeviceLicenseRequest&& from) noexcept
: CheckDeviceLicenseRequest() {
*this = ::std::move(from);
}

inline CheckDeviceLicenseRequest& operator=(const CheckDeviceLicenseRequest& from) {
CopyFrom(from);
return *this;
}
inline CheckDeviceLicenseRequest& operator=(CheckDeviceLicenseRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CheckDeviceLicenseRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CheckDeviceLicenseRequest* internal_default_instance() {
return reinterpret_cast<const CheckDeviceLicenseRequest*>(
&_CheckDeviceLicenseRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
119;

friend void swap(CheckDeviceLicenseRequest& a, CheckDeviceLicenseRequest& b) {
a.Swap(&b);
}
inline void Swap(CheckDeviceLicenseRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CheckDeviceLicenseRequest* New() const final {
return CreateMaybeMessage<CheckDeviceLicenseRequest>(nullptr);
}

CheckDeviceLicenseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CheckDeviceLicenseRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CheckDeviceLicenseRequest& from);
void MergeFrom(const CheckDeviceLicenseRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CheckDeviceLicenseRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CheckDeviceLicenseRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.CheckDeviceLicenseRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT LicenseAvailability :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LicenseAvailability) */ {
public:
LicenseAvailability();
virtual ~LicenseAvailability();

LicenseAvailability(const LicenseAvailability& from);
LicenseAvailability(LicenseAvailability&& from) noexcept
: LicenseAvailability() {
*this = ::std::move(from);
}

inline LicenseAvailability& operator=(const LicenseAvailability& from) {
CopyFrom(from);
return *this;
}
inline LicenseAvailability& operator=(LicenseAvailability&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const LicenseAvailability& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const LicenseAvailability* internal_default_instance() {
return reinterpret_cast<const LicenseAvailability*>(
&_LicenseAvailability_default_instance_);
}
static constexpr int kIndexInFileMessages =
120;

friend void swap(LicenseAvailability& a, LicenseAvailability& b) {
a.Swap(&b);
}
inline void Swap(LicenseAvailability* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline LicenseAvailability* New() const final {
return CreateMaybeMessage<LicenseAvailability>(nullptr);
}

LicenseAvailability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<LicenseAvailability>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const LicenseAvailability& from);
void MergeFrom(const LicenseAvailability& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LicenseAvailability* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.LicenseAvailability";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kLicenseTypeDeprecatedFieldNumber = 1,
kAvailableLicensesDeprecatedFieldNumber = 2,
};
// optional .enterprise_management.LicenseType license_type_deprecated = 1 [deprecated = true];
PROTOBUF_DEPRECATED bool has_license_type_deprecated() const;
PROTOBUF_DEPRECATED void clear_license_type_deprecated();
PROTOBUF_DEPRECATED const ::enterprise_management::LicenseType& license_type_deprecated() const;
PROTOBUF_DEPRECATED ::enterprise_management::LicenseType* release_license_type_deprecated();
PROTOBUF_DEPRECATED ::enterprise_management::LicenseType* mutable_license_type_deprecated();
PROTOBUF_DEPRECATED void set_allocated_license_type_deprecated(::enterprise_management::LicenseType* license_type_deprecated);

// optional int32 available_licenses_deprecated = 2 [deprecated = true];
PROTOBUF_DEPRECATED bool has_available_licenses_deprecated() const;
PROTOBUF_DEPRECATED void clear_available_licenses_deprecated();
PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 available_licenses_deprecated() const;
PROTOBUF_DEPRECATED void set_available_licenses_deprecated(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.LicenseAvailability)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::enterprise_management::LicenseType* license_type_deprecated_;
::PROTOBUF_NAMESPACE_ID::int32 available_licenses_deprecated_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckDeviceLicenseResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDeviceLicenseResponse) */ {
public:
CheckDeviceLicenseResponse();
virtual ~CheckDeviceLicenseResponse();

CheckDeviceLicenseResponse(const CheckDeviceLicenseResponse& from);
CheckDeviceLicenseResponse(CheckDeviceLicenseResponse&& from) noexcept
: CheckDeviceLicenseResponse() {
*this = ::std::move(from);
}

inline CheckDeviceLicenseResponse& operator=(const CheckDeviceLicenseResponse& from) {
CopyFrom(from);
return *this;
}
inline CheckDeviceLicenseResponse& operator=(CheckDeviceLicenseResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const CheckDeviceLicenseResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const CheckDeviceLicenseResponse* internal_default_instance() {
return reinterpret_cast<const CheckDeviceLicenseResponse*>(
&_CheckDeviceLicenseResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
121;

friend void swap(CheckDeviceLicenseResponse& a, CheckDeviceLicenseResponse& b) {
a.Swap(&b);
}
inline void Swap(CheckDeviceLicenseResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline CheckDeviceLicenseResponse* New() const final {
return CreateMaybeMessage<CheckDeviceLicenseResponse>(nullptr);
}

CheckDeviceLicenseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<CheckDeviceLicenseResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const CheckDeviceLicenseResponse& from);
void MergeFrom(const CheckDeviceLicenseResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(CheckDeviceLicenseResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.CheckDeviceLicenseResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef CheckDeviceLicenseResponse_LicenseSelectionMode LicenseSelectionMode;
static constexpr LicenseSelectionMode UNDEFINED =
CheckDeviceLicenseResponse_LicenseSelectionMode_UNDEFINED;
static constexpr LicenseSelectionMode USER_SELECTION =
CheckDeviceLicenseResponse_LicenseSelectionMode_USER_SELECTION;
static constexpr LicenseSelectionMode ADMIN_SELECTION =
CheckDeviceLicenseResponse_LicenseSelectionMode_ADMIN_SELECTION;
static inline bool LicenseSelectionMode_IsValid(int value) {
return CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(value);
}
static constexpr LicenseSelectionMode LicenseSelectionMode_MIN =
CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MIN;
static constexpr LicenseSelectionMode LicenseSelectionMode_MAX =
CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MAX;
static constexpr int LicenseSelectionMode_ARRAYSIZE =
CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_ARRAYSIZE;
template<typename T>
static inline const std::string& LicenseSelectionMode_Name(T enum_t_value) {
static_assert(::std::is_same<T, LicenseSelectionMode>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function LicenseSelectionMode_Name.");
return CheckDeviceLicenseResponse_LicenseSelectionMode_Name(enum_t_value);
}
static inline bool LicenseSelectionMode_Parse(const std::string& name,
LicenseSelectionMode* value) {
return CheckDeviceLicenseResponse_LicenseSelectionMode_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kLicenseAvailabilitiesDeprecatedFieldNumber = 2,
kLicenseSelectionModeDeprecatedFieldNumber = 1,
};
// repeated .enterprise_management.LicenseAvailability license_availabilities_deprecated = 2 [deprecated = true];
PROTOBUF_DEPRECATED int license_availabilities_deprecated_size() const;
PROTOBUF_DEPRECATED void clear_license_availabilities_deprecated();
PROTOBUF_DEPRECATED ::enterprise_management::LicenseAvailability* mutable_license_availabilities_deprecated(int index);
PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >*
mutable_license_availabilities_deprecated();
PROTOBUF_DEPRECATED const ::enterprise_management::LicenseAvailability& license_availabilities_deprecated(int index) const;
PROTOBUF_DEPRECATED ::enterprise_management::LicenseAvailability* add_license_availabilities_deprecated();
PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >&
license_availabilities_deprecated() const;

// optional .enterprise_management.CheckDeviceLicenseResponse.LicenseSelectionMode license_selection_mode_deprecated = 1 [deprecated = true];
PROTOBUF_DEPRECATED bool has_license_selection_mode_deprecated() const;
PROTOBUF_DEPRECATED void clear_license_selection_mode_deprecated();
PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode license_selection_mode_deprecated() const;
PROTOBUF_DEPRECATED void set_license_selection_mode_deprecated(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode value);

// @@protoc_insertion_point(class_scope:enterprise_management.CheckDeviceLicenseResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability > license_availabilities_deprecated_;
int license_selection_mode_deprecated_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveDirectoryUserSigninRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryUserSigninRequest) */ {
public:
ActiveDirectoryUserSigninRequest();
virtual ~ActiveDirectoryUserSigninRequest();

ActiveDirectoryUserSigninRequest(const ActiveDirectoryUserSigninRequest& from);
ActiveDirectoryUserSigninRequest(ActiveDirectoryUserSigninRequest&& from) noexcept
: ActiveDirectoryUserSigninRequest() {
*this = ::std::move(from);
}

inline ActiveDirectoryUserSigninRequest& operator=(const ActiveDirectoryUserSigninRequest& from) {
CopyFrom(from);
return *this;
}
inline ActiveDirectoryUserSigninRequest& operator=(ActiveDirectoryUserSigninRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ActiveDirectoryUserSigninRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ActiveDirectoryUserSigninRequest* internal_default_instance() {
return reinterpret_cast<const ActiveDirectoryUserSigninRequest*>(
&_ActiveDirectoryUserSigninRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
122;

friend void swap(ActiveDirectoryUserSigninRequest& a, ActiveDirectoryUserSigninRequest& b) {
a.Swap(&b);
}
inline void Swap(ActiveDirectoryUserSigninRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ActiveDirectoryUserSigninRequest* New() const final {
return CreateMaybeMessage<ActiveDirectoryUserSigninRequest>(nullptr);
}

ActiveDirectoryUserSigninRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ActiveDirectoryUserSigninRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ActiveDirectoryUserSigninRequest& from);
void MergeFrom(const ActiveDirectoryUserSigninRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ActiveDirectoryUserSigninRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ActiveDirectoryUserSigninRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryUserSigninRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveDirectoryUserSigninResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryUserSigninResponse) */ {
public:
ActiveDirectoryUserSigninResponse();
virtual ~ActiveDirectoryUserSigninResponse();

ActiveDirectoryUserSigninResponse(const ActiveDirectoryUserSigninResponse& from);
ActiveDirectoryUserSigninResponse(ActiveDirectoryUserSigninResponse&& from) noexcept
: ActiveDirectoryUserSigninResponse() {
*this = ::std::move(from);
}

inline ActiveDirectoryUserSigninResponse& operator=(const ActiveDirectoryUserSigninResponse& from) {
CopyFrom(from);
return *this;
}
inline ActiveDirectoryUserSigninResponse& operator=(ActiveDirectoryUserSigninResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ActiveDirectoryUserSigninResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ActiveDirectoryUserSigninResponse* internal_default_instance() {
return reinterpret_cast<const ActiveDirectoryUserSigninResponse*>(
&_ActiveDirectoryUserSigninResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
123;

friend void swap(ActiveDirectoryUserSigninResponse& a, ActiveDirectoryUserSigninResponse& b) {
a.Swap(&b);
}
inline void Swap(ActiveDirectoryUserSigninResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ActiveDirectoryUserSigninResponse* New() const final {
return CreateMaybeMessage<ActiveDirectoryUserSigninResponse>(nullptr);
}

ActiveDirectoryUserSigninResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ActiveDirectoryUserSigninResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ActiveDirectoryUserSigninResponse& from);
void MergeFrom(const ActiveDirectoryUserSigninResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ActiveDirectoryUserSigninResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ActiveDirectoryUserSigninResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAuthRedirectUrlFieldNumber = 1,
};
// optional string auth_redirect_url = 1;
bool has_auth_redirect_url() const;
void clear_auth_redirect_url();
const std::string& auth_redirect_url() const;
void set_auth_redirect_url(const std::string& value);
void set_auth_redirect_url(std::string&& value);
void set_auth_redirect_url(const char* value);
void set_auth_redirect_url(const char* value, size_t size);
std::string* mutable_auth_redirect_url();
std::string* release_auth_redirect_url();
void set_allocated_auth_redirect_url(std::string* auth_redirect_url);

// @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryUserSigninResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_redirect_url_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT TpmVersionInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TpmVersionInfo) */ {
public:
TpmVersionInfo();
virtual ~TpmVersionInfo();

TpmVersionInfo(const TpmVersionInfo& from);
TpmVersionInfo(TpmVersionInfo&& from) noexcept
: TpmVersionInfo() {
*this = ::std::move(from);
}

inline TpmVersionInfo& operator=(const TpmVersionInfo& from) {
CopyFrom(from);
return *this;
}
inline TpmVersionInfo& operator=(TpmVersionInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const TpmVersionInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const TpmVersionInfo* internal_default_instance() {
return reinterpret_cast<const TpmVersionInfo*>(
&_TpmVersionInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
124;

friend void swap(TpmVersionInfo& a, TpmVersionInfo& b) {
a.Swap(&b);
}
inline void Swap(TpmVersionInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline TpmVersionInfo* New() const final {
return CreateMaybeMessage<TpmVersionInfo>(nullptr);
}

TpmVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<TpmVersionInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const TpmVersionInfo& from);
void MergeFrom(const TpmVersionInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TpmVersionInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.TpmVersionInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kVendorSpecificFieldNumber = 6,
kSpecLevelFieldNumber = 2,
kFamilyFieldNumber = 1,
kManufacturerFieldNumber = 3,
kFirmwareVersionFieldNumber = 5,
kTpmModelFieldNumber = 4,
};
// optional string vendor_specific = 6;
bool has_vendor_specific() const;
void clear_vendor_specific();
const std::string& vendor_specific() const;
void set_vendor_specific(const std::string& value);
void set_vendor_specific(std::string&& value);
void set_vendor_specific(const char* value);
void set_vendor_specific(const char* value, size_t size);
std::string* mutable_vendor_specific();
std::string* release_vendor_specific();
void set_allocated_vendor_specific(std::string* vendor_specific);

// optional uint64 spec_level = 2;
bool has_spec_level() const;
void clear_spec_level();
::PROTOBUF_NAMESPACE_ID::uint64 spec_level() const;
void set_spec_level(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint32 family = 1;
bool has_family() const;
void clear_family();
::PROTOBUF_NAMESPACE_ID::uint32 family() const;
void set_family(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint32 manufacturer = 3;
bool has_manufacturer() const;
void clear_manufacturer();
::PROTOBUF_NAMESPACE_ID::uint32 manufacturer() const;
void set_manufacturer(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint64 firmware_version = 5;
bool has_firmware_version() const;
void clear_firmware_version();
::PROTOBUF_NAMESPACE_ID::uint64 firmware_version() const;
void set_firmware_version(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint32 tpm_model = 4;
bool has_tpm_model() const;
void clear_tpm_model();
::PROTOBUF_NAMESPACE_ID::uint32 tpm_model() const;
void set_tpm_model(::PROTOBUF_NAMESPACE_ID::uint32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.TpmVersionInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_specific_;
::PROTOBUF_NAMESPACE_ID::uint64 spec_level_;
::PROTOBUF_NAMESPACE_ID::uint32 family_;
::PROTOBUF_NAMESPACE_ID::uint32 manufacturer_;
::PROTOBUF_NAMESPACE_ID::uint64 firmware_version_;
::PROTOBUF_NAMESPACE_ID::uint32 tpm_model_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT TpmStatusInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TpmStatusInfo) */ {
public:
TpmStatusInfo();
virtual ~TpmStatusInfo();

TpmStatusInfo(const TpmStatusInfo& from);
TpmStatusInfo(TpmStatusInfo&& from) noexcept
: TpmStatusInfo() {
*this = ::std::move(from);
}

inline TpmStatusInfo& operator=(const TpmStatusInfo& from) {
CopyFrom(from);
return *this;
}
inline TpmStatusInfo& operator=(TpmStatusInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const TpmStatusInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const TpmStatusInfo* internal_default_instance() {
return reinterpret_cast<const TpmStatusInfo*>(
&_TpmStatusInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
125;

friend void swap(TpmStatusInfo& a, TpmStatusInfo& b) {
a.Swap(&b);
}
inline void Swap(TpmStatusInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline TpmStatusInfo* New() const final {
return CreateMaybeMessage<TpmStatusInfo>(nullptr);
}

TpmStatusInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<TpmStatusInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const TpmStatusInfo& from);
void MergeFrom(const TpmStatusInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TpmStatusInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.TpmStatusInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kEnabledFieldNumber = 1,
kOwnedFieldNumber = 2,
kTpmInitializedFieldNumber = 3,
kAttestationPreparedFieldNumber = 4,
kDictionaryAttackCounterFieldNumber = 6,
kDictionaryAttackThresholdFieldNumber = 7,
kAttestationEnrolledFieldNumber = 5,
kDictionaryAttackLockoutInEffectFieldNumber = 8,
kBootLockboxFinalizedFieldNumber = 10,
kDictionaryAttackLockoutSecondsRemainingFieldNumber = 9,
};
// optional bool enabled = 1;
bool has_enabled() const;
void clear_enabled();
bool enabled() const;
void set_enabled(bool value);

// optional bool owned = 2;
bool has_owned() const;
void clear_owned();
bool owned() const;
void set_owned(bool value);

// optional bool tpm_initialized = 3;
bool has_tpm_initialized() const;
void clear_tpm_initialized();
bool tpm_initialized() const;
void set_tpm_initialized(bool value);

// optional bool attestation_prepared = 4;
bool has_attestation_prepared() const;
void clear_attestation_prepared();
bool attestation_prepared() const;
void set_attestation_prepared(bool value);

// optional int32 dictionary_attack_counter = 6;
bool has_dictionary_attack_counter() const;
void clear_dictionary_attack_counter();
::PROTOBUF_NAMESPACE_ID::int32 dictionary_attack_counter() const;
void set_dictionary_attack_counter(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 dictionary_attack_threshold = 7;
bool has_dictionary_attack_threshold() const;
void clear_dictionary_attack_threshold();
::PROTOBUF_NAMESPACE_ID::int32 dictionary_attack_threshold() const;
void set_dictionary_attack_threshold(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional bool attestation_enrolled = 5;
bool has_attestation_enrolled() const;
void clear_attestation_enrolled();
bool attestation_enrolled() const;
void set_attestation_enrolled(bool value);

// optional bool dictionary_attack_lockout_in_effect = 8;
bool has_dictionary_attack_lockout_in_effect() const;
void clear_dictionary_attack_lockout_in_effect();
bool dictionary_attack_lockout_in_effect() const;
void set_dictionary_attack_lockout_in_effect(bool value);

// optional bool boot_lockbox_finalized = 10;
bool has_boot_lockbox_finalized() const;
void clear_boot_lockbox_finalized();
bool boot_lockbox_finalized() const;
void set_boot_lockbox_finalized(bool value);

// optional int32 dictionary_attack_lockout_seconds_remaining = 9;
bool has_dictionary_attack_lockout_seconds_remaining() const;
void clear_dictionary_attack_lockout_seconds_remaining();
::PROTOBUF_NAMESPACE_ID::int32 dictionary_attack_lockout_seconds_remaining() const;
void set_dictionary_attack_lockout_seconds_remaining(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.TpmStatusInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
bool enabled_;
bool owned_;
bool tpm_initialized_;
bool attestation_prepared_;
::PROTOBUF_NAMESPACE_ID::int32 dictionary_attack_counter_;
::PROTOBUF_NAMESPACE_ID::int32 dictionary_attack_threshold_;
bool attestation_enrolled_;
bool dictionary_attack_lockout_in_effect_;
bool boot_lockbox_finalized_;
::PROTOBUF_NAMESPACE_ID::int32 dictionary_attack_lockout_seconds_remaining_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SystemState :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemState) */ {
public:
SystemState();
virtual ~SystemState();

SystemState(const SystemState& from);
SystemState(SystemState&& from) noexcept
: SystemState() {
*this = ::std::move(from);
}

inline SystemState& operator=(const SystemState& from) {
CopyFrom(from);
return *this;
}
inline SystemState& operator=(SystemState&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SystemState& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SystemState* internal_default_instance() {
return reinterpret_cast<const SystemState*>(
&_SystemState_default_instance_);
}
static constexpr int kIndexInFileMessages =
126;

friend void swap(SystemState& a, SystemState& b) {
a.Swap(&b);
}
inline void Swap(SystemState* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SystemState* New() const final {
return CreateMaybeMessage<SystemState>(nullptr);
}

SystemState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SystemState>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SystemState& from);
void MergeFrom(const SystemState& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SystemState* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.SystemState";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kVolumeInfosFieldNumber = 1,
};
// repeated .enterprise_management.VolumeInfo volume_infos = 1;
int volume_infos_size() const;
void clear_volume_infos();
::enterprise_management::VolumeInfo* mutable_volume_infos(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
mutable_volume_infos();
const ::enterprise_management::VolumeInfo& volume_infos(int index) const;
::enterprise_management::VolumeInfo* add_volume_infos();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
volume_infos() const;

// @@protoc_insertion_point(class_scope:enterprise_management.SystemState)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo > volume_infos_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ExtensionInstallReportLogEvent :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionInstallReportLogEvent) */ {
public:
ExtensionInstallReportLogEvent();
virtual ~ExtensionInstallReportLogEvent();

ExtensionInstallReportLogEvent(const ExtensionInstallReportLogEvent& from);
ExtensionInstallReportLogEvent(ExtensionInstallReportLogEvent&& from) noexcept
: ExtensionInstallReportLogEvent() {
*this = ::std::move(from);
}

inline ExtensionInstallReportLogEvent& operator=(const ExtensionInstallReportLogEvent& from) {
CopyFrom(from);
return *this;
}
inline ExtensionInstallReportLogEvent& operator=(ExtensionInstallReportLogEvent&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ExtensionInstallReportLogEvent& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ExtensionInstallReportLogEvent* internal_default_instance() {
return reinterpret_cast<const ExtensionInstallReportLogEvent*>(
&_ExtensionInstallReportLogEvent_default_instance_);
}
static constexpr int kIndexInFileMessages =
127;

friend void swap(ExtensionInstallReportLogEvent& a, ExtensionInstallReportLogEvent& b) {
a.Swap(&b);
}
inline void Swap(ExtensionInstallReportLogEvent* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ExtensionInstallReportLogEvent* New() const final {
return CreateMaybeMessage<ExtensionInstallReportLogEvent>(nullptr);
}

ExtensionInstallReportLogEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ExtensionInstallReportLogEvent>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ExtensionInstallReportLogEvent& from);
void MergeFrom(const ExtensionInstallReportLogEvent& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ExtensionInstallReportLogEvent* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ExtensionInstallReportLogEvent";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef ExtensionInstallReportLogEvent_EventType EventType;
static constexpr EventType LOG_EVENT_TYPE_UNKNOWN =
ExtensionInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
static constexpr EventType POLICY_REQUEST =
ExtensionInstallReportLogEvent_EventType_POLICY_REQUEST;
static constexpr EventType SUCCESS =
ExtensionInstallReportLogEvent_EventType_SUCCESS;
static constexpr EventType CANCELED =
ExtensionInstallReportLogEvent_EventType_CANCELED;
static constexpr EventType CONNECTIVITY_CHANGE =
ExtensionInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE;
static constexpr EventType SESSION_STATE_CHANGE =
ExtensionInstallReportLogEvent_EventType_SESSION_STATE_CHANGE;
static constexpr EventType INSTALLATION_FAILED =
ExtensionInstallReportLogEvent_EventType_INSTALLATION_FAILED;
static inline bool EventType_IsValid(int value) {
return ExtensionInstallReportLogEvent_EventType_IsValid(value);
}
static constexpr EventType EventType_MIN =
ExtensionInstallReportLogEvent_EventType_EventType_MIN;
static constexpr EventType EventType_MAX =
ExtensionInstallReportLogEvent_EventType_EventType_MAX;
static constexpr int EventType_ARRAYSIZE =
ExtensionInstallReportLogEvent_EventType_EventType_ARRAYSIZE;
template<typename T>
static inline const std::string& EventType_Name(T enum_t_value) {
static_assert(::std::is_same<T, EventType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function EventType_Name.");
return ExtensionInstallReportLogEvent_EventType_Name(enum_t_value);
}
static inline bool EventType_Parse(const std::string& name,
EventType* value) {
return ExtensionInstallReportLogEvent_EventType_Parse(name, value);
}

typedef ExtensionInstallReportLogEvent_SessionStateChangeType SessionStateChangeType;
static constexpr SessionStateChangeType SESSION_STATE_CHANGE_TYPE_UNKNOWN =
ExtensionInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
static constexpr SessionStateChangeType LOGIN =
ExtensionInstallReportLogEvent_SessionStateChangeType_LOGIN;
static constexpr SessionStateChangeType LOGOUT =
ExtensionInstallReportLogEvent_SessionStateChangeType_LOGOUT;
static constexpr SessionStateChangeType SUSPEND =
ExtensionInstallReportLogEvent_SessionStateChangeType_SUSPEND;
static constexpr SessionStateChangeType RESUME =
ExtensionInstallReportLogEvent_SessionStateChangeType_RESUME;
static inline bool SessionStateChangeType_IsValid(int value) {
return ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(value);
}
static constexpr SessionStateChangeType SessionStateChangeType_MIN =
ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN;
static constexpr SessionStateChangeType SessionStateChangeType_MAX =
ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX;
static constexpr int SessionStateChangeType_ARRAYSIZE =
ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE;
template<typename T>
static inline const std::string& SessionStateChangeType_Name(T enum_t_value) {
static_assert(::std::is_same<T, SessionStateChangeType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function SessionStateChangeType_Name.");
return ExtensionInstallReportLogEvent_SessionStateChangeType_Name(enum_t_value);
}
static inline bool SessionStateChangeType_Parse(const std::string& name,
SessionStateChangeType* value) {
return ExtensionInstallReportLogEvent_SessionStateChangeType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kTimestampFieldNumber = 1,
kStatefulTotalFieldNumber = 3,
kEventTypeFieldNumber = 2,
kOnlineFieldNumber = 5,
kStatefulFreeFieldNumber = 4,
kSessionStateChangeTypeFieldNumber = 6,
};
// optional int64 timestamp = 1;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 stateful_total = 3;
bool has_stateful_total() const;
void clear_stateful_total();
::PROTOBUF_NAMESPACE_ID::int64 stateful_total() const;
void set_stateful_total(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.ExtensionInstallReportLogEvent.EventType event_type = 2;
bool has_event_type() const;
void clear_event_type();
::enterprise_management::ExtensionInstallReportLogEvent_EventType event_type() const;
void set_event_type(::enterprise_management::ExtensionInstallReportLogEvent_EventType value);

// optional bool online = 5;
bool has_online() const;
void clear_online();
bool online() const;
void set_online(bool value);

// optional int64 stateful_free = 4;
bool has_stateful_free() const;
void clear_stateful_free();
::PROTOBUF_NAMESPACE_ID::int64 stateful_free() const;
void set_stateful_free(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.ExtensionInstallReportLogEvent.SessionStateChangeType session_state_change_type = 6;
bool has_session_state_change_type() const;
void clear_session_state_change_type();
::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType session_state_change_type() const;
void set_session_state_change_type(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType value);

// @@protoc_insertion_point(class_scope:enterprise_management.ExtensionInstallReportLogEvent)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
::PROTOBUF_NAMESPACE_ID::int64 stateful_total_;
int event_type_;
bool online_;
::PROTOBUF_NAMESPACE_ID::int64 stateful_free_;
int session_state_change_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppInstallReportLogEvent :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReportLogEvent) */ {
public:
AppInstallReportLogEvent();
virtual ~AppInstallReportLogEvent();

AppInstallReportLogEvent(const AppInstallReportLogEvent& from);
AppInstallReportLogEvent(AppInstallReportLogEvent&& from) noexcept
: AppInstallReportLogEvent() {
*this = ::std::move(from);
}

inline AppInstallReportLogEvent& operator=(const AppInstallReportLogEvent& from) {
CopyFrom(from);
return *this;
}
inline AppInstallReportLogEvent& operator=(AppInstallReportLogEvent&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppInstallReportLogEvent& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppInstallReportLogEvent* internal_default_instance() {
return reinterpret_cast<const AppInstallReportLogEvent*>(
&_AppInstallReportLogEvent_default_instance_);
}
static constexpr int kIndexInFileMessages =
128;

friend void swap(AppInstallReportLogEvent& a, AppInstallReportLogEvent& b) {
a.Swap(&b);
}
inline void Swap(AppInstallReportLogEvent* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppInstallReportLogEvent* New() const final {
return CreateMaybeMessage<AppInstallReportLogEvent>(nullptr);
}

AppInstallReportLogEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppInstallReportLogEvent>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppInstallReportLogEvent& from);
void MergeFrom(const AppInstallReportLogEvent& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppInstallReportLogEvent* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AppInstallReportLogEvent";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef AppInstallReportLogEvent_EventType EventType;
static constexpr EventType LOG_EVENT_TYPE_UNKNOWN =
AppInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
static constexpr EventType SERVER_REQUEST =
AppInstallReportLogEvent_EventType_SERVER_REQUEST;
static constexpr EventType CLOUDDPC_REQUEST =
AppInstallReportLogEvent_EventType_CLOUDDPC_REQUEST;
static constexpr EventType CLOUDDPS_REQUEST =
AppInstallReportLogEvent_EventType_CLOUDDPS_REQUEST;
static constexpr EventType CLOUDDPS_RESPONSE =
AppInstallReportLogEvent_EventType_CLOUDDPS_RESPONSE;
static constexpr EventType PHONESKY_LOG =
AppInstallReportLogEvent_EventType_PHONESKY_LOG;
static constexpr EventType SUCCESS =
AppInstallReportLogEvent_EventType_SUCCESS;
static constexpr EventType CANCELED =
AppInstallReportLogEvent_EventType_CANCELED;
static constexpr EventType CONNECTIVITY_CHANGE =
AppInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE;
static constexpr EventType SESSION_STATE_CHANGE =
AppInstallReportLogEvent_EventType_SESSION_STATE_CHANGE;
static constexpr EventType INSTALLATION_STARTED =
AppInstallReportLogEvent_EventType_INSTALLATION_STARTED;
static constexpr EventType INSTALLATION_FINISHED =
AppInstallReportLogEvent_EventType_INSTALLATION_FINISHED;
static constexpr EventType INSTALLATION_FAILED =
AppInstallReportLogEvent_EventType_INSTALLATION_FAILED;
static constexpr EventType DIRECT_INSTALL =
AppInstallReportLogEvent_EventType_DIRECT_INSTALL;
static constexpr EventType CLOUDDPC_MAIN_LOOP_FAILED =
AppInstallReportLogEvent_EventType_CLOUDDPC_MAIN_LOOP_FAILED;
static inline bool EventType_IsValid(int value) {
return AppInstallReportLogEvent_EventType_IsValid(value);
}
static constexpr EventType EventType_MIN =
AppInstallReportLogEvent_EventType_EventType_MIN;
static constexpr EventType EventType_MAX =
AppInstallReportLogEvent_EventType_EventType_MAX;
static constexpr int EventType_ARRAYSIZE =
AppInstallReportLogEvent_EventType_EventType_ARRAYSIZE;
template<typename T>
static inline const std::string& EventType_Name(T enum_t_value) {
static_assert(::std::is_same<T, EventType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function EventType_Name.");
return AppInstallReportLogEvent_EventType_Name(enum_t_value);
}
static inline bool EventType_Parse(const std::string& name,
EventType* value) {
return AppInstallReportLogEvent_EventType_Parse(name, value);
}

typedef AppInstallReportLogEvent_SessionStateChangeType SessionStateChangeType;
static constexpr SessionStateChangeType SESSION_STATE_CHANGE_TYPE_UNKNOWN =
AppInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
static constexpr SessionStateChangeType LOGIN =
AppInstallReportLogEvent_SessionStateChangeType_LOGIN;
static constexpr SessionStateChangeType LOGOUT =
AppInstallReportLogEvent_SessionStateChangeType_LOGOUT;
static constexpr SessionStateChangeType SUSPEND =
AppInstallReportLogEvent_SessionStateChangeType_SUSPEND;
static constexpr SessionStateChangeType RESUME =
AppInstallReportLogEvent_SessionStateChangeType_RESUME;
static inline bool SessionStateChangeType_IsValid(int value) {
return AppInstallReportLogEvent_SessionStateChangeType_IsValid(value);
}
static constexpr SessionStateChangeType SessionStateChangeType_MIN =
AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN;
static constexpr SessionStateChangeType SessionStateChangeType_MAX =
AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX;
static constexpr int SessionStateChangeType_ARRAYSIZE =
AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE;
template<typename T>
static inline const std::string& SessionStateChangeType_Name(T enum_t_value) {
static_assert(::std::is_same<T, SessionStateChangeType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function SessionStateChangeType_Name.");
return AppInstallReportLogEvent_SessionStateChangeType_Name(enum_t_value);
}
static inline bool SessionStateChangeType_Parse(const std::string& name,
SessionStateChangeType* value) {
return AppInstallReportLogEvent_SessionStateChangeType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kPhoneskyLogFieldNumber = 6,
kTimestampFieldNumber = 1,
kStatefulTotalFieldNumber = 3,
kEventTypeFieldNumber = 2,
kClouddpsResponseFieldNumber = 5,
kStatefulFreeFieldNumber = 4,
kOnlineFieldNumber = 7,
kSessionStateChangeTypeFieldNumber = 8,
kAndroidIdFieldNumber = 9,
};
// optional string phonesky_log = 6;
bool has_phonesky_log() const;
void clear_phonesky_log();
const std::string& phonesky_log() const;
void set_phonesky_log(const std::string& value);
void set_phonesky_log(std::string&& value);
void set_phonesky_log(const char* value);
void set_phonesky_log(const char* value, size_t size);
std::string* mutable_phonesky_log();
std::string* release_phonesky_log();
void set_allocated_phonesky_log(std::string* phonesky_log);

// optional int64 timestamp = 1;
bool has_timestamp() const;
void clear_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 stateful_total = 3;
bool has_stateful_total() const;
void clear_stateful_total();
::PROTOBUF_NAMESPACE_ID::int64 stateful_total() const;
void set_stateful_total(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.AppInstallReportLogEvent.EventType event_type = 2;
bool has_event_type() const;
void clear_event_type();
::enterprise_management::AppInstallReportLogEvent_EventType event_type() const;
void set_event_type(::enterprise_management::AppInstallReportLogEvent_EventType value);

// optional int32 clouddps_response = 5;
bool has_clouddps_response() const;
void clear_clouddps_response();
::PROTOBUF_NAMESPACE_ID::int32 clouddps_response() const;
void set_clouddps_response(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 stateful_free = 4;
bool has_stateful_free() const;
void clear_stateful_free();
::PROTOBUF_NAMESPACE_ID::int64 stateful_free() const;
void set_stateful_free(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional bool online = 7;
bool has_online() const;
void clear_online();
bool online() const;
void set_online(bool value);

// optional .enterprise_management.AppInstallReportLogEvent.SessionStateChangeType session_state_change_type = 8;
bool has_session_state_change_type() const;
void clear_session_state_change_type();
::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType session_state_change_type() const;
void set_session_state_change_type(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType value);

// optional int64 android_id = 9;
bool has_android_id() const;
void clear_android_id();
::PROTOBUF_NAMESPACE_ID::int64 android_id() const;
void set_android_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReportLogEvent)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phonesky_log_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
::PROTOBUF_NAMESPACE_ID::int64 stateful_total_;
int event_type_;
::PROTOBUF_NAMESPACE_ID::int32 clouddps_response_;
::PROTOBUF_NAMESPACE_ID::int64 stateful_free_;
bool online_;
int session_state_change_type_;
::PROTOBUF_NAMESPACE_ID::int64 android_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ExtensionInstallReport :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionInstallReport) */ {
public:
ExtensionInstallReport();
virtual ~ExtensionInstallReport();

ExtensionInstallReport(const ExtensionInstallReport& from);
ExtensionInstallReport(ExtensionInstallReport&& from) noexcept
: ExtensionInstallReport() {
*this = ::std::move(from);
}

inline ExtensionInstallReport& operator=(const ExtensionInstallReport& from) {
CopyFrom(from);
return *this;
}
inline ExtensionInstallReport& operator=(ExtensionInstallReport&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ExtensionInstallReport& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ExtensionInstallReport* internal_default_instance() {
return reinterpret_cast<const ExtensionInstallReport*>(
&_ExtensionInstallReport_default_instance_);
}
static constexpr int kIndexInFileMessages =
129;

friend void swap(ExtensionInstallReport& a, ExtensionInstallReport& b) {
a.Swap(&b);
}
inline void Swap(ExtensionInstallReport* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ExtensionInstallReport* New() const final {
return CreateMaybeMessage<ExtensionInstallReport>(nullptr);
}

ExtensionInstallReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ExtensionInstallReport>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ExtensionInstallReport& from);
void MergeFrom(const ExtensionInstallReport& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ExtensionInstallReport* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ExtensionInstallReport";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kLogsFieldNumber = 3,
kExtensionIdFieldNumber = 1,
kIncompleteFieldNumber = 2,
};
// repeated .enterprise_management.ExtensionInstallReportLogEvent logs = 3;
int logs_size() const;
void clear_logs();
::enterprise_management::ExtensionInstallReportLogEvent* mutable_logs(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >*
mutable_logs();
const ::enterprise_management::ExtensionInstallReportLogEvent& logs(int index) const;
::enterprise_management::ExtensionInstallReportLogEvent* add_logs();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >&
logs() const;

// optional string extension_id = 1;
bool has_extension_id() const;
void clear_extension_id();
const std::string& extension_id() const;
void set_extension_id(const std::string& value);
void set_extension_id(std::string&& value);
void set_extension_id(const char* value);
void set_extension_id(const char* value, size_t size);
std::string* mutable_extension_id();
std::string* release_extension_id();
void set_allocated_extension_id(std::string* extension_id);

// optional bool incomplete = 2;
bool has_incomplete() const;
void clear_incomplete();
bool incomplete() const;
void set_incomplete(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.ExtensionInstallReport)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent > logs_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_id_;
bool incomplete_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppInstallReport :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReport) */ {
public:
AppInstallReport();
virtual ~AppInstallReport();

AppInstallReport(const AppInstallReport& from);
AppInstallReport(AppInstallReport&& from) noexcept
: AppInstallReport() {
*this = ::std::move(from);
}

inline AppInstallReport& operator=(const AppInstallReport& from) {
CopyFrom(from);
return *this;
}
inline AppInstallReport& operator=(AppInstallReport&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppInstallReport& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppInstallReport* internal_default_instance() {
return reinterpret_cast<const AppInstallReport*>(
&_AppInstallReport_default_instance_);
}
static constexpr int kIndexInFileMessages =
130;

friend void swap(AppInstallReport& a, AppInstallReport& b) {
a.Swap(&b);
}
inline void Swap(AppInstallReport* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppInstallReport* New() const final {
return CreateMaybeMessage<AppInstallReport>(nullptr);
}

AppInstallReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppInstallReport>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppInstallReport& from);
void MergeFrom(const AppInstallReport& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppInstallReport* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AppInstallReport";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kLogsFieldNumber = 3,
kPackageFieldNumber = 1,
kIncompleteFieldNumber = 2,
};
// repeated .enterprise_management.AppInstallReportLogEvent logs = 3;
int logs_size() const;
void clear_logs();
::enterprise_management::AppInstallReportLogEvent* mutable_logs(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >*
mutable_logs();
const ::enterprise_management::AppInstallReportLogEvent& logs(int index) const;
::enterprise_management::AppInstallReportLogEvent* add_logs();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >&
logs() const;

// optional string package = 1;
bool has_package() const;
void clear_package();
const std::string& package() const;
void set_package(const std::string& value);
void set_package(std::string&& value);
void set_package(const char* value);
void set_package(const char* value, size_t size);
std::string* mutable_package();
std::string* release_package();
void set_allocated_package(std::string* package);

// optional bool incomplete = 2;
bool has_incomplete() const;
void clear_incomplete();
bool incomplete() const;
void set_incomplete(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReport)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent > logs_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_;
bool incomplete_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppInstallReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReportRequest) */ {
public:
AppInstallReportRequest();
virtual ~AppInstallReportRequest();

AppInstallReportRequest(const AppInstallReportRequest& from);
AppInstallReportRequest(AppInstallReportRequest&& from) noexcept
: AppInstallReportRequest() {
*this = ::std::move(from);
}

inline AppInstallReportRequest& operator=(const AppInstallReportRequest& from) {
CopyFrom(from);
return *this;
}
inline AppInstallReportRequest& operator=(AppInstallReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppInstallReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppInstallReportRequest* internal_default_instance() {
return reinterpret_cast<const AppInstallReportRequest*>(
&_AppInstallReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
131;

friend void swap(AppInstallReportRequest& a, AppInstallReportRequest& b) {
a.Swap(&b);
}
inline void Swap(AppInstallReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppInstallReportRequest* New() const final {
return CreateMaybeMessage<AppInstallReportRequest>(nullptr);
}

AppInstallReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppInstallReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppInstallReportRequest& from);
void MergeFrom(const AppInstallReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppInstallReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AppInstallReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAppInstallReportsFieldNumber = 1,
};
// repeated .enterprise_management.AppInstallReport app_install_reports = 1;
int app_install_reports_size() const;
void clear_app_install_reports();
::enterprise_management::AppInstallReport* mutable_app_install_reports(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >*
mutable_app_install_reports();
const ::enterprise_management::AppInstallReport& app_install_reports(int index) const;
::enterprise_management::AppInstallReport* add_app_install_reports();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >&
app_install_reports() const;

// @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport > app_install_reports_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ExtensionInstallReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionInstallReportRequest) */ {
public:
ExtensionInstallReportRequest();
virtual ~ExtensionInstallReportRequest();

ExtensionInstallReportRequest(const ExtensionInstallReportRequest& from);
ExtensionInstallReportRequest(ExtensionInstallReportRequest&& from) noexcept
: ExtensionInstallReportRequest() {
*this = ::std::move(from);
}

inline ExtensionInstallReportRequest& operator=(const ExtensionInstallReportRequest& from) {
CopyFrom(from);
return *this;
}
inline ExtensionInstallReportRequest& operator=(ExtensionInstallReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ExtensionInstallReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ExtensionInstallReportRequest* internal_default_instance() {
return reinterpret_cast<const ExtensionInstallReportRequest*>(
&_ExtensionInstallReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
132;

friend void swap(ExtensionInstallReportRequest& a, ExtensionInstallReportRequest& b) {
a.Swap(&b);
}
inline void Swap(ExtensionInstallReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ExtensionInstallReportRequest* New() const final {
return CreateMaybeMessage<ExtensionInstallReportRequest>(nullptr);
}

ExtensionInstallReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ExtensionInstallReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ExtensionInstallReportRequest& from);
void MergeFrom(const ExtensionInstallReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ExtensionInstallReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ExtensionInstallReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kExtensionInstallReportsFieldNumber = 1,
};
// repeated .enterprise_management.ExtensionInstallReport extension_install_reports = 1;
int extension_install_reports_size() const;
void clear_extension_install_reports();
::enterprise_management::ExtensionInstallReport* mutable_extension_install_reports(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >*
mutable_extension_install_reports();
const ::enterprise_management::ExtensionInstallReport& extension_install_reports(int index) const;
::enterprise_management::ExtensionInstallReport* add_extension_install_reports();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >&
extension_install_reports() const;

// @@protoc_insertion_point(class_scope:enterprise_management.ExtensionInstallReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport > extension_install_reports_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppInstallReportResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReportResponse) */ {
public:
AppInstallReportResponse();
virtual ~AppInstallReportResponse();

AppInstallReportResponse(const AppInstallReportResponse& from);
AppInstallReportResponse(AppInstallReportResponse&& from) noexcept
: AppInstallReportResponse() {
*this = ::std::move(from);
}

inline AppInstallReportResponse& operator=(const AppInstallReportResponse& from) {
CopyFrom(from);
return *this;
}
inline AppInstallReportResponse& operator=(AppInstallReportResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppInstallReportResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppInstallReportResponse* internal_default_instance() {
return reinterpret_cast<const AppInstallReportResponse*>(
&_AppInstallReportResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
133;

friend void swap(AppInstallReportResponse& a, AppInstallReportResponse& b) {
a.Swap(&b);
}
inline void Swap(AppInstallReportResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppInstallReportResponse* New() const final {
return CreateMaybeMessage<AppInstallReportResponse>(nullptr);
}

AppInstallReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppInstallReportResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppInstallReportResponse& from);
void MergeFrom(const AppInstallReportResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppInstallReportResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AppInstallReportResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReportResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RefreshAccountRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RefreshAccountRequest) */ {
public:
RefreshAccountRequest();
virtual ~RefreshAccountRequest();

RefreshAccountRequest(const RefreshAccountRequest& from);
RefreshAccountRequest(RefreshAccountRequest&& from) noexcept
: RefreshAccountRequest() {
*this = ::std::move(from);
}

inline RefreshAccountRequest& operator=(const RefreshAccountRequest& from) {
CopyFrom(from);
return *this;
}
inline RefreshAccountRequest& operator=(RefreshAccountRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const RefreshAccountRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const RefreshAccountRequest* internal_default_instance() {
return reinterpret_cast<const RefreshAccountRequest*>(
&_RefreshAccountRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
134;

friend void swap(RefreshAccountRequest& a, RefreshAccountRequest& b) {
a.Swap(&b);
}
inline void Swap(RefreshAccountRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline RefreshAccountRequest* New() const final {
return CreateMaybeMessage<RefreshAccountRequest>(nullptr);
}

RefreshAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<RefreshAccountRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const RefreshAccountRequest& from);
void MergeFrom(const RefreshAccountRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RefreshAccountRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.RefreshAccountRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef RefreshAccountRequest_AccountType AccountType;
static constexpr AccountType ACCOUNT_TYPE_UNSPECIFIED =
RefreshAccountRequest_AccountType_ACCOUNT_TYPE_UNSPECIFIED;
static constexpr AccountType CHROME_OS_DEMO_MODE =
RefreshAccountRequest_AccountType_CHROME_OS_DEMO_MODE;
static inline bool AccountType_IsValid(int value) {
return RefreshAccountRequest_AccountType_IsValid(value);
}
static constexpr AccountType AccountType_MIN =
RefreshAccountRequest_AccountType_AccountType_MIN;
static constexpr AccountType AccountType_MAX =
RefreshAccountRequest_AccountType_AccountType_MAX;
static constexpr int AccountType_ARRAYSIZE =
RefreshAccountRequest_AccountType_AccountType_ARRAYSIZE;
template<typename T>
static inline const std::string& AccountType_Name(T enum_t_value) {
static_assert(::std::is_same<T, AccountType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AccountType_Name.");
return RefreshAccountRequest_AccountType_Name(enum_t_value);
}
static inline bool AccountType_Parse(const std::string& name,
AccountType* value) {
return RefreshAccountRequest_AccountType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kAccountTypeFieldNumber = 1,
};
// optional .enterprise_management.RefreshAccountRequest.AccountType account_type = 1;
bool has_account_type() const;
void clear_account_type();
::enterprise_management::RefreshAccountRequest_AccountType account_type() const;
void set_account_type(::enterprise_management::RefreshAccountRequest_AccountType value);

// @@protoc_insertion_point(class_scope:enterprise_management.RefreshAccountRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int account_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RefreshAccountResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RefreshAccountResponse) */ {
public:
RefreshAccountResponse();
virtual ~RefreshAccountResponse();

RefreshAccountResponse(const RefreshAccountResponse& from);
RefreshAccountResponse(RefreshAccountResponse&& from) noexcept
: RefreshAccountResponse() {
*this = ::std::move(from);
}

inline RefreshAccountResponse& operator=(const RefreshAccountResponse& from) {
CopyFrom(from);
return *this;
}
inline RefreshAccountResponse& operator=(RefreshAccountResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const RefreshAccountResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const RefreshAccountResponse* internal_default_instance() {
return reinterpret_cast<const RefreshAccountResponse*>(
&_RefreshAccountResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
135;

friend void swap(RefreshAccountResponse& a, RefreshAccountResponse& b) {
a.Swap(&b);
}
inline void Swap(RefreshAccountResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline RefreshAccountResponse* New() const final {
return CreateMaybeMessage<RefreshAccountResponse>(nullptr);
}

RefreshAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<RefreshAccountResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const RefreshAccountResponse& from);
void MergeFrom(const RefreshAccountResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RefreshAccountResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.RefreshAccountResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.RefreshAccountResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RsuLookupKeyUploadRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RsuLookupKeyUploadRequest) */ {
public:
RsuLookupKeyUploadRequest();
virtual ~RsuLookupKeyUploadRequest();

RsuLookupKeyUploadRequest(const RsuLookupKeyUploadRequest& from);
RsuLookupKeyUploadRequest(RsuLookupKeyUploadRequest&& from) noexcept
: RsuLookupKeyUploadRequest() {
*this = ::std::move(from);
}

inline RsuLookupKeyUploadRequest& operator=(const RsuLookupKeyUploadRequest& from) {
CopyFrom(from);
return *this;
}
inline RsuLookupKeyUploadRequest& operator=(RsuLookupKeyUploadRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const RsuLookupKeyUploadRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const RsuLookupKeyUploadRequest* internal_default_instance() {
return reinterpret_cast<const RsuLookupKeyUploadRequest*>(
&_RsuLookupKeyUploadRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
136;

friend void swap(RsuLookupKeyUploadRequest& a, RsuLookupKeyUploadRequest& b) {
a.Swap(&b);
}
inline void Swap(RsuLookupKeyUploadRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline RsuLookupKeyUploadRequest* New() const final {
return CreateMaybeMessage<RsuLookupKeyUploadRequest>(nullptr);
}

RsuLookupKeyUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<RsuLookupKeyUploadRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const RsuLookupKeyUploadRequest& from);
void MergeFrom(const RsuLookupKeyUploadRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RsuLookupKeyUploadRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.RsuLookupKeyUploadRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kBoardIdFieldNumber = 1,
kCr50HashedDeviceIdFieldNumber = 2,
};
// optional bytes board_id = 1;
bool has_board_id() const;
void clear_board_id();
const std::string& board_id() const;
void set_board_id(const std::string& value);
void set_board_id(std::string&& value);
void set_board_id(const char* value);
void set_board_id(const void* value, size_t size);
std::string* mutable_board_id();
std::string* release_board_id();
void set_allocated_board_id(std::string* board_id);

// optional bytes cr50_hashed_device_id = 2;
bool has_cr50_hashed_device_id() const;
void clear_cr50_hashed_device_id();
const std::string& cr50_hashed_device_id() const;
void set_cr50_hashed_device_id(const std::string& value);
void set_cr50_hashed_device_id(std::string&& value);
void set_cr50_hashed_device_id(const char* value);
void set_cr50_hashed_device_id(const void* value, size_t size);
std::string* mutable_cr50_hashed_device_id();
std::string* release_cr50_hashed_device_id();
void set_allocated_cr50_hashed_device_id(std::string* cr50_hashed_device_id);

// @@protoc_insertion_point(class_scope:enterprise_management.RsuLookupKeyUploadRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr board_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cr50_hashed_device_id_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RsuLookupKeyUploadResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RsuLookupKeyUploadResponse) */ {
public:
RsuLookupKeyUploadResponse();
virtual ~RsuLookupKeyUploadResponse();

RsuLookupKeyUploadResponse(const RsuLookupKeyUploadResponse& from);
RsuLookupKeyUploadResponse(RsuLookupKeyUploadResponse&& from) noexcept
: RsuLookupKeyUploadResponse() {
*this = ::std::move(from);
}

inline RsuLookupKeyUploadResponse& operator=(const RsuLookupKeyUploadResponse& from) {
CopyFrom(from);
return *this;
}
inline RsuLookupKeyUploadResponse& operator=(RsuLookupKeyUploadResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const RsuLookupKeyUploadResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const RsuLookupKeyUploadResponse* internal_default_instance() {
return reinterpret_cast<const RsuLookupKeyUploadResponse*>(
&_RsuLookupKeyUploadResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
137;

friend void swap(RsuLookupKeyUploadResponse& a, RsuLookupKeyUploadResponse& b) {
a.Swap(&b);
}
inline void Swap(RsuLookupKeyUploadResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline RsuLookupKeyUploadResponse* New() const final {
return CreateMaybeMessage<RsuLookupKeyUploadResponse>(nullptr);
}

RsuLookupKeyUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<RsuLookupKeyUploadResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const RsuLookupKeyUploadResponse& from);
void MergeFrom(const RsuLookupKeyUploadResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RsuLookupKeyUploadResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.RsuLookupKeyUploadResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kRsuLookupKeyUpdatedFieldNumber = 1,
};
// optional bool rsu_lookup_key_updated = 1;
bool has_rsu_lookup_key_updated() const;
void clear_rsu_lookup_key_updated();
bool rsu_lookup_key_updated() const;
void set_rsu_lookup_key_updated(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.RsuLookupKeyUploadResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
bool rsu_lookup_key_updated_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT App :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.App) */ {
public:
App();
virtual ~App();

App(const App& from);
App(App&& from) noexcept
: App() {
*this = ::std::move(from);
}

inline App& operator=(const App& from) {
CopyFrom(from);
return *this;
}
inline App& operator=(App&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const App& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const App* internal_default_instance() {
return reinterpret_cast<const App*>(
&_App_default_instance_);
}
static constexpr int kIndexInFileMessages =
138;

friend void swap(App& a, App& b) {
a.Swap(&b);
}
inline void Swap(App* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline App* New() const final {
return CreateMaybeMessage<App>(nullptr);
}

App* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<App>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const App& from);
void MergeFrom(const App& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(App* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.App";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef App_AppType AppType;
static constexpr AppType UNKNOWN =
App_AppType_UNKNOWN;
static constexpr AppType ARC =
App_AppType_ARC;
static constexpr AppType BUILT_IN =
App_AppType_BUILT_IN;
static constexpr AppType CROSTINI =
App_AppType_CROSTINI;
static constexpr AppType EXTENSION =
App_AppType_EXTENSION;
static constexpr AppType WEB =
App_AppType_WEB;
static constexpr AppType PLUGIN_VM =
App_AppType_PLUGIN_VM;
static inline bool AppType_IsValid(int value) {
return App_AppType_IsValid(value);
}
static constexpr AppType AppType_MIN =
App_AppType_AppType_MIN;
static constexpr AppType AppType_MAX =
App_AppType_AppType_MAX;
static constexpr int AppType_ARRAYSIZE =
App_AppType_AppType_ARRAYSIZE;
template<typename T>
static inline const std::string& AppType_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppType_Name.");
return App_AppType_Name(enum_t_value);
}
static inline bool AppType_Parse(const std::string& name,
AppType* value) {
return App_AppType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kAdditionalAppIdFieldNumber = 3,
kAppIdFieldNumber = 1,
kAppTypeFieldNumber = 2,
};
// repeated string additional_app_id = 3;
int additional_app_id_size() const;
void clear_additional_app_id();
const std::string& additional_app_id(int index) const;
std::string* mutable_additional_app_id(int index);
void set_additional_app_id(int index, const std::string& value);
void set_additional_app_id(int index, std::string&& value);
void set_additional_app_id(int index, const char* value);
void set_additional_app_id(int index, const char* value, size_t size);
std::string* add_additional_app_id();
void add_additional_app_id(const std::string& value);
void add_additional_app_id(std::string&& value);
void add_additional_app_id(const char* value);
void add_additional_app_id(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& additional_app_id() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_additional_app_id();

// optional string app_id = 1;
bool has_app_id() const;
void clear_app_id();
const std::string& app_id() const;
void set_app_id(const std::string& value);
void set_app_id(std::string&& value);
void set_app_id(const char* value);
void set_app_id(const char* value, size_t size);
std::string* mutable_app_id();
std::string* release_app_id();
void set_allocated_app_id(std::string* app_id);

// optional .enterprise_management.App.AppType app_type = 2;
bool has_app_type() const;
void clear_app_type();
::enterprise_management::App_AppType app_type() const;
void set_app_type(::enterprise_management::App_AppType value);

// @@protoc_insertion_point(class_scope:enterprise_management.App)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> additional_app_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
int app_type_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppActivity :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppActivity) */ {
public:
AppActivity();
virtual ~AppActivity();

AppActivity(const AppActivity& from);
AppActivity(AppActivity&& from) noexcept
: AppActivity() {
*this = ::std::move(from);
}

inline AppActivity& operator=(const AppActivity& from) {
CopyFrom(from);
return *this;
}
inline AppActivity& operator=(AppActivity&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppActivity& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppActivity* internal_default_instance() {
return reinterpret_cast<const AppActivity*>(
&_AppActivity_default_instance_);
}
static constexpr int kIndexInFileMessages =
139;

friend void swap(AppActivity& a, AppActivity& b) {
a.Swap(&b);
}
inline void Swap(AppActivity* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppActivity* New() const final {
return CreateMaybeMessage<AppActivity>(nullptr);
}

AppActivity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppActivity>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppActivity& from);
void MergeFrom(const AppActivity& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppActivity* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.AppActivity";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef AppActivity_AppState AppState;
static constexpr AppState UNKNOWN =
AppActivity_AppState_UNKNOWN;
static constexpr AppState DEFAULT =
AppActivity_AppState_DEFAULT;
static constexpr AppState ALWAYS_AVAILABLE =
AppActivity_AppState_ALWAYS_AVAILABLE;
static constexpr AppState BLOCKED =
AppActivity_AppState_BLOCKED;
static constexpr AppState LIMIT_REACHED =
AppActivity_AppState_LIMIT_REACHED;
static constexpr AppState UNINSTALLED =
AppActivity_AppState_UNINSTALLED;
static inline bool AppState_IsValid(int value) {
return AppActivity_AppState_IsValid(value);
}
static constexpr AppState AppState_MIN =
AppActivity_AppState_AppState_MIN;
static constexpr AppState AppState_MAX =
AppActivity_AppState_AppState_MAX;
static constexpr int AppState_ARRAYSIZE =
AppActivity_AppState_AppState_ARRAYSIZE;
template<typename T>
static inline const std::string& AppState_Name(T enum_t_value) {
static_assert(::std::is_same<T, AppState>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AppState_Name.");
return AppActivity_AppState_Name(enum_t_value);
}
static inline bool AppState_Parse(const std::string& name,
AppState* value) {
return AppActivity_AppState_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kActiveTimePeriodsFieldNumber = 2,
kAppInfoFieldNumber = 1,
kPopulatedAtFieldNumber = 3,
kAppStateFieldNumber = 4,
};
// repeated .enterprise_management.TimePeriod active_time_periods = 2;
int active_time_periods_size() const;
void clear_active_time_periods();
::enterprise_management::TimePeriod* mutable_active_time_periods(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
mutable_active_time_periods();
const ::enterprise_management::TimePeriod& active_time_periods(int index) const;
::enterprise_management::TimePeriod* add_active_time_periods();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
active_time_periods() const;

// optional .enterprise_management.App app_info = 1;
bool has_app_info() const;
void clear_app_info();
const ::enterprise_management::App& app_info() const;
::enterprise_management::App* release_app_info();
::enterprise_management::App* mutable_app_info();
void set_allocated_app_info(::enterprise_management::App* app_info);

// optional int64 populated_at = 3;
bool has_populated_at() const;
void clear_populated_at();
::PROTOBUF_NAMESPACE_ID::int64 populated_at() const;
void set_populated_at(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.AppActivity.AppState app_state = 4;
bool has_app_state() const;
void clear_app_state();
::enterprise_management::AppActivity_AppState app_state() const;
void set_app_state(::enterprise_management::AppActivity_AppState value);

// @@protoc_insertion_point(class_scope:enterprise_management.AppActivity)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod > active_time_periods_;
::enterprise_management::App* app_info_;
::PROTOBUF_NAMESPACE_ID::int64 populated_at_;
int app_state_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ScreenTimeSpan :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ScreenTimeSpan) */ {
public:
ScreenTimeSpan();
virtual ~ScreenTimeSpan();

ScreenTimeSpan(const ScreenTimeSpan& from);
ScreenTimeSpan(ScreenTimeSpan&& from) noexcept
: ScreenTimeSpan() {
*this = ::std::move(from);
}

inline ScreenTimeSpan& operator=(const ScreenTimeSpan& from) {
CopyFrom(from);
return *this;
}
inline ScreenTimeSpan& operator=(ScreenTimeSpan&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ScreenTimeSpan& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ScreenTimeSpan* internal_default_instance() {
return reinterpret_cast<const ScreenTimeSpan*>(
&_ScreenTimeSpan_default_instance_);
}
static constexpr int kIndexInFileMessages =
140;

friend void swap(ScreenTimeSpan& a, ScreenTimeSpan& b) {
a.Swap(&b);
}
inline void Swap(ScreenTimeSpan* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ScreenTimeSpan* New() const final {
return CreateMaybeMessage<ScreenTimeSpan>(nullptr);
}

ScreenTimeSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ScreenTimeSpan>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ScreenTimeSpan& from);
void MergeFrom(const ScreenTimeSpan& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ScreenTimeSpan* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ScreenTimeSpan";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kTimePeriodFieldNumber = 1,
kActiveDurationMsFieldNumber = 2,
};
// optional .enterprise_management.TimePeriod time_period = 1;
bool has_time_period() const;
void clear_time_period();
const ::enterprise_management::TimePeriod& time_period() const;
::enterprise_management::TimePeriod* release_time_period();
::enterprise_management::TimePeriod* mutable_time_period();
void set_allocated_time_period(::enterprise_management::TimePeriod* time_period);

// optional int64 active_duration_ms = 2;
bool has_active_duration_ms() const;
void clear_active_duration_ms();
::PROTOBUF_NAMESPACE_ID::int64 active_duration_ms() const;
void set_active_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.ScreenTimeSpan)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::enterprise_management::TimePeriod* time_period_;
::PROTOBUF_NAMESPACE_ID::int64 active_duration_ms_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChildStatusReportRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChildStatusReportRequest) */ {
public:
ChildStatusReportRequest();
virtual ~ChildStatusReportRequest();

ChildStatusReportRequest(const ChildStatusReportRequest& from);
ChildStatusReportRequest(ChildStatusReportRequest&& from) noexcept
: ChildStatusReportRequest() {
*this = ::std::move(from);
}

inline ChildStatusReportRequest& operator=(const ChildStatusReportRequest& from) {
CopyFrom(from);
return *this;
}
inline ChildStatusReportRequest& operator=(ChildStatusReportRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChildStatusReportRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChildStatusReportRequest* internal_default_instance() {
return reinterpret_cast<const ChildStatusReportRequest*>(
&_ChildStatusReportRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
141;

friend void swap(ChildStatusReportRequest& a, ChildStatusReportRequest& b) {
a.Swap(&b);
}
inline void Swap(ChildStatusReportRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChildStatusReportRequest* New() const final {
return CreateMaybeMessage<ChildStatusReportRequest>(nullptr);
}

ChildStatusReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChildStatusReportRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChildStatusReportRequest& from);
void MergeFrom(const ChildStatusReportRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChildStatusReportRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChildStatusReportRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kScreenTimeSpanFieldNumber = 4,
kAppActivityFieldNumber = 8,
kUserDmTokenFieldNumber = 1,
kTimeZoneFieldNumber = 3,
kOsVersionFieldNumber = 6,
kBootModeFieldNumber = 7,
kAndroidStatusFieldNumber = 5,
kTimestampMsFieldNumber = 2,
};
// repeated .enterprise_management.ScreenTimeSpan screen_time_span = 4;
int screen_time_span_size() const;
void clear_screen_time_span();
::enterprise_management::ScreenTimeSpan* mutable_screen_time_span(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >*
mutable_screen_time_span();
const ::enterprise_management::ScreenTimeSpan& screen_time_span(int index) const;
::enterprise_management::ScreenTimeSpan* add_screen_time_span();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >&
screen_time_span() const;

// repeated .enterprise_management.AppActivity app_activity = 8;
int app_activity_size() const;
void clear_app_activity();
::enterprise_management::AppActivity* mutable_app_activity(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >*
mutable_app_activity();
const ::enterprise_management::AppActivity& app_activity(int index) const;
::enterprise_management::AppActivity* add_app_activity();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >&
app_activity() const;

// optional string user_dm_token = 1;
bool has_user_dm_token() const;
void clear_user_dm_token();
const std::string& user_dm_token() const;
void set_user_dm_token(const std::string& value);
void set_user_dm_token(std::string&& value);
void set_user_dm_token(const char* value);
void set_user_dm_token(const char* value, size_t size);
std::string* mutable_user_dm_token();
std::string* release_user_dm_token();
void set_allocated_user_dm_token(std::string* user_dm_token);

// optional string time_zone = 3;
bool has_time_zone() const;
void clear_time_zone();
const std::string& time_zone() const;
void set_time_zone(const std::string& value);
void set_time_zone(std::string&& value);
void set_time_zone(const char* value);
void set_time_zone(const char* value, size_t size);
std::string* mutable_time_zone();
std::string* release_time_zone();
void set_allocated_time_zone(std::string* time_zone);

// optional string os_version = 6;
bool has_os_version() const;
void clear_os_version();
const std::string& os_version() const;
void set_os_version(const std::string& value);
void set_os_version(std::string&& value);
void set_os_version(const char* value);
void set_os_version(const char* value, size_t size);
std::string* mutable_os_version();
std::string* release_os_version();
void set_allocated_os_version(std::string* os_version);

// optional string boot_mode = 7;
bool has_boot_mode() const;
void clear_boot_mode();
const std::string& boot_mode() const;
void set_boot_mode(const std::string& value);
void set_boot_mode(std::string&& value);
void set_boot_mode(const char* value);
void set_boot_mode(const char* value, size_t size);
std::string* mutable_boot_mode();
std::string* release_boot_mode();
void set_allocated_boot_mode(std::string* boot_mode);

// optional .enterprise_management.AndroidStatus android_status = 5;
bool has_android_status() const;
void clear_android_status();
const ::enterprise_management::AndroidStatus& android_status() const;
::enterprise_management::AndroidStatus* release_android_status();
::enterprise_management::AndroidStatus* mutable_android_status();
void set_allocated_android_status(::enterprise_management::AndroidStatus* android_status);

// optional int64 timestamp_ms = 2;
bool has_timestamp_ms() const;
void clear_timestamp_ms();
::PROTOBUF_NAMESPACE_ID::int64 timestamp_ms() const;
void set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:enterprise_management.ChildStatusReportRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan > screen_time_span_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity > app_activity_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_dm_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boot_mode_;
::enterprise_management::AndroidStatus* android_status_;
::PROTOBUF_NAMESPACE_ID::int64 timestamp_ms_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ChildStatusReportResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChildStatusReportResponse) */ {
public:
ChildStatusReportResponse();
virtual ~ChildStatusReportResponse();

ChildStatusReportResponse(const ChildStatusReportResponse& from);
ChildStatusReportResponse(ChildStatusReportResponse&& from) noexcept
: ChildStatusReportResponse() {
*this = ::std::move(from);
}

inline ChildStatusReportResponse& operator=(const ChildStatusReportResponse& from) {
CopyFrom(from);
return *this;
}
inline ChildStatusReportResponse& operator=(ChildStatusReportResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ChildStatusReportResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ChildStatusReportResponse* internal_default_instance() {
return reinterpret_cast<const ChildStatusReportResponse*>(
&_ChildStatusReportResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
142;

friend void swap(ChildStatusReportResponse& a, ChildStatusReportResponse& b) {
a.Swap(&b);
}
inline void Swap(ChildStatusReportResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ChildStatusReportResponse* New() const final {
return CreateMaybeMessage<ChildStatusReportResponse>(nullptr);
}

ChildStatusReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ChildStatusReportResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ChildStatusReportResponse& from);
void MergeFrom(const ChildStatusReportResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ChildStatusReportResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ChildStatusReportResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kErrorMessageFieldNumber = 2,
kErrorCodeFieldNumber = 1,
};
// optional string error_message = 2;
bool has_error_message() const;
void clear_error_message();
const std::string& error_message() const;
void set_error_message(const std::string& value);
void set_error_message(std::string&& value);
void set_error_message(const char* value);
void set_error_message(const char* value, size_t size);
std::string* mutable_error_message();
std::string* release_error_message();
void set_allocated_error_message(std::string* error_message);

// optional int32 error_code = 1;
bool has_error_code() const;
void clear_error_code();
::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:enterprise_management.ChildStatusReportResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
::PROTOBUF_NAMESPACE_ID::int32 error_code_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT StartCsrRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StartCsrRequest) */ {
public:
StartCsrRequest();
virtual ~StartCsrRequest();

StartCsrRequest(const StartCsrRequest& from);
StartCsrRequest(StartCsrRequest&& from) noexcept
: StartCsrRequest() {
*this = ::std::move(from);
}

inline StartCsrRequest& operator=(const StartCsrRequest& from) {
CopyFrom(from);
return *this;
}
inline StartCsrRequest& operator=(StartCsrRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const StartCsrRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const StartCsrRequest* internal_default_instance() {
return reinterpret_cast<const StartCsrRequest*>(
&_StartCsrRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
143;

friend void swap(StartCsrRequest& a, StartCsrRequest& b) {
a.Swap(&b);
}
inline void Swap(StartCsrRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline StartCsrRequest* New() const final {
return CreateMaybeMessage<StartCsrRequest>(nullptr);
}

StartCsrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<StartCsrRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const StartCsrRequest& from);
void MergeFrom(const StartCsrRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StartCsrRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.StartCsrRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.StartCsrRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT StartCsrResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StartCsrResponse) */ {
public:
StartCsrResponse();
virtual ~StartCsrResponse();

StartCsrResponse(const StartCsrResponse& from);
StartCsrResponse(StartCsrResponse&& from) noexcept
: StartCsrResponse() {
*this = ::std::move(from);
}

inline StartCsrResponse& operator=(const StartCsrResponse& from) {
CopyFrom(from);
return *this;
}
inline StartCsrResponse& operator=(StartCsrResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const StartCsrResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const StartCsrResponse* internal_default_instance() {
return reinterpret_cast<const StartCsrResponse*>(
&_StartCsrResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
144;

friend void swap(StartCsrResponse& a, StartCsrResponse& b) {
a.Swap(&b);
}
inline void Swap(StartCsrResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline StartCsrResponse* New() const final {
return CreateMaybeMessage<StartCsrResponse>(nullptr);
}

StartCsrResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<StartCsrResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const StartCsrResponse& from);
void MergeFrom(const StartCsrResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StartCsrResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.StartCsrResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kInvalidationTopicFieldNumber = 1,
kVaChallengeFieldNumber = 2,
kDataToSignFieldNumber = 4,
kSigningAlgorithmFieldNumber = 3,
kHashingAlgorithmFieldNumber = 5,
};
// optional string invalidation_topic = 1;
bool has_invalidation_topic() const;
void clear_invalidation_topic();
const std::string& invalidation_topic() const;
void set_invalidation_topic(const std::string& value);
void set_invalidation_topic(std::string&& value);
void set_invalidation_topic(const char* value);
void set_invalidation_topic(const char* value, size_t size);
std::string* mutable_invalidation_topic();
std::string* release_invalidation_topic();
void set_allocated_invalidation_topic(std::string* invalidation_topic);

// optional bytes va_challenge = 2;
bool has_va_challenge() const;
void clear_va_challenge();
const std::string& va_challenge() const;
void set_va_challenge(const std::string& value);
void set_va_challenge(std::string&& value);
void set_va_challenge(const char* value);
void set_va_challenge(const void* value, size_t size);
std::string* mutable_va_challenge();
std::string* release_va_challenge();
void set_allocated_va_challenge(std::string* va_challenge);

// optional bytes data_to_sign = 4;
bool has_data_to_sign() const;
void clear_data_to_sign();
const std::string& data_to_sign() const;
void set_data_to_sign(const std::string& value);
void set_data_to_sign(std::string&& value);
void set_data_to_sign(const char* value);
void set_data_to_sign(const void* value, size_t size);
std::string* mutable_data_to_sign();
std::string* release_data_to_sign();
void set_allocated_data_to_sign(std::string* data_to_sign);

// optional .enterprise_management.SigningAlgorithm signing_algorithm = 3;
bool has_signing_algorithm() const;
void clear_signing_algorithm();
::enterprise_management::SigningAlgorithm signing_algorithm() const;
void set_signing_algorithm(::enterprise_management::SigningAlgorithm value);

// optional .enterprise_management.HashingAlgorithm hashing_algorithm = 5;
bool has_hashing_algorithm() const;
void clear_hashing_algorithm();
::enterprise_management::HashingAlgorithm hashing_algorithm() const;
void set_hashing_algorithm(::enterprise_management::HashingAlgorithm value);

// @@protoc_insertion_point(class_scope:enterprise_management.StartCsrResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidation_topic_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr va_challenge_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_to_sign_;
int signing_algorithm_;
int hashing_algorithm_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT FinishCsrRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.FinishCsrRequest) */ {
public:
FinishCsrRequest();
virtual ~FinishCsrRequest();

FinishCsrRequest(const FinishCsrRequest& from);
FinishCsrRequest(FinishCsrRequest&& from) noexcept
: FinishCsrRequest() {
*this = ::std::move(from);
}

inline FinishCsrRequest& operator=(const FinishCsrRequest& from) {
CopyFrom(from);
return *this;
}
inline FinishCsrRequest& operator=(FinishCsrRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const FinishCsrRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const FinishCsrRequest* internal_default_instance() {
return reinterpret_cast<const FinishCsrRequest*>(
&_FinishCsrRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
145;

friend void swap(FinishCsrRequest& a, FinishCsrRequest& b) {
a.Swap(&b);
}
inline void Swap(FinishCsrRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline FinishCsrRequest* New() const final {
return CreateMaybeMessage<FinishCsrRequest>(nullptr);
}

FinishCsrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<FinishCsrRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const FinishCsrRequest& from);
void MergeFrom(const FinishCsrRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(FinishCsrRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.FinishCsrRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kVaChallengeResponseFieldNumber = 1,
kSignatureFieldNumber = 2,
};
// optional bytes va_challenge_response = 1;
bool has_va_challenge_response() const;
void clear_va_challenge_response();
const std::string& va_challenge_response() const;
void set_va_challenge_response(const std::string& value);
void set_va_challenge_response(std::string&& value);
void set_va_challenge_response(const char* value);
void set_va_challenge_response(const void* value, size_t size);
std::string* mutable_va_challenge_response();
std::string* release_va_challenge_response();
void set_allocated_va_challenge_response(std::string* va_challenge_response);

// optional bytes signature = 2;
bool has_signature() const;
void clear_signature();
const std::string& signature() const;
void set_signature(const std::string& value);
void set_signature(std::string&& value);
void set_signature(const char* value);
void set_signature(const void* value, size_t size);
std::string* mutable_signature();
std::string* release_signature();
void set_allocated_signature(std::string* signature);

// @@protoc_insertion_point(class_scope:enterprise_management.FinishCsrRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr va_challenge_response_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT FinishCsrResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.FinishCsrResponse) */ {
public:
FinishCsrResponse();
virtual ~FinishCsrResponse();

FinishCsrResponse(const FinishCsrResponse& from);
FinishCsrResponse(FinishCsrResponse&& from) noexcept
: FinishCsrResponse() {
*this = ::std::move(from);
}

inline FinishCsrResponse& operator=(const FinishCsrResponse& from) {
CopyFrom(from);
return *this;
}
inline FinishCsrResponse& operator=(FinishCsrResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const FinishCsrResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const FinishCsrResponse* internal_default_instance() {
return reinterpret_cast<const FinishCsrResponse*>(
&_FinishCsrResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
146;

friend void swap(FinishCsrResponse& a, FinishCsrResponse& b) {
a.Swap(&b);
}
inline void Swap(FinishCsrResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline FinishCsrResponse* New() const final {
return CreateMaybeMessage<FinishCsrResponse>(nullptr);
}

FinishCsrResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<FinishCsrResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const FinishCsrResponse& from);
void MergeFrom(const FinishCsrResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(FinishCsrResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.FinishCsrResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.FinishCsrResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DownloadCertRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DownloadCertRequest) */ {
public:
DownloadCertRequest();
virtual ~DownloadCertRequest();

DownloadCertRequest(const DownloadCertRequest& from);
DownloadCertRequest(DownloadCertRequest&& from) noexcept
: DownloadCertRequest() {
*this = ::std::move(from);
}

inline DownloadCertRequest& operator=(const DownloadCertRequest& from) {
CopyFrom(from);
return *this;
}
inline DownloadCertRequest& operator=(DownloadCertRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DownloadCertRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DownloadCertRequest* internal_default_instance() {
return reinterpret_cast<const DownloadCertRequest*>(
&_DownloadCertRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
147;

friend void swap(DownloadCertRequest& a, DownloadCertRequest& b) {
a.Swap(&b);
}
inline void Swap(DownloadCertRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DownloadCertRequest* New() const final {
return CreateMaybeMessage<DownloadCertRequest>(nullptr);
}

DownloadCertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DownloadCertRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DownloadCertRequest& from);
void MergeFrom(const DownloadCertRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DownloadCertRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DownloadCertRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:enterprise_management.DownloadCertRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DownloadCertResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DownloadCertResponse) */ {
public:
DownloadCertResponse();
virtual ~DownloadCertResponse();

DownloadCertResponse(const DownloadCertResponse& from);
DownloadCertResponse(DownloadCertResponse&& from) noexcept
: DownloadCertResponse() {
*this = ::std::move(from);
}

inline DownloadCertResponse& operator=(const DownloadCertResponse& from) {
CopyFrom(from);
return *this;
}
inline DownloadCertResponse& operator=(DownloadCertResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DownloadCertResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DownloadCertResponse* internal_default_instance() {
return reinterpret_cast<const DownloadCertResponse*>(
&_DownloadCertResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
148;

friend void swap(DownloadCertResponse& a, DownloadCertResponse& b) {
a.Swap(&b);
}
inline void Swap(DownloadCertResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DownloadCertResponse* New() const final {
return CreateMaybeMessage<DownloadCertResponse>(nullptr);
}

DownloadCertResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DownloadCertResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DownloadCertResponse& from);
void MergeFrom(const DownloadCertResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DownloadCertResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DownloadCertResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kPemEncodedCertificateFieldNumber = 1,
};
// optional string pem_encoded_certificate = 1;
bool has_pem_encoded_certificate() const;
void clear_pem_encoded_certificate();
const std::string& pem_encoded_certificate() const;
void set_pem_encoded_certificate(const std::string& value);
void set_pem_encoded_certificate(std::string&& value);
void set_pem_encoded_certificate(const char* value);
void set_pem_encoded_certificate(const char* value, size_t size);
std::string* mutable_pem_encoded_certificate();
std::string* release_pem_encoded_certificate();
void set_allocated_pem_encoded_certificate(std::string* pem_encoded_certificate);

// @@protoc_insertion_point(class_scope:enterprise_management.DownloadCertResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pem_encoded_certificate_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ClientCertificateProvisioningRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ClientCertificateProvisioningRequest) */ {
public:
ClientCertificateProvisioningRequest();
virtual ~ClientCertificateProvisioningRequest();

ClientCertificateProvisioningRequest(const ClientCertificateProvisioningRequest& from);
ClientCertificateProvisioningRequest(ClientCertificateProvisioningRequest&& from) noexcept
: ClientCertificateProvisioningRequest() {
*this = ::std::move(from);
}

inline ClientCertificateProvisioningRequest& operator=(const ClientCertificateProvisioningRequest& from) {
CopyFrom(from);
return *this;
}
inline ClientCertificateProvisioningRequest& operator=(ClientCertificateProvisioningRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ClientCertificateProvisioningRequest& default_instance();

enum RequestCase {
kStartCsrRequest = 5,
kFinishCsrRequest = 6,
kDownloadCertRequest = 7,
REQUEST_NOT_SET = 0,
};

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ClientCertificateProvisioningRequest* internal_default_instance() {
return reinterpret_cast<const ClientCertificateProvisioningRequest*>(
&_ClientCertificateProvisioningRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
149;

friend void swap(ClientCertificateProvisioningRequest& a, ClientCertificateProvisioningRequest& b) {
a.Swap(&b);
}
inline void Swap(ClientCertificateProvisioningRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ClientCertificateProvisioningRequest* New() const final {
return CreateMaybeMessage<ClientCertificateProvisioningRequest>(nullptr);
}

ClientCertificateProvisioningRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ClientCertificateProvisioningRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ClientCertificateProvisioningRequest& from);
void MergeFrom(const ClientCertificateProvisioningRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ClientCertificateProvisioningRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ClientCertificateProvisioningRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kCertificateScopeFieldNumber = 1,
kCertProfileIdFieldNumber = 2,
kPublicKeyFieldNumber = 3,
kDeviceDmTokenFieldNumber = 4,
kPolicyVersionFieldNumber = 8,
kStartCsrRequestFieldNumber = 5,
kFinishCsrRequestFieldNumber = 6,
kDownloadCertRequestFieldNumber = 7,
};
// optional string certificate_scope = 1;
bool has_certificate_scope() const;
void clear_certificate_scope();
const std::string& certificate_scope() const;
void set_certificate_scope(const std::string& value);
void set_certificate_scope(std::string&& value);
void set_certificate_scope(const char* value);
void set_certificate_scope(const char* value, size_t size);
std::string* mutable_certificate_scope();
std::string* release_certificate_scope();
void set_allocated_certificate_scope(std::string* certificate_scope);

// optional string cert_profile_id = 2;
bool has_cert_profile_id() const;
void clear_cert_profile_id();
const std::string& cert_profile_id() const;
void set_cert_profile_id(const std::string& value);
void set_cert_profile_id(std::string&& value);
void set_cert_profile_id(const char* value);
void set_cert_profile_id(const char* value, size_t size);
std::string* mutable_cert_profile_id();
std::string* release_cert_profile_id();
void set_allocated_cert_profile_id(std::string* cert_profile_id);

// optional bytes public_key = 3;
bool has_public_key() const;
void clear_public_key();
const std::string& public_key() const;
void set_public_key(const std::string& value);
void set_public_key(std::string&& value);
void set_public_key(const char* value);
void set_public_key(const void* value, size_t size);
std::string* mutable_public_key();
std::string* release_public_key();
void set_allocated_public_key(std::string* public_key);

// optional string device_dm_token = 4;
bool has_device_dm_token() const;
void clear_device_dm_token();
const std::string& device_dm_token() const;
void set_device_dm_token(const std::string& value);
void set_device_dm_token(std::string&& value);
void set_device_dm_token(const char* value);
void set_device_dm_token(const char* value, size_t size);
std::string* mutable_device_dm_token();
std::string* release_device_dm_token();
void set_allocated_device_dm_token(std::string* device_dm_token);

// optional bytes policy_version = 8;
bool has_policy_version() const;
void clear_policy_version();
const std::string& policy_version() const;
void set_policy_version(const std::string& value);
void set_policy_version(std::string&& value);
void set_policy_version(const char* value);
void set_policy_version(const void* value, size_t size);
std::string* mutable_policy_version();
std::string* release_policy_version();
void set_allocated_policy_version(std::string* policy_version);

// optional .enterprise_management.StartCsrRequest start_csr_request = 5;
bool has_start_csr_request() const;
void clear_start_csr_request();
const ::enterprise_management::StartCsrRequest& start_csr_request() const;
::enterprise_management::StartCsrRequest* release_start_csr_request();
::enterprise_management::StartCsrRequest* mutable_start_csr_request();
void set_allocated_start_csr_request(::enterprise_management::StartCsrRequest* start_csr_request);

// optional .enterprise_management.FinishCsrRequest finish_csr_request = 6;
bool has_finish_csr_request() const;
void clear_finish_csr_request();
const ::enterprise_management::FinishCsrRequest& finish_csr_request() const;
::enterprise_management::FinishCsrRequest* release_finish_csr_request();
::enterprise_management::FinishCsrRequest* mutable_finish_csr_request();
void set_allocated_finish_csr_request(::enterprise_management::FinishCsrRequest* finish_csr_request);

// optional .enterprise_management.DownloadCertRequest download_cert_request = 7;
bool has_download_cert_request() const;
void clear_download_cert_request();
const ::enterprise_management::DownloadCertRequest& download_cert_request() const;
::enterprise_management::DownloadCertRequest* release_download_cert_request();
::enterprise_management::DownloadCertRequest* mutable_download_cert_request();
void set_allocated_download_cert_request(::enterprise_management::DownloadCertRequest* download_cert_request);

void clear_request();
RequestCase request_case() const;
// @@protoc_insertion_point(class_scope:enterprise_management.ClientCertificateProvisioningRequest)
private:
class _Internal;
void set_has_start_csr_request();
void set_has_finish_csr_request();
void set_has_download_cert_request();

inline bool has_request() const;
inline void clear_has_request();

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr certificate_scope_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cert_profile_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_dm_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_version_;
union RequestUnion {
RequestUnion() {}
::enterprise_management::StartCsrRequest* start_csr_request_;
::enterprise_management::FinishCsrRequest* finish_csr_request_;
::enterprise_management::DownloadCertRequest* download_cert_request_;
} request_;
::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ClientCertificateProvisioningResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ClientCertificateProvisioningResponse) */ {
public:
ClientCertificateProvisioningResponse();
virtual ~ClientCertificateProvisioningResponse();

ClientCertificateProvisioningResponse(const ClientCertificateProvisioningResponse& from);
ClientCertificateProvisioningResponse(ClientCertificateProvisioningResponse&& from) noexcept
: ClientCertificateProvisioningResponse() {
*this = ::std::move(from);
}

inline ClientCertificateProvisioningResponse& operator=(const ClientCertificateProvisioningResponse& from) {
CopyFrom(from);
return *this;
}
inline ClientCertificateProvisioningResponse& operator=(ClientCertificateProvisioningResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ClientCertificateProvisioningResponse& default_instance();

enum ResponseCase {
kError = 2,
kStartCsrResponse = 3,
kFinishCsrResponse = 4,
kDownloadCertResponse = 5,
RESPONSE_NOT_SET = 0,
};

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ClientCertificateProvisioningResponse* internal_default_instance() {
return reinterpret_cast<const ClientCertificateProvisioningResponse*>(
&_ClientCertificateProvisioningResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
150;

friend void swap(ClientCertificateProvisioningResponse& a, ClientCertificateProvisioningResponse& b) {
a.Swap(&b);
}
inline void Swap(ClientCertificateProvisioningResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ClientCertificateProvisioningResponse* New() const final {
return CreateMaybeMessage<ClientCertificateProvisioningResponse>(nullptr);
}

ClientCertificateProvisioningResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ClientCertificateProvisioningResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ClientCertificateProvisioningResponse& from);
void MergeFrom(const ClientCertificateProvisioningResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ClientCertificateProvisioningResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.ClientCertificateProvisioningResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef ClientCertificateProvisioningResponse_Error Error;
static constexpr Error UNDEFINED =
ClientCertificateProvisioningResponse_Error_UNDEFINED;
static constexpr Error TIMED_OUT =
ClientCertificateProvisioningResponse_Error_TIMED_OUT;
static constexpr Error IDENTITY_VERIFICATION_ERROR =
ClientCertificateProvisioningResponse_Error_IDENTITY_VERIFICATION_ERROR;
static constexpr Error CA_ERROR =
ClientCertificateProvisioningResponse_Error_CA_ERROR;
static constexpr Error INCONSISTENT_DATA =
ClientCertificateProvisioningResponse_Error_INCONSISTENT_DATA;
static inline bool Error_IsValid(int value) {
return ClientCertificateProvisioningResponse_Error_IsValid(value);
}
static constexpr Error Error_MIN =
ClientCertificateProvisioningResponse_Error_Error_MIN;
static constexpr Error Error_MAX =
ClientCertificateProvisioningResponse_Error_Error_MAX;
static constexpr int Error_ARRAYSIZE =
ClientCertificateProvisioningResponse_Error_Error_ARRAYSIZE;
template<typename T>
static inline const std::string& Error_Name(T enum_t_value) {
static_assert(::std::is_same<T, Error>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Error_Name.");
return ClientCertificateProvisioningResponse_Error_Name(enum_t_value);
}
static inline bool Error_Parse(const std::string& name,
Error* value) {
return ClientCertificateProvisioningResponse_Error_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kTryAgainLaterFieldNumber = 1,
kErrorFieldNumber = 2,
kStartCsrResponseFieldNumber = 3,
kFinishCsrResponseFieldNumber = 4,
kDownloadCertResponseFieldNumber = 5,
};
// optional int64 try_again_later = 1;
bool has_try_again_later() const;
void clear_try_again_later();
::PROTOBUF_NAMESPACE_ID::int64 try_again_later() const;
void set_try_again_later(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .enterprise_management.ClientCertificateProvisioningResponse.Error error = 2;
bool has_error() const;
void clear_error();
::enterprise_management::ClientCertificateProvisioningResponse_Error error() const;
void set_error(::enterprise_management::ClientCertificateProvisioningResponse_Error value);

// optional .enterprise_management.StartCsrResponse start_csr_response = 3;
bool has_start_csr_response() const;
void clear_start_csr_response();
const ::enterprise_management::StartCsrResponse& start_csr_response() const;
::enterprise_management::StartCsrResponse* release_start_csr_response();
::enterprise_management::StartCsrResponse* mutable_start_csr_response();
void set_allocated_start_csr_response(::enterprise_management::StartCsrResponse* start_csr_response);

// optional .enterprise_management.FinishCsrResponse finish_csr_response = 4;
bool has_finish_csr_response() const;
void clear_finish_csr_response();
const ::enterprise_management::FinishCsrResponse& finish_csr_response() const;
::enterprise_management::FinishCsrResponse* release_finish_csr_response();
::enterprise_management::FinishCsrResponse* mutable_finish_csr_response();
void set_allocated_finish_csr_response(::enterprise_management::FinishCsrResponse* finish_csr_response);

// optional .enterprise_management.DownloadCertResponse download_cert_response = 5;
bool has_download_cert_response() const;
void clear_download_cert_response();
const ::enterprise_management::DownloadCertResponse& download_cert_response() const;
::enterprise_management::DownloadCertResponse* release_download_cert_response();
::enterprise_management::DownloadCertResponse* mutable_download_cert_response();
void set_allocated_download_cert_response(::enterprise_management::DownloadCertResponse* download_cert_response);

void clear_response();
ResponseCase response_case() const;
// @@protoc_insertion_point(class_scope:enterprise_management.ClientCertificateProvisioningResponse)
private:
class _Internal;
void set_has_error();
void set_has_start_csr_response();
void set_has_finish_csr_response();
void set_has_download_cert_response();

inline bool has_response() const;
inline void clear_has_response();

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int64 try_again_later_;
union ResponseUnion {
ResponseUnion() {}
int error_;
::enterprise_management::StartCsrResponse* start_csr_response_;
::enterprise_management::FinishCsrResponse* finish_csr_response_;
::enterprise_management::DownloadCertResponse* download_cert_response_;
} response_;
::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceManagementRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceManagementRequest) */ {
public:
DeviceManagementRequest();
virtual ~DeviceManagementRequest();

DeviceManagementRequest(const DeviceManagementRequest& from);
DeviceManagementRequest(DeviceManagementRequest&& from) noexcept
: DeviceManagementRequest() {
*this = ::std::move(from);
}

inline DeviceManagementRequest& operator=(const DeviceManagementRequest& from) {
CopyFrom(from);
return *this;
}
inline DeviceManagementRequest& operator=(DeviceManagementRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceManagementRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceManagementRequest* internal_default_instance() {
return reinterpret_cast<const DeviceManagementRequest*>(
&_DeviceManagementRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
151;

friend void swap(DeviceManagementRequest& a, DeviceManagementRequest& b) {
a.Swap(&b);
}
inline void Swap(DeviceManagementRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceManagementRequest* New() const final {
return CreateMaybeMessage<DeviceManagementRequest>(nullptr);
}

DeviceManagementRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceManagementRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceManagementRequest& from);
void MergeFrom(const DeviceManagementRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceManagementRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceManagementRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kRegisterRequestFieldNumber = 1,
kUnregisterRequestFieldNumber = 2,
kPolicyRequestFieldNumber = 3,
kDeviceStatusReportRequestFieldNumber = 4,
kSessionStatusReportRequestFieldNumber = 5,
kAutoEnrollmentRequestFieldNumber = 6,
kCertUploadRequestFieldNumber = 7,
kServiceApiAccessRequestFieldNumber = 8,
kDeviceStateRetrievalRequestFieldNumber = 9,
kDeviceStateKeyUpdateRequestFieldNumber = 10,
kDevicePairingRequestFieldNumber = 11,
kCheckDevicePairingRequestFieldNumber = 12,
kRemoteCommandRequestFieldNumber = 13,
kDeviceAttributeUpdatePermissionRequestFieldNumber = 14,
kDeviceAttributeUpdateRequestFieldNumber = 15,
kGcmIdUpdateRequestFieldNumber = 16,
kCheckAndroidManagementRequestFieldNumber = 17,
kCertificateBasedRegisterRequestFieldNumber = 18,
kActiveDirectoryEnrollPlayUserRequestFieldNumber = 19,
kActiveDirectoryPlayActivityRequestFieldNumber = 20,
kCheckDeviceLicenseRequestDeprecatedFieldNumber = 21,
kActiveDirectoryUserSigninRequestFieldNumber = 22,
kRegisterBrowserRequestFieldNumber = 23,
kAppInstallReportRequestFieldNumber = 25,
kChromeDesktopReportRequestFieldNumber = 26,
kPolicyValidationReportRequestFieldNumber = 27,
kDeviceInitialEnrollmentStateRequestFieldNumber = 28,
kRefreshAccountRequestFieldNumber = 29,
kChildStatusReportRequestFieldNumber = 30,
kRsuLookupKeyUploadRequestFieldNumber = 31,
kPublicSamlUserRequestFieldNumber = 32,
kChromeOsUserReportRequestFieldNumber = 33,
kClientCertificateProvisioningRequestFieldNumber = 34,
kExtensionInstallReportRequestFieldNumber = 35,
};
// optional .enterprise_management.DeviceRegisterRequest register_request = 1;
bool has_register_request() const;
void clear_register_request();
const ::enterprise_management::DeviceRegisterRequest& register_request() const;
::enterprise_management::DeviceRegisterRequest* release_register_request();
::enterprise_management::DeviceRegisterRequest* mutable_register_request();
void set_allocated_register_request(::enterprise_management::DeviceRegisterRequest* register_request);

// optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
bool has_unregister_request() const;
void clear_unregister_request();
const ::enterprise_management::DeviceUnregisterRequest& unregister_request() const;
::enterprise_management::DeviceUnregisterRequest* release_unregister_request();
::enterprise_management::DeviceUnregisterRequest* mutable_unregister_request();
void set_allocated_unregister_request(::enterprise_management::DeviceUnregisterRequest* unregister_request);

// optional .enterprise_management.DevicePolicyRequest policy_request = 3;
bool has_policy_request() const;
void clear_policy_request();
const ::enterprise_management::DevicePolicyRequest& policy_request() const;
::enterprise_management::DevicePolicyRequest* release_policy_request();
::enterprise_management::DevicePolicyRequest* mutable_policy_request();
void set_allocated_policy_request(::enterprise_management::DevicePolicyRequest* policy_request);

// optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
bool has_device_status_report_request() const;
void clear_device_status_report_request();
const ::enterprise_management::DeviceStatusReportRequest& device_status_report_request() const;
::enterprise_management::DeviceStatusReportRequest* release_device_status_report_request();
::enterprise_management::DeviceStatusReportRequest* mutable_device_status_report_request();
void set_allocated_device_status_report_request(::enterprise_management::DeviceStatusReportRequest* device_status_report_request);

// optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
bool has_session_status_report_request() const;
void clear_session_status_report_request();
const ::enterprise_management::SessionStatusReportRequest& session_status_report_request() const;
::enterprise_management::SessionStatusReportRequest* release_session_status_report_request();
::enterprise_management::SessionStatusReportRequest* mutable_session_status_report_request();
void set_allocated_session_status_report_request(::enterprise_management::SessionStatusReportRequest* session_status_report_request);

// optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
bool has_auto_enrollment_request() const;
void clear_auto_enrollment_request();
const ::enterprise_management::DeviceAutoEnrollmentRequest& auto_enrollment_request() const;
::enterprise_management::DeviceAutoEnrollmentRequest* release_auto_enrollment_request();
::enterprise_management::DeviceAutoEnrollmentRequest* mutable_auto_enrollment_request();
void set_allocated_auto_enrollment_request(::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request);

// optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
bool has_cert_upload_request() const;
void clear_cert_upload_request();
const ::enterprise_management::DeviceCertUploadRequest& cert_upload_request() const;
::enterprise_management::DeviceCertUploadRequest* release_cert_upload_request();
::enterprise_management::DeviceCertUploadRequest* mutable_cert_upload_request();
void set_allocated_cert_upload_request(::enterprise_management::DeviceCertUploadRequest* cert_upload_request);

// optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
bool has_service_api_access_request() const;
void clear_service_api_access_request();
const ::enterprise_management::DeviceServiceApiAccessRequest& service_api_access_request() const;
::enterprise_management::DeviceServiceApiAccessRequest* release_service_api_access_request();
::enterprise_management::DeviceServiceApiAccessRequest* mutable_service_api_access_request();
void set_allocated_service_api_access_request(::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request);

// optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
bool has_device_state_retrieval_request() const;
void clear_device_state_retrieval_request();
const ::enterprise_management::DeviceStateRetrievalRequest& device_state_retrieval_request() const;
::enterprise_management::DeviceStateRetrievalRequest* release_device_state_retrieval_request();
::enterprise_management::DeviceStateRetrievalRequest* mutable_device_state_retrieval_request();
void set_allocated_device_state_retrieval_request(::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request);

// optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
bool has_device_state_key_update_request() const;
void clear_device_state_key_update_request();
const ::enterprise_management::DeviceStateKeyUpdateRequest& device_state_key_update_request() const;
::enterprise_management::DeviceStateKeyUpdateRequest* release_device_state_key_update_request();
::enterprise_management::DeviceStateKeyUpdateRequest* mutable_device_state_key_update_request();
void set_allocated_device_state_key_update_request(::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request);

// optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
bool has_device_pairing_request() const;
void clear_device_pairing_request();
const ::enterprise_management::DevicePairingRequest& device_pairing_request() const;
::enterprise_management::DevicePairingRequest* release_device_pairing_request();
::enterprise_management::DevicePairingRequest* mutable_device_pairing_request();
void set_allocated_device_pairing_request(::enterprise_management::DevicePairingRequest* device_pairing_request);

// optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
bool has_check_device_pairing_request() const;
void clear_check_device_pairing_request();
const ::enterprise_management::CheckDevicePairingRequest& check_device_pairing_request() const;
::enterprise_management::CheckDevicePairingRequest* release_check_device_pairing_request();
::enterprise_management::CheckDevicePairingRequest* mutable_check_device_pairing_request();
void set_allocated_check_device_pairing_request(::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request);

// optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
bool has_remote_command_request() const;
void clear_remote_command_request();
const ::enterprise_management::DeviceRemoteCommandRequest& remote_command_request() const;
::enterprise_management::DeviceRemoteCommandRequest* release_remote_command_request();
::enterprise_management::DeviceRemoteCommandRequest* mutable_remote_command_request();
void set_allocated_remote_command_request(::enterprise_management::DeviceRemoteCommandRequest* remote_command_request);

// optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
bool has_device_attribute_update_permission_request() const;
void clear_device_attribute_update_permission_request();
const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& device_attribute_update_permission_request() const;
::enterprise_management::DeviceAttributeUpdatePermissionRequest* release_device_attribute_update_permission_request();
::enterprise_management::DeviceAttributeUpdatePermissionRequest* mutable_device_attribute_update_permission_request();
void set_allocated_device_attribute_update_permission_request(::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request);

// optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
bool has_device_attribute_update_request() const;
void clear_device_attribute_update_request();
const ::enterprise_management::DeviceAttributeUpdateRequest& device_attribute_update_request() const;
::enterprise_management::DeviceAttributeUpdateRequest* release_device_attribute_update_request();
::enterprise_management::DeviceAttributeUpdateRequest* mutable_device_attribute_update_request();
void set_allocated_device_attribute_update_request(::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request);

// optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
bool has_gcm_id_update_request() const;
void clear_gcm_id_update_request();
const ::enterprise_management::GcmIdUpdateRequest& gcm_id_update_request() const;
::enterprise_management::GcmIdUpdateRequest* release_gcm_id_update_request();
::enterprise_management::GcmIdUpdateRequest* mutable_gcm_id_update_request();
void set_allocated_gcm_id_update_request(::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request);

// optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
bool has_check_android_management_request() const;
void clear_check_android_management_request();
const ::enterprise_management::CheckAndroidManagementRequest& check_android_management_request() const;
::enterprise_management::CheckAndroidManagementRequest* release_check_android_management_request();
::enterprise_management::CheckAndroidManagementRequest* mutable_check_android_management_request();
void set_allocated_check_android_management_request(::enterprise_management::CheckAndroidManagementRequest* check_android_management_request);

// optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
bool has_certificate_based_register_request() const;
void clear_certificate_based_register_request();
const ::enterprise_management::CertificateBasedDeviceRegisterRequest& certificate_based_register_request() const;
::enterprise_management::CertificateBasedDeviceRegisterRequest* release_certificate_based_register_request();
::enterprise_management::CertificateBasedDeviceRegisterRequest* mutable_certificate_based_register_request();
void set_allocated_certificate_based_register_request(::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request);

// optional .enterprise_management.ActiveDirectoryEnrollPlayUserRequest active_directory_enroll_play_user_request = 19;
bool has_active_directory_enroll_play_user_request() const;
void clear_active_directory_enroll_play_user_request();
const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest& active_directory_enroll_play_user_request() const;
::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* release_active_directory_enroll_play_user_request();
::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* mutable_active_directory_enroll_play_user_request();
void set_allocated_active_directory_enroll_play_user_request(::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request);

// optional .enterprise_management.ActiveDirectoryPlayActivityRequest active_directory_play_activity_request = 20;
bool has_active_directory_play_activity_request() const;
void clear_active_directory_play_activity_request();
const ::enterprise_management::ActiveDirectoryPlayActivityRequest& active_directory_play_activity_request() const;
::enterprise_management::ActiveDirectoryPlayActivityRequest* release_active_directory_play_activity_request();
::enterprise_management::ActiveDirectoryPlayActivityRequest* mutable_active_directory_play_activity_request();
void set_allocated_active_directory_play_activity_request(::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request);

// optional .enterprise_management.CheckDeviceLicenseRequest check_device_license_request_deprecated = 21 [deprecated = true];
PROTOBUF_DEPRECATED bool has_check_device_license_request_deprecated() const;
PROTOBUF_DEPRECATED void clear_check_device_license_request_deprecated();
PROTOBUF_DEPRECATED const ::enterprise_management::CheckDeviceLicenseRequest& check_device_license_request_deprecated() const;
PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseRequest* release_check_device_license_request_deprecated();
PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseRequest* mutable_check_device_license_request_deprecated();
PROTOBUF_DEPRECATED void set_allocated_check_device_license_request_deprecated(::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated);

// optional .enterprise_management.ActiveDirectoryUserSigninRequest active_directory_user_signin_request = 22;
bool has_active_directory_user_signin_request() const;
void clear_active_directory_user_signin_request();
const ::enterprise_management::ActiveDirectoryUserSigninRequest& active_directory_user_signin_request() const;
::enterprise_management::ActiveDirectoryUserSigninRequest* release_active_directory_user_signin_request();
::enterprise_management::ActiveDirectoryUserSigninRequest* mutable_active_directory_user_signin_request();
void set_allocated_active_directory_user_signin_request(::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request);

// optional .enterprise_management.RegisterBrowserRequest register_browser_request = 23;
bool has_register_browser_request() const;
void clear_register_browser_request();
const ::enterprise_management::RegisterBrowserRequest& register_browser_request() const;
::enterprise_management::RegisterBrowserRequest* release_register_browser_request();
::enterprise_management::RegisterBrowserRequest* mutable_register_browser_request();
void set_allocated_register_browser_request(::enterprise_management::RegisterBrowserRequest* register_browser_request);

// optional .enterprise_management.AppInstallReportRequest app_install_report_request = 25;
bool has_app_install_report_request() const;
void clear_app_install_report_request();
const ::enterprise_management::AppInstallReportRequest& app_install_report_request() const;
::enterprise_management::AppInstallReportRequest* release_app_install_report_request();
::enterprise_management::AppInstallReportRequest* mutable_app_install_report_request();
void set_allocated_app_install_report_request(::enterprise_management::AppInstallReportRequest* app_install_report_request);

// optional .enterprise_management.ChromeDesktopReportRequest chrome_desktop_report_request = 26;
bool has_chrome_desktop_report_request() const;
void clear_chrome_desktop_report_request();
const ::enterprise_management::ChromeDesktopReportRequest& chrome_desktop_report_request() const;
::enterprise_management::ChromeDesktopReportRequest* release_chrome_desktop_report_request();
::enterprise_management::ChromeDesktopReportRequest* mutable_chrome_desktop_report_request();
void set_allocated_chrome_desktop_report_request(::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request);

// optional .enterprise_management.PolicyValidationReportRequest policy_validation_report_request = 27;
bool has_policy_validation_report_request() const;
void clear_policy_validation_report_request();
const ::enterprise_management::PolicyValidationReportRequest& policy_validation_report_request() const;
::enterprise_management::PolicyValidationReportRequest* release_policy_validation_report_request();
::enterprise_management::PolicyValidationReportRequest* mutable_policy_validation_report_request();
void set_allocated_policy_validation_report_request(::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request);

// optional .enterprise_management.DeviceInitialEnrollmentStateRequest device_initial_enrollment_state_request = 28;
bool has_device_initial_enrollment_state_request() const;
void clear_device_initial_enrollment_state_request();
const ::enterprise_management::DeviceInitialEnrollmentStateRequest& device_initial_enrollment_state_request() const;
::enterprise_management::DeviceInitialEnrollmentStateRequest* release_device_initial_enrollment_state_request();
::enterprise_management::DeviceInitialEnrollmentStateRequest* mutable_device_initial_enrollment_state_request();
void set_allocated_device_initial_enrollment_state_request(::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request);

// optional .enterprise_management.RefreshAccountRequest refresh_account_request = 29;
bool has_refresh_account_request() const;
void clear_refresh_account_request();
const ::enterprise_management::RefreshAccountRequest& refresh_account_request() const;
::enterprise_management::RefreshAccountRequest* release_refresh_account_request();
::enterprise_management::RefreshAccountRequest* mutable_refresh_account_request();
void set_allocated_refresh_account_request(::enterprise_management::RefreshAccountRequest* refresh_account_request);

// optional .enterprise_management.ChildStatusReportRequest child_status_report_request = 30;
bool has_child_status_report_request() const;
void clear_child_status_report_request();
const ::enterprise_management::ChildStatusReportRequest& child_status_report_request() const;
::enterprise_management::ChildStatusReportRequest* release_child_status_report_request();
::enterprise_management::ChildStatusReportRequest* mutable_child_status_report_request();
void set_allocated_child_status_report_request(::enterprise_management::ChildStatusReportRequest* child_status_report_request);

// optional .enterprise_management.RsuLookupKeyUploadRequest rsu_lookup_key_upload_request = 31;
bool has_rsu_lookup_key_upload_request() const;
void clear_rsu_lookup_key_upload_request();
const ::enterprise_management::RsuLookupKeyUploadRequest& rsu_lookup_key_upload_request() const;
::enterprise_management::RsuLookupKeyUploadRequest* release_rsu_lookup_key_upload_request();
::enterprise_management::RsuLookupKeyUploadRequest* mutable_rsu_lookup_key_upload_request();
void set_allocated_rsu_lookup_key_upload_request(::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request);

// optional .enterprise_management.PublicSamlUserRequest public_saml_user_request = 32;
bool has_public_saml_user_request() const;
void clear_public_saml_user_request();
const ::enterprise_management::PublicSamlUserRequest& public_saml_user_request() const;
::enterprise_management::PublicSamlUserRequest* release_public_saml_user_request();
::enterprise_management::PublicSamlUserRequest* mutable_public_saml_user_request();
void set_allocated_public_saml_user_request(::enterprise_management::PublicSamlUserRequest* public_saml_user_request);

// optional .enterprise_management.ChromeOsUserReportRequest chrome_os_user_report_request = 33;
bool has_chrome_os_user_report_request() const;
void clear_chrome_os_user_report_request();
const ::enterprise_management::ChromeOsUserReportRequest& chrome_os_user_report_request() const;
::enterprise_management::ChromeOsUserReportRequest* release_chrome_os_user_report_request();
::enterprise_management::ChromeOsUserReportRequest* mutable_chrome_os_user_report_request();
void set_allocated_chrome_os_user_report_request(::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request);

// optional .enterprise_management.ClientCertificateProvisioningRequest client_certificate_provisioning_request = 34;
bool has_client_certificate_provisioning_request() const;
void clear_client_certificate_provisioning_request();
const ::enterprise_management::ClientCertificateProvisioningRequest& client_certificate_provisioning_request() const;
::enterprise_management::ClientCertificateProvisioningRequest* release_client_certificate_provisioning_request();
::enterprise_management::ClientCertificateProvisioningRequest* mutable_client_certificate_provisioning_request();
void set_allocated_client_certificate_provisioning_request(::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request);

// optional .enterprise_management.ExtensionInstallReportRequest extension_install_report_request = 35;
bool has_extension_install_report_request() const;
void clear_extension_install_report_request();
const ::enterprise_management::ExtensionInstallReportRequest& extension_install_report_request() const;
::enterprise_management::ExtensionInstallReportRequest* release_extension_install_report_request();
::enterprise_management::ExtensionInstallReportRequest* mutable_extension_install_report_request();
void set_allocated_extension_install_report_request(::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceManagementRequest)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::enterprise_management::DeviceRegisterRequest* register_request_;
::enterprise_management::DeviceUnregisterRequest* unregister_request_;
::enterprise_management::DevicePolicyRequest* policy_request_;
::enterprise_management::DeviceStatusReportRequest* device_status_report_request_;
::enterprise_management::SessionStatusReportRequest* session_status_report_request_;
::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request_;
::enterprise_management::DeviceCertUploadRequest* cert_upload_request_;
::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request_;
::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request_;
::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request_;
::enterprise_management::DevicePairingRequest* device_pairing_request_;
::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request_;
::enterprise_management::DeviceRemoteCommandRequest* remote_command_request_;
::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request_;
::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request_;
::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request_;
::enterprise_management::CheckAndroidManagementRequest* check_android_management_request_;
::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request_;
::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request_;
::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request_;
::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated_;
::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request_;
::enterprise_management::RegisterBrowserRequest* register_browser_request_;
::enterprise_management::AppInstallReportRequest* app_install_report_request_;
::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request_;
::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request_;
::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request_;
::enterprise_management::RefreshAccountRequest* refresh_account_request_;
::enterprise_management::ChildStatusReportRequest* child_status_report_request_;
::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request_;
::enterprise_management::PublicSamlUserRequest* public_saml_user_request_;
::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request_;
::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request_;
::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceManagementResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceManagementResponse) */ {
public:
DeviceManagementResponse();
virtual ~DeviceManagementResponse();

DeviceManagementResponse(const DeviceManagementResponse& from);
DeviceManagementResponse(DeviceManagementResponse&& from) noexcept
: DeviceManagementResponse() {
*this = ::std::move(from);
}

inline DeviceManagementResponse& operator=(const DeviceManagementResponse& from) {
CopyFrom(from);
return *this;
}
inline DeviceManagementResponse& operator=(DeviceManagementResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceManagementResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceManagementResponse* internal_default_instance() {
return reinterpret_cast<const DeviceManagementResponse*>(
&_DeviceManagementResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
152;

friend void swap(DeviceManagementResponse& a, DeviceManagementResponse& b) {
a.Swap(&b);
}
inline void Swap(DeviceManagementResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceManagementResponse* New() const final {
return CreateMaybeMessage<DeviceManagementResponse>(nullptr);
}

DeviceManagementResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceManagementResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceManagementResponse& from);
void MergeFrom(const DeviceManagementResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceManagementResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceManagementResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kErrorMessageFieldNumber = 2,
kRegisterResponseFieldNumber = 3,
kUnregisterResponseFieldNumber = 4,
kPolicyResponseFieldNumber = 5,
kDeviceStatusReportResponseFieldNumber = 6,
kSessionStatusReportResponseFieldNumber = 7,
kAutoEnrollmentResponseFieldNumber = 8,
kCertUploadResponseFieldNumber = 9,
kServiceApiAccessResponseFieldNumber = 10,
kDeviceStateRetrievalResponseFieldNumber = 11,
kDevicePairingResponseFieldNumber = 12,
kCheckDevicePairingResponseFieldNumber = 13,
kRemoteCommandResponseFieldNumber = 14,
kDeviceAttributeUpdatePermissionResponseFieldNumber = 15,
kDeviceAttributeUpdateResponseFieldNumber = 16,
kGcmIdUpdateResponseFieldNumber = 17,
kCheckAndroidManagementResponseFieldNumber = 18,
kActiveDirectoryEnrollPlayUserResponseFieldNumber = 19,
kActiveDirectoryPlayActivityResponseFieldNumber = 20,
kCheckDeviceLicenseResponseDeprecatedFieldNumber = 21,
kActiveDirectoryUserSigninResponseFieldNumber = 22,
kChromeDesktopReportResponseFieldNumber = 23,
kAppInstallReportResponseFieldNumber = 25,
kPolicyValidationReportResponseFieldNumber = 26,
kDeviceInitialEnrollmentStateResponseFieldNumber = 27,
kRefreshAccountResponseFieldNumber = 28,
kChildStatusReportResponseFieldNumber = 29,
kRsuLookupKeyUploadResponseFieldNumber = 30,
kPublicSamlUserResponseFieldNumber = 31,
kChromeOsUserReportResponseFieldNumber = 32,
kClientCertificateProvisioningResponseFieldNumber = 33,
};
// optional string error_message = 2;
bool has_error_message() const;
void clear_error_message();
const std::string& error_message() const;
void set_error_message(const std::string& value);
void set_error_message(std::string&& value);
void set_error_message(const char* value);
void set_error_message(const char* value, size_t size);
std::string* mutable_error_message();
std::string* release_error_message();
void set_allocated_error_message(std::string* error_message);

// optional .enterprise_management.DeviceRegisterResponse register_response = 3;
bool has_register_response() const;
void clear_register_response();
const ::enterprise_management::DeviceRegisterResponse& register_response() const;
::enterprise_management::DeviceRegisterResponse* release_register_response();
::enterprise_management::DeviceRegisterResponse* mutable_register_response();
void set_allocated_register_response(::enterprise_management::DeviceRegisterResponse* register_response);

// optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
bool has_unregister_response() const;
void clear_unregister_response();
const ::enterprise_management::DeviceUnregisterResponse& unregister_response() const;
::enterprise_management::DeviceUnregisterResponse* release_unregister_response();
::enterprise_management::DeviceUnregisterResponse* mutable_unregister_response();
void set_allocated_unregister_response(::enterprise_management::DeviceUnregisterResponse* unregister_response);

// optional .enterprise_management.DevicePolicyResponse policy_response = 5;
bool has_policy_response() const;
void clear_policy_response();
const ::enterprise_management::DevicePolicyResponse& policy_response() const;
::enterprise_management::DevicePolicyResponse* release_policy_response();
::enterprise_management::DevicePolicyResponse* mutable_policy_response();
void set_allocated_policy_response(::enterprise_management::DevicePolicyResponse* policy_response);

// optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
bool has_device_status_report_response() const;
void clear_device_status_report_response();
const ::enterprise_management::DeviceStatusReportResponse& device_status_report_response() const;
::enterprise_management::DeviceStatusReportResponse* release_device_status_report_response();
::enterprise_management::DeviceStatusReportResponse* mutable_device_status_report_response();
void set_allocated_device_status_report_response(::enterprise_management::DeviceStatusReportResponse* device_status_report_response);

// optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
bool has_session_status_report_response() const;
void clear_session_status_report_response();
const ::enterprise_management::SessionStatusReportResponse& session_status_report_response() const;
::enterprise_management::SessionStatusReportResponse* release_session_status_report_response();
::enterprise_management::SessionStatusReportResponse* mutable_session_status_report_response();
void set_allocated_session_status_report_response(::enterprise_management::SessionStatusReportResponse* session_status_report_response);

// optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
bool has_auto_enrollment_response() const;
void clear_auto_enrollment_response();
const ::enterprise_management::DeviceAutoEnrollmentResponse& auto_enrollment_response() const;
::enterprise_management::DeviceAutoEnrollmentResponse* release_auto_enrollment_response();
::enterprise_management::DeviceAutoEnrollmentResponse* mutable_auto_enrollment_response();
void set_allocated_auto_enrollment_response(::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response);

// optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
bool has_cert_upload_response() const;
void clear_cert_upload_response();
const ::enterprise_management::DeviceCertUploadResponse& cert_upload_response() const;
::enterprise_management::DeviceCertUploadResponse* release_cert_upload_response();
::enterprise_management::DeviceCertUploadResponse* mutable_cert_upload_response();
void set_allocated_cert_upload_response(::enterprise_management::DeviceCertUploadResponse* cert_upload_response);

// optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
bool has_service_api_access_response() const;
void clear_service_api_access_response();
const ::enterprise_management::DeviceServiceApiAccessResponse& service_api_access_response() const;
::enterprise_management::DeviceServiceApiAccessResponse* release_service_api_access_response();
::enterprise_management::DeviceServiceApiAccessResponse* mutable_service_api_access_response();
void set_allocated_service_api_access_response(::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response);

// optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
bool has_device_state_retrieval_response() const;
void clear_device_state_retrieval_response();
const ::enterprise_management::DeviceStateRetrievalResponse& device_state_retrieval_response() const;
::enterprise_management::DeviceStateRetrievalResponse* release_device_state_retrieval_response();
::enterprise_management::DeviceStateRetrievalResponse* mutable_device_state_retrieval_response();
void set_allocated_device_state_retrieval_response(::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response);

// optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
bool has_device_pairing_response() const;
void clear_device_pairing_response();
const ::enterprise_management::DevicePairingResponse& device_pairing_response() const;
::enterprise_management::DevicePairingResponse* release_device_pairing_response();
::enterprise_management::DevicePairingResponse* mutable_device_pairing_response();
void set_allocated_device_pairing_response(::enterprise_management::DevicePairingResponse* device_pairing_response);

// optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
bool has_check_device_pairing_response() const;
void clear_check_device_pairing_response();
const ::enterprise_management::CheckDevicePairingResponse& check_device_pairing_response() const;
::enterprise_management::CheckDevicePairingResponse* release_check_device_pairing_response();
::enterprise_management::CheckDevicePairingResponse* mutable_check_device_pairing_response();
void set_allocated_check_device_pairing_response(::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response);

// optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
bool has_remote_command_response() const;
void clear_remote_command_response();
const ::enterprise_management::DeviceRemoteCommandResponse& remote_command_response() const;
::enterprise_management::DeviceRemoteCommandResponse* release_remote_command_response();
::enterprise_management::DeviceRemoteCommandResponse* mutable_remote_command_response();
void set_allocated_remote_command_response(::enterprise_management::DeviceRemoteCommandResponse* remote_command_response);

// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
bool has_device_attribute_update_permission_response() const;
void clear_device_attribute_update_permission_response();
const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& device_attribute_update_permission_response() const;
::enterprise_management::DeviceAttributeUpdatePermissionResponse* release_device_attribute_update_permission_response();
::enterprise_management::DeviceAttributeUpdatePermissionResponse* mutable_device_attribute_update_permission_response();
void set_allocated_device_attribute_update_permission_response(::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response);

// optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
bool has_device_attribute_update_response() const;
void clear_device_attribute_update_response();
const ::enterprise_management::DeviceAttributeUpdateResponse& device_attribute_update_response() const;
::enterprise_management::DeviceAttributeUpdateResponse* release_device_attribute_update_response();
::enterprise_management::DeviceAttributeUpdateResponse* mutable_device_attribute_update_response();
void set_allocated_device_attribute_update_response(::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response);

// optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
bool has_gcm_id_update_response() const;
void clear_gcm_id_update_response();
const ::enterprise_management::GcmIdUpdateResponse& gcm_id_update_response() const;
::enterprise_management::GcmIdUpdateResponse* release_gcm_id_update_response();
::enterprise_management::GcmIdUpdateResponse* mutable_gcm_id_update_response();
void set_allocated_gcm_id_update_response(::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response);

// optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
bool has_check_android_management_response() const;
void clear_check_android_management_response();
const ::enterprise_management::CheckAndroidManagementResponse& check_android_management_response() const;
::enterprise_management::CheckAndroidManagementResponse* release_check_android_management_response();
::enterprise_management::CheckAndroidManagementResponse* mutable_check_android_management_response();
void set_allocated_check_android_management_response(::enterprise_management::CheckAndroidManagementResponse* check_android_management_response);

// optional .enterprise_management.ActiveDirectoryEnrollPlayUserResponse active_directory_enroll_play_user_response = 19;
bool has_active_directory_enroll_play_user_response() const;
void clear_active_directory_enroll_play_user_response();
const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse& active_directory_enroll_play_user_response() const;
::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* release_active_directory_enroll_play_user_response();
::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* mutable_active_directory_enroll_play_user_response();
void set_allocated_active_directory_enroll_play_user_response(::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response);

// optional .enterprise_management.ActiveDirectoryPlayActivityResponse active_directory_play_activity_response = 20;
bool has_active_directory_play_activity_response() const;
void clear_active_directory_play_activity_response();
const ::enterprise_management::ActiveDirectoryPlayActivityResponse& active_directory_play_activity_response() const;
::enterprise_management::ActiveDirectoryPlayActivityResponse* release_active_directory_play_activity_response();
::enterprise_management::ActiveDirectoryPlayActivityResponse* mutable_active_directory_play_activity_response();
void set_allocated_active_directory_play_activity_response(::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response);

// optional .enterprise_management.CheckDeviceLicenseResponse check_device_license_response_deprecated = 21 [deprecated = true];
PROTOBUF_DEPRECATED bool has_check_device_license_response_deprecated() const;
PROTOBUF_DEPRECATED void clear_check_device_license_response_deprecated();
PROTOBUF_DEPRECATED const ::enterprise_management::CheckDeviceLicenseResponse& check_device_license_response_deprecated() const;
PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseResponse* release_check_device_license_response_deprecated();
PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseResponse* mutable_check_device_license_response_deprecated();
PROTOBUF_DEPRECATED void set_allocated_check_device_license_response_deprecated(::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated);

// optional .enterprise_management.ActiveDirectoryUserSigninResponse active_directory_user_signin_response = 22;
bool has_active_directory_user_signin_response() const;
void clear_active_directory_user_signin_response();
const ::enterprise_management::ActiveDirectoryUserSigninResponse& active_directory_user_signin_response() const;
::enterprise_management::ActiveDirectoryUserSigninResponse* release_active_directory_user_signin_response();
::enterprise_management::ActiveDirectoryUserSigninResponse* mutable_active_directory_user_signin_response();
void set_allocated_active_directory_user_signin_response(::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response);

// optional .enterprise_management.ChromeDesktopReportResponse chrome_desktop_report_response = 23;
bool has_chrome_desktop_report_response() const;
void clear_chrome_desktop_report_response();
const ::enterprise_management::ChromeDesktopReportResponse& chrome_desktop_report_response() const;
::enterprise_management::ChromeDesktopReportResponse* release_chrome_desktop_report_response();
::enterprise_management::ChromeDesktopReportResponse* mutable_chrome_desktop_report_response();
void set_allocated_chrome_desktop_report_response(::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response);

// optional .enterprise_management.AppInstallReportResponse app_install_report_response = 25;
bool has_app_install_report_response() const;
void clear_app_install_report_response();
const ::enterprise_management::AppInstallReportResponse& app_install_report_response() const;
::enterprise_management::AppInstallReportResponse* release_app_install_report_response();
::enterprise_management::AppInstallReportResponse* mutable_app_install_report_response();
void set_allocated_app_install_report_response(::enterprise_management::AppInstallReportResponse* app_install_report_response);

// optional .enterprise_management.PolicyValidationReportResponse policy_validation_report_response = 26;
bool has_policy_validation_report_response() const;
void clear_policy_validation_report_response();
const ::enterprise_management::PolicyValidationReportResponse& policy_validation_report_response() const;
::enterprise_management::PolicyValidationReportResponse* release_policy_validation_report_response();
::enterprise_management::PolicyValidationReportResponse* mutable_policy_validation_report_response();
void set_allocated_policy_validation_report_response(::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response);

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse device_initial_enrollment_state_response = 27;
bool has_device_initial_enrollment_state_response() const;
void clear_device_initial_enrollment_state_response();
const ::enterprise_management::DeviceInitialEnrollmentStateResponse& device_initial_enrollment_state_response() const;
::enterprise_management::DeviceInitialEnrollmentStateResponse* release_device_initial_enrollment_state_response();
::enterprise_management::DeviceInitialEnrollmentStateResponse* mutable_device_initial_enrollment_state_response();
void set_allocated_device_initial_enrollment_state_response(::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response);

// optional .enterprise_management.RefreshAccountResponse refresh_account_response = 28;
bool has_refresh_account_response() const;
void clear_refresh_account_response();
const ::enterprise_management::RefreshAccountResponse& refresh_account_response() const;
::enterprise_management::RefreshAccountResponse* release_refresh_account_response();
::enterprise_management::RefreshAccountResponse* mutable_refresh_account_response();
void set_allocated_refresh_account_response(::enterprise_management::RefreshAccountResponse* refresh_account_response);

// optional .enterprise_management.ChildStatusReportResponse child_status_report_response = 29;
bool has_child_status_report_response() const;
void clear_child_status_report_response();
const ::enterprise_management::ChildStatusReportResponse& child_status_report_response() const;
::enterprise_management::ChildStatusReportResponse* release_child_status_report_response();
::enterprise_management::ChildStatusReportResponse* mutable_child_status_report_response();
void set_allocated_child_status_report_response(::enterprise_management::ChildStatusReportResponse* child_status_report_response);

// optional .enterprise_management.RsuLookupKeyUploadResponse rsu_lookup_key_upload_response = 30;
bool has_rsu_lookup_key_upload_response() const;
void clear_rsu_lookup_key_upload_response();
const ::enterprise_management::RsuLookupKeyUploadResponse& rsu_lookup_key_upload_response() const;
::enterprise_management::RsuLookupKeyUploadResponse* release_rsu_lookup_key_upload_response();
::enterprise_management::RsuLookupKeyUploadResponse* mutable_rsu_lookup_key_upload_response();
void set_allocated_rsu_lookup_key_upload_response(::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response);

// optional .enterprise_management.PublicSamlUserResponse public_saml_user_response = 31;
bool has_public_saml_user_response() const;
void clear_public_saml_user_response();
const ::enterprise_management::PublicSamlUserResponse& public_saml_user_response() const;
::enterprise_management::PublicSamlUserResponse* release_public_saml_user_response();
::enterprise_management::PublicSamlUserResponse* mutable_public_saml_user_response();
void set_allocated_public_saml_user_response(::enterprise_management::PublicSamlUserResponse* public_saml_user_response);

// optional .enterprise_management.ChromeOsUserReportResponse chrome_os_user_report_response = 32;
bool has_chrome_os_user_report_response() const;
void clear_chrome_os_user_report_response();
const ::enterprise_management::ChromeOsUserReportResponse& chrome_os_user_report_response() const;
::enterprise_management::ChromeOsUserReportResponse* release_chrome_os_user_report_response();
::enterprise_management::ChromeOsUserReportResponse* mutable_chrome_os_user_report_response();
void set_allocated_chrome_os_user_report_response(::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response);

// optional .enterprise_management.ClientCertificateProvisioningResponse client_certificate_provisioning_response = 33;
bool has_client_certificate_provisioning_response() const;
void clear_client_certificate_provisioning_response();
const ::enterprise_management::ClientCertificateProvisioningResponse& client_certificate_provisioning_response() const;
::enterprise_management::ClientCertificateProvisioningResponse* release_client_certificate_provisioning_response();
::enterprise_management::ClientCertificateProvisioningResponse* mutable_client_certificate_provisioning_response();
void set_allocated_client_certificate_provisioning_response(::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceManagementResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
::enterprise_management::DeviceRegisterResponse* register_response_;
::enterprise_management::DeviceUnregisterResponse* unregister_response_;
::enterprise_management::DevicePolicyResponse* policy_response_;
::enterprise_management::DeviceStatusReportResponse* device_status_report_response_;
::enterprise_management::SessionStatusReportResponse* session_status_report_response_;
::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response_;
::enterprise_management::DeviceCertUploadResponse* cert_upload_response_;
::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response_;
::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response_;
::enterprise_management::DevicePairingResponse* device_pairing_response_;
::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response_;
::enterprise_management::DeviceRemoteCommandResponse* remote_command_response_;
::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response_;
::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response_;
::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response_;
::enterprise_management::CheckAndroidManagementResponse* check_android_management_response_;
::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response_;
::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response_;
::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated_;
::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response_;
::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response_;
::enterprise_management::AppInstallReportResponse* app_install_report_response_;
::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response_;
::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response_;
::enterprise_management::RefreshAccountResponse* refresh_account_response_;
::enterprise_management::ChildStatusReportResponse* child_status_report_response_;
::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response_;
::enterprise_management::PublicSamlUserResponse* public_saml_user_response_;
::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response_;
::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStateRetrievalInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateRetrievalInfo) */ {
public:
DeviceStateRetrievalInfo();
virtual ~DeviceStateRetrievalInfo();

DeviceStateRetrievalInfo(const DeviceStateRetrievalInfo& from);
DeviceStateRetrievalInfo(DeviceStateRetrievalInfo&& from) noexcept
: DeviceStateRetrievalInfo() {
*this = ::std::move(from);
}

inline DeviceStateRetrievalInfo& operator=(const DeviceStateRetrievalInfo& from) {
CopyFrom(from);
return *this;
}
inline DeviceStateRetrievalInfo& operator=(DeviceStateRetrievalInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DeviceStateRetrievalInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DeviceStateRetrievalInfo* internal_default_instance() {
return reinterpret_cast<const DeviceStateRetrievalInfo*>(
&_DeviceStateRetrievalInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
153;

friend void swap(DeviceStateRetrievalInfo& a, DeviceStateRetrievalInfo& b) {
a.Swap(&b);
}
inline void Swap(DeviceStateRetrievalInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DeviceStateRetrievalInfo* New() const final {
return CreateMaybeMessage<DeviceStateRetrievalInfo>(nullptr);
}

DeviceStateRetrievalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DeviceStateRetrievalInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DeviceStateRetrievalInfo& from);
void MergeFrom(const DeviceStateRetrievalInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DeviceStateRetrievalInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "enterprise_management.DeviceStateRetrievalInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kHasInitialStateFieldNumber = 1,
};
// optional bool has_initial_state = 1;
bool has_has_initial_state() const;
void clear_has_initial_state();
bool has_initial_state() const;
void set_has_initial_state(bool value);

// @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
bool has_initial_state_;
friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LicenseType

// optional .enterprise_management.LicenseType.LicenseTypeEnum license_type_deprecated = 1 [deprecated = true];
inline bool LicenseType::has_license_type_deprecated() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseType::clear_license_type_deprecated() {
license_type_deprecated_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::LicenseType_LicenseTypeEnum LicenseType::license_type_deprecated() const {
// @@protoc_insertion_point(field_get:enterprise_management.LicenseType.license_type_deprecated)
return static_cast< ::enterprise_management::LicenseType_LicenseTypeEnum >(license_type_deprecated_);
}
inline void LicenseType::set_license_type_deprecated(::enterprise_management::LicenseType_LicenseTypeEnum value) {
assert(::enterprise_management::LicenseType_LicenseTypeEnum_IsValid(value));
_has_bits_[0] |= 0x00000001u;
license_type_deprecated_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.LicenseType.license_type_deprecated)
}

// -------------------------------------------------------------------

// SignedData

// optional bytes data = 1;
inline bool SignedData::has_data() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedData::clear_data() {
data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignedData::data() const {
// @@protoc_insertion_point(field_get:enterprise_management.SignedData.data)
return data_.GetNoArena();
}
inline void SignedData::set_data(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SignedData.data)
}
inline void SignedData::set_data(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SignedData.data)
}
inline void SignedData::set_data(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SignedData.data)
}
inline void SignedData::set_data(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SignedData.data)
}
inline std::string* SignedData::mutable_data() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SignedData.data)
return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SignedData::release_data() {
// @@protoc_insertion_point(field_release:enterprise_management.SignedData.data)
if (!has_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SignedData::set_allocated_data(std::string* data) {
if (data != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SignedData.data)
}

// optional bytes signature = 2;
inline bool SignedData::has_signature() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedData::clear_signature() {
signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignedData::signature() const {
// @@protoc_insertion_point(field_get:enterprise_management.SignedData.signature)
return signature_.GetNoArena();
}
inline void SignedData::set_signature(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SignedData.signature)
}
inline void SignedData::set_signature(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SignedData.signature)
}
inline void SignedData::set_signature(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SignedData.signature)
}
inline void SignedData::set_signature(const void* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SignedData.signature)
}
inline std::string* SignedData::mutable_signature() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SignedData.signature)
return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SignedData::release_signature() {
// @@protoc_insertion_point(field_release:enterprise_management.SignedData.signature)
if (!has_signature()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SignedData::set_allocated_signature(std::string* signature) {
if (signature != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SignedData.signature)
}

// optional int32 extra_data_bytes = 3;
inline bool SignedData::has_extra_data_bytes() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedData::clear_extra_data_bytes() {
extra_data_bytes_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignedData::extra_data_bytes() const {
// @@protoc_insertion_point(field_get:enterprise_management.SignedData.extra_data_bytes)
return extra_data_bytes_;
}
inline void SignedData::set_extra_data_bytes(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000004u;
extra_data_bytes_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.SignedData.extra_data_bytes)
}

// -------------------------------------------------------------------

// DeviceRegisterRequest

// optional bool reregister = 1;
inline bool DeviceRegisterRequest::has_reregister() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceRegisterRequest::clear_reregister() {
reregister_ = false;
_has_bits_[0] &= ~0x00001000u;
}
inline bool DeviceRegisterRequest::reregister() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.reregister)
return reregister_;
}
inline void DeviceRegisterRequest::set_reregister(bool value) {
_has_bits_[0] |= 0x00001000u;
reregister_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.reregister)
}

// optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
inline bool DeviceRegisterRequest::has_type() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceRegisterRequest::clear_type() {
type_ = 0;
_has_bits_[0] &= ~0x00002000u;
}
inline ::enterprise_management::DeviceRegisterRequest_Type DeviceRegisterRequest::type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.type)
return static_cast< ::enterprise_management::DeviceRegisterRequest_Type >(type_);
}
inline void DeviceRegisterRequest::set_type(::enterprise_management::DeviceRegisterRequest_Type value) {
assert(::enterprise_management::DeviceRegisterRequest_Type_IsValid(value));
_has_bits_[0] |= 0x00002000u;
type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.type)
}

// optional string machine_id = 3;
inline bool DeviceRegisterRequest::has_machine_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRegisterRequest::clear_machine_id() {
machine_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterRequest::machine_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.machine_id)
return machine_id_.GetNoArena();
}
inline void DeviceRegisterRequest::set_machine_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
machine_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline void DeviceRegisterRequest::set_machine_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
machine_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline void DeviceRegisterRequest::set_machine_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
machine_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline void DeviceRegisterRequest::set_machine_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
machine_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline std::string* DeviceRegisterRequest::mutable_machine_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.machine_id)
return machine_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_machine_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.machine_id)
if (!has_machine_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return machine_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_machine_id(std::string* machine_id) {
if (machine_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
machine_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.machine_id)
}

// optional string machine_model = 4;
inline bool DeviceRegisterRequest::has_machine_model() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceRegisterRequest::clear_machine_model() {
machine_model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceRegisterRequest::machine_model() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.machine_model)
return machine_model_.GetNoArena();
}
inline void DeviceRegisterRequest::set_machine_model(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
machine_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline void DeviceRegisterRequest::set_machine_model(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
machine_model_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline void DeviceRegisterRequest::set_machine_model(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
machine_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline void DeviceRegisterRequest::set_machine_model(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
machine_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline std::string* DeviceRegisterRequest::mutable_machine_model() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.machine_model)
return machine_model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_machine_model() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.machine_model)
if (!has_machine_model()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return machine_model_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_machine_model(std::string* machine_model) {
if (machine_model != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
machine_model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_model);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.machine_model)
}

// optional string requisition = 6;
inline bool DeviceRegisterRequest::has_requisition() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceRegisterRequest::clear_requisition() {
requisition_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceRegisterRequest::requisition() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.requisition)
return requisition_.GetNoArena();
}
inline void DeviceRegisterRequest::set_requisition(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
requisition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.requisition)
}
inline void DeviceRegisterRequest::set_requisition(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
requisition_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.requisition)
}
inline void DeviceRegisterRequest::set_requisition(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
requisition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.requisition)
}
inline void DeviceRegisterRequest::set_requisition(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
requisition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.requisition)
}
inline std::string* DeviceRegisterRequest::mutable_requisition() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.requisition)
return requisition_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_requisition() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.requisition)
if (!has_requisition()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return requisition_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_requisition(std::string* requisition) {
if (requisition != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
requisition_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requisition);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.requisition)
}

// optional bytes server_backed_state_key = 7;
inline bool DeviceRegisterRequest::has_server_backed_state_key() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceRegisterRequest::clear_server_backed_state_key() {
server_backed_state_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceRegisterRequest::server_backed_state_key() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
return server_backed_state_key_.GetNoArena();
}
inline void DeviceRegisterRequest::set_server_backed_state_key(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
server_backed_state_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline void DeviceRegisterRequest::set_server_backed_state_key(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
server_backed_state_key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline void DeviceRegisterRequest::set_server_backed_state_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
server_backed_state_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline void DeviceRegisterRequest::set_server_backed_state_key(const void* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
server_backed_state_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline std::string* DeviceRegisterRequest::mutable_server_backed_state_key() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
return server_backed_state_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_server_backed_state_key() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
if (!has_server_backed_state_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return server_backed_state_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_server_backed_state_key(std::string* server_backed_state_key) {
if (server_backed_state_key != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
server_backed_state_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_backed_state_key);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}

// optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
inline bool DeviceRegisterRequest::has_flavor() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceRegisterRequest::clear_flavor() {
flavor_ = 0;
_has_bits_[0] &= ~0x00004000u;
}
inline ::enterprise_management::DeviceRegisterRequest_Flavor DeviceRegisterRequest::flavor() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.flavor)
return static_cast< ::enterprise_management::DeviceRegisterRequest_Flavor >(flavor_);
}
inline void DeviceRegisterRequest::set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value) {
assert(::enterprise_management::DeviceRegisterRequest_Flavor_IsValid(value));
_has_bits_[0] |= 0x00004000u;
flavor_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.flavor)
}

// optional .enterprise_management.LicenseType license_type = 9;
inline bool DeviceRegisterRequest::has_license_type() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceRegisterRequest::clear_license_type() {
if (license_type_ != nullptr) license_type_->Clear();
_has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::LicenseType& DeviceRegisterRequest::license_type() const {
const ::enterprise_management::LicenseType* p = license_type_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.license_type)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::LicenseType*>(
&::enterprise_management::_LicenseType_default_instance_);
}
inline ::enterprise_management::LicenseType* DeviceRegisterRequest::release_license_type() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.license_type)
_has_bits_[0] &= ~0x00000400u;
::enterprise_management::LicenseType* temp = license_type_;
license_type_ = nullptr;
return temp;
}
inline ::enterprise_management::LicenseType* DeviceRegisterRequest::mutable_license_type() {
_has_bits_[0] |= 0x00000400u;
if (license_type_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::LicenseType>(GetArenaNoVirtual());
license_type_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.license_type)
return license_type_;
}
inline void DeviceRegisterRequest::set_allocated_license_type(::enterprise_management::LicenseType* license_type) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete license_type_;
}
if (license_type) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
license_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, license_type, submessage_arena);
}
_has_bits_[0] |= 0x00000400u;
} else {
_has_bits_[0] &= ~0x00000400u;
}
license_type_ = license_type;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.license_type)
}

// optional .enterprise_management.DeviceRegisterRequest.Lifetime lifetime = 11 [default = LIFETIME_INDEFINITE];
inline bool DeviceRegisterRequest::has_lifetime() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceRegisterRequest::clear_lifetime() {
lifetime_ = 1;
_has_bits_[0] &= ~0x00008000u;
}
inline ::enterprise_management::DeviceRegisterRequest_Lifetime DeviceRegisterRequest::lifetime() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.lifetime)
return static_cast< ::enterprise_management::DeviceRegisterRequest_Lifetime >(lifetime_);
}
inline void DeviceRegisterRequest::set_lifetime(::enterprise_management::DeviceRegisterRequest_Lifetime value) {
assert(::enterprise_management::DeviceRegisterRequest_Lifetime_IsValid(value));
_has_bits_[0] |= 0x00008000u;
lifetime_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.lifetime)
}

// optional string brand_code = 12;
inline bool DeviceRegisterRequest::has_brand_code() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceRegisterRequest::clear_brand_code() {
brand_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DeviceRegisterRequest::brand_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.brand_code)
return brand_code_.GetNoArena();
}
inline void DeviceRegisterRequest::set_brand_code(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
brand_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.brand_code)
}
inline void DeviceRegisterRequest::set_brand_code(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
brand_code_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.brand_code)
}
inline void DeviceRegisterRequest::set_brand_code(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
brand_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.brand_code)
}
inline void DeviceRegisterRequest::set_brand_code(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
brand_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.brand_code)
}
inline std::string* DeviceRegisterRequest::mutable_brand_code() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.brand_code)
return brand_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_brand_code() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.brand_code)
if (!has_brand_code()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return brand_code_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_brand_code(std::string* brand_code) {
if (brand_code != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
brand_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brand_code);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.brand_code)
}

// optional string reregistration_dm_token = 13;
inline bool DeviceRegisterRequest::has_reregistration_dm_token() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceRegisterRequest::clear_reregistration_dm_token() {
reregistration_dm_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DeviceRegisterRequest::reregistration_dm_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
return reregistration_dm_token_.GetNoArena();
}
inline void DeviceRegisterRequest::set_reregistration_dm_token(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
reregistration_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
}
inline void DeviceRegisterRequest::set_reregistration_dm_token(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
reregistration_dm_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
}
inline void DeviceRegisterRequest::set_reregistration_dm_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
reregistration_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
}
inline void DeviceRegisterRequest::set_reregistration_dm_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
reregistration_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
}
inline std::string* DeviceRegisterRequest::mutable_reregistration_dm_token() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
return reregistration_dm_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_reregistration_dm_token() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
if (!has_reregistration_dm_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return reregistration_dm_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_reregistration_dm_token(std::string* reregistration_dm_token) {
if (reregistration_dm_token != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
reregistration_dm_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reregistration_dm_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
}

// optional string ethernet_mac_address = 14;
inline bool DeviceRegisterRequest::has_ethernet_mac_address() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceRegisterRequest::clear_ethernet_mac_address() {
ethernet_mac_address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DeviceRegisterRequest::ethernet_mac_address() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
return ethernet_mac_address_.GetNoArena();
}
inline void DeviceRegisterRequest::set_ethernet_mac_address(const std::string& value) {
_has_bits_[0] |= 0x00000040u;
ethernet_mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
}
inline void DeviceRegisterRequest::set_ethernet_mac_address(std::string&& value) {
_has_bits_[0] |= 0x00000040u;
ethernet_mac_address_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
}
inline void DeviceRegisterRequest::set_ethernet_mac_address(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000040u;
ethernet_mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
}
inline void DeviceRegisterRequest::set_ethernet_mac_address(const char* value, size_t size) {
_has_bits_[0] |= 0x00000040u;
ethernet_mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
}
inline std::string* DeviceRegisterRequest::mutable_ethernet_mac_address() {
_has_bits_[0] |= 0x00000040u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
return ethernet_mac_address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_ethernet_mac_address() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
if (!has_ethernet_mac_address()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000040u;
return ethernet_mac_address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_ethernet_mac_address(std::string* ethernet_mac_address) {
if (ethernet_mac_address != nullptr) {
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
ethernet_mac_address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ethernet_mac_address);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
}

// optional string dock_mac_address = 15;
inline bool DeviceRegisterRequest::has_dock_mac_address() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceRegisterRequest::clear_dock_mac_address() {
dock_mac_address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DeviceRegisterRequest::dock_mac_address() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.dock_mac_address)
return dock_mac_address_.GetNoArena();
}
inline void DeviceRegisterRequest::set_dock_mac_address(const std::string& value) {
_has_bits_[0] |= 0x00000080u;
dock_mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.dock_mac_address)
}
inline void DeviceRegisterRequest::set_dock_mac_address(std::string&& value) {
_has_bits_[0] |= 0x00000080u;
dock_mac_address_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.dock_mac_address)
}
inline void DeviceRegisterRequest::set_dock_mac_address(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000080u;
dock_mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.dock_mac_address)
}
inline void DeviceRegisterRequest::set_dock_mac_address(const char* value, size_t size) {
_has_bits_[0] |= 0x00000080u;
dock_mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.dock_mac_address)
}
inline std::string* DeviceRegisterRequest::mutable_dock_mac_address() {
_has_bits_[0] |= 0x00000080u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.dock_mac_address)
return dock_mac_address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_dock_mac_address() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.dock_mac_address)
if (!has_dock_mac_address()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000080u;
return dock_mac_address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_dock_mac_address(std::string* dock_mac_address) {
if (dock_mac_address != nullptr) {
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
dock_mac_address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dock_mac_address);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.dock_mac_address)
}

// optional string manufacture_date = 16;
inline bool DeviceRegisterRequest::has_manufacture_date() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceRegisterRequest::clear_manufacture_date() {
manufacture_date_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000100u;
}
inline const std::string& DeviceRegisterRequest::manufacture_date() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.manufacture_date)
return manufacture_date_.GetNoArena();
}
inline void DeviceRegisterRequest::set_manufacture_date(const std::string& value) {
_has_bits_[0] |= 0x00000100u;
manufacture_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.manufacture_date)
}
inline void DeviceRegisterRequest::set_manufacture_date(std::string&& value) {
_has_bits_[0] |= 0x00000100u;
manufacture_date_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.manufacture_date)
}
inline void DeviceRegisterRequest::set_manufacture_date(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000100u;
manufacture_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.manufacture_date)
}
inline void DeviceRegisterRequest::set_manufacture_date(const char* value, size_t size) {
_has_bits_[0] |= 0x00000100u;
manufacture_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.manufacture_date)
}
inline std::string* DeviceRegisterRequest::mutable_manufacture_date() {
_has_bits_[0] |= 0x00000100u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.manufacture_date)
return manufacture_date_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_manufacture_date() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.manufacture_date)
if (!has_manufacture_date()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000100u;
return manufacture_date_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_manufacture_date(std::string* manufacture_date) {
if (manufacture_date != nullptr) {
_has_bits_[0] |= 0x00000100u;
} else {
_has_bits_[0] &= ~0x00000100u;
}
manufacture_date_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacture_date);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.manufacture_date)
}

// optional string expected_enrollment_domain = 17;
inline bool DeviceRegisterRequest::has_expected_enrollment_domain() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceRegisterRequest::clear_expected_enrollment_domain() {
expected_enrollment_domain_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000200u;
}
inline const std::string& DeviceRegisterRequest::expected_enrollment_domain() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
return expected_enrollment_domain_.GetNoArena();
}
inline void DeviceRegisterRequest::set_expected_enrollment_domain(const std::string& value) {
_has_bits_[0] |= 0x00000200u;
expected_enrollment_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
}
inline void DeviceRegisterRequest::set_expected_enrollment_domain(std::string&& value) {
_has_bits_[0] |= 0x00000200u;
expected_enrollment_domain_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
}
inline void DeviceRegisterRequest::set_expected_enrollment_domain(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000200u;
expected_enrollment_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
}
inline void DeviceRegisterRequest::set_expected_enrollment_domain(const char* value, size_t size) {
_has_bits_[0] |= 0x00000200u;
expected_enrollment_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
}
inline std::string* DeviceRegisterRequest::mutable_expected_enrollment_domain() {
_has_bits_[0] |= 0x00000200u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
return expected_enrollment_domain_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterRequest::release_expected_enrollment_domain() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
if (!has_expected_enrollment_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000200u;
return expected_enrollment_domain_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_expected_enrollment_domain(std::string* expected_enrollment_domain) {
if (expected_enrollment_domain != nullptr) {
_has_bits_[0] |= 0x00000200u;
} else {
_has_bits_[0] &= ~0x00000200u;
}
expected_enrollment_domain_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expected_enrollment_domain);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
}

// optional .enterprise_management.DeviceRegisterIdentification device_register_identification = 18;
inline bool DeviceRegisterRequest::has_device_register_identification() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceRegisterRequest::clear_device_register_identification() {
if (device_register_identification_ != nullptr) device_register_identification_->Clear();
_has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::DeviceRegisterIdentification& DeviceRegisterRequest::device_register_identification() const {
const ::enterprise_management::DeviceRegisterIdentification* p = device_register_identification_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.device_register_identification)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceRegisterIdentification*>(
&::enterprise_management::_DeviceRegisterIdentification_default_instance_);
}
inline ::enterprise_management::DeviceRegisterIdentification* DeviceRegisterRequest::release_device_register_identification() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.device_register_identification)
_has_bits_[0] &= ~0x00000800u;
::enterprise_management::DeviceRegisterIdentification* temp = device_register_identification_;
device_register_identification_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceRegisterIdentification* DeviceRegisterRequest::mutable_device_register_identification() {
_has_bits_[0] |= 0x00000800u;
if (device_register_identification_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterIdentification>(GetArenaNoVirtual());
device_register_identification_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.device_register_identification)
return device_register_identification_;
}
inline void DeviceRegisterRequest::set_allocated_device_register_identification(::enterprise_management::DeviceRegisterIdentification* device_register_identification) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_register_identification_;
}
if (device_register_identification) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_register_identification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_register_identification, submessage_arena);
}
_has_bits_[0] |= 0x00000800u;
} else {
_has_bits_[0] &= ~0x00000800u;
}
device_register_identification_ = device_register_identification;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.device_register_identification)
}

// -------------------------------------------------------------------

// DeviceRegisterIdentification

// optional string attested_device_id = 1;
inline bool DeviceRegisterIdentification::has_attested_device_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRegisterIdentification::clear_attested_device_id() {
attested_device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterIdentification::attested_device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterIdentification.attested_device_id)
return attested_device_id_.GetNoArena();
}
inline void DeviceRegisterIdentification::set_attested_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
attested_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterIdentification.attested_device_id)
}
inline void DeviceRegisterIdentification::set_attested_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
attested_device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterIdentification.attested_device_id)
}
inline void DeviceRegisterIdentification::set_attested_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
attested_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterIdentification.attested_device_id)
}
inline void DeviceRegisterIdentification::set_attested_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
attested_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterIdentification.attested_device_id)
}
inline std::string* DeviceRegisterIdentification::mutable_attested_device_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterIdentification.attested_device_id)
return attested_device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterIdentification::release_attested_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterIdentification.attested_device_id)
if (!has_attested_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return attested_device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterIdentification::set_allocated_attested_device_id(std::string* attested_device_id) {
if (attested_device_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
attested_device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attested_device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterIdentification.attested_device_id)
}

// -------------------------------------------------------------------

// DeviceRegisterResponse

// required string device_management_token = 1;
inline bool DeviceRegisterResponse::has_device_management_token() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRegisterResponse::clear_device_management_token() {
device_management_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterResponse::device_management_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.device_management_token)
return device_management_token_.GetNoArena();
}
inline void DeviceRegisterResponse::set_device_management_token(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
device_management_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline void DeviceRegisterResponse::set_device_management_token(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
device_management_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline void DeviceRegisterResponse::set_device_management_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
device_management_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline void DeviceRegisterResponse::set_device_management_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
device_management_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline std::string* DeviceRegisterResponse::mutable_device_management_token() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.device_management_token)
return device_management_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterResponse::release_device_management_token() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.device_management_token)
if (!has_device_management_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return device_management_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_allocated_device_management_token(std::string* device_management_token) {
if (device_management_token != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
device_management_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_management_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.device_management_token)
}

// optional string machine_name = 2;
inline bool DeviceRegisterResponse::has_machine_name() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceRegisterResponse::clear_machine_name() {
machine_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceRegisterResponse::machine_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.machine_name)
return machine_name_.GetNoArena();
}
inline void DeviceRegisterResponse::set_machine_name(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline void DeviceRegisterResponse::set_machine_name(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
machine_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline void DeviceRegisterResponse::set_machine_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline void DeviceRegisterResponse::set_machine_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline std::string* DeviceRegisterResponse::mutable_machine_name() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.machine_name)
return machine_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterResponse::release_machine_name() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.machine_name)
if (!has_machine_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return machine_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_allocated_machine_name(std::string* machine_name) {
if (machine_name != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
machine_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.machine_name)
}

// optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
inline bool DeviceRegisterResponse::has_enrollment_type() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceRegisterResponse::clear_enrollment_type() {
enrollment_type_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::enrollment_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.enrollment_type)
return static_cast< ::enterprise_management::DeviceRegisterResponse_DeviceMode >(enrollment_type_);
}
inline void DeviceRegisterResponse::set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value) {
assert(::enterprise_management::DeviceRegisterResponse_DeviceMode_IsValid(value));
_has_bits_[0] |= 0x00000010u;
enrollment_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.enrollment_type)
}

// optional string configuration_seed = 4;
inline bool DeviceRegisterResponse::has_configuration_seed() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceRegisterResponse::clear_configuration_seed() {
configuration_seed_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceRegisterResponse::configuration_seed() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.configuration_seed)
return configuration_seed_.GetNoArena();
}
inline void DeviceRegisterResponse::set_configuration_seed(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
configuration_seed_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline void DeviceRegisterResponse::set_configuration_seed(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
configuration_seed_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline void DeviceRegisterResponse::set_configuration_seed(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
configuration_seed_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline void DeviceRegisterResponse::set_configuration_seed(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
configuration_seed_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline std::string* DeviceRegisterResponse::mutable_configuration_seed() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.configuration_seed)
return configuration_seed_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterResponse::release_configuration_seed() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.configuration_seed)
if (!has_configuration_seed()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return configuration_seed_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_allocated_configuration_seed(std::string* configuration_seed) {
if (configuration_seed != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
configuration_seed_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), configuration_seed);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.configuration_seed)
}

// repeated string user_affiliation_ids = 5;
inline int DeviceRegisterResponse::user_affiliation_ids_size() const {
return user_affiliation_ids_.size();
}
inline void DeviceRegisterResponse::clear_user_affiliation_ids() {
user_affiliation_ids_.Clear();
}
inline const std::string& DeviceRegisterResponse::user_affiliation_ids(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
return user_affiliation_ids_.Get(index);
}
inline std::string* DeviceRegisterResponse::mutable_user_affiliation_ids(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
return user_affiliation_ids_.Mutable(index);
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
user_affiliation_ids_.Mutable(index)->assign(value);
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
user_affiliation_ids_.Mutable(index)->assign(std::move(value));
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
user_affiliation_ids_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, const char* value, size_t size) {
user_affiliation_ids_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline std::string* DeviceRegisterResponse::add_user_affiliation_ids() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
return user_affiliation_ids_.Add();
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(const std::string& value) {
user_affiliation_ids_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(std::string&& value) {
user_affiliation_ids_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(const char* value) {
GOOGLE_DCHECK(value != nullptr);
user_affiliation_ids_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(const char* value, size_t size) {
user_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceRegisterResponse::user_affiliation_ids() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
return user_affiliation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceRegisterResponse::mutable_user_affiliation_ids() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
return &user_affiliation_ids_;
}

// optional string directory_api_id = 6;
inline bool DeviceRegisterResponse::has_directory_api_id() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceRegisterResponse::clear_directory_api_id() {
directory_api_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceRegisterResponse::directory_api_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.directory_api_id)
return directory_api_id_.GetNoArena();
}
inline void DeviceRegisterResponse::set_directory_api_id(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
directory_api_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.directory_api_id)
}
inline void DeviceRegisterResponse::set_directory_api_id(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
directory_api_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterResponse.directory_api_id)
}
inline void DeviceRegisterResponse::set_directory_api_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
directory_api_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.directory_api_id)
}
inline void DeviceRegisterResponse::set_directory_api_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
directory_api_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.directory_api_id)
}
inline std::string* DeviceRegisterResponse::mutable_directory_api_id() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.directory_api_id)
return directory_api_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterResponse::release_directory_api_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.directory_api_id)
if (!has_directory_api_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return directory_api_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_allocated_directory_api_id(std::string* directory_api_id) {
if (directory_api_id != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
directory_api_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory_api_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.directory_api_id)
}

// -------------------------------------------------------------------

// DeviceUnregisterRequest

// -------------------------------------------------------------------

// DeviceUnregisterResponse

// -------------------------------------------------------------------

// DeviceCertUploadRequest

// optional bytes device_certificate = 1;
inline bool DeviceCertUploadRequest::has_device_certificate() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCertUploadRequest::clear_device_certificate() {
device_certificate_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceCertUploadRequest::device_certificate() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceCertUploadRequest.device_certificate)
return device_certificate_.GetNoArena();
}
inline void DeviceCertUploadRequest::set_device_certificate(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline void DeviceCertUploadRequest::set_device_certificate(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline void DeviceCertUploadRequest::set_device_certificate(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline void DeviceCertUploadRequest::set_device_certificate(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline std::string* DeviceCertUploadRequest::mutable_device_certificate() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceCertUploadRequest.device_certificate)
return device_certificate_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceCertUploadRequest::release_device_certificate() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceCertUploadRequest.device_certificate)
if (!has_device_certificate()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return device_certificate_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceCertUploadRequest::set_allocated_device_certificate(std::string* device_certificate) {
if (device_certificate != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
device_certificate_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_certificate);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceCertUploadRequest.device_certificate)
}

// optional .enterprise_management.DeviceCertUploadRequest.CertificateType certificate_type = 2;
inline bool DeviceCertUploadRequest::has_certificate_type() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceCertUploadRequest::clear_certificate_type() {
certificate_type_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::certificate_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceCertUploadRequest.certificate_type)
return static_cast< ::enterprise_management::DeviceCertUploadRequest_CertificateType >(certificate_type_);
}
inline void DeviceCertUploadRequest::set_certificate_type(::enterprise_management::DeviceCertUploadRequest_CertificateType value) {
assert(::enterprise_management::DeviceCertUploadRequest_CertificateType_IsValid(value));
_has_bits_[0] |= 0x00000004u;
certificate_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceCertUploadRequest.certificate_type)
}

// optional bytes enrollment_id = 3;
inline bool DeviceCertUploadRequest::has_enrollment_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceCertUploadRequest::clear_enrollment_id() {
enrollment_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceCertUploadRequest::enrollment_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceCertUploadRequest.enrollment_id)
return enrollment_id_.GetNoArena();
}
inline void DeviceCertUploadRequest::set_enrollment_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
enrollment_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceCertUploadRequest.enrollment_id)
}
inline void DeviceCertUploadRequest::set_enrollment_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
enrollment_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceCertUploadRequest.enrollment_id)
}
inline void DeviceCertUploadRequest::set_enrollment_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
enrollment_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceCertUploadRequest.enrollment_id)
}
inline void DeviceCertUploadRequest::set_enrollment_id(const void* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
enrollment_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceCertUploadRequest.enrollment_id)
}
inline std::string* DeviceCertUploadRequest::mutable_enrollment_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceCertUploadRequest.enrollment_id)
return enrollment_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceCertUploadRequest::release_enrollment_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceCertUploadRequest.enrollment_id)
if (!has_enrollment_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return enrollment_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceCertUploadRequest::set_allocated_enrollment_id(std::string* enrollment_id) {
if (enrollment_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
enrollment_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollment_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceCertUploadRequest.enrollment_id)
}

// -------------------------------------------------------------------

// DeviceCertUploadResponse

// -------------------------------------------------------------------

// DeviceServiceApiAccessRequest

// repeated string auth_scopes = 1;
inline int DeviceServiceApiAccessRequest::auth_scopes_size() const {
return auth_scopes_.size();
}
inline void DeviceServiceApiAccessRequest::clear_auth_scopes() {
auth_scopes_.Clear();
}
inline const std::string& DeviceServiceApiAccessRequest::auth_scopes(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
return auth_scopes_.Get(index);
}
inline std::string* DeviceServiceApiAccessRequest::mutable_auth_scopes(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
return auth_scopes_.Mutable(index);
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
auth_scopes_.Mutable(index)->assign(value);
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
auth_scopes_.Mutable(index)->assign(std::move(value));
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
auth_scopes_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, const char* value, size_t size) {
auth_scopes_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline std::string* DeviceServiceApiAccessRequest::add_auth_scopes() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
return auth_scopes_.Add();
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(const std::string& value) {
auth_scopes_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(std::string&& value) {
auth_scopes_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(const char* value) {
GOOGLE_DCHECK(value != nullptr);
auth_scopes_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(const char* value, size_t size) {
auth_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceServiceApiAccessRequest::auth_scopes() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
return auth_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceServiceApiAccessRequest::mutable_auth_scopes() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
return &auth_scopes_;
}

// optional string oauth2_client_id = 2;
inline bool DeviceServiceApiAccessRequest::has_oauth2_client_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceServiceApiAccessRequest::clear_oauth2_client_id() {
oauth2_client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceServiceApiAccessRequest::oauth2_client_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
return oauth2_client_id_.GetNoArena();
}
inline void DeviceServiceApiAccessRequest::set_oauth2_client_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
oauth2_client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline void DeviceServiceApiAccessRequest::set_oauth2_client_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
oauth2_client_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline void DeviceServiceApiAccessRequest::set_oauth2_client_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
oauth2_client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline void DeviceServiceApiAccessRequest::set_oauth2_client_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
oauth2_client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline std::string* DeviceServiceApiAccessRequest::mutable_oauth2_client_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
return oauth2_client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceServiceApiAccessRequest::release_oauth2_client_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
if (!has_oauth2_client_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return oauth2_client_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceServiceApiAccessRequest::set_allocated_oauth2_client_id(std::string* oauth2_client_id) {
if (oauth2_client_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
oauth2_client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oauth2_client_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}

// optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
inline bool DeviceServiceApiAccessRequest::has_device_type() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceServiceApiAccessRequest::clear_device_type() {
device_type_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::device_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.device_type)
return static_cast< ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType >(device_type_);
}
inline void DeviceServiceApiAccessRequest::set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value) {
assert(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType_IsValid(value));
_has_bits_[0] |= 0x00000002u;
device_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.device_type)
}

// -------------------------------------------------------------------

// DeviceServiceApiAccessResponse

// optional string auth_code = 1;
inline bool DeviceServiceApiAccessResponse::has_auth_code() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceServiceApiAccessResponse::clear_auth_code() {
auth_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceServiceApiAccessResponse::auth_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
return auth_code_.GetNoArena();
}
inline void DeviceServiceApiAccessResponse::set_auth_code(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
auth_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline void DeviceServiceApiAccessResponse::set_auth_code(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
auth_code_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline void DeviceServiceApiAccessResponse::set_auth_code(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
auth_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline void DeviceServiceApiAccessResponse::set_auth_code(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
auth_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline std::string* DeviceServiceApiAccessResponse::mutable_auth_code() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
return auth_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceServiceApiAccessResponse::release_auth_code() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
if (!has_auth_code()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return auth_code_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceServiceApiAccessResponse::set_allocated_auth_code(std::string* auth_code) {
if (auth_code != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
auth_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_code);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}

// -------------------------------------------------------------------

// PolicyFetchRequest

// optional string policy_type = 1;
inline bool PolicyFetchRequest::has_policy_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyFetchRequest::clear_policy_type() {
policy_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyFetchRequest::policy_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.policy_type)
return policy_type_.GetNoArena();
}
inline void PolicyFetchRequest::set_policy_type(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.policy_type)
}
inline void PolicyFetchRequest::set_policy_type(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchRequest.policy_type)
}
inline void PolicyFetchRequest::set_policy_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.policy_type)
}
inline void PolicyFetchRequest::set_policy_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.policy_type)
}
inline std::string* PolicyFetchRequest::mutable_policy_type() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.policy_type)
return policy_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchRequest::release_policy_type() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.policy_type)
if (!has_policy_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return policy_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_policy_type(std::string* policy_type) {
if (policy_type != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
policy_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_type);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.policy_type)
}

// optional int64 timestamp = 2;
inline bool PolicyFetchRequest::has_timestamp() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PolicyFetchRequest::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PolicyFetchRequest::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.timestamp)
return timestamp_;
}
inline void PolicyFetchRequest::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000040u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.timestamp)
}

// optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
inline bool PolicyFetchRequest::has_signature_type() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PolicyFetchRequest::clear_signature_type() {
signature_type_ = 0;
_has_bits_[0] &= ~0x00000080u;
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType PolicyFetchRequest::signature_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.signature_type)
return static_cast< ::enterprise_management::PolicyFetchRequest_SignatureType >(signature_type_);
}
inline void PolicyFetchRequest::set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
assert(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(value));
_has_bits_[0] |= 0x00000080u;
signature_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.signature_type)
}

// optional int32 public_key_version = 4;
inline bool PolicyFetchRequest::has_public_key_version() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PolicyFetchRequest::clear_public_key_version() {
public_key_version_ = 0;
_has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PolicyFetchRequest::public_key_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.public_key_version)
return public_key_version_;
}
inline void PolicyFetchRequest::set_public_key_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000100u;
public_key_version_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.public_key_version)
}

// optional string settings_entity_id = 6;
inline bool PolicyFetchRequest::has_settings_entity_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyFetchRequest::clear_settings_entity_id() {
settings_entity_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyFetchRequest::settings_entity_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.settings_entity_id)
return settings_entity_id_.GetNoArena();
}
inline void PolicyFetchRequest::set_settings_entity_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
settings_entity_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline void PolicyFetchRequest::set_settings_entity_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
settings_entity_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline void PolicyFetchRequest::set_settings_entity_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
settings_entity_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline void PolicyFetchRequest::set_settings_entity_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
settings_entity_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline std::string* PolicyFetchRequest::mutable_settings_entity_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.settings_entity_id)
return settings_entity_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchRequest::release_settings_entity_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.settings_entity_id)
if (!has_settings_entity_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return settings_entity_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_settings_entity_id(std::string* settings_entity_id) {
if (settings_entity_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
settings_entity_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), settings_entity_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.settings_entity_id)
}

// optional int64 invalidation_version = 7;
inline bool PolicyFetchRequest::has_invalidation_version() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PolicyFetchRequest::clear_invalidation_version() {
invalidation_version_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PolicyFetchRequest::invalidation_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_version)
return invalidation_version_;
}
inline void PolicyFetchRequest::set_invalidation_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000200u;
invalidation_version_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_version)
}

// optional bytes invalidation_payload = 8;
inline bool PolicyFetchRequest::has_invalidation_payload() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyFetchRequest::clear_invalidation_payload() {
invalidation_payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PolicyFetchRequest::invalidation_payload() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_payload)
return invalidation_payload_.GetNoArena();
}
inline void PolicyFetchRequest::set_invalidation_payload(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
invalidation_payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline void PolicyFetchRequest::set_invalidation_payload(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
invalidation_payload_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline void PolicyFetchRequest::set_invalidation_payload(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
invalidation_payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline void PolicyFetchRequest::set_invalidation_payload(const void* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
invalidation_payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline std::string* PolicyFetchRequest::mutable_invalidation_payload() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.invalidation_payload)
return invalidation_payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchRequest::release_invalidation_payload() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.invalidation_payload)
if (!has_invalidation_payload()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return invalidation_payload_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_invalidation_payload(std::string* invalidation_payload) {
if (invalidation_payload != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
invalidation_payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invalidation_payload);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.invalidation_payload)
}

// optional string verification_key_hash = 9;
inline bool PolicyFetchRequest::has_verification_key_hash() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PolicyFetchRequest::clear_verification_key_hash() {
verification_key_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PolicyFetchRequest::verification_key_hash() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.verification_key_hash)
return verification_key_hash_.GetNoArena();
}
inline void PolicyFetchRequest::set_verification_key_hash(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
verification_key_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline void PolicyFetchRequest::set_verification_key_hash(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
verification_key_hash_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline void PolicyFetchRequest::set_verification_key_hash(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
verification_key_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline void PolicyFetchRequest::set_verification_key_hash(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
verification_key_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline std::string* PolicyFetchRequest::mutable_verification_key_hash() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.verification_key_hash)
return verification_key_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchRequest::release_verification_key_hash() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.verification_key_hash)
if (!has_verification_key_hash()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return verification_key_hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_verification_key_hash(std::string* verification_key_hash) {
if (verification_key_hash != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
verification_key_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verification_key_hash);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.verification_key_hash)
}

// optional string policy_invalidation_info = 10;
inline bool PolicyFetchRequest::has_policy_invalidation_info() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PolicyFetchRequest::clear_policy_invalidation_info() {
policy_invalidation_info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PolicyFetchRequest::policy_invalidation_info() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
return policy_invalidation_info_.GetNoArena();
}
inline void PolicyFetchRequest::set_policy_invalidation_info(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
policy_invalidation_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
}
inline void PolicyFetchRequest::set_policy_invalidation_info(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
policy_invalidation_info_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
}
inline void PolicyFetchRequest::set_policy_invalidation_info(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
policy_invalidation_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
}
inline void PolicyFetchRequest::set_policy_invalidation_info(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
policy_invalidation_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
}
inline std::string* PolicyFetchRequest::mutable_policy_invalidation_info() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
return policy_invalidation_info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchRequest::release_policy_invalidation_info() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
if (!has_policy_invalidation_info()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return policy_invalidation_info_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_policy_invalidation_info(std::string* policy_invalidation_info) {
if (policy_invalidation_info != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
policy_invalidation_info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_invalidation_info);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
}

// optional bool invalidation_topics_only = 11;
inline bool PolicyFetchRequest::has_invalidation_topics_only() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PolicyFetchRequest::clear_invalidation_topics_only() {
invalidation_topics_only_ = false;
_has_bits_[0] &= ~0x00000400u;
}
inline bool PolicyFetchRequest::invalidation_topics_only() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_topics_only)
return invalidation_topics_only_;
}
inline void PolicyFetchRequest::set_invalidation_topics_only(bool value) {
_has_bits_[0] |= 0x00000400u;
invalidation_topics_only_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_topics_only)
}

// optional string device_dm_token = 12;
inline bool PolicyFetchRequest::has_device_dm_token() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PolicyFetchRequest::clear_device_dm_token() {
device_dm_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PolicyFetchRequest::device_dm_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.device_dm_token)
return device_dm_token_.GetNoArena();
}
inline void PolicyFetchRequest::set_device_dm_token(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
device_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.device_dm_token)
}
inline void PolicyFetchRequest::set_device_dm_token(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
device_dm_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchRequest.device_dm_token)
}
inline void PolicyFetchRequest::set_device_dm_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
device_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.device_dm_token)
}
inline void PolicyFetchRequest::set_device_dm_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
device_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.device_dm_token)
}
inline std::string* PolicyFetchRequest::mutable_device_dm_token() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.device_dm_token)
return device_dm_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchRequest::release_device_dm_token() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.device_dm_token)
if (!has_device_dm_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return device_dm_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_device_dm_token(std::string* device_dm_token) {
if (device_dm_token != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
device_dm_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_dm_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.device_dm_token)
}

// -------------------------------------------------------------------

// DisabledState

// optional string message = 1;
inline bool DisabledState::has_message() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisabledState::clear_message() {
message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DisabledState::message() const {
// @@protoc_insertion_point(field_get:enterprise_management.DisabledState.message)
return message_.GetNoArena();
}
inline void DisabledState::set_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DisabledState.message)
}
inline void DisabledState::set_message(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DisabledState.message)
}
inline void DisabledState::set_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DisabledState.message)
}
inline void DisabledState::set_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DisabledState.message)
}
inline std::string* DisabledState::mutable_message() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DisabledState.message)
return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DisabledState::release_message() {
// @@protoc_insertion_point(field_release:enterprise_management.DisabledState.message)
if (!has_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DisabledState::set_allocated_message(std::string* message) {
if (message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DisabledState.message)
}

// -------------------------------------------------------------------

// DeviceState

// optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
inline bool DeviceState::has_device_mode() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceState::clear_device_mode() {
device_mode_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::DeviceState_DeviceMode DeviceState::device_mode() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceState.device_mode)
return static_cast< ::enterprise_management::DeviceState_DeviceMode >(device_mode_);
}
inline void DeviceState::set_device_mode(::enterprise_management::DeviceState_DeviceMode value) {
assert(::enterprise_management::DeviceState_DeviceMode_IsValid(value));
_has_bits_[0] |= 0x00000002u;
device_mode_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceState.device_mode)
}

// optional .enterprise_management.DisabledState disabled_state = 2;
inline bool DeviceState::has_disabled_state() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceState::clear_disabled_state() {
if (disabled_state_ != nullptr) disabled_state_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DisabledState& DeviceState::disabled_state() const {
const ::enterprise_management::DisabledState* p = disabled_state_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceState.disabled_state)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DisabledState*>(
&::enterprise_management::_DisabledState_default_instance_);
}
inline ::enterprise_management::DisabledState* DeviceState::release_disabled_state() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceState.disabled_state)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::DisabledState* temp = disabled_state_;
disabled_state_ = nullptr;
return temp;
}
inline ::enterprise_management::DisabledState* DeviceState::mutable_disabled_state() {
_has_bits_[0] |= 0x00000001u;
if (disabled_state_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DisabledState>(GetArenaNoVirtual());
disabled_state_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceState.disabled_state)
return disabled_state_;
}
inline void DeviceState::set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete disabled_state_;
}
if (disabled_state) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
disabled_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, disabled_state, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
disabled_state_ = disabled_state;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceState.disabled_state)
}

// -------------------------------------------------------------------

// CustomerLogo

// optional string logo_url = 1;
inline bool CustomerLogo::has_logo_url() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomerLogo::clear_logo_url() {
logo_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomerLogo::logo_url() const {
// @@protoc_insertion_point(field_get:enterprise_management.CustomerLogo.logo_url)
return logo_url_.GetNoArena();
}
inline void CustomerLogo::set_logo_url(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
logo_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CustomerLogo.logo_url)
}
inline void CustomerLogo::set_logo_url(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
logo_url_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CustomerLogo.logo_url)
}
inline void CustomerLogo::set_logo_url(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
logo_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CustomerLogo.logo_url)
}
inline void CustomerLogo::set_logo_url(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
logo_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CustomerLogo.logo_url)
}
inline std::string* CustomerLogo::mutable_logo_url() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CustomerLogo.logo_url)
return logo_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CustomerLogo::release_logo_url() {
// @@protoc_insertion_point(field_release:enterprise_management.CustomerLogo.logo_url)
if (!has_logo_url()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return logo_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CustomerLogo::set_allocated_logo_url(std::string* logo_url) {
if (logo_url != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
logo_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logo_url);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CustomerLogo.logo_url)
}

// -------------------------------------------------------------------

// PolicyData

// optional string policy_type = 1;
inline bool PolicyData::has_policy_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyData::clear_policy_type() {
policy_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyData::policy_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_type)
return policy_type_.GetNoArena();
}
inline void PolicyData::set_policy_type(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_type)
}
inline void PolicyData::set_policy_type(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.policy_type)
}
inline void PolicyData::set_policy_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.policy_type)
}
inline void PolicyData::set_policy_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.policy_type)
}
inline std::string* PolicyData::mutable_policy_type() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_type)
return policy_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_policy_type() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_type)
if (!has_policy_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return policy_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_policy_type(std::string* policy_type) {
if (policy_type != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
policy_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_type);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_type)
}

// optional int64 timestamp = 2;
inline bool PolicyData::has_timestamp() const {
return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PolicyData::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PolicyData::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.timestamp)
return timestamp_;
}
inline void PolicyData::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00800000u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.timestamp)
}

// optional string request_token = 3;
inline bool PolicyData::has_request_token() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyData::clear_request_token() {
request_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyData::request_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.request_token)
return request_token_.GetNoArena();
}
inline void PolicyData::set_request_token(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
request_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.request_token)
}
inline void PolicyData::set_request_token(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
request_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.request_token)
}
inline void PolicyData::set_request_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
request_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.request_token)
}
inline void PolicyData::set_request_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
request_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.request_token)
}
inline std::string* PolicyData::mutable_request_token() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.request_token)
return request_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_request_token() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.request_token)
if (!has_request_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return request_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_request_token(std::string* request_token) {
if (request_token != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
request_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.request_token)
}

// optional bytes policy_value = 4;
inline bool PolicyData::has_policy_value() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyData::clear_policy_value() {
policy_value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PolicyData::policy_value() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_value)
return policy_value_.GetNoArena();
}
inline void PolicyData::set_policy_value(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
policy_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_value)
}
inline void PolicyData::set_policy_value(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
policy_value_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.policy_value)
}
inline void PolicyData::set_policy_value(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
policy_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.policy_value)
}
inline void PolicyData::set_policy_value(const void* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
policy_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.policy_value)
}
inline std::string* PolicyData::mutable_policy_value() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_value)
return policy_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_policy_value() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_value)
if (!has_policy_value()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return policy_value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_policy_value(std::string* policy_value) {
if (policy_value != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
policy_value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_value);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_value)
}

// optional string machine_name = 5;
inline bool PolicyData::has_machine_name() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PolicyData::clear_machine_name() {
machine_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PolicyData::machine_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.machine_name)
return machine_name_.GetNoArena();
}
inline void PolicyData::set_machine_name(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.machine_name)
}
inline void PolicyData::set_machine_name(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
machine_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.machine_name)
}
inline void PolicyData::set_machine_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.machine_name)
}
inline void PolicyData::set_machine_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.machine_name)
}
inline std::string* PolicyData::mutable_machine_name() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.machine_name)
return machine_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_machine_name() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.machine_name)
if (!has_machine_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return machine_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_machine_name(std::string* machine_name) {
if (machine_name != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
machine_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.machine_name)
}

// optional int32 public_key_version = 6;
inline bool PolicyData::has_public_key_version() const {
return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PolicyData::clear_public_key_version() {
public_key_version_ = 0;
_has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PolicyData::public_key_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.public_key_version)
return public_key_version_;
}
inline void PolicyData::set_public_key_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x01000000u;
public_key_version_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.public_key_version)
}

// optional string username = 7;
inline bool PolicyData::has_username() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PolicyData::clear_username() {
username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PolicyData::username() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.username)
return username_.GetNoArena();
}
inline void PolicyData::set_username(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.username)
}
inline void PolicyData::set_username(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
username_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.username)
}
inline void PolicyData::set_username(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.username)
}
inline void PolicyData::set_username(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.username)
}
inline std::string* PolicyData::mutable_username() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.username)
return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_username() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.username)
if (!has_username()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_username(std::string* username) {
if (username != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.username)
}

// optional string device_id = 8;
inline bool PolicyData::has_device_id() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PolicyData::clear_device_id() {
device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PolicyData::device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_id)
return device_id_.GetNoArena();
}
inline void PolicyData::set_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_id)
}
inline void PolicyData::set_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.device_id)
}
inline void PolicyData::set_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.device_id)
}
inline void PolicyData::set_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.device_id)
}
inline std::string* PolicyData::mutable_device_id() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_id)
return device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.device_id)
if (!has_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_device_id(std::string* device_id) {
if (device_id != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.device_id)
}

// optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
inline bool PolicyData::has_state() const {
return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PolicyData::clear_state() {
state_ = 0;
_has_bits_[0] &= ~0x02000000u;
}
inline ::enterprise_management::PolicyData_AssociationState PolicyData::state() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.state)
return static_cast< ::enterprise_management::PolicyData_AssociationState >(state_);
}
inline void PolicyData::set_state(::enterprise_management::PolicyData_AssociationState value) {
assert(::enterprise_management::PolicyData_AssociationState_IsValid(value));
_has_bits_[0] |= 0x02000000u;
state_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.state)
}

// optional string settings_entity_id = 11;
inline bool PolicyData::has_settings_entity_id() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PolicyData::clear_settings_entity_id() {
settings_entity_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000040u;
}
inline const std::string& PolicyData::settings_entity_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.settings_entity_id)
return settings_entity_id_.GetNoArena();
}
inline void PolicyData::set_settings_entity_id(const std::string& value) {
_has_bits_[0] |= 0x00000040u;
settings_entity_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.settings_entity_id)
}
inline void PolicyData::set_settings_entity_id(std::string&& value) {
_has_bits_[0] |= 0x00000040u;
settings_entity_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.settings_entity_id)
}
inline void PolicyData::set_settings_entity_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000040u;
settings_entity_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.settings_entity_id)
}
inline void PolicyData::set_settings_entity_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000040u;
settings_entity_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.settings_entity_id)
}
inline std::string* PolicyData::mutable_settings_entity_id() {
_has_bits_[0] |= 0x00000040u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.settings_entity_id)
return settings_entity_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_settings_entity_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.settings_entity_id)
if (!has_settings_entity_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000040u;
return settings_entity_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_settings_entity_id(std::string* settings_entity_id) {
if (settings_entity_id != nullptr) {
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
settings_entity_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), settings_entity_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.settings_entity_id)
}

// optional string service_account_identity = 12;
inline bool PolicyData::has_service_account_identity() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PolicyData::clear_service_account_identity() {
service_account_identity_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000080u;
}
inline const std::string& PolicyData::service_account_identity() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.service_account_identity)
return service_account_identity_.GetNoArena();
}
inline void PolicyData::set_service_account_identity(const std::string& value) {
_has_bits_[0] |= 0x00000080u;
service_account_identity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.service_account_identity)
}
inline void PolicyData::set_service_account_identity(std::string&& value) {
_has_bits_[0] |= 0x00000080u;
service_account_identity_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.service_account_identity)
}
inline void PolicyData::set_service_account_identity(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000080u;
service_account_identity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.service_account_identity)
}
inline void PolicyData::set_service_account_identity(const char* value, size_t size) {
_has_bits_[0] |= 0x00000080u;
service_account_identity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.service_account_identity)
}
inline std::string* PolicyData::mutable_service_account_identity() {
_has_bits_[0] |= 0x00000080u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.service_account_identity)
return service_account_identity_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_service_account_identity() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.service_account_identity)
if (!has_service_account_identity()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000080u;
return service_account_identity_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_service_account_identity(std::string* service_account_identity) {
if (service_account_identity != nullptr) {
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
service_account_identity_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_account_identity);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.service_account_identity)
}

// optional int32 invalidation_source = 13;
inline bool PolicyData::has_invalidation_source() const {
return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PolicyData::clear_invalidation_source() {
invalidation_source_ = 0;
_has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PolicyData::invalidation_source() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.invalidation_source)
return invalidation_source_;
}
inline void PolicyData::set_invalidation_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x04000000u;
invalidation_source_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.invalidation_source)
}

// optional bytes invalidation_name = 14;
inline bool PolicyData::has_invalidation_name() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PolicyData::clear_invalidation_name() {
invalidation_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000100u;
}
inline const std::string& PolicyData::invalidation_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.invalidation_name)
return invalidation_name_.GetNoArena();
}
inline void PolicyData::set_invalidation_name(const std::string& value) {
_has_bits_[0] |= 0x00000100u;
invalidation_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.invalidation_name)
}
inline void PolicyData::set_invalidation_name(std::string&& value) {
_has_bits_[0] |= 0x00000100u;
invalidation_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.invalidation_name)
}
inline void PolicyData::set_invalidation_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000100u;
invalidation_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.invalidation_name)
}
inline void PolicyData::set_invalidation_name(const void* value, size_t size) {
_has_bits_[0] |= 0x00000100u;
invalidation_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.invalidation_name)
}
inline std::string* PolicyData::mutable_invalidation_name() {
_has_bits_[0] |= 0x00000100u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.invalidation_name)
return invalidation_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_invalidation_name() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.invalidation_name)
if (!has_invalidation_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000100u;
return invalidation_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_invalidation_name(std::string* invalidation_name) {
if (invalidation_name != nullptr) {
_has_bits_[0] |= 0x00000100u;
} else {
_has_bits_[0] &= ~0x00000100u;
}
invalidation_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invalidation_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.invalidation_name)
}

// optional string policy_token = 15;
inline bool PolicyData::has_policy_token() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PolicyData::clear_policy_token() {
policy_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000200u;
}
inline const std::string& PolicyData::policy_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_token)
return policy_token_.GetNoArena();
}
inline void PolicyData::set_policy_token(const std::string& value) {
_has_bits_[0] |= 0x00000200u;
policy_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_token)
}
inline void PolicyData::set_policy_token(std::string&& value) {
_has_bits_[0] |= 0x00000200u;
policy_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.policy_token)
}
inline void PolicyData::set_policy_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000200u;
policy_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.policy_token)
}
inline void PolicyData::set_policy_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000200u;
policy_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.policy_token)
}
inline std::string* PolicyData::mutable_policy_token() {
_has_bits_[0] |= 0x00000200u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_token)
return policy_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_policy_token() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_token)
if (!has_policy_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000200u;
return policy_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_policy_token(std::string* policy_token) {
if (policy_token != nullptr) {
_has_bits_[0] |= 0x00000200u;
} else {
_has_bits_[0] &= ~0x00000200u;
}
policy_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_token)
}

// optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
inline bool PolicyData::has_management_mode() const {
return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PolicyData::clear_management_mode() {
management_mode_ = 0;
_has_bits_[0] &= ~0x08000000u;
}
inline ::enterprise_management::PolicyData_ManagementMode PolicyData::management_mode() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.management_mode)
return static_cast< ::enterprise_management::PolicyData_ManagementMode >(management_mode_);
}
inline void PolicyData::set_management_mode(::enterprise_management::PolicyData_ManagementMode value) {
assert(::enterprise_management::PolicyData_ManagementMode_IsValid(value));
_has_bits_[0] |= 0x08000000u;
management_mode_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.management_mode)
}

// optional .enterprise_management.DeviceState device_state = 17;
inline bool PolicyData::has_device_state() const {
return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PolicyData::clear_device_state() {
if (device_state_ != nullptr) device_state_->Clear();
_has_bits_[0] &= ~0x00100000u;
}
inline const ::enterprise_management::DeviceState& PolicyData::device_state() const {
const ::enterprise_management::DeviceState* p = device_state_;
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_state)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceState*>(
&::enterprise_management::_DeviceState_default_instance_);
}
inline ::enterprise_management::DeviceState* PolicyData::release_device_state() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.device_state)
_has_bits_[0] &= ~0x00100000u;
::enterprise_management::DeviceState* temp = device_state_;
device_state_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceState* PolicyData::mutable_device_state() {
_has_bits_[0] |= 0x00100000u;
if (device_state_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceState>(GetArenaNoVirtual());
device_state_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_state)
return device_state_;
}
inline void PolicyData::set_allocated_device_state(::enterprise_management::DeviceState* device_state) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_state_;
}
if (device_state) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_state, submessage_arena);
}
_has_bits_[0] |= 0x00100000u;
} else {
_has_bits_[0] &= ~0x00100000u;
}
device_state_ = device_state;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.device_state)
}

// optional int32 command_invalidation_source = 18;
inline bool PolicyData::has_command_invalidation_source() const {
return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PolicyData::clear_command_invalidation_source() {
command_invalidation_source_ = 0;
_has_bits_[0] &= ~0x10000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PolicyData::command_invalidation_source() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.command_invalidation_source)
return command_invalidation_source_;
}
inline void PolicyData::set_command_invalidation_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x10000000u;
command_invalidation_source_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.command_invalidation_source)
}

// optional bytes command_invalidation_name = 19;
inline bool PolicyData::has_command_invalidation_name() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PolicyData::clear_command_invalidation_name() {
command_invalidation_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000400u;
}
inline const std::string& PolicyData::command_invalidation_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.command_invalidation_name)
return command_invalidation_name_.GetNoArena();
}
inline void PolicyData::set_command_invalidation_name(const std::string& value) {
_has_bits_[0] |= 0x00000400u;
command_invalidation_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.command_invalidation_name)
}
inline void PolicyData::set_command_invalidation_name(std::string&& value) {
_has_bits_[0] |= 0x00000400u;
command_invalidation_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.command_invalidation_name)
}
inline void PolicyData::set_command_invalidation_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000400u;
command_invalidation_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.command_invalidation_name)
}
inline void PolicyData::set_command_invalidation_name(const void* value, size_t size) {
_has_bits_[0] |= 0x00000400u;
command_invalidation_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.command_invalidation_name)
}
inline std::string* PolicyData::mutable_command_invalidation_name() {
_has_bits_[0] |= 0x00000400u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.command_invalidation_name)
return command_invalidation_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_command_invalidation_name() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.command_invalidation_name)
if (!has_command_invalidation_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000400u;
return command_invalidation_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_command_invalidation_name(std::string* command_invalidation_name) {
if (command_invalidation_name != nullptr) {
_has_bits_[0] |= 0x00000400u;
} else {
_has_bits_[0] &= ~0x00000400u;
}
command_invalidation_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command_invalidation_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.command_invalidation_name)
}

// optional string annotated_location = 20;
inline bool PolicyData::has_annotated_location() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PolicyData::clear_annotated_location() {
annotated_location_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000800u;
}
inline const std::string& PolicyData::annotated_location() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.annotated_location)
return annotated_location_.GetNoArena();
}
inline void PolicyData::set_annotated_location(const std::string& value) {
_has_bits_[0] |= 0x00000800u;
annotated_location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.annotated_location)
}
inline void PolicyData::set_annotated_location(std::string&& value) {
_has_bits_[0] |= 0x00000800u;
annotated_location_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.annotated_location)
}
inline void PolicyData::set_annotated_location(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000800u;
annotated_location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.annotated_location)
}
inline void PolicyData::set_annotated_location(const char* value, size_t size) {
_has_bits_[0] |= 0x00000800u;
annotated_location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.annotated_location)
}
inline std::string* PolicyData::mutable_annotated_location() {
_has_bits_[0] |= 0x00000800u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.annotated_location)
return annotated_location_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_annotated_location() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.annotated_location)
if (!has_annotated_location()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000800u;
return annotated_location_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_annotated_location(std::string* annotated_location) {
if (annotated_location != nullptr) {
_has_bits_[0] |= 0x00000800u;
} else {
_has_bits_[0] &= ~0x00000800u;
}
annotated_location_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), annotated_location);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.annotated_location)
}

// optional string annotated_asset_id = 21;
inline bool PolicyData::has_annotated_asset_id() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PolicyData::clear_annotated_asset_id() {
annotated_asset_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00001000u;
}
inline const std::string& PolicyData::annotated_asset_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.annotated_asset_id)
return annotated_asset_id_.GetNoArena();
}
inline void PolicyData::set_annotated_asset_id(const std::string& value) {
_has_bits_[0] |= 0x00001000u;
annotated_asset_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.annotated_asset_id)
}
inline void PolicyData::set_annotated_asset_id(std::string&& value) {
_has_bits_[0] |= 0x00001000u;
annotated_asset_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.annotated_asset_id)
}
inline void PolicyData::set_annotated_asset_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00001000u;
annotated_asset_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.annotated_asset_id)
}
inline void PolicyData::set_annotated_asset_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00001000u;
annotated_asset_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.annotated_asset_id)
}
inline std::string* PolicyData::mutable_annotated_asset_id() {
_has_bits_[0] |= 0x00001000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.annotated_asset_id)
return annotated_asset_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_annotated_asset_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.annotated_asset_id)
if (!has_annotated_asset_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00001000u;
return annotated_asset_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_annotated_asset_id(std::string* annotated_asset_id) {
if (annotated_asset_id != nullptr) {
_has_bits_[0] |= 0x00001000u;
} else {
_has_bits_[0] &= ~0x00001000u;
}
annotated_asset_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), annotated_asset_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.annotated_asset_id)
}

// optional string directory_api_id = 22;
inline bool PolicyData::has_directory_api_id() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PolicyData::clear_directory_api_id() {
directory_api_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00002000u;
}
inline const std::string& PolicyData::directory_api_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.directory_api_id)
return directory_api_id_.GetNoArena();
}
inline void PolicyData::set_directory_api_id(const std::string& value) {
_has_bits_[0] |= 0x00002000u;
directory_api_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.directory_api_id)
}
inline void PolicyData::set_directory_api_id(std::string&& value) {
_has_bits_[0] |= 0x00002000u;
directory_api_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.directory_api_id)
}
inline void PolicyData::set_directory_api_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00002000u;
directory_api_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.directory_api_id)
}
inline void PolicyData::set_directory_api_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00002000u;
directory_api_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.directory_api_id)
}
inline std::string* PolicyData::mutable_directory_api_id() {
_has_bits_[0] |= 0x00002000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.directory_api_id)
return directory_api_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_directory_api_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.directory_api_id)
if (!has_directory_api_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00002000u;
return directory_api_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_directory_api_id(std::string* directory_api_id) {
if (directory_api_id != nullptr) {
_has_bits_[0] |= 0x00002000u;
} else {
_has_bits_[0] &= ~0x00002000u;
}
directory_api_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory_api_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.directory_api_id)
}

// repeated string device_affiliation_ids = 23;
inline int PolicyData::device_affiliation_ids_size() const {
return device_affiliation_ids_.size();
}
inline void PolicyData::clear_device_affiliation_ids() {
device_affiliation_ids_.Clear();
}
inline const std::string& PolicyData::device_affiliation_ids(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_affiliation_ids)
return device_affiliation_ids_.Get(index);
}
inline std::string* PolicyData::mutable_device_affiliation_ids(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_affiliation_ids)
return device_affiliation_ids_.Mutable(index);
}
inline void PolicyData::set_device_affiliation_ids(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_affiliation_ids)
device_affiliation_ids_.Mutable(index)->assign(value);
}
inline void PolicyData::set_device_affiliation_ids(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_affiliation_ids)
device_affiliation_ids_.Mutable(index)->assign(std::move(value));
}
inline void PolicyData::set_device_affiliation_ids(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
device_affiliation_ids_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::set_device_affiliation_ids(int index, const char* value, size_t size) {
device_affiliation_ids_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.device_affiliation_ids)
}
inline std::string* PolicyData::add_device_affiliation_ids() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.PolicyData.device_affiliation_ids)
return device_affiliation_ids_.Add();
}
inline void PolicyData::add_device_affiliation_ids(const std::string& value) {
device_affiliation_ids_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(std::string&& value) {
device_affiliation_ids_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(const char* value) {
GOOGLE_DCHECK(value != nullptr);
device_affiliation_ids_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(const char* value, size_t size) {
device_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.PolicyData.device_affiliation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PolicyData::device_affiliation_ids() const {
// @@protoc_insertion_point(field_list:enterprise_management.PolicyData.device_affiliation_ids)
return device_affiliation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PolicyData::mutable_device_affiliation_ids() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyData.device_affiliation_ids)
return &device_affiliation_ids_;
}

// repeated string user_affiliation_ids = 24;
inline int PolicyData::user_affiliation_ids_size() const {
return user_affiliation_ids_.size();
}
inline void PolicyData::clear_user_affiliation_ids() {
user_affiliation_ids_.Clear();
}
inline const std::string& PolicyData::user_affiliation_ids(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.user_affiliation_ids)
return user_affiliation_ids_.Get(index);
}
inline std::string* PolicyData::mutable_user_affiliation_ids(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.user_affiliation_ids)
return user_affiliation_ids_.Mutable(index);
}
inline void PolicyData::set_user_affiliation_ids(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.user_affiliation_ids)
user_affiliation_ids_.Mutable(index)->assign(value);
}
inline void PolicyData::set_user_affiliation_ids(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.user_affiliation_ids)
user_affiliation_ids_.Mutable(index)->assign(std::move(value));
}
inline void PolicyData::set_user_affiliation_ids(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
user_affiliation_ids_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::set_user_affiliation_ids(int index, const char* value, size_t size) {
user_affiliation_ids_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.user_affiliation_ids)
}
inline std::string* PolicyData::add_user_affiliation_ids() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.PolicyData.user_affiliation_ids)
return user_affiliation_ids_.Add();
}
inline void PolicyData::add_user_affiliation_ids(const std::string& value) {
user_affiliation_ids_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(std::string&& value) {
user_affiliation_ids_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(const char* value) {
GOOGLE_DCHECK(value != nullptr);
user_affiliation_ids_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(const char* value, size_t size) {
user_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.PolicyData.user_affiliation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PolicyData::user_affiliation_ids() const {
// @@protoc_insertion_point(field_list:enterprise_management.PolicyData.user_affiliation_ids)
return user_affiliation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PolicyData::mutable_user_affiliation_ids() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyData.user_affiliation_ids)
return &user_affiliation_ids_;
}

// optional string display_domain = 25;
inline bool PolicyData::has_display_domain() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PolicyData::clear_display_domain() {
display_domain_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00004000u;
}
inline const std::string& PolicyData::display_domain() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.display_domain)
return display_domain_.GetNoArena();
}
inline void PolicyData::set_display_domain(const std::string& value) {
_has_bits_[0] |= 0x00004000u;
display_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.display_domain)
}
inline void PolicyData::set_display_domain(std::string&& value) {
_has_bits_[0] |= 0x00004000u;
display_domain_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.display_domain)
}
inline void PolicyData::set_display_domain(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00004000u;
display_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.display_domain)
}
inline void PolicyData::set_display_domain(const char* value, size_t size) {
_has_bits_[0] |= 0x00004000u;
display_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.display_domain)
}
inline std::string* PolicyData::mutable_display_domain() {
_has_bits_[0] |= 0x00004000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.display_domain)
return display_domain_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_display_domain() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.display_domain)
if (!has_display_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00004000u;
return display_domain_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_display_domain(std::string* display_domain) {
if (display_domain != nullptr) {
_has_bits_[0] |= 0x00004000u;
} else {
_has_bits_[0] &= ~0x00004000u;
}
display_domain_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_domain);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.display_domain)
}

// optional string policy_invalidation_topic = 26;
inline bool PolicyData::has_policy_invalidation_topic() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PolicyData::clear_policy_invalidation_topic() {
policy_invalidation_topic_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00008000u;
}
inline const std::string& PolicyData::policy_invalidation_topic() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_invalidation_topic)
return policy_invalidation_topic_.GetNoArena();
}
inline void PolicyData::set_policy_invalidation_topic(const std::string& value) {
_has_bits_[0] |= 0x00008000u;
policy_invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_invalidation_topic)
}
inline void PolicyData::set_policy_invalidation_topic(std::string&& value) {
_has_bits_[0] |= 0x00008000u;
policy_invalidation_topic_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.policy_invalidation_topic)
}
inline void PolicyData::set_policy_invalidation_topic(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00008000u;
policy_invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.policy_invalidation_topic)
}
inline void PolicyData::set_policy_invalidation_topic(const char* value, size_t size) {
_has_bits_[0] |= 0x00008000u;
policy_invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.policy_invalidation_topic)
}
inline std::string* PolicyData::mutable_policy_invalidation_topic() {
_has_bits_[0] |= 0x00008000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_invalidation_topic)
return policy_invalidation_topic_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_policy_invalidation_topic() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_invalidation_topic)
if (!has_policy_invalidation_topic()) {
return nullptr;
}
_has_bits_[0] &= ~0x00008000u;
return policy_invalidation_topic_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_policy_invalidation_topic(std::string* policy_invalidation_topic) {
if (policy_invalidation_topic != nullptr) {
_has_bits_[0] |= 0x00008000u;
} else {
_has_bits_[0] &= ~0x00008000u;
}
policy_invalidation_topic_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_invalidation_topic);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_invalidation_topic)
}

// optional string command_invalidation_topic = 27;
inline bool PolicyData::has_command_invalidation_topic() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PolicyData::clear_command_invalidation_topic() {
command_invalidation_topic_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00010000u;
}
inline const std::string& PolicyData::command_invalidation_topic() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.command_invalidation_topic)
return command_invalidation_topic_.GetNoArena();
}
inline void PolicyData::set_command_invalidation_topic(const std::string& value) {
_has_bits_[0] |= 0x00010000u;
command_invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.command_invalidation_topic)
}
inline void PolicyData::set_command_invalidation_topic(std::string&& value) {
_has_bits_[0] |= 0x00010000u;
command_invalidation_topic_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.command_invalidation_topic)
}
inline void PolicyData::set_command_invalidation_topic(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00010000u;
command_invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.command_invalidation_topic)
}
inline void PolicyData::set_command_invalidation_topic(const char* value, size_t size) {
_has_bits_[0] |= 0x00010000u;
command_invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.command_invalidation_topic)
}
inline std::string* PolicyData::mutable_command_invalidation_topic() {
_has_bits_[0] |= 0x00010000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.command_invalidation_topic)
return command_invalidation_topic_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_command_invalidation_topic() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.command_invalidation_topic)
if (!has_command_invalidation_topic()) {
return nullptr;
}
_has_bits_[0] &= ~0x00010000u;
return command_invalidation_topic_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_command_invalidation_topic(std::string* command_invalidation_topic) {
if (command_invalidation_topic != nullptr) {
_has_bits_[0] |= 0x00010000u;
} else {
_has_bits_[0] &= ~0x00010000u;
}
command_invalidation_topic_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command_invalidation_topic);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.command_invalidation_topic)
}

// optional bool enrollment_id_needed = 28;
inline bool PolicyData::has_enrollment_id_needed() const {
return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PolicyData::clear_enrollment_id_needed() {
enrollment_id_needed_ = false;
_has_bits_[0] &= ~0x20000000u;
}
inline bool PolicyData::enrollment_id_needed() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.enrollment_id_needed)
return enrollment_id_needed_;
}
inline void PolicyData::set_enrollment_id_needed(bool value) {
_has_bits_[0] |= 0x20000000u;
enrollment_id_needed_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.enrollment_id_needed)
}

// optional string gaia_id = 29;
inline bool PolicyData::has_gaia_id() const {
return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PolicyData::clear_gaia_id() {
gaia_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00020000u;
}
inline const std::string& PolicyData::gaia_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.gaia_id)
return gaia_id_.GetNoArena();
}
inline void PolicyData::set_gaia_id(const std::string& value) {
_has_bits_[0] |= 0x00020000u;
gaia_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.gaia_id)
}
inline void PolicyData::set_gaia_id(std::string&& value) {
_has_bits_[0] |= 0x00020000u;
gaia_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.gaia_id)
}
inline void PolicyData::set_gaia_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00020000u;
gaia_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.gaia_id)
}
inline void PolicyData::set_gaia_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00020000u;
gaia_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.gaia_id)
}
inline std::string* PolicyData::mutable_gaia_id() {
_has_bits_[0] |= 0x00020000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.gaia_id)
return gaia_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_gaia_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.gaia_id)
if (!has_gaia_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00020000u;
return gaia_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_gaia_id(std::string* gaia_id) {
if (gaia_id != nullptr) {
_has_bits_[0] |= 0x00020000u;
} else {
_has_bits_[0] &= ~0x00020000u;
}
gaia_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gaia_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.gaia_id)
}

// optional .enterprise_management.PolicyData.MarketSegment market_segment = 30;
inline bool PolicyData::has_market_segment() const {
return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PolicyData::clear_market_segment() {
market_segment_ = 0;
_has_bits_[0] &= ~0x40000000u;
}
inline ::enterprise_management::PolicyData_MarketSegment PolicyData::market_segment() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.market_segment)
return static_cast< ::enterprise_management::PolicyData_MarketSegment >(market_segment_);
}
inline void PolicyData::set_market_segment(::enterprise_management::PolicyData_MarketSegment value) {
assert(::enterprise_management::PolicyData_MarketSegment_IsValid(value));
_has_bits_[0] |= 0x40000000u;
market_segment_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.market_segment)
}

// optional .enterprise_management.CustomerLogo customer_logo = 31;
inline bool PolicyData::has_customer_logo() const {
return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PolicyData::clear_customer_logo() {
if (customer_logo_ != nullptr) customer_logo_->Clear();
_has_bits_[0] &= ~0x00200000u;
}
inline const ::enterprise_management::CustomerLogo& PolicyData::customer_logo() const {
const ::enterprise_management::CustomerLogo* p = customer_logo_;
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.customer_logo)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CustomerLogo*>(
&::enterprise_management::_CustomerLogo_default_instance_);
}
inline ::enterprise_management::CustomerLogo* PolicyData::release_customer_logo() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.customer_logo)
_has_bits_[0] &= ~0x00200000u;
::enterprise_management::CustomerLogo* temp = customer_logo_;
customer_logo_ = nullptr;
return temp;
}
inline ::enterprise_management::CustomerLogo* PolicyData::mutable_customer_logo() {
_has_bits_[0] |= 0x00200000u;
if (customer_logo_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CustomerLogo>(GetArenaNoVirtual());
customer_logo_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.customer_logo)
return customer_logo_;
}
inline void PolicyData::set_allocated_customer_logo(::enterprise_management::CustomerLogo* customer_logo) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete customer_logo_;
}
if (customer_logo) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
customer_logo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, customer_logo, submessage_arena);
}
_has_bits_[0] |= 0x00200000u;
} else {
_has_bits_[0] &= ~0x00200000u;
}
customer_logo_ = customer_logo;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.customer_logo)
}

// optional string change_password_uri = 32;
inline bool PolicyData::has_change_password_uri() const {
return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PolicyData::clear_change_password_uri() {
change_password_uri_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00040000u;
}
inline const std::string& PolicyData::change_password_uri() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.change_password_uri)
return change_password_uri_.GetNoArena();
}
inline void PolicyData::set_change_password_uri(const std::string& value) {
_has_bits_[0] |= 0x00040000u;
change_password_uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.change_password_uri)
}
inline void PolicyData::set_change_password_uri(std::string&& value) {
_has_bits_[0] |= 0x00040000u;
change_password_uri_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.change_password_uri)
}
inline void PolicyData::set_change_password_uri(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00040000u;
change_password_uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.change_password_uri)
}
inline void PolicyData::set_change_password_uri(const char* value, size_t size) {
_has_bits_[0] |= 0x00040000u;
change_password_uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.change_password_uri)
}
inline std::string* PolicyData::mutable_change_password_uri() {
_has_bits_[0] |= 0x00040000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.change_password_uri)
return change_password_uri_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_change_password_uri() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.change_password_uri)
if (!has_change_password_uri()) {
return nullptr;
}
_has_bits_[0] &= ~0x00040000u;
return change_password_uri_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_change_password_uri(std::string* change_password_uri) {
if (change_password_uri != nullptr) {
_has_bits_[0] |= 0x00040000u;
} else {
_has_bits_[0] &= ~0x00040000u;
}
change_password_uri_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), change_password_uri);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.change_password_uri)
}

// optional .enterprise_management.ClientActionRequired client_action_required = 33;
inline bool PolicyData::has_client_action_required() const {
return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PolicyData::clear_client_action_required() {
if (client_action_required_ != nullptr) client_action_required_->Clear();
_has_bits_[0] &= ~0x00400000u;
}
inline const ::enterprise_management::ClientActionRequired& PolicyData::client_action_required() const {
const ::enterprise_management::ClientActionRequired* p = client_action_required_;
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.client_action_required)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ClientActionRequired*>(
&::enterprise_management::_ClientActionRequired_default_instance_);
}
inline ::enterprise_management::ClientActionRequired* PolicyData::release_client_action_required() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.client_action_required)
_has_bits_[0] &= ~0x00400000u;
::enterprise_management::ClientActionRequired* temp = client_action_required_;
client_action_required_ = nullptr;
return temp;
}
inline ::enterprise_management::ClientActionRequired* PolicyData::mutable_client_action_required() {
_has_bits_[0] |= 0x00400000u;
if (client_action_required_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ClientActionRequired>(GetArenaNoVirtual());
client_action_required_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.client_action_required)
return client_action_required_;
}
inline void PolicyData::set_allocated_client_action_required(::enterprise_management::ClientActionRequired* client_action_required) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete client_action_required_;
}
if (client_action_required) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
client_action_required = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, client_action_required, submessage_arena);
}
_has_bits_[0] |= 0x00400000u;
} else {
_has_bits_[0] &= ~0x00400000u;
}
client_action_required_ = client_action_required;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.client_action_required)
}

// optional string obfuscated_customer_id = 34;
inline bool PolicyData::has_obfuscated_customer_id() const {
return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PolicyData::clear_obfuscated_customer_id() {
obfuscated_customer_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00080000u;
}
inline const std::string& PolicyData::obfuscated_customer_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.obfuscated_customer_id)
return obfuscated_customer_id_.GetNoArena();
}
inline void PolicyData::set_obfuscated_customer_id(const std::string& value) {
_has_bits_[0] |= 0x00080000u;
obfuscated_customer_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyData.obfuscated_customer_id)
}
inline void PolicyData::set_obfuscated_customer_id(std::string&& value) {
_has_bits_[0] |= 0x00080000u;
obfuscated_customer_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyData.obfuscated_customer_id)
}
inline void PolicyData::set_obfuscated_customer_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00080000u;
obfuscated_customer_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.obfuscated_customer_id)
}
inline void PolicyData::set_obfuscated_customer_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00080000u;
obfuscated_customer_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.obfuscated_customer_id)
}
inline std::string* PolicyData::mutable_obfuscated_customer_id() {
_has_bits_[0] |= 0x00080000u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.obfuscated_customer_id)
return obfuscated_customer_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyData::release_obfuscated_customer_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyData.obfuscated_customer_id)
if (!has_obfuscated_customer_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00080000u;
return obfuscated_customer_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_obfuscated_customer_id(std::string* obfuscated_customer_id) {
if (obfuscated_customer_id != nullptr) {
_has_bits_[0] |= 0x00080000u;
} else {
_has_bits_[0] &= ~0x00080000u;
}
obfuscated_customer_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obfuscated_customer_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.obfuscated_customer_id)
}

// -------------------------------------------------------------------

// ClientActionRequired

// optional bool enrollment_certificate_needed = 1;
inline bool ClientActionRequired::has_enrollment_certificate_needed() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientActionRequired::clear_enrollment_certificate_needed() {
enrollment_certificate_needed_ = false;
_has_bits_[0] &= ~0x00000001u;
}
inline bool ClientActionRequired::enrollment_certificate_needed() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientActionRequired.enrollment_certificate_needed)
return enrollment_certificate_needed_;
}
inline void ClientActionRequired::set_enrollment_certificate_needed(bool value) {
_has_bits_[0] |= 0x00000001u;
enrollment_certificate_needed_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ClientActionRequired.enrollment_certificate_needed)
}

// -------------------------------------------------------------------

// PolicyFetchResponse

// optional int32 error_code = 1;
inline bool PolicyFetchResponse::has_error_code() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PolicyFetchResponse::clear_error_code() {
error_code_ = 0;
_has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PolicyFetchResponse::error_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.error_code)
return error_code_;
}
inline void PolicyFetchResponse::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000200u;
error_code_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.error_code)
}

// optional string error_message = 2;
inline bool PolicyFetchResponse::has_error_message() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyFetchResponse::clear_error_message() {
error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyFetchResponse::error_message() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.error_message)
return error_message_.GetNoArena();
}
inline void PolicyFetchResponse::set_error_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.error_message)
}
inline void PolicyFetchResponse::set_error_message(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.error_message)
}
inline void PolicyFetchResponse::set_error_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.error_message)
}
inline void PolicyFetchResponse::set_error_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.error_message)
}
inline std::string* PolicyFetchResponse::mutable_error_message() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.error_message)
return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_error_message() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.error_message)
if (!has_error_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return error_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_error_message(std::string* error_message) {
if (error_message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.error_message)
}

// optional bytes policy_data = 3;
inline bool PolicyFetchResponse::has_policy_data() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyFetchResponse::clear_policy_data() {
policy_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyFetchResponse::policy_data() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data)
return policy_data_.GetNoArena();
}
inline void PolicyFetchResponse::set_policy_data(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
policy_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data)
}
inline void PolicyFetchResponse::set_policy_data(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
policy_data_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.policy_data)
}
inline void PolicyFetchResponse::set_policy_data(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
policy_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.policy_data)
}
inline void PolicyFetchResponse::set_policy_data(const void* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
policy_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.policy_data)
}
inline std::string* PolicyFetchResponse::mutable_policy_data() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_data)
return policy_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_policy_data() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_data)
if (!has_policy_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return policy_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_policy_data(std::string* policy_data) {
if (policy_data != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
policy_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_data);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_data)
}

// optional bytes policy_data_signature = 4;
inline bool PolicyFetchResponse::has_policy_data_signature() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyFetchResponse::clear_policy_data_signature() {
policy_data_signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PolicyFetchResponse::policy_data_signature() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data_signature)
return policy_data_signature_.GetNoArena();
}
inline void PolicyFetchResponse::set_policy_data_signature(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
policy_data_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline void PolicyFetchResponse::set_policy_data_signature(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
policy_data_signature_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline void PolicyFetchResponse::set_policy_data_signature(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
policy_data_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline void PolicyFetchResponse::set_policy_data_signature(const void* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
policy_data_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline std::string* PolicyFetchResponse::mutable_policy_data_signature() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_data_signature)
return policy_data_signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_policy_data_signature() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_data_signature)
if (!has_policy_data_signature()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return policy_data_signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_policy_data_signature(std::string* policy_data_signature) {
if (policy_data_signature != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
policy_data_signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_data_signature);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_data_signature)
}

// optional bytes new_public_key = 5;
inline bool PolicyFetchResponse::has_new_public_key() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PolicyFetchResponse::clear_new_public_key() {
new_public_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PolicyFetchResponse::new_public_key() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key)
return new_public_key_.GetNoArena();
}
inline void PolicyFetchResponse::set_new_public_key(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline void PolicyFetchResponse::set_new_public_key(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
new_public_key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline void PolicyFetchResponse::set_new_public_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline void PolicyFetchResponse::set_new_public_key(const void* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key)
return new_public_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_new_public_key() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key)
if (!has_new_public_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return new_public_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key(std::string* new_public_key) {
if (new_public_key != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
new_public_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_public_key);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key)
}

// optional bytes new_public_key_signature = 6;
inline bool PolicyFetchResponse::has_new_public_key_signature() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PolicyFetchResponse::clear_new_public_key_signature() {
new_public_key_signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PolicyFetchResponse::new_public_key_signature() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_signature)
return new_public_key_signature_.GetNoArena();
}
inline void PolicyFetchResponse::set_new_public_key_signature(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
new_public_key_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline void PolicyFetchResponse::set_new_public_key_signature(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
new_public_key_signature_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline void PolicyFetchResponse::set_new_public_key_signature(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
new_public_key_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline void PolicyFetchResponse::set_new_public_key_signature(const void* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
new_public_key_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_signature() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_signature)
return new_public_key_signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_new_public_key_signature() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_signature)
if (!has_new_public_key_signature()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return new_public_key_signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_signature(std::string* new_public_key_signature) {
if (new_public_key_signature != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
new_public_key_signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_public_key_signature);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}

// optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
inline bool PolicyFetchResponse::has_new_public_key_verification_signature_deprecated() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PolicyFetchResponse::clear_new_public_key_verification_signature_deprecated() {
new_public_key_verification_signature_deprecated_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PolicyFetchResponse::new_public_key_verification_signature_deprecated() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
return new_public_key_verification_signature_deprecated_.GetNoArena();
}
inline void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
new_public_key_verification_signature_deprecated_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
new_public_key_verification_signature_deprecated_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
new_public_key_verification_signature_deprecated_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(const void* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
new_public_key_verification_signature_deprecated_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_verification_signature_deprecated() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
return new_public_key_verification_signature_deprecated_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_new_public_key_verification_signature_deprecated() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
if (!has_new_public_key_verification_signature_deprecated()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return new_public_key_verification_signature_deprecated_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_signature_deprecated(std::string* new_public_key_verification_signature_deprecated) {
if (new_public_key_verification_signature_deprecated != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
new_public_key_verification_signature_deprecated_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_public_key_verification_signature_deprecated);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}

// optional bytes new_public_key_verification_data = 8;
inline bool PolicyFetchResponse::has_new_public_key_verification_data() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PolicyFetchResponse::clear_new_public_key_verification_data() {
new_public_key_verification_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000040u;
}
inline const std::string& PolicyFetchResponse::new_public_key_verification_data() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
return new_public_key_verification_data_.GetNoArena();
}
inline void PolicyFetchResponse::set_new_public_key_verification_data(const std::string& value) {
_has_bits_[0] |= 0x00000040u;
new_public_key_verification_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data(std::string&& value) {
_has_bits_[0] |= 0x00000040u;
new_public_key_verification_data_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000040u;
new_public_key_verification_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data(const void* value, size_t size) {
_has_bits_[0] |= 0x00000040u;
new_public_key_verification_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_verification_data() {
_has_bits_[0] |= 0x00000040u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
return new_public_key_verification_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_new_public_key_verification_data() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
if (!has_new_public_key_verification_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000040u;
return new_public_key_verification_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_data(std::string* new_public_key_verification_data) {
if (new_public_key_verification_data != nullptr) {
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
new_public_key_verification_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_public_key_verification_data);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}

// optional bytes new_public_key_verification_data_signature = 9;
inline bool PolicyFetchResponse::has_new_public_key_verification_data_signature() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PolicyFetchResponse::clear_new_public_key_verification_data_signature() {
new_public_key_verification_data_signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000080u;
}
inline const std::string& PolicyFetchResponse::new_public_key_verification_data_signature() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
return new_public_key_verification_data_signature_.GetNoArena();
}
inline void PolicyFetchResponse::set_new_public_key_verification_data_signature(const std::string& value) {
_has_bits_[0] |= 0x00000080u;
new_public_key_verification_data_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data_signature(std::string&& value) {
_has_bits_[0] |= 0x00000080u;
new_public_key_verification_data_signature_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data_signature(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000080u;
new_public_key_verification_data_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data_signature(const void* value, size_t size) {
_has_bits_[0] |= 0x00000080u;
new_public_key_verification_data_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_verification_data_signature() {
_has_bits_[0] |= 0x00000080u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
return new_public_key_verification_data_signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_new_public_key_verification_data_signature() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
if (!has_new_public_key_verification_data_signature()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000080u;
return new_public_key_verification_data_signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_data_signature(std::string* new_public_key_verification_data_signature) {
if (new_public_key_verification_data_signature != nullptr) {
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
new_public_key_verification_data_signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_public_key_verification_data_signature);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}

// optional string policy_type = 10 [deprecated = true];
inline bool PolicyFetchResponse::has_policy_type() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PolicyFetchResponse::clear_policy_type() {
policy_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000100u;
}
inline const std::string& PolicyFetchResponse::policy_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_type)
return policy_type_.GetNoArena();
}
inline void PolicyFetchResponse::set_policy_type(const std::string& value) {
_has_bits_[0] |= 0x00000100u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_type)
}
inline void PolicyFetchResponse::set_policy_type(std::string&& value) {
_has_bits_[0] |= 0x00000100u;
policy_type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchResponse.policy_type)
}
inline void PolicyFetchResponse::set_policy_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000100u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.policy_type)
}
inline void PolicyFetchResponse::set_policy_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000100u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.policy_type)
}
inline std::string* PolicyFetchResponse::mutable_policy_type() {
_has_bits_[0] |= 0x00000100u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_type)
return policy_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchResponse::release_policy_type() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_type)
if (!has_policy_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000100u;
return policy_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_policy_type(std::string* policy_type) {
if (policy_type != nullptr) {
_has_bits_[0] |= 0x00000100u;
} else {
_has_bits_[0] &= ~0x00000100u;
}
policy_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_type);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_type)
}

// optional .enterprise_management.PolicyFetchRequest.SignatureType policy_data_signature_type = 11;
inline bool PolicyFetchResponse::has_policy_data_signature_type() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PolicyFetchResponse::clear_policy_data_signature_type() {
policy_data_signature_type_ = 0;
_has_bits_[0] &= ~0x00000400u;
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType PolicyFetchResponse::policy_data_signature_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data_signature_type)
return static_cast< ::enterprise_management::PolicyFetchRequest_SignatureType >(policy_data_signature_type_);
}
inline void PolicyFetchResponse::set_policy_data_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
assert(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(value));
_has_bits_[0] |= 0x00000400u;
policy_data_signature_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data_signature_type)
}

// -------------------------------------------------------------------

// DEPRECATEDPolicyPublicKeyAndDomain

// optional bytes new_public_key = 1;
inline bool DEPRECATEDPolicyPublicKeyAndDomain::has_new_public_key() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_new_public_key() {
new_public_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DEPRECATEDPolicyPublicKeyAndDomain::new_public_key() const {
// @@protoc_insertion_point(field_get:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
return new_public_key_.GetNoArena();
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::mutable_new_public_key() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
return new_public_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::release_new_public_key() {
// @@protoc_insertion_point(field_release:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
if (!has_new_public_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return new_public_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_allocated_new_public_key(std::string* new_public_key) {
if (new_public_key != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
new_public_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_public_key);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}

// optional string domain = 2;
inline bool DEPRECATEDPolicyPublicKeyAndDomain::has_domain() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_domain() {
domain_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DEPRECATEDPolicyPublicKeyAndDomain::domain() const {
// @@protoc_insertion_point(field_get:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
return domain_.GetNoArena();
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::mutable_domain() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
return domain_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::release_domain() {
// @@protoc_insertion_point(field_release:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
if (!has_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return domain_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_allocated_domain(std::string* domain) {
if (domain != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
domain_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}

// -------------------------------------------------------------------

// PublicKeyVerificationData

// optional bytes new_public_key = 1;
inline bool PublicKeyVerificationData::has_new_public_key() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicKeyVerificationData::clear_new_public_key() {
new_public_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublicKeyVerificationData::new_public_key() const {
// @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.new_public_key)
return new_public_key_.GetNoArena();
}
inline void PublicKeyVerificationData::set_new_public_key(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline void PublicKeyVerificationData::set_new_public_key(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline void PublicKeyVerificationData::set_new_public_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline void PublicKeyVerificationData::set_new_public_key(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
new_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline std::string* PublicKeyVerificationData::mutable_new_public_key() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PublicKeyVerificationData.new_public_key)
return new_public_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicKeyVerificationData::release_new_public_key() {
// @@protoc_insertion_point(field_release:enterprise_management.PublicKeyVerificationData.new_public_key)
if (!has_new_public_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return new_public_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyVerificationData::set_allocated_new_public_key(std::string* new_public_key) {
if (new_public_key != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
new_public_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_public_key);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicKeyVerificationData.new_public_key)
}

// optional string domain = 2;
inline bool PublicKeyVerificationData::has_domain() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicKeyVerificationData::clear_domain() {
domain_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PublicKeyVerificationData::domain() const {
// @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.domain)
return domain_.GetNoArena();
}
inline void PublicKeyVerificationData::set_domain(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.domain)
}
inline void PublicKeyVerificationData::set_domain(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PublicKeyVerificationData.domain)
}
inline void PublicKeyVerificationData::set_domain(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PublicKeyVerificationData.domain)
}
inline void PublicKeyVerificationData::set_domain(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PublicKeyVerificationData.domain)
}
inline std::string* PublicKeyVerificationData::mutable_domain() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PublicKeyVerificationData.domain)
return domain_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicKeyVerificationData::release_domain() {
// @@protoc_insertion_point(field_release:enterprise_management.PublicKeyVerificationData.domain)
if (!has_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return domain_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyVerificationData::set_allocated_domain(std::string* domain) {
if (domain != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
domain_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicKeyVerificationData.domain)
}

// optional int32 new_public_key_version = 3;
inline bool PublicKeyVerificationData::has_new_public_key_version() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublicKeyVerificationData::clear_new_public_key_version() {
new_public_key_version_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PublicKeyVerificationData::new_public_key_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.new_public_key_version)
return new_public_key_version_;
}
inline void PublicKeyVerificationData::set_new_public_key_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000004u;
new_public_key_version_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.new_public_key_version)
}

// -------------------------------------------------------------------

// DevicePolicyRequest

// repeated .enterprise_management.PolicyFetchRequest requests = 3;
inline int DevicePolicyRequest::requests_size() const {
return requests_.size();
}
inline void DevicePolicyRequest::clear_requests() {
requests_.Clear();
}
inline ::enterprise_management::PolicyFetchRequest* DevicePolicyRequest::mutable_requests(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DevicePolicyRequest.requests)
return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >*
DevicePolicyRequest::mutable_requests() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePolicyRequest.requests)
return &requests_;
}
inline const ::enterprise_management::PolicyFetchRequest& DevicePolicyRequest::requests(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DevicePolicyRequest.requests)
return requests_.Get(index);
}
inline ::enterprise_management::PolicyFetchRequest* DevicePolicyRequest::add_requests() {
// @@protoc_insertion_point(field_add:enterprise_management.DevicePolicyRequest.requests)
return requests_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >&
DevicePolicyRequest::requests() const {
// @@protoc_insertion_point(field_list:enterprise_management.DevicePolicyRequest.requests)
return requests_;
}

// -------------------------------------------------------------------

// DevicePolicyResponse

// repeated .enterprise_management.PolicyFetchResponse responses = 3;
inline int DevicePolicyResponse::responses_size() const {
return responses_.size();
}
inline void DevicePolicyResponse::clear_responses() {
responses_.Clear();
}
inline ::enterprise_management::PolicyFetchResponse* DevicePolicyResponse::mutable_responses(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DevicePolicyResponse.responses)
return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >*
DevicePolicyResponse::mutable_responses() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePolicyResponse.responses)
return &responses_;
}
inline const ::enterprise_management::PolicyFetchResponse& DevicePolicyResponse::responses(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DevicePolicyResponse.responses)
return responses_.Get(index);
}
inline ::enterprise_management::PolicyFetchResponse* DevicePolicyResponse::add_responses() {
// @@protoc_insertion_point(field_add:enterprise_management.DevicePolicyResponse.responses)
return responses_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >&
DevicePolicyResponse::responses() const {
// @@protoc_insertion_point(field_list:enterprise_management.DevicePolicyResponse.responses)
return responses_;
}

// -------------------------------------------------------------------

// TimePeriod

// optional int64 start_timestamp = 1;
inline bool TimePeriod::has_start_timestamp() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimePeriod::clear_start_timestamp() {
start_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimePeriod::start_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.TimePeriod.start_timestamp)
return start_timestamp_;
}
inline void TimePeriod::set_start_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
start_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TimePeriod.start_timestamp)
}

// optional int64 end_timestamp = 2;
inline bool TimePeriod::has_end_timestamp() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimePeriod::clear_end_timestamp() {
end_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimePeriod::end_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.TimePeriod.end_timestamp)
return end_timestamp_;
}
inline void TimePeriod::set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
end_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TimePeriod.end_timestamp)
}

// -------------------------------------------------------------------

// ActiveTimePeriod

// optional .enterprise_management.TimePeriod time_period = 1;
inline bool ActiveTimePeriod::has_time_period() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveTimePeriod::clear_time_period() {
if (time_period_ != nullptr) time_period_->Clear();
_has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::TimePeriod& ActiveTimePeriod::time_period() const {
const ::enterprise_management::TimePeriod* p = time_period_;
// @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.time_period)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::TimePeriod*>(
&::enterprise_management::_TimePeriod_default_instance_);
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::release_time_period() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveTimePeriod.time_period)
_has_bits_[0] &= ~0x00000002u;
::enterprise_management::TimePeriod* temp = time_period_;
time_period_ = nullptr;
return temp;
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::mutable_time_period() {
_has_bits_[0] |= 0x00000002u;
if (time_period_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::TimePeriod>(GetArenaNoVirtual());
time_period_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveTimePeriod.time_period)
return time_period_;
}
inline void ActiveTimePeriod::set_allocated_time_period(::enterprise_management::TimePeriod* time_period) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete time_period_;
}
if (time_period) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
time_period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, time_period, submessage_arena);
}
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
time_period_ = time_period;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveTimePeriod.time_period)
}

// optional int32 active_duration = 2;
inline bool ActiveTimePeriod::has_active_duration() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActiveTimePeriod::clear_active_duration() {
active_duration_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActiveTimePeriod::active_duration() const {
// @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.active_duration)
return active_duration_;
}
inline void ActiveTimePeriod::set_active_duration(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000004u;
active_duration_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ActiveTimePeriod.active_duration)
}

// optional string user_email = 3;
inline bool ActiveTimePeriod::has_user_email() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveTimePeriod::clear_user_email() {
user_email_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveTimePeriod::user_email() const {
// @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.user_email)
return user_email_.GetNoArena();
}
inline void ActiveTimePeriod::set_user_email(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
user_email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ActiveTimePeriod.user_email)
}
inline void ActiveTimePeriod::set_user_email(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
user_email_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ActiveTimePeriod.user_email)
}
inline void ActiveTimePeriod::set_user_email(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
user_email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ActiveTimePeriod.user_email)
}
inline void ActiveTimePeriod::set_user_email(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
user_email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ActiveTimePeriod.user_email)
}
inline std::string* ActiveTimePeriod::mutable_user_email() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveTimePeriod.user_email)
return user_email_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActiveTimePeriod::release_user_email() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveTimePeriod.user_email)
if (!has_user_email()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return user_email_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActiveTimePeriod::set_allocated_user_email(std::string* user_email) {
if (user_email != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
user_email_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_email);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveTimePeriod.user_email)
}

// -------------------------------------------------------------------

// NetworkInterface

// optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
inline bool NetworkInterface::has_type() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkInterface::clear_type() {
type_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::NetworkInterface_NetworkDeviceType NetworkInterface::type() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.type)
return static_cast< ::enterprise_management::NetworkInterface_NetworkDeviceType >(type_);
}
inline void NetworkInterface::set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value) {
assert(::enterprise_management::NetworkInterface_NetworkDeviceType_IsValid(value));
_has_bits_[0] |= 0x00000010u;
type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.type)
}

// optional string mac_address = 2;
inline bool NetworkInterface::has_mac_address() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInterface::clear_mac_address() {
mac_address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkInterface::mac_address() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.mac_address)
return mac_address_.GetNoArena();
}
inline void NetworkInterface::set_mac_address(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.mac_address)
}
inline void NetworkInterface::set_mac_address(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
mac_address_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.NetworkInterface.mac_address)
}
inline void NetworkInterface::set_mac_address(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.mac_address)
}
inline void NetworkInterface::set_mac_address(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
mac_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.mac_address)
}
inline std::string* NetworkInterface::mutable_mac_address() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.mac_address)
return mac_address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NetworkInterface::release_mac_address() {
// @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.mac_address)
if (!has_mac_address()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return mac_address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_mac_address(std::string* mac_address) {
if (mac_address != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
mac_address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.mac_address)
}

// optional string meid = 3;
inline bool NetworkInterface::has_meid() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInterface::clear_meid() {
meid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkInterface::meid() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.meid)
return meid_.GetNoArena();
}
inline void NetworkInterface::set_meid(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
meid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.meid)
}
inline void NetworkInterface::set_meid(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
meid_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.NetworkInterface.meid)
}
inline void NetworkInterface::set_meid(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
meid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.meid)
}
inline void NetworkInterface::set_meid(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
meid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.meid)
}
inline std::string* NetworkInterface::mutable_meid() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.meid)
return meid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NetworkInterface::release_meid() {
// @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.meid)
if (!has_meid()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return meid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_meid(std::string* meid) {
if (meid != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
meid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meid);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.meid)
}

// optional string imei = 4;
inline bool NetworkInterface::has_imei() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkInterface::clear_imei() {
imei_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkInterface::imei() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.imei)
return imei_.GetNoArena();
}
inline void NetworkInterface::set_imei(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
imei_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.imei)
}
inline void NetworkInterface::set_imei(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
imei_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.NetworkInterface.imei)
}
inline void NetworkInterface::set_imei(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
imei_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.imei)
}
inline void NetworkInterface::set_imei(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
imei_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.imei)
}
inline std::string* NetworkInterface::mutable_imei() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.imei)
return imei_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NetworkInterface::release_imei() {
// @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.imei)
if (!has_imei()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return imei_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_imei(std::string* imei) {
if (imei != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
imei_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imei);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.imei)
}

// optional string device_path = 5;
inline bool NetworkInterface::has_device_path() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkInterface::clear_device_path() {
device_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NetworkInterface::device_path() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.device_path)
return device_path_.GetNoArena();
}
inline void NetworkInterface::set_device_path(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
device_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.device_path)
}
inline void NetworkInterface::set_device_path(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
device_path_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.NetworkInterface.device_path)
}
inline void NetworkInterface::set_device_path(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
device_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.device_path)
}
inline void NetworkInterface::set_device_path(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
device_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.device_path)
}
inline std::string* NetworkInterface::mutable_device_path() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.device_path)
return device_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NetworkInterface::release_device_path() {
// @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.device_path)
if (!has_device_path()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return device_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_device_path(std::string* device_path) {
if (device_path != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
device_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_path);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.device_path)
}

// -------------------------------------------------------------------

// NetworkState

// optional string device_path = 1;
inline bool NetworkState::has_device_path() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkState::clear_device_path() {
device_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkState::device_path() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkState.device_path)
return device_path_.GetNoArena();
}
inline void NetworkState::set_device_path(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
device_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.NetworkState.device_path)
}
inline void NetworkState::set_device_path(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
device_path_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.NetworkState.device_path)
}
inline void NetworkState::set_device_path(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
device_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.NetworkState.device_path)
}
inline void NetworkState::set_device_path(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
device_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkState.device_path)
}
inline std::string* NetworkState::mutable_device_path() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.device_path)
return device_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NetworkState::release_device_path() {
// @@protoc_insertion_point(field_release:enterprise_management.NetworkState.device_path)
if (!has_device_path()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return device_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_allocated_device_path(std::string* device_path) {
if (device_path != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
device_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_path);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.device_path)
}

// optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
inline bool NetworkState::has_connection_state() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkState::clear_connection_state() {
connection_state_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::NetworkState_ConnectionState NetworkState::connection_state() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkState.connection_state)
return static_cast< ::enterprise_management::NetworkState_ConnectionState >(connection_state_);
}
inline void NetworkState::set_connection_state(::enterprise_management::NetworkState_ConnectionState value) {
assert(::enterprise_management::NetworkState_ConnectionState_IsValid(value));
_has_bits_[0] |= 0x00000008u;
connection_state_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.NetworkState.connection_state)
}

// optional int32 signal_strength = 3;
inline bool NetworkState::has_signal_strength() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkState::clear_signal_strength() {
signal_strength_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetworkState::signal_strength() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkState.signal_strength)
return signal_strength_;
}
inline void NetworkState::set_signal_strength(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000010u;
signal_strength_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.NetworkState.signal_strength)
}

// optional string ip_address = 4;
inline bool NetworkState::has_ip_address() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkState::clear_ip_address() {
ip_address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkState::ip_address() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkState.ip_address)
return ip_address_.GetNoArena();
}
inline void NetworkState::set_ip_address(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
ip_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.NetworkState.ip_address)
}
inline void NetworkState::set_ip_address(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
ip_address_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.NetworkState.ip_address)
}
inline void NetworkState::set_ip_address(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
ip_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.NetworkState.ip_address)
}
inline void NetworkState::set_ip_address(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
ip_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkState.ip_address)
}
inline std::string* NetworkState::mutable_ip_address() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.ip_address)
return ip_address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NetworkState::release_ip_address() {
// @@protoc_insertion_point(field_release:enterprise_management.NetworkState.ip_address)
if (!has_ip_address()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return ip_address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_allocated_ip_address(std::string* ip_address) {
if (ip_address != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
ip_address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.ip_address)
}

// optional string gateway = 5;
inline bool NetworkState::has_gateway() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkState::clear_gateway() {
gateway_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkState::gateway() const {
// @@protoc_insertion_point(field_get:enterprise_management.NetworkState.gateway)
return gateway_.GetNoArena();
}
inline void NetworkState::set_gateway(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
gateway_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.NetworkState.gateway)
}
inline void NetworkState::set_gateway(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
gateway_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.NetworkState.gateway)
}
inline void NetworkState::set_gateway(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
gateway_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.NetworkState.gateway)
}
inline void NetworkState::set_gateway(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
gateway_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkState.gateway)
}
inline std::string* NetworkState::mutable_gateway() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.gateway)
return gateway_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NetworkState::release_gateway() {
// @@protoc_insertion_point(field_release:enterprise_management.NetworkState.gateway)
if (!has_gateway()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return gateway_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_allocated_gateway(std::string* gateway) {
if (gateway != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
gateway_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gateway);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.gateway)
}

// -------------------------------------------------------------------

// DeviceUser

// required .enterprise_management.DeviceUser.UserType type = 1;
inline bool DeviceUser::has_type() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceUser::clear_type() {
type_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::DeviceUser_UserType DeviceUser::type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceUser.type)
return static_cast< ::enterprise_management::DeviceUser_UserType >(type_);
}
inline void DeviceUser::set_type(::enterprise_management::DeviceUser_UserType value) {
assert(::enterprise_management::DeviceUser_UserType_IsValid(value));
_has_bits_[0] |= 0x00000002u;
type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceUser.type)
}

// optional string email = 2;
inline bool DeviceUser::has_email() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceUser::clear_email() {
email_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceUser::email() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceUser.email)
return email_.GetNoArena();
}
inline void DeviceUser::set_email(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceUser.email)
}
inline void DeviceUser::set_email(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceUser.email)
}
inline void DeviceUser::set_email(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceUser.email)
}
inline void DeviceUser::set_email(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceUser.email)
}
inline std::string* DeviceUser::mutable_email() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceUser.email)
return email_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceUser::release_email() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceUser.email)
if (!has_email()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return email_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceUser::set_allocated_email(std::string* email) {
if (email != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
email_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceUser.email)
}

// -------------------------------------------------------------------

// VolumeInfo

// optional string volume_id = 1;
inline bool VolumeInfo::has_volume_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VolumeInfo::clear_volume_id() {
volume_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VolumeInfo::volume_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.volume_id)
return volume_id_.GetNoArena();
}
inline void VolumeInfo::set_volume_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
volume_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.volume_id)
}
inline void VolumeInfo::set_volume_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
volume_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.VolumeInfo.volume_id)
}
inline void VolumeInfo::set_volume_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
volume_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.VolumeInfo.volume_id)
}
inline void VolumeInfo::set_volume_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
volume_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.VolumeInfo.volume_id)
}
inline std::string* VolumeInfo::mutable_volume_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.VolumeInfo.volume_id)
return volume_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VolumeInfo::release_volume_id() {
// @@protoc_insertion_point(field_release:enterprise_management.VolumeInfo.volume_id)
if (!has_volume_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return volume_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VolumeInfo::set_allocated_volume_id(std::string* volume_id) {
if (volume_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
volume_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.VolumeInfo.volume_id)
}

// optional int64 storage_total = 2;
inline bool VolumeInfo::has_storage_total() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VolumeInfo::clear_storage_total() {
storage_total_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeInfo::storage_total() const {
// @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.storage_total)
return storage_total_;
}
inline void VolumeInfo::set_storage_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
storage_total_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.storage_total)
}

// optional int64 storage_free = 3;
inline bool VolumeInfo::has_storage_free() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VolumeInfo::clear_storage_free() {
storage_free_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeInfo::storage_free() const {
// @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.storage_free)
return storage_free_;
}
inline void VolumeInfo::set_storage_free(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
storage_free_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.storage_free)
}

// -------------------------------------------------------------------

// CpuUtilizationInfo

// optional int32 cpu_utilization_pct = 1;
inline bool CpuUtilizationInfo::has_cpu_utilization_pct() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CpuUtilizationInfo::clear_cpu_utilization_pct() {
cpu_utilization_pct_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CpuUtilizationInfo::cpu_utilization_pct() const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuUtilizationInfo.cpu_utilization_pct)
return cpu_utilization_pct_;
}
inline void CpuUtilizationInfo::set_cpu_utilization_pct(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
cpu_utilization_pct_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CpuUtilizationInfo.cpu_utilization_pct)
}

// optional int64 timestamp = 2;
inline bool CpuUtilizationInfo::has_timestamp() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpuUtilizationInfo::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CpuUtilizationInfo::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuUtilizationInfo.timestamp)
return timestamp_;
}
inline void CpuUtilizationInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CpuUtilizationInfo.timestamp)
}

// -------------------------------------------------------------------

// SystemFreeRamInfo

// optional int64 size_in_bytes = 1;
inline bool SystemFreeRamInfo::has_size_in_bytes() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemFreeRamInfo::clear_size_in_bytes() {
size_in_bytes_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SystemFreeRamInfo::size_in_bytes() const {
// @@protoc_insertion_point(field_get:enterprise_management.SystemFreeRamInfo.size_in_bytes)
return size_in_bytes_;
}
inline void SystemFreeRamInfo::set_size_in_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
size_in_bytes_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.SystemFreeRamInfo.size_in_bytes)
}

// optional int64 timestamp = 2;
inline bool SystemFreeRamInfo::has_timestamp() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemFreeRamInfo::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SystemFreeRamInfo::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.SystemFreeRamInfo.timestamp)
return timestamp_;
}
inline void SystemFreeRamInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.SystemFreeRamInfo.timestamp)
}

// -------------------------------------------------------------------

// CPUTempInfo

// optional string cpu_label = 1;
inline bool CPUTempInfo::has_cpu_label() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPUTempInfo::clear_cpu_label() {
cpu_label_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CPUTempInfo::cpu_label() const {
// @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.cpu_label)
return cpu_label_.GetNoArena();
}
inline void CPUTempInfo::set_cpu_label(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
cpu_label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.cpu_label)
}
inline void CPUTempInfo::set_cpu_label(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
cpu_label_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CPUTempInfo.cpu_label)
}
inline void CPUTempInfo::set_cpu_label(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
cpu_label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CPUTempInfo.cpu_label)
}
inline void CPUTempInfo::set_cpu_label(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
cpu_label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CPUTempInfo.cpu_label)
}
inline std::string* CPUTempInfo::mutable_cpu_label() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CPUTempInfo.cpu_label)
return cpu_label_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CPUTempInfo::release_cpu_label() {
// @@protoc_insertion_point(field_release:enterprise_management.CPUTempInfo.cpu_label)
if (!has_cpu_label()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return cpu_label_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CPUTempInfo::set_allocated_cpu_label(std::string* cpu_label) {
if (cpu_label != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
cpu_label_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpu_label);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CPUTempInfo.cpu_label)
}

// optional int32 cpu_temp = 2;
inline bool CPUTempInfo::has_cpu_temp() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPUTempInfo::clear_cpu_temp() {
cpu_temp_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPUTempInfo::cpu_temp() const {
// @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.cpu_temp)
return cpu_temp_;
}
inline void CPUTempInfo::set_cpu_temp(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000004u;
cpu_temp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.cpu_temp)
}

// optional int64 timestamp = 3;
inline bool CPUTempInfo::has_timestamp() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPUTempInfo::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CPUTempInfo::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.timestamp)
return timestamp_;
}
inline void CPUTempInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.timestamp)
}

// -------------------------------------------------------------------

// StatefulPartitionInfo

// optional int64 available_space = 1;
inline bool StatefulPartitionInfo::has_available_space() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatefulPartitionInfo::clear_available_space() {
available_space_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatefulPartitionInfo::available_space() const {
// @@protoc_insertion_point(field_get:enterprise_management.StatefulPartitionInfo.available_space)
return available_space_;
}
inline void StatefulPartitionInfo::set_available_space(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
available_space_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.StatefulPartitionInfo.available_space)
}

// optional int64 total_space = 2;
inline bool StatefulPartitionInfo::has_total_space() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatefulPartitionInfo::clear_total_space() {
total_space_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatefulPartitionInfo::total_space() const {
// @@protoc_insertion_point(field_get:enterprise_management.StatefulPartitionInfo.total_space)
return total_space_;
}
inline void StatefulPartitionInfo::set_total_space(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
total_space_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.StatefulPartitionInfo.total_space)
}

// -------------------------------------------------------------------

// BatterySample

// optional int64 timestamp = 1;
inline bool BatterySample::has_timestamp() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatterySample::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatterySample::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.timestamp)
return timestamp_;
}
inline void BatterySample::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.timestamp)
}

// optional int64 voltage = 2;
inline bool BatterySample::has_voltage() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatterySample::clear_voltage() {
voltage_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatterySample::voltage() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.voltage)
return voltage_;
}
inline void BatterySample::set_voltage(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
voltage_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.voltage)
}

// optional int64 remaining_capacity = 3;
inline bool BatterySample::has_remaining_capacity() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BatterySample::clear_remaining_capacity() {
remaining_capacity_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatterySample::remaining_capacity() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.remaining_capacity)
return remaining_capacity_;
}
inline void BatterySample::set_remaining_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000008u;
remaining_capacity_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.remaining_capacity)
}

// optional int32 temperature = 4;
inline bool BatterySample::has_temperature() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BatterySample::clear_temperature() {
temperature_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatterySample::temperature() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.temperature)
return temperature_;
}
inline void BatterySample::set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000010u;
temperature_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.temperature)
}

// optional int32 discharge_rate = 5;
inline bool BatterySample::has_discharge_rate() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BatterySample::clear_discharge_rate() {
discharge_rate_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatterySample::discharge_rate() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.discharge_rate)
return discharge_rate_;
}
inline void BatterySample::set_discharge_rate(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000020u;
discharge_rate_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.discharge_rate)
}

// optional int32 charge_rate = 6;
inline bool BatterySample::has_charge_rate() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BatterySample::clear_charge_rate() {
charge_rate_ = 0;
_has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatterySample::charge_rate() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.charge_rate)
return charge_rate_;
}
inline void BatterySample::set_charge_rate(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000080u;
charge_rate_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.charge_rate)
}

// optional int64 current = 7;
inline bool BatterySample::has_current() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BatterySample::clear_current() {
current_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatterySample::current() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.current)
return current_;
}
inline void BatterySample::set_current(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000040u;
current_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.current)
}

// optional string status = 8;
inline bool BatterySample::has_status() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatterySample::clear_status() {
status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BatterySample::status() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatterySample.status)
return status_.GetNoArena();
}
inline void BatterySample::set_status(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BatterySample.status)
}
inline void BatterySample::set_status(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
status_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BatterySample.status)
}
inline void BatterySample::set_status(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BatterySample.status)
}
inline void BatterySample::set_status(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BatterySample.status)
}
inline std::string* BatterySample::mutable_status() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BatterySample.status)
return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BatterySample::release_status() {
// @@protoc_insertion_point(field_release:enterprise_management.BatterySample.status)
if (!has_status()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return status_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BatterySample::set_allocated_status(std::string* status) {
if (status != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BatterySample.status)
}

// -------------------------------------------------------------------

// BatteryInfo

// optional string serial = 1;
inline bool BatteryInfo::has_serial() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatteryInfo::clear_serial() {
serial_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BatteryInfo::serial() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.serial)
return serial_.GetNoArena();
}
inline void BatteryInfo::set_serial(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.serial)
}
inline void BatteryInfo::set_serial(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BatteryInfo.serial)
}
inline void BatteryInfo::set_serial(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BatteryInfo.serial)
}
inline void BatteryInfo::set_serial(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BatteryInfo.serial)
}
inline std::string* BatteryInfo::mutable_serial() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.serial)
return serial_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BatteryInfo::release_serial() {
// @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.serial)
if (!has_serial()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return serial_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BatteryInfo::set_allocated_serial(std::string* serial) {
if (serial != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
serial_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.serial)
}

// optional string manufacturer = 2;
inline bool BatteryInfo::has_manufacturer() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatteryInfo::clear_manufacturer() {
manufacturer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BatteryInfo::manufacturer() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.manufacturer)
return manufacturer_.GetNoArena();
}
inline void BatteryInfo::set_manufacturer(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.manufacturer)
}
inline void BatteryInfo::set_manufacturer(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BatteryInfo.manufacturer)
}
inline void BatteryInfo::set_manufacturer(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BatteryInfo.manufacturer)
}
inline void BatteryInfo::set_manufacturer(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BatteryInfo.manufacturer)
}
inline std::string* BatteryInfo::mutable_manufacturer() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.manufacturer)
return manufacturer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BatteryInfo::release_manufacturer() {
// @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.manufacturer)
if (!has_manufacturer()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return manufacturer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BatteryInfo::set_allocated_manufacturer(std::string* manufacturer) {
if (manufacturer != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
manufacturer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.manufacturer)
}

// optional string battery_health = 3;
inline bool BatteryInfo::has_battery_health() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatteryInfo::clear_battery_health() {
battery_health_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BatteryInfo::battery_health() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.battery_health)
return battery_health_.GetNoArena();
}
inline void BatteryInfo::set_battery_health(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
battery_health_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.battery_health)
}
inline void BatteryInfo::set_battery_health(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
battery_health_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BatteryInfo.battery_health)
}
inline void BatteryInfo::set_battery_health(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
battery_health_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BatteryInfo.battery_health)
}
inline void BatteryInfo::set_battery_health(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
battery_health_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BatteryInfo.battery_health)
}
inline std::string* BatteryInfo::mutable_battery_health() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.battery_health)
return battery_health_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BatteryInfo::release_battery_health() {
// @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.battery_health)
if (!has_battery_health()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return battery_health_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BatteryInfo::set_allocated_battery_health(std::string* battery_health) {
if (battery_health != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
battery_health_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), battery_health);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.battery_health)
}

// optional int64 design_capacity = 4;
inline bool BatteryInfo::has_design_capacity() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BatteryInfo::clear_design_capacity() {
design_capacity_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatteryInfo::design_capacity() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.design_capacity)
return design_capacity_;
}
inline void BatteryInfo::set_design_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000020u;
design_capacity_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.design_capacity)
}

// optional int64 full_charge_capacity = 5;
inline bool BatteryInfo::has_full_charge_capacity() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BatteryInfo::clear_full_charge_capacity() {
full_charge_capacity_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatteryInfo::full_charge_capacity() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.full_charge_capacity)
return full_charge_capacity_;
}
inline void BatteryInfo::set_full_charge_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000040u;
full_charge_capacity_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.full_charge_capacity)
}

// optional int32 cycle_count = 6;
inline bool BatteryInfo::has_cycle_count() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BatteryInfo::clear_cycle_count() {
cycle_count_ = 0;
_has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatteryInfo::cycle_count() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.cycle_count)
return cycle_count_;
}
inline void BatteryInfo::set_cycle_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000080u;
cycle_count_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.cycle_count)
}

// repeated .enterprise_management.BatterySample samples = 7;
inline int BatteryInfo::samples_size() const {
return samples_.size();
}
inline void BatteryInfo::clear_samples() {
samples_.Clear();
}
inline ::enterprise_management::BatterySample* BatteryInfo::mutable_samples(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.samples)
return samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >*
BatteryInfo::mutable_samples() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.BatteryInfo.samples)
return &samples_;
}
inline const ::enterprise_management::BatterySample& BatteryInfo::samples(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.samples)
return samples_.Get(index);
}
inline ::enterprise_management::BatterySample* BatteryInfo::add_samples() {
// @@protoc_insertion_point(field_add:enterprise_management.BatteryInfo.samples)
return samples_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >&
BatteryInfo::samples() const {
// @@protoc_insertion_point(field_list:enterprise_management.BatteryInfo.samples)
return samples_;
}

// optional int32 design_min_voltage = 9;
inline bool BatteryInfo::has_design_min_voltage() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BatteryInfo::clear_design_min_voltage() {
design_min_voltage_ = 0;
_has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatteryInfo::design_min_voltage() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.design_min_voltage)
return design_min_voltage_;
}
inline void BatteryInfo::set_design_min_voltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000100u;
design_min_voltage_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.design_min_voltage)
}

// optional string manufacture_date = 10;
inline bool BatteryInfo::has_manufacture_date() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BatteryInfo::clear_manufacture_date() {
manufacture_date_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BatteryInfo::manufacture_date() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.manufacture_date)
return manufacture_date_.GetNoArena();
}
inline void BatteryInfo::set_manufacture_date(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
manufacture_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.manufacture_date)
}
inline void BatteryInfo::set_manufacture_date(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
manufacture_date_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BatteryInfo.manufacture_date)
}
inline void BatteryInfo::set_manufacture_date(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
manufacture_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BatteryInfo.manufacture_date)
}
inline void BatteryInfo::set_manufacture_date(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
manufacture_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BatteryInfo.manufacture_date)
}
inline std::string* BatteryInfo::mutable_manufacture_date() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.manufacture_date)
return manufacture_date_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BatteryInfo::release_manufacture_date() {
// @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.manufacture_date)
if (!has_manufacture_date()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return manufacture_date_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BatteryInfo::set_allocated_manufacture_date(std::string* manufacture_date) {
if (manufacture_date != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
manufacture_date_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacture_date);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.manufacture_date)
}

// optional string technology = 11;
inline bool BatteryInfo::has_technology() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BatteryInfo::clear_technology() {
technology_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BatteryInfo::technology() const {
// @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.technology)
return technology_.GetNoArena();
}
inline void BatteryInfo::set_technology(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
technology_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.technology)
}
inline void BatteryInfo::set_technology(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
technology_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BatteryInfo.technology)
}
inline void BatteryInfo::set_technology(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
technology_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BatteryInfo.technology)
}
inline void BatteryInfo::set_technology(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
technology_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BatteryInfo.technology)
}
inline std::string* BatteryInfo::mutable_technology() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.technology)
return technology_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BatteryInfo::release_technology() {
// @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.technology)
if (!has_technology()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return technology_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BatteryInfo::set_allocated_technology(std::string* technology) {
if (technology != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
technology_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), technology);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.technology)
}

// -------------------------------------------------------------------

// PowerStatus

// optional .enterprise_management.PowerStatus.PowerSource power_source = 1;
inline bool PowerStatus::has_power_source() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PowerStatus::clear_power_source() {
power_source_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::PowerStatus_PowerSource PowerStatus::power_source() const {
// @@protoc_insertion_point(field_get:enterprise_management.PowerStatus.power_source)
return static_cast< ::enterprise_management::PowerStatus_PowerSource >(power_source_);
}
inline void PowerStatus::set_power_source(::enterprise_management::PowerStatus_PowerSource value) {
assert(::enterprise_management::PowerStatus_PowerSource_IsValid(value));
_has_bits_[0] |= 0x00000001u;
power_source_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PowerStatus.power_source)
}

// repeated .enterprise_management.BatteryInfo batteries = 2;
inline int PowerStatus::batteries_size() const {
return batteries_.size();
}
inline void PowerStatus::clear_batteries() {
batteries_.Clear();
}
inline ::enterprise_management::BatteryInfo* PowerStatus::mutable_batteries(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.PowerStatus.batteries)
return batteries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >*
PowerStatus::mutable_batteries() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.PowerStatus.batteries)
return &batteries_;
}
inline const ::enterprise_management::BatteryInfo& PowerStatus::batteries(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.PowerStatus.batteries)
return batteries_.Get(index);
}
inline ::enterprise_management::BatteryInfo* PowerStatus::add_batteries() {
// @@protoc_insertion_point(field_add:enterprise_management.PowerStatus.batteries)
return batteries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >&
PowerStatus::batteries() const {
// @@protoc_insertion_point(field_list:enterprise_management.PowerStatus.batteries)
return batteries_;
}

// -------------------------------------------------------------------

// DiskLifetimeEstimation

// optional int32 slc = 1;
inline bool DiskLifetimeEstimation::has_slc() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskLifetimeEstimation::clear_slc() {
slc_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DiskLifetimeEstimation::slc() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskLifetimeEstimation.slc)
return slc_;
}
inline void DiskLifetimeEstimation::set_slc(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000001u;
slc_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskLifetimeEstimation.slc)
}

// optional int32 mlc = 2;
inline bool DiskLifetimeEstimation::has_mlc() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskLifetimeEstimation::clear_mlc() {
mlc_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DiskLifetimeEstimation::mlc() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskLifetimeEstimation.mlc)
return mlc_;
}
inline void DiskLifetimeEstimation::set_mlc(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
mlc_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskLifetimeEstimation.mlc)
}

// -------------------------------------------------------------------

// DiskInfo

// optional string serial = 1;
inline bool DiskInfo::has_serial() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskInfo::clear_serial() {
serial_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DiskInfo::serial() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.serial)
return serial_.GetNoArena();
}
inline void DiskInfo::set_serial(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.serial)
}
inline void DiskInfo::set_serial(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DiskInfo.serial)
}
inline void DiskInfo::set_serial(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DiskInfo.serial)
}
inline void DiskInfo::set_serial(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DiskInfo.serial)
}
inline std::string* DiskInfo::mutable_serial() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.serial)
return serial_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DiskInfo::release_serial() {
// @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.serial)
if (!has_serial()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return serial_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DiskInfo::set_allocated_serial(std::string* serial) {
if (serial != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
serial_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.serial)
}

// optional string manufacturer = 2;
inline bool DiskInfo::has_manufacturer() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskInfo::clear_manufacturer() {
manufacturer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DiskInfo::manufacturer() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.manufacturer)
return manufacturer_.GetNoArena();
}
inline void DiskInfo::set_manufacturer(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.manufacturer)
}
inline void DiskInfo::set_manufacturer(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DiskInfo.manufacturer)
}
inline void DiskInfo::set_manufacturer(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DiskInfo.manufacturer)
}
inline void DiskInfo::set_manufacturer(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DiskInfo.manufacturer)
}
inline std::string* DiskInfo::mutable_manufacturer() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.manufacturer)
return manufacturer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DiskInfo::release_manufacturer() {
// @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.manufacturer)
if (!has_manufacturer()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return manufacturer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DiskInfo::set_allocated_manufacturer(std::string* manufacturer) {
if (manufacturer != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
manufacturer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.manufacturer)
}

// optional string model = 3;
inline bool DiskInfo::has_model() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskInfo::clear_model() {
model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DiskInfo::model() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.model)
return model_.GetNoArena();
}
inline void DiskInfo::set_model(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.model)
}
inline void DiskInfo::set_model(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
model_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DiskInfo.model)
}
inline void DiskInfo::set_model(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DiskInfo.model)
}
inline void DiskInfo::set_model(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DiskInfo.model)
}
inline std::string* DiskInfo::mutable_model() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.model)
return model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DiskInfo::release_model() {
// @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.model)
if (!has_model()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return model_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DiskInfo::set_allocated_model(std::string* model) {
if (model != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.model)
}

// optional int64 size = 4;
inline bool DiskInfo::has_size() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiskInfo::clear_size() {
size_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskInfo::size() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.size)
return size_;
}
inline void DiskInfo::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000020u;
size_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.size)
}

// optional string type = 5;
inline bool DiskInfo::has_type() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskInfo::clear_type() {
type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DiskInfo::type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.type)
return type_.GetNoArena();
}
inline void DiskInfo::set_type(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.type)
}
inline void DiskInfo::set_type(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DiskInfo.type)
}
inline void DiskInfo::set_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DiskInfo.type)
}
inline void DiskInfo::set_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DiskInfo.type)
}
inline std::string* DiskInfo::mutable_type() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.type)
return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DiskInfo::release_type() {
// @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.type)
if (!has_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DiskInfo::set_allocated_type(std::string* type) {
if (type != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.type)
}

// optional string health = 6;
inline bool DiskInfo::has_health() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiskInfo::clear_health() {
health_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DiskInfo::health() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.health)
return health_.GetNoArena();
}
inline void DiskInfo::set_health(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
health_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.health)
}
inline void DiskInfo::set_health(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
health_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DiskInfo.health)
}
inline void DiskInfo::set_health(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
health_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DiskInfo.health)
}
inline void DiskInfo::set_health(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
health_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DiskInfo.health)
}
inline std::string* DiskInfo::mutable_health() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.health)
return health_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DiskInfo::release_health() {
// @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.health)
if (!has_health()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return health_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DiskInfo::set_allocated_health(std::string* health) {
if (health != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
health_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), health);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.health)
}

// repeated string volumes = 7;
inline int DiskInfo::volumes_size() const {
return volumes_.size();
}
inline void DiskInfo::clear_volumes() {
volumes_.Clear();
}
inline const std::string& DiskInfo::volumes(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.volumes)
return volumes_.Get(index);
}
inline std::string* DiskInfo::mutable_volumes(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.volumes)
return volumes_.Mutable(index);
}
inline void DiskInfo::set_volumes(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.volumes)
volumes_.Mutable(index)->assign(value);
}
inline void DiskInfo::set_volumes(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.volumes)
volumes_.Mutable(index)->assign(std::move(value));
}
inline void DiskInfo::set_volumes(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
volumes_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::set_volumes(int index, const char* value, size_t size) {
volumes_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DiskInfo.volumes)
}
inline std::string* DiskInfo::add_volumes() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.DiskInfo.volumes)
return volumes_.Add();
}
inline void DiskInfo::add_volumes(const std::string& value) {
volumes_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::add_volumes(std::string&& value) {
volumes_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::add_volumes(const char* value) {
GOOGLE_DCHECK(value != nullptr);
volumes_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::add_volumes(const char* value, size_t size) {
volumes_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.DiskInfo.volumes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DiskInfo::volumes() const {
// @@protoc_insertion_point(field_list:enterprise_management.DiskInfo.volumes)
return volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DiskInfo::mutable_volumes() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DiskInfo.volumes)
return &volumes_;
}

// optional uint64 bytes_read_since_last_boot = 8;
inline bool DiskInfo::has_bytes_read_since_last_boot() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiskInfo::clear_bytes_read_since_last_boot() {
bytes_read_since_last_boot_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DiskInfo::bytes_read_since_last_boot() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.bytes_read_since_last_boot)
return bytes_read_since_last_boot_;
}
inline void DiskInfo::set_bytes_read_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000040u;
bytes_read_since_last_boot_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.bytes_read_since_last_boot)
}

// optional uint64 bytes_written_since_last_boot = 9;
inline bool DiskInfo::has_bytes_written_since_last_boot() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DiskInfo::clear_bytes_written_since_last_boot() {
bytes_written_since_last_boot_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DiskInfo::bytes_written_since_last_boot() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.bytes_written_since_last_boot)
return bytes_written_since_last_boot_;
}
inline void DiskInfo::set_bytes_written_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000080u;
bytes_written_since_last_boot_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.bytes_written_since_last_boot)
}

// optional uint64 read_time_seconds_since_last_boot = 10;
inline bool DiskInfo::has_read_time_seconds_since_last_boot() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DiskInfo::clear_read_time_seconds_since_last_boot() {
read_time_seconds_since_last_boot_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DiskInfo::read_time_seconds_since_last_boot() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.read_time_seconds_since_last_boot)
return read_time_seconds_since_last_boot_;
}
inline void DiskInfo::set_read_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000100u;
read_time_seconds_since_last_boot_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.read_time_seconds_since_last_boot)
}

// optional uint64 write_time_seconds_since_last_boot = 11;
inline bool DiskInfo::has_write_time_seconds_since_last_boot() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DiskInfo::clear_write_time_seconds_since_last_boot() {
write_time_seconds_since_last_boot_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DiskInfo::write_time_seconds_since_last_boot() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.write_time_seconds_since_last_boot)
return write_time_seconds_since_last_boot_;
}
inline void DiskInfo::set_write_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000200u;
write_time_seconds_since_last_boot_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.write_time_seconds_since_last_boot)
}

// optional uint64 io_time_seconds_since_last_boot = 12;
inline bool DiskInfo::has_io_time_seconds_since_last_boot() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DiskInfo::clear_io_time_seconds_since_last_boot() {
io_time_seconds_since_last_boot_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DiskInfo::io_time_seconds_since_last_boot() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.io_time_seconds_since_last_boot)
return io_time_seconds_since_last_boot_;
}
inline void DiskInfo::set_io_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000400u;
io_time_seconds_since_last_boot_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.io_time_seconds_since_last_boot)
}

// optional uint64 discard_time_seconds_since_last_boot = 13;
inline bool DiskInfo::has_discard_time_seconds_since_last_boot() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DiskInfo::clear_discard_time_seconds_since_last_boot() {
discard_time_seconds_since_last_boot_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DiskInfo::discard_time_seconds_since_last_boot() const {
// @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.discard_time_seconds_since_last_boot)
return discard_time_seconds_since_last_boot_;
}
inline void DiskInfo::set_discard_time_seconds_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000800u;
discard_time_seconds_since_last_boot_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.discard_time_seconds_since_last_boot)
}

// -------------------------------------------------------------------

// StorageStatus

// repeated .enterprise_management.DiskInfo disks = 1;
inline int StorageStatus::disks_size() const {
return disks_.size();
}
inline void StorageStatus::clear_disks() {
disks_.Clear();
}
inline ::enterprise_management::DiskInfo* StorageStatus::mutable_disks(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.StorageStatus.disks)
return disks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >*
StorageStatus::mutable_disks() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.StorageStatus.disks)
return &disks_;
}
inline const ::enterprise_management::DiskInfo& StorageStatus::disks(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.StorageStatus.disks)
return disks_.Get(index);
}
inline ::enterprise_management::DiskInfo* StorageStatus::add_disks() {
// @@protoc_insertion_point(field_add:enterprise_management.StorageStatus.disks)
return disks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >&
StorageStatus::disks() const {
// @@protoc_insertion_point(field_list:enterprise_management.StorageStatus.disks)
return disks_;
}

// optional .enterprise_management.DiskLifetimeEstimation lifetime_estimation = 2;
inline bool StorageStatus::has_lifetime_estimation() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageStatus::clear_lifetime_estimation() {
if (lifetime_estimation_ != nullptr) lifetime_estimation_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DiskLifetimeEstimation& StorageStatus::lifetime_estimation() const {
const ::enterprise_management::DiskLifetimeEstimation* p = lifetime_estimation_;
// @@protoc_insertion_point(field_get:enterprise_management.StorageStatus.lifetime_estimation)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DiskLifetimeEstimation*>(
&::enterprise_management::_DiskLifetimeEstimation_default_instance_);
}
inline ::enterprise_management::DiskLifetimeEstimation* StorageStatus::release_lifetime_estimation() {
// @@protoc_insertion_point(field_release:enterprise_management.StorageStatus.lifetime_estimation)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::DiskLifetimeEstimation* temp = lifetime_estimation_;
lifetime_estimation_ = nullptr;
return temp;
}
inline ::enterprise_management::DiskLifetimeEstimation* StorageStatus::mutable_lifetime_estimation() {
_has_bits_[0] |= 0x00000001u;
if (lifetime_estimation_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DiskLifetimeEstimation>(GetArenaNoVirtual());
lifetime_estimation_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.StorageStatus.lifetime_estimation)
return lifetime_estimation_;
}
inline void StorageStatus::set_allocated_lifetime_estimation(::enterprise_management::DiskLifetimeEstimation* lifetime_estimation) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete lifetime_estimation_;
}
if (lifetime_estimation) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
lifetime_estimation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, lifetime_estimation, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
lifetime_estimation_ = lifetime_estimation;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.StorageStatus.lifetime_estimation)
}

// -------------------------------------------------------------------

// ThermalSample

// optional int64 timestamp = 1;
inline bool ThermalSample::has_timestamp() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThermalSample::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ThermalSample::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.ThermalSample.timestamp)
return timestamp_;
}
inline void ThermalSample::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ThermalSample.timestamp)
}

// optional int32 temperature = 2;
inline bool ThermalSample::has_temperature() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThermalSample::clear_temperature() {
temperature_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ThermalSample::temperature() const {
// @@protoc_insertion_point(field_get:enterprise_management.ThermalSample.temperature)
return temperature_;
}
inline void ThermalSample::set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
temperature_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ThermalSample.temperature)
}

// -------------------------------------------------------------------

// ThermalInfo

// optional string label = 1;
inline bool ThermalInfo::has_label() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThermalInfo::clear_label() {
label_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThermalInfo::label() const {
// @@protoc_insertion_point(field_get:enterprise_management.ThermalInfo.label)
return label_.GetNoArena();
}
inline void ThermalInfo::set_label(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ThermalInfo.label)
}
inline void ThermalInfo::set_label(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
label_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ThermalInfo.label)
}
inline void ThermalInfo::set_label(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ThermalInfo.label)
}
inline void ThermalInfo::set_label(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ThermalInfo.label)
}
inline std::string* ThermalInfo::mutable_label() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ThermalInfo.label)
return label_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThermalInfo::release_label() {
// @@protoc_insertion_point(field_release:enterprise_management.ThermalInfo.label)
if (!has_label()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return label_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThermalInfo::set_allocated_label(std::string* label) {
if (label != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
label_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ThermalInfo.label)
}

// repeated .enterprise_management.ThermalSample samples = 3;
inline int ThermalInfo::samples_size() const {
return samples_.size();
}
inline void ThermalInfo::clear_samples() {
samples_.Clear();
}
inline ::enterprise_management::ThermalSample* ThermalInfo::mutable_samples(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ThermalInfo.samples)
return samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >*
ThermalInfo::mutable_samples() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ThermalInfo.samples)
return &samples_;
}
inline const ::enterprise_management::ThermalSample& ThermalInfo::samples(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ThermalInfo.samples)
return samples_.Get(index);
}
inline ::enterprise_management::ThermalSample* ThermalInfo::add_samples() {
// @@protoc_insertion_point(field_add:enterprise_management.ThermalInfo.samples)
return samples_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >&
ThermalInfo::samples() const {
// @@protoc_insertion_point(field_list:enterprise_management.ThermalInfo.samples)
return samples_;
}

// -------------------------------------------------------------------

// BoardStatus

// repeated .enterprise_management.ThermalInfo thermal_infos = 1;
inline int BoardStatus::thermal_infos_size() const {
return thermal_infos_.size();
}
inline void BoardStatus::clear_thermal_infos() {
thermal_infos_.Clear();
}
inline ::enterprise_management::ThermalInfo* BoardStatus::mutable_thermal_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.BoardStatus.thermal_infos)
return thermal_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >*
BoardStatus::mutable_thermal_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.BoardStatus.thermal_infos)
return &thermal_infos_;
}
inline const ::enterprise_management::ThermalInfo& BoardStatus::thermal_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.BoardStatus.thermal_infos)
return thermal_infos_.Get(index);
}
inline ::enterprise_management::ThermalInfo* BoardStatus::add_thermal_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.BoardStatus.thermal_infos)
return thermal_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >&
BoardStatus::thermal_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.BoardStatus.thermal_infos)
return thermal_infos_;
}

// -------------------------------------------------------------------

// SystemStatus

// optional string vpd_sku_number = 1;
inline bool SystemStatus::has_vpd_sku_number() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemStatus::clear_vpd_sku_number() {
vpd_sku_number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SystemStatus::vpd_sku_number() const {
// @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.vpd_sku_number)
return vpd_sku_number_.GetNoArena();
}
inline void SystemStatus::set_vpd_sku_number(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
vpd_sku_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.vpd_sku_number)
}
inline void SystemStatus::set_vpd_sku_number(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
vpd_sku_number_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SystemStatus.vpd_sku_number)
}
inline void SystemStatus::set_vpd_sku_number(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
vpd_sku_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SystemStatus.vpd_sku_number)
}
inline void SystemStatus::set_vpd_sku_number(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
vpd_sku_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SystemStatus.vpd_sku_number)
}
inline std::string* SystemStatus::mutable_vpd_sku_number() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.vpd_sku_number)
return vpd_sku_number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SystemStatus::release_vpd_sku_number() {
// @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.vpd_sku_number)
if (!has_vpd_sku_number()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return vpd_sku_number_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SystemStatus::set_allocated_vpd_sku_number(std::string* vpd_sku_number) {
if (vpd_sku_number != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
vpd_sku_number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vpd_sku_number);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.vpd_sku_number)
}

// -------------------------------------------------------------------

// CpuCStateInfo

// optional string name = 1;
inline bool CpuCStateInfo::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpuCStateInfo::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CpuCStateInfo::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuCStateInfo.name)
return name_.GetNoArena();
}
inline void CpuCStateInfo::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CpuCStateInfo.name)
}
inline void CpuCStateInfo::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CpuCStateInfo.name)
}
inline void CpuCStateInfo::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CpuCStateInfo.name)
}
inline void CpuCStateInfo::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CpuCStateInfo.name)
}
inline std::string* CpuCStateInfo::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CpuCStateInfo.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CpuCStateInfo::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.CpuCStateInfo.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CpuCStateInfo::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CpuCStateInfo.name)
}

// optional uint64 time_in_state_since_last_boot_us = 2;
inline bool CpuCStateInfo::has_time_in_state_since_last_boot_us() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CpuCStateInfo::clear_time_in_state_since_last_boot_us() {
time_in_state_since_last_boot_us_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuCStateInfo::time_in_state_since_last_boot_us() const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuCStateInfo.time_in_state_since_last_boot_us)
return time_in_state_since_last_boot_us_;
}
inline void CpuCStateInfo::set_time_in_state_since_last_boot_us(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000002u;
time_in_state_since_last_boot_us_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CpuCStateInfo.time_in_state_since_last_boot_us)
}

// -------------------------------------------------------------------

// LogicalCpuInfo

// optional uint32 scaling_max_frequency_khz = 1;
inline bool LogicalCpuInfo::has_scaling_max_frequency_khz() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalCpuInfo::clear_scaling_max_frequency_khz() {
scaling_max_frequency_khz_ = 0u;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicalCpuInfo::scaling_max_frequency_khz() const {
// @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.scaling_max_frequency_khz)
return scaling_max_frequency_khz_;
}
inline void LogicalCpuInfo::set_scaling_max_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000001u;
scaling_max_frequency_khz_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.LogicalCpuInfo.scaling_max_frequency_khz)
}

// optional uint32 scaling_current_frequency_khz = 2;
inline bool LogicalCpuInfo::has_scaling_current_frequency_khz() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicalCpuInfo::clear_scaling_current_frequency_khz() {
scaling_current_frequency_khz_ = 0u;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicalCpuInfo::scaling_current_frequency_khz() const {
// @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.scaling_current_frequency_khz)
return scaling_current_frequency_khz_;
}
inline void LogicalCpuInfo::set_scaling_current_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000002u;
scaling_current_frequency_khz_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.LogicalCpuInfo.scaling_current_frequency_khz)
}

// optional uint32 idle_time_seconds = 3;
inline bool LogicalCpuInfo::has_idle_time_seconds() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicalCpuInfo::clear_idle_time_seconds() {
idle_time_seconds_ = 0u;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicalCpuInfo::idle_time_seconds() const {
// @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.idle_time_seconds)
return idle_time_seconds_;
}
inline void LogicalCpuInfo::set_idle_time_seconds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000004u;
idle_time_seconds_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.LogicalCpuInfo.idle_time_seconds)
}

// repeated .enterprise_management.CpuCStateInfo c_states = 4;
inline int LogicalCpuInfo::c_states_size() const {
return c_states_.size();
}
inline void LogicalCpuInfo::clear_c_states() {
c_states_.Clear();
}
inline ::enterprise_management::CpuCStateInfo* LogicalCpuInfo::mutable_c_states(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.LogicalCpuInfo.c_states)
return c_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >*
LogicalCpuInfo::mutable_c_states() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.LogicalCpuInfo.c_states)
return &c_states_;
}
inline const ::enterprise_management::CpuCStateInfo& LogicalCpuInfo::c_states(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.c_states)
return c_states_.Get(index);
}
inline ::enterprise_management::CpuCStateInfo* LogicalCpuInfo::add_c_states() {
// @@protoc_insertion_point(field_add:enterprise_management.LogicalCpuInfo.c_states)
return c_states_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >&
LogicalCpuInfo::c_states() const {
// @@protoc_insertion_point(field_list:enterprise_management.LogicalCpuInfo.c_states)
return c_states_;
}

// -------------------------------------------------------------------

// CpuInfo

// optional string model_name = 1;
inline bool CpuInfo::has_model_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpuInfo::clear_model_name() {
model_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CpuInfo::model_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.model_name)
return model_name_.GetNoArena();
}
inline void CpuInfo::set_model_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
model_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CpuInfo.model_name)
}
inline void CpuInfo::set_model_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
model_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CpuInfo.model_name)
}
inline void CpuInfo::set_model_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
model_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CpuInfo.model_name)
}
inline void CpuInfo::set_model_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
model_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CpuInfo.model_name)
}
inline std::string* CpuInfo::mutable_model_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CpuInfo.model_name)
return model_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CpuInfo::release_model_name() {
// @@protoc_insertion_point(field_release:enterprise_management.CpuInfo.model_name)
if (!has_model_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return model_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CpuInfo::set_allocated_model_name(std::string* model_name) {
if (model_name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
model_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CpuInfo.model_name)
}

// optional .enterprise_management.CpuInfo.Architecture architecture = 2;
inline bool CpuInfo::has_architecture() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CpuInfo::clear_architecture() {
architecture_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::CpuInfo_Architecture CpuInfo::architecture() const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.architecture)
return static_cast< ::enterprise_management::CpuInfo_Architecture >(architecture_);
}
inline void CpuInfo::set_architecture(::enterprise_management::CpuInfo_Architecture value) {
assert(::enterprise_management::CpuInfo_Architecture_IsValid(value));
_has_bits_[0] |= 0x00000002u;
architecture_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CpuInfo.architecture)
}

// optional uint32 max_clock_speed_khz = 3;
inline bool CpuInfo::has_max_clock_speed_khz() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CpuInfo::clear_max_clock_speed_khz() {
max_clock_speed_khz_ = 0u;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CpuInfo::max_clock_speed_khz() const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.max_clock_speed_khz)
return max_clock_speed_khz_;
}
inline void CpuInfo::set_max_clock_speed_khz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000004u;
max_clock_speed_khz_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CpuInfo.max_clock_speed_khz)
}

// repeated .enterprise_management.LogicalCpuInfo logical_cpus = 4;
inline int CpuInfo::logical_cpus_size() const {
return logical_cpus_.size();
}
inline void CpuInfo::clear_logical_cpus() {
logical_cpus_.Clear();
}
inline ::enterprise_management::LogicalCpuInfo* CpuInfo::mutable_logical_cpus(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.CpuInfo.logical_cpus)
return logical_cpus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >*
CpuInfo::mutable_logical_cpus() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.CpuInfo.logical_cpus)
return &logical_cpus_;
}
inline const ::enterprise_management::LogicalCpuInfo& CpuInfo::logical_cpus(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.logical_cpus)
return logical_cpus_.Get(index);
}
inline ::enterprise_management::LogicalCpuInfo* CpuInfo::add_logical_cpus() {
// @@protoc_insertion_point(field_add:enterprise_management.CpuInfo.logical_cpus)
return logical_cpus_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >&
CpuInfo::logical_cpus() const {
// @@protoc_insertion_point(field_list:enterprise_management.CpuInfo.logical_cpus)
return logical_cpus_;
}

// -------------------------------------------------------------------

// GlobalCpuInfo

// optional uint32 num_total_threads = 1;
inline bool GlobalCpuInfo::has_num_total_threads() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalCpuInfo::clear_num_total_threads() {
num_total_threads_ = 0u;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GlobalCpuInfo::num_total_threads() const {
// @@protoc_insertion_point(field_get:enterprise_management.GlobalCpuInfo.num_total_threads)
return num_total_threads_;
}
inline void GlobalCpuInfo::set_num_total_threads(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000001u;
num_total_threads_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.GlobalCpuInfo.num_total_threads)
}

// -------------------------------------------------------------------

// DisplayInfo

// optional uint32 resolution_width = 1;
inline bool DisplayInfo::has_resolution_width() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisplayInfo::clear_resolution_width() {
resolution_width_ = 0u;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DisplayInfo::resolution_width() const {
// @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.resolution_width)
return resolution_width_;
}
inline void DisplayInfo::set_resolution_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000001u;
resolution_width_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.resolution_width)
}

// optional uint32 resolution_height = 2;
inline bool DisplayInfo::has_resolution_height() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisplayInfo::clear_resolution_height() {
resolution_height_ = 0u;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DisplayInfo::resolution_height() const {
// @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.resolution_height)
return resolution_height_;
}
inline void DisplayInfo::set_resolution_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000002u;
resolution_height_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.resolution_height)
}

// optional uint32 refresh_rate = 3;
inline bool DisplayInfo::has_refresh_rate() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisplayInfo::clear_refresh_rate() {
refresh_rate_ = 0u;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DisplayInfo::refresh_rate() const {
// @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.refresh_rate)
return refresh_rate_;
}
inline void DisplayInfo::set_refresh_rate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000004u;
refresh_rate_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.refresh_rate)
}

// optional bool is_internal = 4;
inline bool DisplayInfo::has_is_internal() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DisplayInfo::clear_is_internal() {
is_internal_ = false;
_has_bits_[0] &= ~0x00000008u;
}
inline bool DisplayInfo::is_internal() const {
// @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.is_internal)
return is_internal_;
}
inline void DisplayInfo::set_is_internal(bool value) {
_has_bits_[0] |= 0x00000008u;
is_internal_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.is_internal)
}

// -------------------------------------------------------------------

// GraphicsAdapterInfo

// optional string name = 1;
inline bool GraphicsAdapterInfo::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GraphicsAdapterInfo::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GraphicsAdapterInfo::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.name)
return name_.GetNoArena();
}
inline void GraphicsAdapterInfo::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.name)
}
inline void GraphicsAdapterInfo::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.GraphicsAdapterInfo.name)
}
inline void GraphicsAdapterInfo::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.GraphicsAdapterInfo.name)
}
inline void GraphicsAdapterInfo::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.GraphicsAdapterInfo.name)
}
inline std::string* GraphicsAdapterInfo::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsAdapterInfo.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GraphicsAdapterInfo::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.GraphicsAdapterInfo.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GraphicsAdapterInfo::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.GraphicsAdapterInfo.name)
}

// optional string driver_version = 2;
inline bool GraphicsAdapterInfo::has_driver_version() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GraphicsAdapterInfo::clear_driver_version() {
driver_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GraphicsAdapterInfo::driver_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.driver_version)
return driver_version_.GetNoArena();
}
inline void GraphicsAdapterInfo::set_driver_version(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
driver_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.driver_version)
}
inline void GraphicsAdapterInfo::set_driver_version(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
driver_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.GraphicsAdapterInfo.driver_version)
}
inline void GraphicsAdapterInfo::set_driver_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
driver_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.GraphicsAdapterInfo.driver_version)
}
inline void GraphicsAdapterInfo::set_driver_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
driver_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.GraphicsAdapterInfo.driver_version)
}
inline std::string* GraphicsAdapterInfo::mutable_driver_version() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsAdapterInfo.driver_version)
return driver_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GraphicsAdapterInfo::release_driver_version() {
// @@protoc_insertion_point(field_release:enterprise_management.GraphicsAdapterInfo.driver_version)
if (!has_driver_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return driver_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GraphicsAdapterInfo::set_allocated_driver_version(std::string* driver_version) {
if (driver_version != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
driver_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), driver_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.GraphicsAdapterInfo.driver_version)
}

// optional uint64 device_id = 3;
inline bool GraphicsAdapterInfo::has_device_id() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GraphicsAdapterInfo::clear_device_id() {
device_id_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GraphicsAdapterInfo::device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.device_id)
return device_id_;
}
inline void GraphicsAdapterInfo::set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000004u;
device_id_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.device_id)
}

// optional uint64 system_ram_usage = 4;
inline bool GraphicsAdapterInfo::has_system_ram_usage() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GraphicsAdapterInfo::clear_system_ram_usage() {
system_ram_usage_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GraphicsAdapterInfo::system_ram_usage() const {
// @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.system_ram_usage)
return system_ram_usage_;
}
inline void GraphicsAdapterInfo::set_system_ram_usage(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000008u;
system_ram_usage_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.system_ram_usage)
}

// -------------------------------------------------------------------

// GraphicsStatus

// optional .enterprise_management.GraphicsAdapterInfo adapter = 1;
inline bool GraphicsStatus::has_adapter() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GraphicsStatus::clear_adapter() {
if (adapter_ != nullptr) adapter_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::GraphicsAdapterInfo& GraphicsStatus::adapter() const {
const ::enterprise_management::GraphicsAdapterInfo* p = adapter_;
// @@protoc_insertion_point(field_get:enterprise_management.GraphicsStatus.adapter)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::GraphicsAdapterInfo*>(
&::enterprise_management::_GraphicsAdapterInfo_default_instance_);
}
inline ::enterprise_management::GraphicsAdapterInfo* GraphicsStatus::release_adapter() {
// @@protoc_insertion_point(field_release:enterprise_management.GraphicsStatus.adapter)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::GraphicsAdapterInfo* temp = adapter_;
adapter_ = nullptr;
return temp;
}
inline ::enterprise_management::GraphicsAdapterInfo* GraphicsStatus::mutable_adapter() {
_has_bits_[0] |= 0x00000001u;
if (adapter_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::GraphicsAdapterInfo>(GetArenaNoVirtual());
adapter_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsStatus.adapter)
return adapter_;
}
inline void GraphicsStatus::set_allocated_adapter(::enterprise_management::GraphicsAdapterInfo* adapter) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete adapter_;
}
if (adapter) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
adapter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, adapter, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
adapter_ = adapter;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.GraphicsStatus.adapter)
}

// repeated .enterprise_management.DisplayInfo displays = 2;
inline int GraphicsStatus::displays_size() const {
return displays_.size();
}
inline void GraphicsStatus::clear_displays() {
displays_.Clear();
}
inline ::enterprise_management::DisplayInfo* GraphicsStatus::mutable_displays(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsStatus.displays)
return displays_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >*
GraphicsStatus::mutable_displays() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.GraphicsStatus.displays)
return &displays_;
}
inline const ::enterprise_management::DisplayInfo& GraphicsStatus::displays(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.GraphicsStatus.displays)
return displays_.Get(index);
}
inline ::enterprise_management::DisplayInfo* GraphicsStatus::add_displays() {
// @@protoc_insertion_point(field_add:enterprise_management.GraphicsStatus.displays)
return displays_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >&
GraphicsStatus::displays() const {
// @@protoc_insertion_point(field_list:enterprise_management.GraphicsStatus.displays)
return displays_;
}

// -------------------------------------------------------------------

// CrashReportInfo

// optional string remote_id = 1;
inline bool CrashReportInfo::has_remote_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrashReportInfo::clear_remote_id() {
remote_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrashReportInfo::remote_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.remote_id)
return remote_id_.GetNoArena();
}
inline void CrashReportInfo::set_remote_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
remote_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.remote_id)
}
inline void CrashReportInfo::set_remote_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
remote_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrashReportInfo.remote_id)
}
inline void CrashReportInfo::set_remote_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
remote_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrashReportInfo.remote_id)
}
inline void CrashReportInfo::set_remote_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
remote_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrashReportInfo.remote_id)
}
inline std::string* CrashReportInfo::mutable_remote_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrashReportInfo.remote_id)
return remote_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrashReportInfo::release_remote_id() {
// @@protoc_insertion_point(field_release:enterprise_management.CrashReportInfo.remote_id)
if (!has_remote_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return remote_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrashReportInfo::set_allocated_remote_id(std::string* remote_id) {
if (remote_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
remote_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrashReportInfo.remote_id)
}

// optional int64 capture_timestamp = 2;
inline bool CrashReportInfo::has_capture_timestamp() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrashReportInfo::clear_capture_timestamp() {
capture_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CrashReportInfo::capture_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.capture_timestamp)
return capture_timestamp_;
}
inline void CrashReportInfo::set_capture_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
capture_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.capture_timestamp)
}

// optional string cause = 3;
inline bool CrashReportInfo::has_cause() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrashReportInfo::clear_cause() {
cause_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CrashReportInfo::cause() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.cause)
return cause_.GetNoArena();
}
inline void CrashReportInfo::set_cause(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
cause_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.cause)
}
inline void CrashReportInfo::set_cause(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
cause_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrashReportInfo.cause)
}
inline void CrashReportInfo::set_cause(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
cause_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrashReportInfo.cause)
}
inline void CrashReportInfo::set_cause(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
cause_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrashReportInfo.cause)
}
inline std::string* CrashReportInfo::mutable_cause() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrashReportInfo.cause)
return cause_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrashReportInfo::release_cause() {
// @@protoc_insertion_point(field_release:enterprise_management.CrashReportInfo.cause)
if (!has_cause()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return cause_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrashReportInfo::set_allocated_cause(std::string* cause) {
if (cause != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
cause_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cause);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrashReportInfo.cause)
}

// optional .enterprise_management.CrashReportInfo.CrashReportUploadStatus upload_status = 4;
inline bool CrashReportInfo::has_upload_status() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CrashReportInfo::clear_upload_status() {
upload_status_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::CrashReportInfo_CrashReportUploadStatus CrashReportInfo::upload_status() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.upload_status)
return static_cast< ::enterprise_management::CrashReportInfo_CrashReportUploadStatus >(upload_status_);
}
inline void CrashReportInfo::set_upload_status(::enterprise_management::CrashReportInfo_CrashReportUploadStatus value) {
assert(::enterprise_management::CrashReportInfo_CrashReportUploadStatus_IsValid(value));
_has_bits_[0] |= 0x00000008u;
upload_status_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.upload_status)
}

// -------------------------------------------------------------------

// TimezoneInfo

// optional string posix = 1;
inline bool TimezoneInfo::has_posix() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimezoneInfo::clear_posix() {
posix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TimezoneInfo::posix() const {
// @@protoc_insertion_point(field_get:enterprise_management.TimezoneInfo.posix)
return posix_.GetNoArena();
}
inline void TimezoneInfo::set_posix(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
posix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.TimezoneInfo.posix)
}
inline void TimezoneInfo::set_posix(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
posix_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.TimezoneInfo.posix)
}
inline void TimezoneInfo::set_posix(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
posix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.TimezoneInfo.posix)
}
inline void TimezoneInfo::set_posix(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
posix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.TimezoneInfo.posix)
}
inline std::string* TimezoneInfo::mutable_posix() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.TimezoneInfo.posix)
return posix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TimezoneInfo::release_posix() {
// @@protoc_insertion_point(field_release:enterprise_management.TimezoneInfo.posix)
if (!has_posix()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return posix_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TimezoneInfo::set_allocated_posix(std::string* posix) {
if (posix != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
posix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), posix);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.TimezoneInfo.posix)
}

// optional string region = 2;
inline bool TimezoneInfo::has_region() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimezoneInfo::clear_region() {
region_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TimezoneInfo::region() const {
// @@protoc_insertion_point(field_get:enterprise_management.TimezoneInfo.region)
return region_.GetNoArena();
}
inline void TimezoneInfo::set_region(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.TimezoneInfo.region)
}
inline void TimezoneInfo::set_region(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
region_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.TimezoneInfo.region)
}
inline void TimezoneInfo::set_region(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.TimezoneInfo.region)
}
inline void TimezoneInfo::set_region(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.TimezoneInfo.region)
}
inline std::string* TimezoneInfo::mutable_region() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.TimezoneInfo.region)
return region_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TimezoneInfo::release_region() {
// @@protoc_insertion_point(field_release:enterprise_management.TimezoneInfo.region)
if (!has_region()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return region_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TimezoneInfo::set_allocated_region(std::string* region) {
if (region != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
region_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.TimezoneInfo.region)
}

// -------------------------------------------------------------------

// MemoryInfo

// optional uint32 total_memory_kib = 1;
inline bool MemoryInfo::has_total_memory_kib() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemoryInfo::clear_total_memory_kib() {
total_memory_kib_ = 0u;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MemoryInfo::total_memory_kib() const {
// @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.total_memory_kib)
return total_memory_kib_;
}
inline void MemoryInfo::set_total_memory_kib(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000001u;
total_memory_kib_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.total_memory_kib)
}

// optional uint32 free_memory_kib = 2;
inline bool MemoryInfo::has_free_memory_kib() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryInfo::clear_free_memory_kib() {
free_memory_kib_ = 0u;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MemoryInfo::free_memory_kib() const {
// @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.free_memory_kib)
return free_memory_kib_;
}
inline void MemoryInfo::set_free_memory_kib(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000002u;
free_memory_kib_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.free_memory_kib)
}

// optional uint32 available_memory_kib = 3;
inline bool MemoryInfo::has_available_memory_kib() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemoryInfo::clear_available_memory_kib() {
available_memory_kib_ = 0u;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MemoryInfo::available_memory_kib() const {
// @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.available_memory_kib)
return available_memory_kib_;
}
inline void MemoryInfo::set_available_memory_kib(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000004u;
available_memory_kib_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.available_memory_kib)
}

// optional uint32 page_faults_since_last_boot = 4;
inline bool MemoryInfo::has_page_faults_since_last_boot() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemoryInfo::clear_page_faults_since_last_boot() {
page_faults_since_last_boot_ = 0u;
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MemoryInfo::page_faults_since_last_boot() const {
// @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.page_faults_since_last_boot)
return page_faults_since_last_boot_;
}
inline void MemoryInfo::set_page_faults_since_last_boot(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000008u;
page_faults_since_last_boot_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.page_faults_since_last_boot)
}

// -------------------------------------------------------------------

// BacklightInfo

// optional string path = 1;
inline bool BacklightInfo::has_path() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacklightInfo::clear_path() {
path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BacklightInfo::path() const {
// @@protoc_insertion_point(field_get:enterprise_management.BacklightInfo.path)
return path_.GetNoArena();
}
inline void BacklightInfo::set_path(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BacklightInfo.path)
}
inline void BacklightInfo::set_path(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
path_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BacklightInfo.path)
}
inline void BacklightInfo::set_path(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BacklightInfo.path)
}
inline void BacklightInfo::set_path(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BacklightInfo.path)
}
inline std::string* BacklightInfo::mutable_path() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BacklightInfo.path)
return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BacklightInfo::release_path() {
// @@protoc_insertion_point(field_release:enterprise_management.BacklightInfo.path)
if (!has_path()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BacklightInfo::set_allocated_path(std::string* path) {
if (path != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BacklightInfo.path)
}

// optional uint32 max_brightness = 2;
inline bool BacklightInfo::has_max_brightness() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BacklightInfo::clear_max_brightness() {
max_brightness_ = 0u;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BacklightInfo::max_brightness() const {
// @@protoc_insertion_point(field_get:enterprise_management.BacklightInfo.max_brightness)
return max_brightness_;
}
inline void BacklightInfo::set_max_brightness(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000002u;
max_brightness_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BacklightInfo.max_brightness)
}

// optional uint32 brightness = 3;
inline bool BacklightInfo::has_brightness() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BacklightInfo::clear_brightness() {
brightness_ = 0u;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BacklightInfo::brightness() const {
// @@protoc_insertion_point(field_get:enterprise_management.BacklightInfo.brightness)
return brightness_;
}
inline void BacklightInfo::set_brightness(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000004u;
brightness_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BacklightInfo.brightness)
}

// -------------------------------------------------------------------

// FanInfo

// optional uint32 speed_rpm = 1;
inline bool FanInfo::has_speed_rpm() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FanInfo::clear_speed_rpm() {
speed_rpm_ = 0u;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FanInfo::speed_rpm() const {
// @@protoc_insertion_point(field_get:enterprise_management.FanInfo.speed_rpm)
return speed_rpm_;
}
inline void FanInfo::set_speed_rpm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000001u;
speed_rpm_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.FanInfo.speed_rpm)
}

// -------------------------------------------------------------------

// BluetoothAdapterInfo

// optional string name = 1;
inline bool BluetoothAdapterInfo::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BluetoothAdapterInfo::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothAdapterInfo::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.name)
return name_.GetNoArena();
}
inline void BluetoothAdapterInfo::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.name)
}
inline void BluetoothAdapterInfo::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BluetoothAdapterInfo.name)
}
inline void BluetoothAdapterInfo::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BluetoothAdapterInfo.name)
}
inline void BluetoothAdapterInfo::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BluetoothAdapterInfo.name)
}
inline std::string* BluetoothAdapterInfo::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BluetoothAdapterInfo.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BluetoothAdapterInfo::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.BluetoothAdapterInfo.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BluetoothAdapterInfo::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BluetoothAdapterInfo.name)
}

// optional string address = 2;
inline bool BluetoothAdapterInfo::has_address() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BluetoothAdapterInfo::clear_address() {
address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BluetoothAdapterInfo::address() const {
// @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.address)
return address_.GetNoArena();
}
inline void BluetoothAdapterInfo::set_address(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.address)
}
inline void BluetoothAdapterInfo::set_address(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
address_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BluetoothAdapterInfo.address)
}
inline void BluetoothAdapterInfo::set_address(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BluetoothAdapterInfo.address)
}
inline void BluetoothAdapterInfo::set_address(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BluetoothAdapterInfo.address)
}
inline std::string* BluetoothAdapterInfo::mutable_address() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BluetoothAdapterInfo.address)
return address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BluetoothAdapterInfo::release_address() {
// @@protoc_insertion_point(field_release:enterprise_management.BluetoothAdapterInfo.address)
if (!has_address()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BluetoothAdapterInfo::set_allocated_address(std::string* address) {
if (address != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BluetoothAdapterInfo.address)
}

// optional bool powered = 3;
inline bool BluetoothAdapterInfo::has_powered() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BluetoothAdapterInfo::clear_powered() {
powered_ = false;
_has_bits_[0] &= ~0x00000004u;
}
inline bool BluetoothAdapterInfo::powered() const {
// @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.powered)
return powered_;
}
inline void BluetoothAdapterInfo::set_powered(bool value) {
_has_bits_[0] |= 0x00000004u;
powered_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.powered)
}

// optional uint32 num_connected_devices = 4;
inline bool BluetoothAdapterInfo::has_num_connected_devices() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BluetoothAdapterInfo::clear_num_connected_devices() {
num_connected_devices_ = 0u;
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BluetoothAdapterInfo::num_connected_devices() const {
// @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.num_connected_devices)
return num_connected_devices_;
}
inline void BluetoothAdapterInfo::set_num_connected_devices(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000008u;
num_connected_devices_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.num_connected_devices)
}

// -------------------------------------------------------------------

// DeviceStatusReportRequest

// optional string os_version = 1;
inline bool DeviceStatusReportRequest::has_os_version() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStatusReportRequest::clear_os_version() {
os_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStatusReportRequest::os_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.os_version)
return os_version_.GetNoArena();
}
inline void DeviceStatusReportRequest::set_os_version(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline void DeviceStatusReportRequest::set_os_version(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
os_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline void DeviceStatusReportRequest::set_os_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline void DeviceStatusReportRequest::set_os_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline std::string* DeviceStatusReportRequest::mutable_os_version() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.os_version)
return os_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceStatusReportRequest::release_os_version() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.os_version)
if (!has_os_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return os_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_os_version(std::string* os_version) {
if (os_version != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
os_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.os_version)
}

// optional string firmware_version = 2;
inline bool DeviceStatusReportRequest::has_firmware_version() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStatusReportRequest::clear_firmware_version() {
firmware_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceStatusReportRequest::firmware_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.firmware_version)
return firmware_version_.GetNoArena();
}
inline void DeviceStatusReportRequest::set_firmware_version(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
firmware_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline void DeviceStatusReportRequest::set_firmware_version(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
firmware_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline void DeviceStatusReportRequest::set_firmware_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
firmware_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline void DeviceStatusReportRequest::set_firmware_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
firmware_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline std::string* DeviceStatusReportRequest::mutable_firmware_version() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.firmware_version)
return firmware_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceStatusReportRequest::release_firmware_version() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.firmware_version)
if (!has_firmware_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return firmware_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_firmware_version(std::string* firmware_version) {
if (firmware_version != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
firmware_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), firmware_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.firmware_version)
}

// optional string boot_mode = 3;
inline bool DeviceStatusReportRequest::has_boot_mode() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceStatusReportRequest::clear_boot_mode() {
boot_mode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceStatusReportRequest::boot_mode() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.boot_mode)
return boot_mode_.GetNoArena();
}
inline void DeviceStatusReportRequest::set_boot_mode(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
boot_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline void DeviceStatusReportRequest::set_boot_mode(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
boot_mode_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline void DeviceStatusReportRequest::set_boot_mode(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
boot_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline void DeviceStatusReportRequest::set_boot_mode(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
boot_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline std::string* DeviceStatusReportRequest::mutable_boot_mode() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.boot_mode)
return boot_mode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceStatusReportRequest::release_boot_mode() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.boot_mode)
if (!has_boot_mode()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return boot_mode_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_boot_mode(std::string* boot_mode) {
if (boot_mode != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
boot_mode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), boot_mode);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.boot_mode)
}

// optional string browser_version = 5;
inline bool DeviceStatusReportRequest::has_browser_version() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceStatusReportRequest::clear_browser_version() {
browser_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceStatusReportRequest::browser_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.browser_version)
return browser_version_.GetNoArena();
}
inline void DeviceStatusReportRequest::set_browser_version(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline void DeviceStatusReportRequest::set_browser_version(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
browser_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline void DeviceStatusReportRequest::set_browser_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline void DeviceStatusReportRequest::set_browser_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline std::string* DeviceStatusReportRequest::mutable_browser_version() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.browser_version)
return browser_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceStatusReportRequest::release_browser_version() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.browser_version)
if (!has_browser_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return browser_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_browser_version(std::string* browser_version) {
if (browser_version != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
browser_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), browser_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.browser_version)
}

// repeated .enterprise_management.ActiveTimePeriod active_periods = 6;
inline int DeviceStatusReportRequest::active_periods_size() const {
return active_periods_.size();
}
inline void DeviceStatusReportRequest::clear_active_periods() {
active_periods_.Clear();
}
inline ::enterprise_management::ActiveTimePeriod* DeviceStatusReportRequest::mutable_active_periods(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.active_periods)
return active_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >*
DeviceStatusReportRequest::mutable_active_periods() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.active_periods)
return &active_periods_;
}
inline const ::enterprise_management::ActiveTimePeriod& DeviceStatusReportRequest::active_periods(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.active_periods)
return active_periods_.Get(index);
}
inline ::enterprise_management::ActiveTimePeriod* DeviceStatusReportRequest::add_active_periods() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.active_periods)
return active_periods_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >&
DeviceStatusReportRequest::active_periods() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.active_periods)
return active_periods_;
}

// repeated .enterprise_management.NetworkInterface network_interfaces = 8;
inline int DeviceStatusReportRequest::network_interfaces_size() const {
return network_interfaces_.size();
}
inline void DeviceStatusReportRequest::clear_network_interfaces() {
network_interfaces_.Clear();
}
inline ::enterprise_management::NetworkInterface* DeviceStatusReportRequest::mutable_network_interfaces(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.network_interfaces)
return network_interfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >*
DeviceStatusReportRequest::mutable_network_interfaces() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.network_interfaces)
return &network_interfaces_;
}
inline const ::enterprise_management::NetworkInterface& DeviceStatusReportRequest::network_interfaces(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.network_interfaces)
return network_interfaces_.Get(index);
}
inline ::enterprise_management::NetworkInterface* DeviceStatusReportRequest::add_network_interfaces() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.network_interfaces)
return network_interfaces_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >&
DeviceStatusReportRequest::network_interfaces() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.network_interfaces)
return network_interfaces_;
}

// repeated .enterprise_management.DeviceUser users = 9;
inline int DeviceStatusReportRequest::users_size() const {
return users_.size();
}
inline void DeviceStatusReportRequest::clear_users() {
users_.Clear();
}
inline ::enterprise_management::DeviceUser* DeviceStatusReportRequest::mutable_users(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.users)
return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >*
DeviceStatusReportRequest::mutable_users() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.users)
return &users_;
}
inline const ::enterprise_management::DeviceUser& DeviceStatusReportRequest::users(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.users)
return users_.Get(index);
}
inline ::enterprise_management::DeviceUser* DeviceStatusReportRequest::add_users() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.users)
return users_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >&
DeviceStatusReportRequest::users() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.users)
return users_;
}

// repeated .enterprise_management.VolumeInfo volume_infos = 10;
inline int DeviceStatusReportRequest::volume_infos_size() const {
return volume_infos_.size();
}
inline void DeviceStatusReportRequest::clear_volume_infos() {
volume_infos_.Clear();
}
inline ::enterprise_management::VolumeInfo* DeviceStatusReportRequest::mutable_volume_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.volume_infos)
return volume_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
DeviceStatusReportRequest::mutable_volume_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.volume_infos)
return &volume_infos_;
}
inline const ::enterprise_management::VolumeInfo& DeviceStatusReportRequest::volume_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.volume_infos)
return volume_infos_.Get(index);
}
inline ::enterprise_management::VolumeInfo* DeviceStatusReportRequest::add_volume_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.volume_infos)
return volume_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
DeviceStatusReportRequest::volume_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.volume_infos)
return volume_infos_;
}

// repeated .enterprise_management.NetworkState network_states = 11;
inline int DeviceStatusReportRequest::network_states_size() const {
return network_states_.size();
}
inline void DeviceStatusReportRequest::clear_network_states() {
network_states_.Clear();
}
inline ::enterprise_management::NetworkState* DeviceStatusReportRequest::mutable_network_states(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.network_states)
return network_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >*
DeviceStatusReportRequest::mutable_network_states() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.network_states)
return &network_states_;
}
inline const ::enterprise_management::NetworkState& DeviceStatusReportRequest::network_states(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.network_states)
return network_states_.Get(index);
}
inline ::enterprise_management::NetworkState* DeviceStatusReportRequest::add_network_states() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.network_states)
return network_states_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >&
DeviceStatusReportRequest::network_states() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.network_states)
return network_states_;
}

// repeated int32 cpu_utilization_pct_samples = 12;
inline int DeviceStatusReportRequest::cpu_utilization_pct_samples_size() const {
return cpu_utilization_pct_samples_.size();
}
inline void DeviceStatusReportRequest::clear_cpu_utilization_pct_samples() {
cpu_utilization_pct_samples_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceStatusReportRequest::cpu_utilization_pct_samples(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
return cpu_utilization_pct_samples_.Get(index);
}
inline void DeviceStatusReportRequest::set_cpu_utilization_pct_samples(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
cpu_utilization_pct_samples_.Set(index, value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
}
inline void DeviceStatusReportRequest::add_cpu_utilization_pct_samples(::PROTOBUF_NAMESPACE_ID::int32 value) {
cpu_utilization_pct_samples_.Add(value);
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DeviceStatusReportRequest::cpu_utilization_pct_samples() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
return cpu_utilization_pct_samples_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DeviceStatusReportRequest::mutable_cpu_utilization_pct_samples() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
return &cpu_utilization_pct_samples_;
}

// optional int64 system_ram_total = 14;
inline bool DeviceStatusReportRequest::has_system_ram_total() const {
return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceStatusReportRequest::clear_system_ram_total() {
system_ram_total_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeviceStatusReportRequest::system_ram_total() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_total)
return system_ram_total_;
}
inline void DeviceStatusReportRequest::set_system_ram_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00020000u;
system_ram_total_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.system_ram_total)
}

// repeated int64 system_ram_free_samples = 15;
inline int DeviceStatusReportRequest::system_ram_free_samples_size() const {
return system_ram_free_samples_.size();
}
inline void DeviceStatusReportRequest::clear_system_ram_free_samples() {
system_ram_free_samples_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeviceStatusReportRequest::system_ram_free_samples(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
return system_ram_free_samples_.Get(index);
}
inline void DeviceStatusReportRequest::set_system_ram_free_samples(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
system_ram_free_samples_.Set(index, value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
}
inline void DeviceStatusReportRequest::add_system_ram_free_samples(::PROTOBUF_NAMESPACE_ID::int64 value) {
system_ram_free_samples_.Add(value);
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
DeviceStatusReportRequest::system_ram_free_samples() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
return system_ram_free_samples_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
DeviceStatusReportRequest::mutable_system_ram_free_samples() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
return &system_ram_free_samples_;
}

// repeated .enterprise_management.CPUTempInfo cpu_temp_infos = 16;
inline int DeviceStatusReportRequest::cpu_temp_infos_size() const {
return cpu_temp_infos_.size();
}
inline void DeviceStatusReportRequest::clear_cpu_temp_infos() {
cpu_temp_infos_.Clear();
}
inline ::enterprise_management::CPUTempInfo* DeviceStatusReportRequest::mutable_cpu_temp_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
return cpu_temp_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >*
DeviceStatusReportRequest::mutable_cpu_temp_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
return &cpu_temp_infos_;
}
inline const ::enterprise_management::CPUTempInfo& DeviceStatusReportRequest::cpu_temp_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
return cpu_temp_infos_.Get(index);
}
inline ::enterprise_management::CPUTempInfo* DeviceStatusReportRequest::add_cpu_temp_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
return cpu_temp_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >&
DeviceStatusReportRequest::cpu_temp_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
return cpu_temp_infos_;
}

// optional .enterprise_management.OsUpdateStatus os_update_status = 17;
inline bool DeviceStatusReportRequest::has_os_update_status() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceStatusReportRequest::clear_os_update_status() {
if (os_update_status_ != nullptr) os_update_status_->Clear();
_has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::OsUpdateStatus& DeviceStatusReportRequest::os_update_status() const {
const ::enterprise_management::OsUpdateStatus* p = os_update_status_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.os_update_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::OsUpdateStatus*>(
&::enterprise_management::_OsUpdateStatus_default_instance_);
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::release_os_update_status() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.os_update_status)
_has_bits_[0] &= ~0x00000010u;
::enterprise_management::OsUpdateStatus* temp = os_update_status_;
os_update_status_ = nullptr;
return temp;
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::mutable_os_update_status() {
_has_bits_[0] |= 0x00000010u;
if (os_update_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::OsUpdateStatus>(GetArenaNoVirtual());
os_update_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.os_update_status)
return os_update_status_;
}
inline void DeviceStatusReportRequest::set_allocated_os_update_status(::enterprise_management::OsUpdateStatus* os_update_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete os_update_status_;
}
if (os_update_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
os_update_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, os_update_status, submessage_arena);
}
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
os_update_status_ = os_update_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.os_update_status)
}

// optional .enterprise_management.AppStatus running_kiosk_app = 18;
inline bool DeviceStatusReportRequest::has_running_kiosk_app() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceStatusReportRequest::clear_running_kiosk_app() {
if (running_kiosk_app_ != nullptr) running_kiosk_app_->Clear();
_has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::AppStatus& DeviceStatusReportRequest::running_kiosk_app() const {
const ::enterprise_management::AppStatus* p = running_kiosk_app_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::AppStatus*>(
&::enterprise_management::_AppStatus_default_instance_);
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::release_running_kiosk_app() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
_has_bits_[0] &= ~0x00000020u;
::enterprise_management::AppStatus* temp = running_kiosk_app_;
running_kiosk_app_ = nullptr;
return temp;
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::mutable_running_kiosk_app() {
_has_bits_[0] |= 0x00000020u;
if (running_kiosk_app_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::AppStatus>(GetArenaNoVirtual());
running_kiosk_app_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
return running_kiosk_app_;
}
inline void DeviceStatusReportRequest::set_allocated_running_kiosk_app(::enterprise_management::AppStatus* running_kiosk_app) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete running_kiosk_app_;
}
if (running_kiosk_app) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
running_kiosk_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, running_kiosk_app, submessage_arena);
}
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
running_kiosk_app_ = running_kiosk_app;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
}

// optional int32 sound_volume = 19;
inline bool DeviceStatusReportRequest::has_sound_volume() const {
return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DeviceStatusReportRequest::clear_sound_volume() {
sound_volume_ = 0;
_has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceStatusReportRequest::sound_volume() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.sound_volume)
return sound_volume_;
}
inline void DeviceStatusReportRequest::set_sound_volume(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00040000u;
sound_volume_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.sound_volume)
}

// optional .enterprise_management.TpmVersionInfo tpm_version_info = 21;
inline bool DeviceStatusReportRequest::has_tpm_version_info() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceStatusReportRequest::clear_tpm_version_info() {
if (tpm_version_info_ != nullptr) tpm_version_info_->Clear();
_has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::TpmVersionInfo& DeviceStatusReportRequest::tpm_version_info() const {
const ::enterprise_management::TpmVersionInfo* p = tpm_version_info_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::TpmVersionInfo*>(
&::enterprise_management::_TpmVersionInfo_default_instance_);
}
inline ::enterprise_management::TpmVersionInfo* DeviceStatusReportRequest::release_tpm_version_info() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
_has_bits_[0] &= ~0x00000040u;
::enterprise_management::TpmVersionInfo* temp = tpm_version_info_;
tpm_version_info_ = nullptr;
return temp;
}
inline ::enterprise_management::TpmVersionInfo* DeviceStatusReportRequest::mutable_tpm_version_info() {
_has_bits_[0] |= 0x00000040u;
if (tpm_version_info_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::TpmVersionInfo>(GetArenaNoVirtual());
tpm_version_info_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
return tpm_version_info_;
}
inline void DeviceStatusReportRequest::set_allocated_tpm_version_info(::enterprise_management::TpmVersionInfo* tpm_version_info) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete tpm_version_info_;
}
if (tpm_version_info) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
tpm_version_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, tpm_version_info, submessage_arena);
}
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
tpm_version_info_ = tpm_version_info;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
}

// optional .enterprise_management.Channel channel = 22;
inline bool DeviceStatusReportRequest::has_channel() const {
return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DeviceStatusReportRequest::clear_channel() {
channel_ = 0;
_has_bits_[0] &= ~0x00080000u;
}
inline ::enterprise_management::Channel DeviceStatusReportRequest::channel() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.channel)
return static_cast< ::enterprise_management::Channel >(channel_);
}
inline void DeviceStatusReportRequest::set_channel(::enterprise_management::Channel value) {
assert(::enterprise_management::Channel_IsValid(value));
_has_bits_[0] |= 0x00080000u;
channel_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.channel)
}

// optional .enterprise_management.TpmStatusInfo tpm_status_info = 23;
inline bool DeviceStatusReportRequest::has_tpm_status_info() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceStatusReportRequest::clear_tpm_status_info() {
if (tpm_status_info_ != nullptr) tpm_status_info_->Clear();
_has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::TpmStatusInfo& DeviceStatusReportRequest::tpm_status_info() const {
const ::enterprise_management::TpmStatusInfo* p = tpm_status_info_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::TpmStatusInfo*>(
&::enterprise_management::_TpmStatusInfo_default_instance_);
}
inline ::enterprise_management::TpmStatusInfo* DeviceStatusReportRequest::release_tpm_status_info() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
_has_bits_[0] &= ~0x00000080u;
::enterprise_management::TpmStatusInfo* temp = tpm_status_info_;
tpm_status_info_ = nullptr;
return temp;
}
inline ::enterprise_management::TpmStatusInfo* DeviceStatusReportRequest::mutable_tpm_status_info() {
_has_bits_[0] |= 0x00000080u;
if (tpm_status_info_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::TpmStatusInfo>(GetArenaNoVirtual());
tpm_status_info_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
return tpm_status_info_;
}
inline void DeviceStatusReportRequest::set_allocated_tpm_status_info(::enterprise_management::TpmStatusInfo* tpm_status_info) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete tpm_status_info_;
}
if (tpm_status_info) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
tpm_status_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, tpm_status_info, submessage_arena);
}
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
tpm_status_info_ = tpm_status_info;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
}

// optional bool write_protect_switch = 24;
inline bool DeviceStatusReportRequest::has_write_protect_switch() const {
return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DeviceStatusReportRequest::clear_write_protect_switch() {
write_protect_switch_ = false;
_has_bits_[0] &= ~0x00100000u;
}
inline bool DeviceStatusReportRequest::write_protect_switch() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.write_protect_switch)
return write_protect_switch_;
}
inline void DeviceStatusReportRequest::set_write_protect_switch(bool value) {
_has_bits_[0] |= 0x00100000u;
write_protect_switch_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.write_protect_switch)
}

// optional .enterprise_management.PowerStatus power_status = 25;
inline bool DeviceStatusReportRequest::has_power_status() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceStatusReportRequest::clear_power_status() {
if (power_status_ != nullptr) power_status_->Clear();
_has_bits_[0] &= ~0x00000100u;
}
inline const ::enterprise_management::PowerStatus& DeviceStatusReportRequest::power_status() const {
const ::enterprise_management::PowerStatus* p = power_status_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.power_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::PowerStatus*>(
&::enterprise_management::_PowerStatus_default_instance_);
}
inline ::enterprise_management::PowerStatus* DeviceStatusReportRequest::release_power_status() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.power_status)
_has_bits_[0] &= ~0x00000100u;
::enterprise_management::PowerStatus* temp = power_status_;
power_status_ = nullptr;
return temp;
}
inline ::enterprise_management::PowerStatus* DeviceStatusReportRequest::mutable_power_status() {
_has_bits_[0] |= 0x00000100u;
if (power_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::PowerStatus>(GetArenaNoVirtual());
power_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.power_status)
return power_status_;
}
inline void DeviceStatusReportRequest::set_allocated_power_status(::enterprise_management::PowerStatus* power_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete power_status_;
}
if (power_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
power_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, power_status, submessage_arena);
}
_has_bits_[0] |= 0x00000100u;
} else {
_has_bits_[0] &= ~0x00000100u;
}
power_status_ = power_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.power_status)
}

// optional .enterprise_management.StorageStatus storage_status = 26;
inline bool DeviceStatusReportRequest::has_storage_status() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceStatusReportRequest::clear_storage_status() {
if (storage_status_ != nullptr) storage_status_->Clear();
_has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::StorageStatus& DeviceStatusReportRequest::storage_status() const {
const ::enterprise_management::StorageStatus* p = storage_status_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.storage_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::StorageStatus*>(
&::enterprise_management::_StorageStatus_default_instance_);
}
inline ::enterprise_management::StorageStatus* DeviceStatusReportRequest::release_storage_status() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.storage_status)
_has_bits_[0] &= ~0x00000200u;
::enterprise_management::StorageStatus* temp = storage_status_;
storage_status_ = nullptr;
return temp;
}
inline ::enterprise_management::StorageStatus* DeviceStatusReportRequest::mutable_storage_status() {
_has_bits_[0] |= 0x00000200u;
if (storage_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::StorageStatus>(GetArenaNoVirtual());
storage_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.storage_status)
return storage_status_;
}
inline void DeviceStatusReportRequest::set_allocated_storage_status(::enterprise_management::StorageStatus* storage_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete storage_status_;
}
if (storage_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
storage_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, storage_status, submessage_arena);
}
_has_bits_[0] |= 0x00000200u;
} else {
_has_bits_[0] &= ~0x00000200u;
}
storage_status_ = storage_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.storage_status)
}

// optional .enterprise_management.BoardStatus board_status = 27;
inline bool DeviceStatusReportRequest::has_board_status() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceStatusReportRequest::clear_board_status() {
if (board_status_ != nullptr) board_status_->Clear();
_has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::BoardStatus& DeviceStatusReportRequest::board_status() const {
const ::enterprise_management::BoardStatus* p = board_status_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.board_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::BoardStatus*>(
&::enterprise_management::_BoardStatus_default_instance_);
}
inline ::enterprise_management::BoardStatus* DeviceStatusReportRequest::release_board_status() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.board_status)
_has_bits_[0] &= ~0x00000400u;
::enterprise_management::BoardStatus* temp = board_status_;
board_status_ = nullptr;
return temp;
}
inline ::enterprise_management::BoardStatus* DeviceStatusReportRequest::mutable_board_status() {
_has_bits_[0] |= 0x00000400u;
if (board_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::BoardStatus>(GetArenaNoVirtual());
board_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.board_status)
return board_status_;
}
inline void DeviceStatusReportRequest::set_allocated_board_status(::enterprise_management::BoardStatus* board_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete board_status_;
}
if (board_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
board_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, board_status, submessage_arena);
}
_has_bits_[0] |= 0x00000400u;
} else {
_has_bits_[0] &= ~0x00000400u;
}
board_status_ = board_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.board_status)
}

// optional .enterprise_management.SystemStatus system_status = 28;
inline bool DeviceStatusReportRequest::has_system_status() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceStatusReportRequest::clear_system_status() {
if (system_status_ != nullptr) system_status_->Clear();
_has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::SystemStatus& DeviceStatusReportRequest::system_status() const {
const ::enterprise_management::SystemStatus* p = system_status_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::SystemStatus*>(
&::enterprise_management::_SystemStatus_default_instance_);
}
inline ::enterprise_management::SystemStatus* DeviceStatusReportRequest::release_system_status() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.system_status)
_has_bits_[0] &= ~0x00000800u;
::enterprise_management::SystemStatus* temp = system_status_;
system_status_ = nullptr;
return temp;
}
inline ::enterprise_management::SystemStatus* DeviceStatusReportRequest::mutable_system_status() {
_has_bits_[0] |= 0x00000800u;
if (system_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::SystemStatus>(GetArenaNoVirtual());
system_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.system_status)
return system_status_;
}
inline void DeviceStatusReportRequest::set_allocated_system_status(::enterprise_management::SystemStatus* system_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete system_status_;
}
if (system_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
system_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, system_status, submessage_arena);
}
_has_bits_[0] |= 0x00000800u;
} else {
_has_bits_[0] &= ~0x00000800u;
}
system_status_ = system_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.system_status)
}

// optional .enterprise_management.StatefulPartitionInfo stateful_partition_info = 29;
inline bool DeviceStatusReportRequest::has_stateful_partition_info() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceStatusReportRequest::clear_stateful_partition_info() {
if (stateful_partition_info_ != nullptr) stateful_partition_info_->Clear();
_has_bits_[0] &= ~0x00001000u;
}
inline const ::enterprise_management::StatefulPartitionInfo& DeviceStatusReportRequest::stateful_partition_info() const {
const ::enterprise_management::StatefulPartitionInfo* p = stateful_partition_info_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::StatefulPartitionInfo*>(
&::enterprise_management::_StatefulPartitionInfo_default_instance_);
}
inline ::enterprise_management::StatefulPartitionInfo* DeviceStatusReportRequest::release_stateful_partition_info() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
_has_bits_[0] &= ~0x00001000u;
::enterprise_management::StatefulPartitionInfo* temp = stateful_partition_info_;
stateful_partition_info_ = nullptr;
return temp;
}
inline ::enterprise_management::StatefulPartitionInfo* DeviceStatusReportRequest::mutable_stateful_partition_info() {
_has_bits_[0] |= 0x00001000u;
if (stateful_partition_info_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::StatefulPartitionInfo>(GetArenaNoVirtual());
stateful_partition_info_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
return stateful_partition_info_;
}
inline void DeviceStatusReportRequest::set_allocated_stateful_partition_info(::enterprise_management::StatefulPartitionInfo* stateful_partition_info) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete stateful_partition_info_;
}
if (stateful_partition_info) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
stateful_partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, stateful_partition_info, submessage_arena);
}
_has_bits_[0] |= 0x00001000u;
} else {
_has_bits_[0] &= ~0x00001000u;
}
stateful_partition_info_ = stateful_partition_info;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
}

// repeated .enterprise_management.CpuUtilizationInfo cpu_utilization_infos = 30;
inline int DeviceStatusReportRequest::cpu_utilization_infos_size() const {
return cpu_utilization_infos_.size();
}
inline void DeviceStatusReportRequest::clear_cpu_utilization_infos() {
cpu_utilization_infos_.Clear();
}
inline ::enterprise_management::CpuUtilizationInfo* DeviceStatusReportRequest::mutable_cpu_utilization_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
return cpu_utilization_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >*
DeviceStatusReportRequest::mutable_cpu_utilization_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
return &cpu_utilization_infos_;
}
inline const ::enterprise_management::CpuUtilizationInfo& DeviceStatusReportRequest::cpu_utilization_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
return cpu_utilization_infos_.Get(index);
}
inline ::enterprise_management::CpuUtilizationInfo* DeviceStatusReportRequest::add_cpu_utilization_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
return cpu_utilization_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >&
DeviceStatusReportRequest::cpu_utilization_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
return cpu_utilization_infos_;
}

// repeated .enterprise_management.SystemFreeRamInfo system_ram_free_infos = 31;
inline int DeviceStatusReportRequest::system_ram_free_infos_size() const {
return system_ram_free_infos_.size();
}
inline void DeviceStatusReportRequest::clear_system_ram_free_infos() {
system_ram_free_infos_.Clear();
}
inline ::enterprise_management::SystemFreeRamInfo* DeviceStatusReportRequest::mutable_system_ram_free_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
return system_ram_free_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >*
DeviceStatusReportRequest::mutable_system_ram_free_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
return &system_ram_free_infos_;
}
inline const ::enterprise_management::SystemFreeRamInfo& DeviceStatusReportRequest::system_ram_free_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
return system_ram_free_infos_.Get(index);
}
inline ::enterprise_management::SystemFreeRamInfo* DeviceStatusReportRequest::add_system_ram_free_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
return system_ram_free_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >&
DeviceStatusReportRequest::system_ram_free_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
return system_ram_free_infos_;
}

// repeated .enterprise_management.CpuInfo cpu_info = 32;
inline int DeviceStatusReportRequest::cpu_info_size() const {
return cpu_info_.size();
}
inline void DeviceStatusReportRequest::clear_cpu_info() {
cpu_info_.Clear();
}
inline ::enterprise_management::CpuInfo* DeviceStatusReportRequest::mutable_cpu_info(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.cpu_info)
return cpu_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >*
DeviceStatusReportRequest::mutable_cpu_info() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_info)
return &cpu_info_;
}
inline const ::enterprise_management::CpuInfo& DeviceStatusReportRequest::cpu_info(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_info)
return cpu_info_.Get(index);
}
inline ::enterprise_management::CpuInfo* DeviceStatusReportRequest::add_cpu_info() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_info)
return cpu_info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >&
DeviceStatusReportRequest::cpu_info() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_info)
return cpu_info_;
}

// optional .enterprise_management.GraphicsStatus graphics_status = 33;
inline bool DeviceStatusReportRequest::has_graphics_status() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceStatusReportRequest::clear_graphics_status() {
if (graphics_status_ != nullptr) graphics_status_->Clear();
_has_bits_[0] &= ~0x00002000u;
}
inline const ::enterprise_management::GraphicsStatus& DeviceStatusReportRequest::graphics_status() const {
const ::enterprise_management::GraphicsStatus* p = graphics_status_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.graphics_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::GraphicsStatus*>(
&::enterprise_management::_GraphicsStatus_default_instance_);
}
inline ::enterprise_management::GraphicsStatus* DeviceStatusReportRequest::release_graphics_status() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.graphics_status)
_has_bits_[0] &= ~0x00002000u;
::enterprise_management::GraphicsStatus* temp = graphics_status_;
graphics_status_ = nullptr;
return temp;
}
inline ::enterprise_management::GraphicsStatus* DeviceStatusReportRequest::mutable_graphics_status() {
_has_bits_[0] |= 0x00002000u;
if (graphics_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::GraphicsStatus>(GetArenaNoVirtual());
graphics_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.graphics_status)
return graphics_status_;
}
inline void DeviceStatusReportRequest::set_allocated_graphics_status(::enterprise_management::GraphicsStatus* graphics_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete graphics_status_;
}
if (graphics_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
graphics_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, graphics_status, submessage_arena);
}
_has_bits_[0] |= 0x00002000u;
} else {
_has_bits_[0] &= ~0x00002000u;
}
graphics_status_ = graphics_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.graphics_status)
}

// repeated .enterprise_management.CrashReportInfo crash_report_infos = 34;
inline int DeviceStatusReportRequest::crash_report_infos_size() const {
return crash_report_infos_.size();
}
inline void DeviceStatusReportRequest::clear_crash_report_infos() {
crash_report_infos_.Clear();
}
inline ::enterprise_management::CrashReportInfo* DeviceStatusReportRequest::mutable_crash_report_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
return crash_report_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >*
DeviceStatusReportRequest::mutable_crash_report_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
return &crash_report_infos_;
}
inline const ::enterprise_management::CrashReportInfo& DeviceStatusReportRequest::crash_report_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
return crash_report_infos_.Get(index);
}
inline ::enterprise_management::CrashReportInfo* DeviceStatusReportRequest::add_crash_report_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
return crash_report_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >&
DeviceStatusReportRequest::crash_report_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
return crash_report_infos_;
}

// optional .enterprise_management.TimezoneInfo timezone_info = 35;
inline bool DeviceStatusReportRequest::has_timezone_info() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceStatusReportRequest::clear_timezone_info() {
if (timezone_info_ != nullptr) timezone_info_->Clear();
_has_bits_[0] &= ~0x00004000u;
}
inline const ::enterprise_management::TimezoneInfo& DeviceStatusReportRequest::timezone_info() const {
const ::enterprise_management::TimezoneInfo* p = timezone_info_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.timezone_info)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::TimezoneInfo*>(
&::enterprise_management::_TimezoneInfo_default_instance_);
}
inline ::enterprise_management::TimezoneInfo* DeviceStatusReportRequest::release_timezone_info() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.timezone_info)
_has_bits_[0] &= ~0x00004000u;
::enterprise_management::TimezoneInfo* temp = timezone_info_;
timezone_info_ = nullptr;
return temp;
}
inline ::enterprise_management::TimezoneInfo* DeviceStatusReportRequest::mutable_timezone_info() {
_has_bits_[0] |= 0x00004000u;
if (timezone_info_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::TimezoneInfo>(GetArenaNoVirtual());
timezone_info_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.timezone_info)
return timezone_info_;
}
inline void DeviceStatusReportRequest::set_allocated_timezone_info(::enterprise_management::TimezoneInfo* timezone_info) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete timezone_info_;
}
if (timezone_info) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
timezone_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, timezone_info, submessage_arena);
}
_has_bits_[0] |= 0x00004000u;
} else {
_has_bits_[0] &= ~0x00004000u;
}
timezone_info_ = timezone_info;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.timezone_info)
}

// optional .enterprise_management.MemoryInfo memory_info = 36;
inline bool DeviceStatusReportRequest::has_memory_info() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceStatusReportRequest::clear_memory_info() {
if (memory_info_ != nullptr) memory_info_->Clear();
_has_bits_[0] &= ~0x00008000u;
}
inline const ::enterprise_management::MemoryInfo& DeviceStatusReportRequest::memory_info() const {
const ::enterprise_management::MemoryInfo* p = memory_info_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.memory_info)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::MemoryInfo*>(
&::enterprise_management::_MemoryInfo_default_instance_);
}
inline ::enterprise_management::MemoryInfo* DeviceStatusReportRequest::release_memory_info() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.memory_info)
_has_bits_[0] &= ~0x00008000u;
::enterprise_management::MemoryInfo* temp = memory_info_;
memory_info_ = nullptr;
return temp;
}
inline ::enterprise_management::MemoryInfo* DeviceStatusReportRequest::mutable_memory_info() {
_has_bits_[0] |= 0x00008000u;
if (memory_info_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::MemoryInfo>(GetArenaNoVirtual());
memory_info_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.memory_info)
return memory_info_;
}
inline void DeviceStatusReportRequest::set_allocated_memory_info(::enterprise_management::MemoryInfo* memory_info) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete memory_info_;
}
if (memory_info) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
memory_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, memory_info, submessage_arena);
}
_has_bits_[0] |= 0x00008000u;
} else {
_has_bits_[0] &= ~0x00008000u;
}
memory_info_ = memory_info;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.memory_info)
}

// repeated .enterprise_management.BacklightInfo backlight_info = 37;
inline int DeviceStatusReportRequest::backlight_info_size() const {
return backlight_info_.size();
}
inline void DeviceStatusReportRequest::clear_backlight_info() {
backlight_info_.Clear();
}
inline ::enterprise_management::BacklightInfo* DeviceStatusReportRequest::mutable_backlight_info(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.backlight_info)
return backlight_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >*
DeviceStatusReportRequest::mutable_backlight_info() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.backlight_info)
return &backlight_info_;
}
inline const ::enterprise_management::BacklightInfo& DeviceStatusReportRequest::backlight_info(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.backlight_info)
return backlight_info_.Get(index);
}
inline ::enterprise_management::BacklightInfo* DeviceStatusReportRequest::add_backlight_info() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.backlight_info)
return backlight_info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >&
DeviceStatusReportRequest::backlight_info() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.backlight_info)
return backlight_info_;
}

// repeated .enterprise_management.FanInfo fan_info = 38;
inline int DeviceStatusReportRequest::fan_info_size() const {
return fan_info_.size();
}
inline void DeviceStatusReportRequest::clear_fan_info() {
fan_info_.Clear();
}
inline ::enterprise_management::FanInfo* DeviceStatusReportRequest::mutable_fan_info(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.fan_info)
return fan_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >*
DeviceStatusReportRequest::mutable_fan_info() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.fan_info)
return &fan_info_;
}
inline const ::enterprise_management::FanInfo& DeviceStatusReportRequest::fan_info(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.fan_info)
return fan_info_.Get(index);
}
inline ::enterprise_management::FanInfo* DeviceStatusReportRequest::add_fan_info() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.fan_info)
return fan_info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >&
DeviceStatusReportRequest::fan_info() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.fan_info)
return fan_info_;
}

// optional .enterprise_management.GlobalCpuInfo global_cpu_info = 39;
inline bool DeviceStatusReportRequest::has_global_cpu_info() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceStatusReportRequest::clear_global_cpu_info() {
if (global_cpu_info_ != nullptr) global_cpu_info_->Clear();
_has_bits_[0] &= ~0x00010000u;
}
inline const ::enterprise_management::GlobalCpuInfo& DeviceStatusReportRequest::global_cpu_info() const {
const ::enterprise_management::GlobalCpuInfo* p = global_cpu_info_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::GlobalCpuInfo*>(
&::enterprise_management::_GlobalCpuInfo_default_instance_);
}
inline ::enterprise_management::GlobalCpuInfo* DeviceStatusReportRequest::release_global_cpu_info() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
_has_bits_[0] &= ~0x00010000u;
::enterprise_management::GlobalCpuInfo* temp = global_cpu_info_;
global_cpu_info_ = nullptr;
return temp;
}
inline ::enterprise_management::GlobalCpuInfo* DeviceStatusReportRequest::mutable_global_cpu_info() {
_has_bits_[0] |= 0x00010000u;
if (global_cpu_info_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::GlobalCpuInfo>(GetArenaNoVirtual());
global_cpu_info_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
return global_cpu_info_;
}
inline void DeviceStatusReportRequest::set_allocated_global_cpu_info(::enterprise_management::GlobalCpuInfo* global_cpu_info) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete global_cpu_info_;
}
if (global_cpu_info) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
global_cpu_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, global_cpu_info, submessage_arena);
}
_has_bits_[0] |= 0x00010000u;
} else {
_has_bits_[0] &= ~0x00010000u;
}
global_cpu_info_ = global_cpu_info;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
}

// repeated .enterprise_management.BluetoothAdapterInfo bluetooth_adapter_info = 40;
inline int DeviceStatusReportRequest::bluetooth_adapter_info_size() const {
return bluetooth_adapter_info_.size();
}
inline void DeviceStatusReportRequest::clear_bluetooth_adapter_info() {
bluetooth_adapter_info_.Clear();
}
inline ::enterprise_management::BluetoothAdapterInfo* DeviceStatusReportRequest::mutable_bluetooth_adapter_info(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
return bluetooth_adapter_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >*
DeviceStatusReportRequest::mutable_bluetooth_adapter_info() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
return &bluetooth_adapter_info_;
}
inline const ::enterprise_management::BluetoothAdapterInfo& DeviceStatusReportRequest::bluetooth_adapter_info(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
return bluetooth_adapter_info_.Get(index);
}
inline ::enterprise_management::BluetoothAdapterInfo* DeviceStatusReportRequest::add_bluetooth_adapter_info() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
return bluetooth_adapter_info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >&
DeviceStatusReportRequest::bluetooth_adapter_info() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
return bluetooth_adapter_info_;
}

// -------------------------------------------------------------------

// OsUpdateStatus

// optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
inline bool OsUpdateStatus::has_update_status() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsUpdateStatus::clear_update_status() {
update_status_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::OsUpdateStatus_UpdateStatus OsUpdateStatus::update_status() const {
// @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.update_status)
return static_cast< ::enterprise_management::OsUpdateStatus_UpdateStatus >(update_status_);
}
inline void OsUpdateStatus::set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value) {
assert(::enterprise_management::OsUpdateStatus_UpdateStatus_IsValid(value));
_has_bits_[0] |= 0x00000010u;
update_status_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.update_status)
}

// optional string new_platform_version = 2;
inline bool OsUpdateStatus::has_new_platform_version() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsUpdateStatus::clear_new_platform_version() {
new_platform_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OsUpdateStatus::new_platform_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.new_platform_version)
return new_platform_version_.GetNoArena();
}
inline void OsUpdateStatus::set_new_platform_version(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
new_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline void OsUpdateStatus::set_new_platform_version(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
new_platform_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline void OsUpdateStatus::set_new_platform_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
new_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline void OsUpdateStatus::set_new_platform_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
new_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline std::string* OsUpdateStatus::mutable_new_platform_version() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.OsUpdateStatus.new_platform_version)
return new_platform_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OsUpdateStatus::release_new_platform_version() {
// @@protoc_insertion_point(field_release:enterprise_management.OsUpdateStatus.new_platform_version)
if (!has_new_platform_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return new_platform_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OsUpdateStatus::set_allocated_new_platform_version(std::string* new_platform_version) {
if (new_platform_version != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
new_platform_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_platform_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.OsUpdateStatus.new_platform_version)
}

// optional string new_required_platform_version = 3;
inline bool OsUpdateStatus::has_new_required_platform_version() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsUpdateStatus::clear_new_required_platform_version() {
new_required_platform_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OsUpdateStatus::new_required_platform_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.new_required_platform_version)
return new_required_platform_version_.GetNoArena();
}
inline void OsUpdateStatus::set_new_required_platform_version(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
new_required_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline void OsUpdateStatus::set_new_required_platform_version(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
new_required_platform_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline void OsUpdateStatus::set_new_required_platform_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
new_required_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline void OsUpdateStatus::set_new_required_platform_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
new_required_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline std::string* OsUpdateStatus::mutable_new_required_platform_version() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.OsUpdateStatus.new_required_platform_version)
return new_required_platform_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OsUpdateStatus::release_new_required_platform_version() {
// @@protoc_insertion_point(field_release:enterprise_management.OsUpdateStatus.new_required_platform_version)
if (!has_new_required_platform_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return new_required_platform_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OsUpdateStatus::set_allocated_new_required_platform_version(std::string* new_required_platform_version) {
if (new_required_platform_version != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
new_required_platform_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_required_platform_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.OsUpdateStatus.new_required_platform_version)
}

// optional int64 last_checked_timestamp = 4;
inline bool OsUpdateStatus::has_last_checked_timestamp() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsUpdateStatus::clear_last_checked_timestamp() {
last_checked_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OsUpdateStatus::last_checked_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.last_checked_timestamp)
return last_checked_timestamp_;
}
inline void OsUpdateStatus::set_last_checked_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
last_checked_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.last_checked_timestamp)
}

// optional int64 last_reboot_timestamp = 5;
inline bool OsUpdateStatus::has_last_reboot_timestamp() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsUpdateStatus::clear_last_reboot_timestamp() {
last_reboot_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OsUpdateStatus::last_reboot_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.last_reboot_timestamp)
return last_reboot_timestamp_;
}
inline void OsUpdateStatus::set_last_reboot_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000008u;
last_reboot_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.last_reboot_timestamp)
}

// -------------------------------------------------------------------

// AppStatus

// optional string app_id = 1;
inline bool AppStatus::has_app_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppStatus::clear_app_id() {
app_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppStatus::app_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppStatus.app_id)
return app_id_.GetNoArena();
}
inline void AppStatus::set_app_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppStatus.app_id)
}
inline void AppStatus::set_app_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppStatus.app_id)
}
inline void AppStatus::set_app_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.app_id)
}
inline void AppStatus::set_app_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.app_id)
}
inline std::string* AppStatus::mutable_app_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.app_id)
return app_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppStatus::release_app_id() {
// @@protoc_insertion_point(field_release:enterprise_management.AppStatus.app_id)
if (!has_app_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return app_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_app_id(std::string* app_id) {
if (app_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
app_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.app_id)
}

// optional string extension_version = 2;
inline bool AppStatus::has_extension_version() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppStatus::clear_extension_version() {
extension_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppStatus::extension_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppStatus.extension_version)
return extension_version_.GetNoArena();
}
inline void AppStatus::set_extension_version(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
extension_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppStatus.extension_version)
}
inline void AppStatus::set_extension_version(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
extension_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppStatus.extension_version)
}
inline void AppStatus::set_extension_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
extension_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.extension_version)
}
inline void AppStatus::set_extension_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
extension_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.extension_version)
}
inline std::string* AppStatus::mutable_extension_version() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.extension_version)
return extension_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppStatus::release_extension_version() {
// @@protoc_insertion_point(field_release:enterprise_management.AppStatus.extension_version)
if (!has_extension_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return extension_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_extension_version(std::string* extension_version) {
if (extension_version != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
extension_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.extension_version)
}

// optional string status = 3;
inline bool AppStatus::has_status() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppStatus::clear_status() {
status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AppStatus::status() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppStatus.status)
return status_.GetNoArena();
}
inline void AppStatus::set_status(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppStatus.status)
}
inline void AppStatus::set_status(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
status_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppStatus.status)
}
inline void AppStatus::set_status(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.status)
}
inline void AppStatus::set_status(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.status)
}
inline std::string* AppStatus::mutable_status() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.status)
return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppStatus::release_status() {
// @@protoc_insertion_point(field_release:enterprise_management.AppStatus.status)
if (!has_status()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return status_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_status(std::string* status) {
if (status != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.status)
}

// optional bool error = 4;
inline bool AppStatus::has_error() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppStatus::clear_error() {
error_ = false;
_has_bits_[0] &= ~0x00000010u;
}
inline bool AppStatus::error() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppStatus.error)
return error_;
}
inline void AppStatus::set_error(bool value) {
_has_bits_[0] |= 0x00000010u;
error_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppStatus.error)
}

// optional string required_platform_version = 5;
inline bool AppStatus::has_required_platform_version() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppStatus::clear_required_platform_version() {
required_platform_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AppStatus::required_platform_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppStatus.required_platform_version)
return required_platform_version_.GetNoArena();
}
inline void AppStatus::set_required_platform_version(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
required_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppStatus.required_platform_version)
}
inline void AppStatus::set_required_platform_version(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
required_platform_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppStatus.required_platform_version)
}
inline void AppStatus::set_required_platform_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
required_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.required_platform_version)
}
inline void AppStatus::set_required_platform_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
required_platform_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.required_platform_version)
}
inline std::string* AppStatus::mutable_required_platform_version() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.required_platform_version)
return required_platform_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppStatus::release_required_platform_version() {
// @@protoc_insertion_point(field_release:enterprise_management.AppStatus.required_platform_version)
if (!has_required_platform_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return required_platform_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_required_platform_version(std::string* required_platform_version) {
if (required_platform_version != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
required_platform_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), required_platform_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.required_platform_version)
}

// -------------------------------------------------------------------

// AppInfo

// optional string app_id = 1;
inline bool AppInfo::has_app_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppInfo::clear_app_id() {
app_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInfo::app_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInfo.app_id)
return app_id_.GetNoArena();
}
inline void AppInfo::set_app_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppInfo.app_id)
}
inline void AppInfo::set_app_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppInfo.app_id)
}
inline void AppInfo::set_app_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppInfo.app_id)
}
inline void AppInfo::set_app_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppInfo.app_id)
}
inline std::string* AppInfo::mutable_app_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.app_id)
return app_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppInfo::release_app_id() {
// @@protoc_insertion_point(field_release:enterprise_management.AppInfo.app_id)
if (!has_app_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return app_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppInfo::set_allocated_app_id(std::string* app_id) {
if (app_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
app_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInfo.app_id)
}

// optional .enterprise_management.AppInfo.AppType app_type = 2;
inline bool AppInfo::has_app_type() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppInfo::clear_app_type() {
app_type_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::AppInfo_AppType AppInfo::app_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInfo.app_type)
return static_cast< ::enterprise_management::AppInfo_AppType >(app_type_);
}
inline void AppInfo::set_app_type(::enterprise_management::AppInfo_AppType value) {
assert(::enterprise_management::AppInfo_AppType_IsValid(value));
_has_bits_[0] |= 0x00000008u;
app_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInfo.app_type)
}

// optional string app_name = 3;
inline bool AppInfo::has_app_name() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppInfo::clear_app_name() {
app_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppInfo::app_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInfo.app_name)
return app_name_.GetNoArena();
}
inline void AppInfo::set_app_name(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppInfo.app_name)
}
inline void AppInfo::set_app_name(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppInfo.app_name)
}
inline void AppInfo::set_app_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppInfo.app_name)
}
inline void AppInfo::set_app_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppInfo.app_name)
}
inline std::string* AppInfo::mutable_app_name() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.app_name)
return app_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppInfo::release_app_name() {
// @@protoc_insertion_point(field_release:enterprise_management.AppInfo.app_name)
if (!has_app_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return app_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppInfo::set_allocated_app_name(std::string* app_name) {
if (app_name != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
app_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInfo.app_name)
}

// optional .enterprise_management.AppInfo.Status status = 4;
inline bool AppInfo::has_status() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppInfo::clear_status() {
status_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::AppInfo_Status AppInfo::status() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInfo.status)
return static_cast< ::enterprise_management::AppInfo_Status >(status_);
}
inline void AppInfo::set_status(::enterprise_management::AppInfo_Status value) {
assert(::enterprise_management::AppInfo_Status_IsValid(value));
_has_bits_[0] |= 0x00000010u;
status_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInfo.status)
}

// optional int64 install_time = 5;
inline bool AppInfo::has_install_time() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppInfo::clear_install_time() {
install_time_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppInfo::install_time() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInfo.install_time)
return install_time_;
}
inline void AppInfo::set_install_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000020u;
install_time_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInfo.install_time)
}

// optional string version = 7;
inline bool AppInfo::has_version() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppInfo::clear_version() {
version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AppInfo::version() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInfo.version)
return version_.GetNoArena();
}
inline void AppInfo::set_version(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppInfo.version)
}
inline void AppInfo::set_version(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppInfo.version)
}
inline void AppInfo::set_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppInfo.version)
}
inline void AppInfo::set_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppInfo.version)
}
inline std::string* AppInfo::mutable_version() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.version)
return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppInfo::release_version() {
// @@protoc_insertion_point(field_release:enterprise_management.AppInfo.version)
if (!has_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppInfo::set_allocated_version(std::string* version) {
if (version != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInfo.version)
}

// repeated .enterprise_management.TimePeriod active_time_periods = 8;
inline int AppInfo::active_time_periods_size() const {
return active_time_periods_.size();
}
inline void AppInfo::clear_active_time_periods() {
active_time_periods_.Clear();
}
inline ::enterprise_management::TimePeriod* AppInfo::mutable_active_time_periods(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.active_time_periods)
return active_time_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
AppInfo::mutable_active_time_periods() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.AppInfo.active_time_periods)
return &active_time_periods_;
}
inline const ::enterprise_management::TimePeriod& AppInfo::active_time_periods(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInfo.active_time_periods)
return active_time_periods_.Get(index);
}
inline ::enterprise_management::TimePeriod* AppInfo::add_active_time_periods() {
// @@protoc_insertion_point(field_add:enterprise_management.AppInfo.active_time_periods)
return active_time_periods_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
AppInfo::active_time_periods() const {
// @@protoc_insertion_point(field_list:enterprise_management.AppInfo.active_time_periods)
return active_time_periods_;
}

// -------------------------------------------------------------------

// AndroidAppPermission

// optional string name = 1;
inline bool AndroidAppPermission::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidAppPermission::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidAppPermission::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppPermission.name)
return name_.GetNoArena();
}
inline void AndroidAppPermission::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppPermission.name)
}
inline void AndroidAppPermission::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AndroidAppPermission.name)
}
inline void AndroidAppPermission::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AndroidAppPermission.name)
}
inline void AndroidAppPermission::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidAppPermission.name)
}
inline std::string* AndroidAppPermission::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppPermission.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AndroidAppPermission::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.AndroidAppPermission.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidAppPermission::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppPermission.name)
}

// optional bool granted = 2;
inline bool AndroidAppPermission::has_granted() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidAppPermission::clear_granted() {
granted_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool AndroidAppPermission::granted() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppPermission.granted)
return granted_;
}
inline void AndroidAppPermission::set_granted(bool value) {
_has_bits_[0] |= 0x00000002u;
granted_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppPermission.granted)
}

// optional bool managed = 3;
inline bool AndroidAppPermission::has_managed() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AndroidAppPermission::clear_managed() {
managed_ = false;
_has_bits_[0] &= ~0x00000004u;
}
inline bool AndroidAppPermission::managed() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppPermission.managed)
return managed_;
}
inline void AndroidAppPermission::set_managed(bool value) {
_has_bits_[0] |= 0x00000004u;
managed_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppPermission.managed)
}

// -------------------------------------------------------------------

// AndroidAppInfo

// optional string app_id = 1;
inline bool AndroidAppInfo::has_app_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidAppInfo::clear_app_id() {
app_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidAppInfo::app_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.app_id)
return app_id_.GetNoArena();
}
inline void AndroidAppInfo::set_app_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.app_id)
}
inline void AndroidAppInfo::set_app_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AndroidAppInfo.app_id)
}
inline void AndroidAppInfo::set_app_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AndroidAppInfo.app_id)
}
inline void AndroidAppInfo::set_app_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidAppInfo.app_id)
}
inline std::string* AndroidAppInfo::mutable_app_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.app_id)
return app_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AndroidAppInfo::release_app_id() {
// @@protoc_insertion_point(field_release:enterprise_management.AndroidAppInfo.app_id)
if (!has_app_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return app_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidAppInfo::set_allocated_app_id(std::string* app_id) {
if (app_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
app_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppInfo.app_id)
}

// optional string app_name = 2;
inline bool AndroidAppInfo::has_app_name() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidAppInfo::clear_app_name() {
app_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AndroidAppInfo::app_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.app_name)
return app_name_.GetNoArena();
}
inline void AndroidAppInfo::set_app_name(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.app_name)
}
inline void AndroidAppInfo::set_app_name(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AndroidAppInfo.app_name)
}
inline void AndroidAppInfo::set_app_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AndroidAppInfo.app_name)
}
inline void AndroidAppInfo::set_app_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidAppInfo.app_name)
}
inline std::string* AndroidAppInfo::mutable_app_name() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.app_name)
return app_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AndroidAppInfo::release_app_name() {
// @@protoc_insertion_point(field_release:enterprise_management.AndroidAppInfo.app_name)
if (!has_app_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return app_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidAppInfo::set_allocated_app_name(std::string* app_name) {
if (app_name != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
app_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppInfo.app_name)
}

// optional string package_name = 3;
inline bool AndroidAppInfo::has_package_name() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AndroidAppInfo::clear_package_name() {
package_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AndroidAppInfo::package_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.package_name)
return package_name_.GetNoArena();
}
inline void AndroidAppInfo::set_package_name(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.package_name)
}
inline void AndroidAppInfo::set_package_name(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
package_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AndroidAppInfo.package_name)
}
inline void AndroidAppInfo::set_package_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AndroidAppInfo.package_name)
}
inline void AndroidAppInfo::set_package_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidAppInfo.package_name)
}
inline std::string* AndroidAppInfo::mutable_package_name() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.package_name)
return package_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AndroidAppInfo::release_package_name() {
// @@protoc_insertion_point(field_release:enterprise_management.AndroidAppInfo.package_name)
if (!has_package_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return package_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidAppInfo::set_allocated_package_name(std::string* package_name) {
if (package_name != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
package_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppInfo.package_name)
}

// optional .enterprise_management.AndroidAppInfo.AndroidAppStatus status = 4;
inline bool AndroidAppInfo::has_status() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AndroidAppInfo::clear_status() {
status_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::AndroidAppInfo_AndroidAppStatus AndroidAppInfo::status() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.status)
return static_cast< ::enterprise_management::AndroidAppInfo_AndroidAppStatus >(status_);
}
inline void AndroidAppInfo::set_status(::enterprise_management::AndroidAppInfo_AndroidAppStatus value) {
assert(::enterprise_management::AndroidAppInfo_AndroidAppStatus_IsValid(value));
_has_bits_[0] |= 0x00000008u;
status_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.status)
}

// optional .enterprise_management.AndroidAppInfo.InstalledSource installed_source = 5;
inline bool AndroidAppInfo::has_installed_source() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AndroidAppInfo::clear_installed_source() {
installed_source_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::AndroidAppInfo_InstalledSource AndroidAppInfo::installed_source() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.installed_source)
return static_cast< ::enterprise_management::AndroidAppInfo_InstalledSource >(installed_source_);
}
inline void AndroidAppInfo::set_installed_source(::enterprise_management::AndroidAppInfo_InstalledSource value) {
assert(::enterprise_management::AndroidAppInfo_InstalledSource_IsValid(value));
_has_bits_[0] |= 0x00000010u;
installed_source_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.installed_source)
}

// optional int32 version = 6;
inline bool AndroidAppInfo::has_version() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AndroidAppInfo::clear_version() {
version_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AndroidAppInfo::version() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.version)
return version_;
}
inline void AndroidAppInfo::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000020u;
version_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.version)
}

// repeated .enterprise_management.AndroidAppPermission permissions = 7;
inline int AndroidAppInfo::permissions_size() const {
return permissions_.size();
}
inline void AndroidAppInfo::clear_permissions() {
permissions_.Clear();
}
inline ::enterprise_management::AndroidAppPermission* AndroidAppInfo::mutable_permissions(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.permissions)
return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >*
AndroidAppInfo::mutable_permissions() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.AndroidAppInfo.permissions)
return &permissions_;
}
inline const ::enterprise_management::AndroidAppPermission& AndroidAppInfo::permissions(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.permissions)
return permissions_.Get(index);
}
inline ::enterprise_management::AndroidAppPermission* AndroidAppInfo::add_permissions() {
// @@protoc_insertion_point(field_add:enterprise_management.AndroidAppInfo.permissions)
return permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >&
AndroidAppInfo::permissions() const {
// @@protoc_insertion_point(field_list:enterprise_management.AndroidAppInfo.permissions)
return permissions_;
}

// -------------------------------------------------------------------

// ChromeUserProfileReport

// optional string id = 1;
inline bool ChromeUserProfileReport::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeUserProfileReport::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeUserProfileReport::id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.id)
return id_.GetNoArena();
}
inline void ChromeUserProfileReport::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.id)
}
inline void ChromeUserProfileReport::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileReport.id)
}
inline void ChromeUserProfileReport::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileReport.id)
}
inline void ChromeUserProfileReport::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileReport.id)
}
inline std::string* ChromeUserProfileReport::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileReport::release_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileReport::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.id)
}

// optional string chrome_signed_in_user = 2;
inline bool ChromeUserProfileReport::has_chrome_signed_in_user() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromeUserProfileReport::clear_chrome_signed_in_user() {
chrome_signed_in_user_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeUserProfileReport::chrome_signed_in_user() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
return chrome_signed_in_user_.GetNoArena();
}
inline void ChromeUserProfileReport::set_chrome_signed_in_user(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
chrome_signed_in_user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
}
inline void ChromeUserProfileReport::set_chrome_signed_in_user(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
chrome_signed_in_user_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
}
inline void ChromeUserProfileReport::set_chrome_signed_in_user(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
chrome_signed_in_user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
}
inline void ChromeUserProfileReport::set_chrome_signed_in_user(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
chrome_signed_in_user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
}
inline std::string* ChromeUserProfileReport::mutable_chrome_signed_in_user() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
return chrome_signed_in_user_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileReport::release_chrome_signed_in_user() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
if (!has_chrome_signed_in_user()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return chrome_signed_in_user_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileReport::set_allocated_chrome_signed_in_user(std::string* chrome_signed_in_user) {
if (chrome_signed_in_user != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
chrome_signed_in_user_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chrome_signed_in_user);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
}

// optional string extension_data = 3;
inline bool ChromeUserProfileReport::has_extension_data() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChromeUserProfileReport::clear_extension_data() {
extension_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ChromeUserProfileReport::extension_data() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.extension_data)
return extension_data_.GetNoArena();
}
inline void ChromeUserProfileReport::set_extension_data(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
extension_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.extension_data)
}
inline void ChromeUserProfileReport::set_extension_data(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
extension_data_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileReport.extension_data)
}
inline void ChromeUserProfileReport::set_extension_data(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
extension_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileReport.extension_data)
}
inline void ChromeUserProfileReport::set_extension_data(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
extension_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileReport.extension_data)
}
inline std::string* ChromeUserProfileReport::mutable_extension_data() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.extension_data)
return extension_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileReport::release_extension_data() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.extension_data)
if (!has_extension_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return extension_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileReport::set_allocated_extension_data(std::string* extension_data) {
if (extension_data != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
extension_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension_data);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.extension_data)
}

// optional string plugins = 4;
inline bool ChromeUserProfileReport::has_plugins() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChromeUserProfileReport::clear_plugins() {
plugins_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ChromeUserProfileReport::plugins() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.plugins)
return plugins_.GetNoArena();
}
inline void ChromeUserProfileReport::set_plugins(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
plugins_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.plugins)
}
inline void ChromeUserProfileReport::set_plugins(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
plugins_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileReport.plugins)
}
inline void ChromeUserProfileReport::set_plugins(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
plugins_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileReport.plugins)
}
inline void ChromeUserProfileReport::set_plugins(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
plugins_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileReport.plugins)
}
inline std::string* ChromeUserProfileReport::mutable_plugins() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.plugins)
return plugins_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileReport::release_plugins() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.plugins)
if (!has_plugins()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return plugins_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileReport::set_allocated_plugins(std::string* plugins) {
if (plugins != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
plugins_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugins);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.plugins)
}

// optional string policy_data = 5;
inline bool ChromeUserProfileReport::has_policy_data() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChromeUserProfileReport::clear_policy_data() {
policy_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ChromeUserProfileReport::policy_data() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.policy_data)
return policy_data_.GetNoArena();
}
inline void ChromeUserProfileReport::set_policy_data(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
policy_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.policy_data)
}
inline void ChromeUserProfileReport::set_policy_data(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
policy_data_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileReport.policy_data)
}
inline void ChromeUserProfileReport::set_policy_data(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
policy_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileReport.policy_data)
}
inline void ChromeUserProfileReport::set_policy_data(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
policy_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileReport.policy_data)
}
inline std::string* ChromeUserProfileReport::mutable_policy_data() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.policy_data)
return policy_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileReport::release_policy_data() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.policy_data)
if (!has_policy_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return policy_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileReport::set_allocated_policy_data(std::string* policy_data) {
if (policy_data != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
policy_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_data);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.policy_data)
}

// optional int64 policy_fetched_timestamp = 6;
inline bool ChromeUserProfileReport::has_policy_fetched_timestamp() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChromeUserProfileReport::clear_policy_fetched_timestamp() {
policy_fetched_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ChromeUserProfileReport::policy_fetched_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.policy_fetched_timestamp)
return policy_fetched_timestamp_;
}
inline void ChromeUserProfileReport::set_policy_fetched_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000040u;
policy_fetched_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.policy_fetched_timestamp)
}

// optional uint64 safe_browsing_warnings = 7;
inline bool ChromeUserProfileReport::has_safe_browsing_warnings() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChromeUserProfileReport::clear_safe_browsing_warnings() {
safe_browsing_warnings_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ChromeUserProfileReport::safe_browsing_warnings() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings)
return safe_browsing_warnings_;
}
inline void ChromeUserProfileReport::set_safe_browsing_warnings(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000080u;
safe_browsing_warnings_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings)
}

// optional uint64 safe_browsing_warnings_click_through = 8;
inline bool ChromeUserProfileReport::has_safe_browsing_warnings_click_through() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChromeUserProfileReport::clear_safe_browsing_warnings_click_through() {
safe_browsing_warnings_click_through_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ChromeUserProfileReport::safe_browsing_warnings_click_through() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings_click_through)
return safe_browsing_warnings_click_through_;
}
inline void ChromeUserProfileReport::set_safe_browsing_warnings_click_through(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000100u;
safe_browsing_warnings_click_through_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings_click_through)
}

// optional string name = 9;
inline bool ChromeUserProfileReport::has_name() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChromeUserProfileReport::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ChromeUserProfileReport::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.name)
return name_.GetNoArena();
}
inline void ChromeUserProfileReport::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.name)
}
inline void ChromeUserProfileReport::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileReport.name)
}
inline void ChromeUserProfileReport::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileReport.name)
}
inline void ChromeUserProfileReport::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileReport.name)
}
inline std::string* ChromeUserProfileReport::mutable_name() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileReport::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileReport::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.name)
}

// repeated .enterprise_management.ExtensionRequest extension_requests = 10;
inline int ChromeUserProfileReport::extension_requests_size() const {
return extension_requests_.size();
}
inline void ChromeUserProfileReport::clear_extension_requests() {
extension_requests_.Clear();
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileReport::mutable_extension_requests(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.extension_requests)
return extension_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
ChromeUserProfileReport::mutable_extension_requests() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileReport.extension_requests)
return &extension_requests_;
}
inline const ::enterprise_management::ExtensionRequest& ChromeUserProfileReport::extension_requests(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.extension_requests)
return extension_requests_.Get(index);
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileReport::add_extension_requests() {
// @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileReport.extension_requests)
return extension_requests_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
ChromeUserProfileReport::extension_requests() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileReport.extension_requests)
return extension_requests_;
}

// -------------------------------------------------------------------

// ChromeSignedInUser

// optional string email = 1;
inline bool ChromeSignedInUser::has_email() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeSignedInUser::clear_email() {
email_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeSignedInUser::email() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeSignedInUser.email)
return email_.GetNoArena();
}
inline void ChromeSignedInUser::set_email(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeSignedInUser.email)
}
inline void ChromeSignedInUser::set_email(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeSignedInUser.email)
}
inline void ChromeSignedInUser::set_email(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeSignedInUser.email)
}
inline void ChromeSignedInUser::set_email(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
email_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeSignedInUser.email)
}
inline std::string* ChromeSignedInUser::mutable_email() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeSignedInUser.email)
return email_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeSignedInUser::release_email() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeSignedInUser.email)
if (!has_email()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return email_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeSignedInUser::set_allocated_email(std::string* email) {
if (email != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
email_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeSignedInUser.email)
}

// optional string obfudscated_gaia_id = 2;
inline bool ChromeSignedInUser::has_obfudscated_gaia_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromeSignedInUser::clear_obfudscated_gaia_id() {
obfudscated_gaia_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeSignedInUser::obfudscated_gaia_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
return obfudscated_gaia_id_.GetNoArena();
}
inline void ChromeSignedInUser::set_obfudscated_gaia_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
obfudscated_gaia_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
}
inline void ChromeSignedInUser::set_obfudscated_gaia_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
obfudscated_gaia_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
}
inline void ChromeSignedInUser::set_obfudscated_gaia_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
obfudscated_gaia_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
}
inline void ChromeSignedInUser::set_obfudscated_gaia_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
obfudscated_gaia_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
}
inline std::string* ChromeSignedInUser::mutable_obfudscated_gaia_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
return obfudscated_gaia_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeSignedInUser::release_obfudscated_gaia_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
if (!has_obfudscated_gaia_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return obfudscated_gaia_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeSignedInUser::set_allocated_obfudscated_gaia_id(std::string* obfudscated_gaia_id) {
if (obfudscated_gaia_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
obfudscated_gaia_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obfudscated_gaia_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeSignedInUser.obfudscated_gaia_id)
}

// -------------------------------------------------------------------

// ExtensionRequest

// optional string id = 1;
inline bool ExtensionRequest::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionRequest::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionRequest::id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionRequest.id)
return id_.GetNoArena();
}
inline void ExtensionRequest::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionRequest.id)
}
inline void ExtensionRequest::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ExtensionRequest.id)
}
inline void ExtensionRequest::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ExtensionRequest.id)
}
inline void ExtensionRequest::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ExtensionRequest.id)
}
inline std::string* ExtensionRequest::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionRequest.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ExtensionRequest::release_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ExtensionRequest.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionRequest::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ExtensionRequest.id)
}

// optional int64 request_timestamp = 2;
inline bool ExtensionRequest::has_request_timestamp() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtensionRequest::clear_request_timestamp() {
request_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtensionRequest::request_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionRequest.request_timestamp)
return request_timestamp_;
}
inline void ExtensionRequest::set_request_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
request_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionRequest.request_timestamp)
}

// -------------------------------------------------------------------

// Extension

// optional string id = 1;
inline bool Extension::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extension::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Extension::id() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.id)
return id_.GetNoArena();
}
inline void Extension::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Extension.id)
}
inline void Extension::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Extension.id)
}
inline void Extension::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Extension.id)
}
inline void Extension::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.id)
}
inline std::string* Extension::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Extension.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_id() {
// @@protoc_insertion_point(field_release:enterprise_management.Extension.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.id)
}

// optional string version = 2;
inline bool Extension::has_version() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extension::clear_version() {
version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Extension::version() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.version)
return version_.GetNoArena();
}
inline void Extension::set_version(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Extension.version)
}
inline void Extension::set_version(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Extension.version)
}
inline void Extension::set_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Extension.version)
}
inline void Extension::set_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.version)
}
inline std::string* Extension::mutable_version() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Extension.version)
return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_version() {
// @@protoc_insertion_point(field_release:enterprise_management.Extension.version)
if (!has_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_version(std::string* version) {
if (version != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.version)
}

// optional string name = 3;
inline bool Extension::has_name() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Extension::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Extension::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.name)
return name_.GetNoArena();
}
inline void Extension::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Extension.name)
}
inline void Extension::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Extension.name)
}
inline void Extension::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Extension.name)
}
inline void Extension::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.name)
}
inline std::string* Extension::mutable_name() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Extension.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.Extension.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.name)
}

// optional string description = 4;
inline bool Extension::has_description() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Extension::clear_description() {
description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Extension::description() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.description)
return description_.GetNoArena();
}
inline void Extension::set_description(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Extension.description)
}
inline void Extension::set_description(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Extension.description)
}
inline void Extension::set_description(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Extension.description)
}
inline void Extension::set_description(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.description)
}
inline std::string* Extension::mutable_description() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Extension.description)
return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_description() {
// @@protoc_insertion_point(field_release:enterprise_management.Extension.description)
if (!has_description()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_description(std::string* description) {
if (description != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.description)
}

// optional .enterprise_management.Extension.ExtensionType app_type = 5;
inline bool Extension::has_app_type() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Extension::clear_app_type() {
app_type_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::Extension_ExtensionType Extension::app_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.app_type)
return static_cast< ::enterprise_management::Extension_ExtensionType >(app_type_);
}
inline void Extension::set_app_type(::enterprise_management::Extension_ExtensionType value) {
assert(::enterprise_management::Extension_ExtensionType_IsValid(value));
_has_bits_[0] |= 0x00000020u;
app_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.Extension.app_type)
}

// optional string homepage_url = 6;
inline bool Extension::has_homepage_url() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Extension::clear_homepage_url() {
homepage_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Extension::homepage_url() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.homepage_url)
return homepage_url_.GetNoArena();
}
inline void Extension::set_homepage_url(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
homepage_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Extension.homepage_url)
}
inline void Extension::set_homepage_url(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
homepage_url_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Extension.homepage_url)
}
inline void Extension::set_homepage_url(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
homepage_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Extension.homepage_url)
}
inline void Extension::set_homepage_url(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
homepage_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.homepage_url)
}
inline std::string* Extension::mutable_homepage_url() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Extension.homepage_url)
return homepage_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_homepage_url() {
// @@protoc_insertion_point(field_release:enterprise_management.Extension.homepage_url)
if (!has_homepage_url()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return homepage_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_homepage_url(std::string* homepage_url) {
if (homepage_url != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
homepage_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), homepage_url);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.homepage_url)
}

// optional .enterprise_management.Extension.InstallType install_type = 8;
inline bool Extension::has_install_type() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Extension::clear_install_type() {
install_type_ = 0;
_has_bits_[0] &= ~0x00000040u;
}
inline ::enterprise_management::Extension_InstallType Extension::install_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.install_type)
return static_cast< ::enterprise_management::Extension_InstallType >(install_type_);
}
inline void Extension::set_install_type(::enterprise_management::Extension_InstallType value) {
assert(::enterprise_management::Extension_InstallType_IsValid(value));
_has_bits_[0] |= 0x00000040u;
install_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.Extension.install_type)
}

// optional bool enabled = 9;
inline bool Extension::has_enabled() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Extension::clear_enabled() {
enabled_ = false;
_has_bits_[0] &= ~0x00000080u;
}
inline bool Extension::enabled() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.enabled)
return enabled_;
}
inline void Extension::set_enabled(bool value) {
_has_bits_[0] |= 0x00000080u;
enabled_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.Extension.enabled)
}

// repeated string permissions = 10;
inline int Extension::permissions_size() const {
return permissions_.size();
}
inline void Extension::clear_permissions() {
permissions_.Clear();
}
inline const std::string& Extension::permissions(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.permissions)
return permissions_.Get(index);
}
inline std::string* Extension::mutable_permissions(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.Extension.permissions)
return permissions_.Mutable(index);
}
inline void Extension::set_permissions(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.Extension.permissions)
permissions_.Mutable(index)->assign(value);
}
inline void Extension::set_permissions(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.Extension.permissions)
permissions_.Mutable(index)->assign(std::move(value));
}
inline void Extension::set_permissions(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
permissions_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.Extension.permissions)
}
inline void Extension::set_permissions(int index, const char* value, size_t size) {
permissions_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.permissions)
}
inline std::string* Extension::add_permissions() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.Extension.permissions)
return permissions_.Add();
}
inline void Extension::add_permissions(const std::string& value) {
permissions_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.Extension.permissions)
}
inline void Extension::add_permissions(std::string&& value) {
permissions_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.Extension.permissions)
}
inline void Extension::add_permissions(const char* value) {
GOOGLE_DCHECK(value != nullptr);
permissions_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.Extension.permissions)
}
inline void Extension::add_permissions(const char* value, size_t size) {
permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.Extension.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Extension::permissions() const {
// @@protoc_insertion_point(field_list:enterprise_management.Extension.permissions)
return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Extension::mutable_permissions() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.Extension.permissions)
return &permissions_;
}

// repeated string host_permissions = 11;
inline int Extension::host_permissions_size() const {
return host_permissions_.size();
}
inline void Extension::clear_host_permissions() {
host_permissions_.Clear();
}
inline const std::string& Extension::host_permissions(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.host_permissions)
return host_permissions_.Get(index);
}
inline std::string* Extension::mutable_host_permissions(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.Extension.host_permissions)
return host_permissions_.Mutable(index);
}
inline void Extension::set_host_permissions(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.Extension.host_permissions)
host_permissions_.Mutable(index)->assign(value);
}
inline void Extension::set_host_permissions(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.Extension.host_permissions)
host_permissions_.Mutable(index)->assign(std::move(value));
}
inline void Extension::set_host_permissions(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
host_permissions_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.Extension.host_permissions)
}
inline void Extension::set_host_permissions(int index, const char* value, size_t size) {
host_permissions_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.host_permissions)
}
inline std::string* Extension::add_host_permissions() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.Extension.host_permissions)
return host_permissions_.Add();
}
inline void Extension::add_host_permissions(const std::string& value) {
host_permissions_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.Extension.host_permissions)
}
inline void Extension::add_host_permissions(std::string&& value) {
host_permissions_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.Extension.host_permissions)
}
inline void Extension::add_host_permissions(const char* value) {
GOOGLE_DCHECK(value != nullptr);
host_permissions_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.Extension.host_permissions)
}
inline void Extension::add_host_permissions(const char* value, size_t size) {
host_permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.Extension.host_permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Extension::host_permissions() const {
// @@protoc_insertion_point(field_list:enterprise_management.Extension.host_permissions)
return host_permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Extension::mutable_host_permissions() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.Extension.host_permissions)
return &host_permissions_;
}

// optional bool from_webstore = 13;
inline bool Extension::has_from_webstore() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Extension::clear_from_webstore() {
from_webstore_ = false;
_has_bits_[0] &= ~0x00000100u;
}
inline bool Extension::from_webstore() const {
// @@protoc_insertion_point(field_get:enterprise_management.Extension.from_webstore)
return from_webstore_;
}
inline void Extension::set_from_webstore(bool value) {
_has_bits_[0] |= 0x00000100u;
from_webstore_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.Extension.from_webstore)
}

// -------------------------------------------------------------------

// Plugin

// optional string name = 1;
inline bool Plugin::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plugin::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Plugin::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.Plugin.name)
return name_.GetNoArena();
}
inline void Plugin::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Plugin.name)
}
inline void Plugin::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Plugin.name)
}
inline void Plugin::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Plugin.name)
}
inline void Plugin::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Plugin.name)
}
inline std::string* Plugin::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Plugin::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.Plugin.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Plugin::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.name)
}

// optional string version = 2;
inline bool Plugin::has_version() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plugin::clear_version() {
version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Plugin::version() const {
// @@protoc_insertion_point(field_get:enterprise_management.Plugin.version)
return version_.GetNoArena();
}
inline void Plugin::set_version(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Plugin.version)
}
inline void Plugin::set_version(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Plugin.version)
}
inline void Plugin::set_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Plugin.version)
}
inline void Plugin::set_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Plugin.version)
}
inline std::string* Plugin::mutable_version() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.version)
return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Plugin::release_version() {
// @@protoc_insertion_point(field_release:enterprise_management.Plugin.version)
if (!has_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Plugin::set_allocated_version(std::string* version) {
if (version != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.version)
}

// optional string filename = 3;
inline bool Plugin::has_filename() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plugin::clear_filename() {
filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Plugin::filename() const {
// @@protoc_insertion_point(field_get:enterprise_management.Plugin.filename)
return filename_.GetNoArena();
}
inline void Plugin::set_filename(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Plugin.filename)
}
inline void Plugin::set_filename(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
filename_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Plugin.filename)
}
inline void Plugin::set_filename(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Plugin.filename)
}
inline void Plugin::set_filename(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Plugin.filename)
}
inline std::string* Plugin::mutable_filename() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.filename)
return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Plugin::release_filename() {
// @@protoc_insertion_point(field_release:enterprise_management.Plugin.filename)
if (!has_filename()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return filename_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Plugin::set_allocated_filename(std::string* filename) {
if (filename != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.filename)
}

// optional string description = 4;
inline bool Plugin::has_description() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Plugin::clear_description() {
description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Plugin::description() const {
// @@protoc_insertion_point(field_get:enterprise_management.Plugin.description)
return description_.GetNoArena();
}
inline void Plugin::set_description(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Plugin.description)
}
inline void Plugin::set_description(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Plugin.description)
}
inline void Plugin::set_description(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Plugin.description)
}
inline void Plugin::set_description(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Plugin.description)
}
inline std::string* Plugin::mutable_description() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.description)
return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Plugin::release_description() {
// @@protoc_insertion_point(field_release:enterprise_management.Plugin.description)
if (!has_description()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Plugin::set_allocated_description(std::string* description) {
if (description != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.description)
}

// -------------------------------------------------------------------

// Policy

// optional string name = 1;
inline bool Policy::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Policy::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Policy::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.Policy.name)
return name_.GetNoArena();
}
inline void Policy::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Policy.name)
}
inline void Policy::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Policy.name)
}
inline void Policy::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Policy.name)
}
inline void Policy::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Policy.name)
}
inline std::string* Policy::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Policy.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Policy::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.Policy.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Policy::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Policy.name)
}

// optional .enterprise_management.Policy.PolicyLevel level = 2;
inline bool Policy::has_level() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Policy::clear_level() {
level_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::Policy_PolicyLevel Policy::level() const {
// @@protoc_insertion_point(field_get:enterprise_management.Policy.level)
return static_cast< ::enterprise_management::Policy_PolicyLevel >(level_);
}
inline void Policy::set_level(::enterprise_management::Policy_PolicyLevel value) {
assert(::enterprise_management::Policy_PolicyLevel_IsValid(value));
_has_bits_[0] |= 0x00000008u;
level_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.Policy.level)
}

// optional .enterprise_management.Policy.PolicyScope scope = 3;
inline bool Policy::has_scope() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Policy::clear_scope() {
scope_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::Policy_PolicyScope Policy::scope() const {
// @@protoc_insertion_point(field_get:enterprise_management.Policy.scope)
return static_cast< ::enterprise_management::Policy_PolicyScope >(scope_);
}
inline void Policy::set_scope(::enterprise_management::Policy_PolicyScope value) {
assert(::enterprise_management::Policy_PolicyScope_IsValid(value));
_has_bits_[0] |= 0x00000010u;
scope_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.Policy.scope)
}

// optional .enterprise_management.Policy.PolicySource source = 4;
inline bool Policy::has_source() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Policy::clear_source() {
source_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::Policy_PolicySource Policy::source() const {
// @@protoc_insertion_point(field_get:enterprise_management.Policy.source)
return static_cast< ::enterprise_management::Policy_PolicySource >(source_);
}
inline void Policy::set_source(::enterprise_management::Policy_PolicySource value) {
assert(::enterprise_management::Policy_PolicySource_IsValid(value));
_has_bits_[0] |= 0x00000020u;
source_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.Policy.source)
}

// optional string value = 5;
inline bool Policy::has_value() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Policy::clear_value() {
value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Policy::value() const {
// @@protoc_insertion_point(field_get:enterprise_management.Policy.value)
return value_.GetNoArena();
}
inline void Policy::set_value(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Policy.value)
}
inline void Policy::set_value(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Policy.value)
}
inline void Policy::set_value(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Policy.value)
}
inline void Policy::set_value(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Policy.value)
}
inline std::string* Policy::mutable_value() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Policy.value)
return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Policy::release_value() {
// @@protoc_insertion_point(field_release:enterprise_management.Policy.value)
if (!has_value()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Policy::set_allocated_value(std::string* value) {
if (value != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Policy.value)
}

// optional string error = 6;
inline bool Policy::has_error() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Policy::clear_error() {
error_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Policy::error() const {
// @@protoc_insertion_point(field_get:enterprise_management.Policy.error)
return error_.GetNoArena();
}
inline void Policy::set_error(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.Policy.error)
}
inline void Policy::set_error(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
error_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.Policy.error)
}
inline void Policy::set_error(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.Policy.error)
}
inline void Policy::set_error(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.Policy.error)
}
inline std::string* Policy::mutable_error() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.Policy.error)
return error_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Policy::release_error() {
// @@protoc_insertion_point(field_release:enterprise_management.Policy.error)
if (!has_error()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return error_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Policy::set_allocated_error(std::string* error) {
if (error != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
error_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.Policy.error)
}

// -------------------------------------------------------------------

// ExtensionPolicy

// optional string extension_id = 1;
inline bool ExtensionPolicy::has_extension_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionPolicy::clear_extension_id() {
extension_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionPolicy::extension_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionPolicy.extension_id)
return extension_id_.GetNoArena();
}
inline void ExtensionPolicy::set_extension_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionPolicy.extension_id)
}
inline void ExtensionPolicy::set_extension_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ExtensionPolicy.extension_id)
}
inline void ExtensionPolicy::set_extension_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ExtensionPolicy.extension_id)
}
inline void ExtensionPolicy::set_extension_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ExtensionPolicy.extension_id)
}
inline std::string* ExtensionPolicy::mutable_extension_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionPolicy.extension_id)
return extension_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ExtensionPolicy::release_extension_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ExtensionPolicy.extension_id)
if (!has_extension_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return extension_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionPolicy::set_allocated_extension_id(std::string* extension_id) {
if (extension_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
extension_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ExtensionPolicy.extension_id)
}

// repeated .enterprise_management.Policy policies = 2;
inline int ExtensionPolicy::policies_size() const {
return policies_.size();
}
inline void ExtensionPolicy::clear_policies() {
policies_.Clear();
}
inline ::enterprise_management::Policy* ExtensionPolicy::mutable_policies(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionPolicy.policies)
return policies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
ExtensionPolicy::mutable_policies() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ExtensionPolicy.policies)
return &policies_;
}
inline const ::enterprise_management::Policy& ExtensionPolicy::policies(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionPolicy.policies)
return policies_.Get(index);
}
inline ::enterprise_management::Policy* ExtensionPolicy::add_policies() {
// @@protoc_insertion_point(field_add:enterprise_management.ExtensionPolicy.policies)
return policies_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
ExtensionPolicy::policies() const {
// @@protoc_insertion_point(field_list:enterprise_management.ExtensionPolicy.policies)
return policies_;
}

// -------------------------------------------------------------------

// PolicyFetchTimestamp

// optional string type = 1;
inline bool PolicyFetchTimestamp::has_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyFetchTimestamp::clear_type() {
type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyFetchTimestamp::type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchTimestamp.type)
return type_.GetNoArena();
}
inline void PolicyFetchTimestamp::set_type(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchTimestamp.type)
}
inline void PolicyFetchTimestamp::set_type(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyFetchTimestamp.type)
}
inline void PolicyFetchTimestamp::set_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchTimestamp.type)
}
inline void PolicyFetchTimestamp::set_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchTimestamp.type)
}
inline std::string* PolicyFetchTimestamp::mutable_type() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchTimestamp.type)
return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyFetchTimestamp::release_type() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchTimestamp.type)
if (!has_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchTimestamp::set_allocated_type(std::string* type) {
if (type != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchTimestamp.type)
}

// optional int64 timestamp = 2;
inline bool PolicyFetchTimestamp::has_timestamp() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyFetchTimestamp::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PolicyFetchTimestamp::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchTimestamp.timestamp)
return timestamp_;
}
inline void PolicyFetchTimestamp::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchTimestamp.timestamp)
}

// -------------------------------------------------------------------

// ChromeUserProfileInfo

// optional string id = 1;
inline bool ChromeUserProfileInfo::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeUserProfileInfo::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeUserProfileInfo::id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.id)
return id_.GetNoArena();
}
inline void ChromeUserProfileInfo::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileInfo.id)
}
inline void ChromeUserProfileInfo::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileInfo.id)
}
inline void ChromeUserProfileInfo::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileInfo.id)
}
inline void ChromeUserProfileInfo::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileInfo.id)
}
inline std::string* ChromeUserProfileInfo::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileInfo::release_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileInfo.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileInfo::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileInfo.id)
}

// optional string name = 2;
inline bool ChromeUserProfileInfo::has_name() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromeUserProfileInfo::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeUserProfileInfo::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.name)
return name_.GetNoArena();
}
inline void ChromeUserProfileInfo::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileInfo.name)
}
inline void ChromeUserProfileInfo::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeUserProfileInfo.name)
}
inline void ChromeUserProfileInfo::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeUserProfileInfo.name)
}
inline void ChromeUserProfileInfo::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeUserProfileInfo.name)
}
inline std::string* ChromeUserProfileInfo::mutable_name() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeUserProfileInfo::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileInfo.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeUserProfileInfo::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileInfo.name)
}

// optional bool is_full_report = 3;
inline bool ChromeUserProfileInfo::has_is_full_report() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChromeUserProfileInfo::clear_is_full_report() {
is_full_report_ = false;
_has_bits_[0] &= ~0x00000008u;
}
inline bool ChromeUserProfileInfo::is_full_report() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.is_full_report)
return is_full_report_;
}
inline void ChromeUserProfileInfo::set_is_full_report(bool value) {
_has_bits_[0] |= 0x00000008u;
is_full_report_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileInfo.is_full_report)
}

// optional .enterprise_management.ChromeSignedInUser chrome_signed_in_user = 4;
inline bool ChromeUserProfileInfo::has_chrome_signed_in_user() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChromeUserProfileInfo::clear_chrome_signed_in_user() {
if (chrome_signed_in_user_ != nullptr) chrome_signed_in_user_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::ChromeSignedInUser& ChromeUserProfileInfo::chrome_signed_in_user() const {
const ::enterprise_management::ChromeSignedInUser* p = chrome_signed_in_user_;
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ChromeSignedInUser*>(
&::enterprise_management::_ChromeSignedInUser_default_instance_);
}
inline ::enterprise_management::ChromeSignedInUser* ChromeUserProfileInfo::release_chrome_signed_in_user() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
_has_bits_[0] &= ~0x00000004u;
::enterprise_management::ChromeSignedInUser* temp = chrome_signed_in_user_;
chrome_signed_in_user_ = nullptr;
return temp;
}
inline ::enterprise_management::ChromeSignedInUser* ChromeUserProfileInfo::mutable_chrome_signed_in_user() {
_has_bits_[0] |= 0x00000004u;
if (chrome_signed_in_user_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ChromeSignedInUser>(GetArenaNoVirtual());
chrome_signed_in_user_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
return chrome_signed_in_user_;
}
inline void ChromeUserProfileInfo::set_allocated_chrome_signed_in_user(::enterprise_management::ChromeSignedInUser* chrome_signed_in_user) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete chrome_signed_in_user_;
}
if (chrome_signed_in_user) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
chrome_signed_in_user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, chrome_signed_in_user, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
chrome_signed_in_user_ = chrome_signed_in_user;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
}

// repeated .enterprise_management.Extension extensions = 5;
inline int ChromeUserProfileInfo::extensions_size() const {
return extensions_.size();
}
inline void ChromeUserProfileInfo::clear_extensions() {
extensions_.Clear();
}
inline ::enterprise_management::Extension* ChromeUserProfileInfo::mutable_extensions(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.extensions)
return extensions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >*
ChromeUserProfileInfo::mutable_extensions() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.extensions)
return &extensions_;
}
inline const ::enterprise_management::Extension& ChromeUserProfileInfo::extensions(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.extensions)
return extensions_.Get(index);
}
inline ::enterprise_management::Extension* ChromeUserProfileInfo::add_extensions() {
// @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.extensions)
return extensions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >&
ChromeUserProfileInfo::extensions() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.extensions)
return extensions_;
}

// repeated .enterprise_management.ExtensionRequest extension_requests = 10;
inline int ChromeUserProfileInfo::extension_requests_size() const {
return extension_requests_.size();
}
inline void ChromeUserProfileInfo::clear_extension_requests() {
extension_requests_.Clear();
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileInfo::mutable_extension_requests(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.extension_requests)
return extension_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
ChromeUserProfileInfo::mutable_extension_requests() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.extension_requests)
return &extension_requests_;
}
inline const ::enterprise_management::ExtensionRequest& ChromeUserProfileInfo::extension_requests(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.extension_requests)
return extension_requests_.Get(index);
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileInfo::add_extension_requests() {
// @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.extension_requests)
return extension_requests_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
ChromeUserProfileInfo::extension_requests() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.extension_requests)
return extension_requests_;
}

// repeated .enterprise_management.Policy chrome_policies = 7;
inline int ChromeUserProfileInfo::chrome_policies_size() const {
return chrome_policies_.size();
}
inline void ChromeUserProfileInfo::clear_chrome_policies() {
chrome_policies_.Clear();
}
inline ::enterprise_management::Policy* ChromeUserProfileInfo::mutable_chrome_policies(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.chrome_policies)
return chrome_policies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
ChromeUserProfileInfo::mutable_chrome_policies() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.chrome_policies)
return &chrome_policies_;
}
inline const ::enterprise_management::Policy& ChromeUserProfileInfo::chrome_policies(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.chrome_policies)
return chrome_policies_.Get(index);
}
inline ::enterprise_management::Policy* ChromeUserProfileInfo::add_chrome_policies() {
// @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.chrome_policies)
return chrome_policies_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
ChromeUserProfileInfo::chrome_policies() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.chrome_policies)
return chrome_policies_;
}

// repeated .enterprise_management.ExtensionPolicy extension_policies = 8;
inline int ChromeUserProfileInfo::extension_policies_size() const {
return extension_policies_.size();
}
inline void ChromeUserProfileInfo::clear_extension_policies() {
extension_policies_.Clear();
}
inline ::enterprise_management::ExtensionPolicy* ChromeUserProfileInfo::mutable_extension_policies(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.extension_policies)
return extension_policies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >*
ChromeUserProfileInfo::mutable_extension_policies() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.extension_policies)
return &extension_policies_;
}
inline const ::enterprise_management::ExtensionPolicy& ChromeUserProfileInfo::extension_policies(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.extension_policies)
return extension_policies_.Get(index);
}
inline ::enterprise_management::ExtensionPolicy* ChromeUserProfileInfo::add_extension_policies() {
// @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.extension_policies)
return extension_policies_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >&
ChromeUserProfileInfo::extension_policies() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.extension_policies)
return extension_policies_;
}

// repeated .enterprise_management.PolicyFetchTimestamp policy_fetched_timestamps = 9;
inline int ChromeUserProfileInfo::policy_fetched_timestamps_size() const {
return policy_fetched_timestamps_.size();
}
inline void ChromeUserProfileInfo::clear_policy_fetched_timestamps() {
policy_fetched_timestamps_.Clear();
}
inline ::enterprise_management::PolicyFetchTimestamp* ChromeUserProfileInfo::mutable_policy_fetched_timestamps(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
return policy_fetched_timestamps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >*
ChromeUserProfileInfo::mutable_policy_fetched_timestamps() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
return &policy_fetched_timestamps_;
}
inline const ::enterprise_management::PolicyFetchTimestamp& ChromeUserProfileInfo::policy_fetched_timestamps(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
return policy_fetched_timestamps_.Get(index);
}
inline ::enterprise_management::PolicyFetchTimestamp* ChromeUserProfileInfo::add_policy_fetched_timestamps() {
// @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
return policy_fetched_timestamps_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >&
ChromeUserProfileInfo::policy_fetched_timestamps() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
return policy_fetched_timestamps_;
}

// -------------------------------------------------------------------

// BrowserReport

// optional string browser_version = 1;
inline bool BrowserReport::has_browser_version() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowserReport::clear_browser_version() {
browser_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BrowserReport::browser_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.browser_version)
return browser_version_.GetNoArena();
}
inline void BrowserReport::set_browser_version(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.browser_version)
}
inline void BrowserReport::set_browser_version(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
browser_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BrowserReport.browser_version)
}
inline void BrowserReport::set_browser_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BrowserReport.browser_version)
}
inline void BrowserReport::set_browser_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BrowserReport.browser_version)
}
inline std::string* BrowserReport::mutable_browser_version() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.browser_version)
return browser_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BrowserReport::release_browser_version() {
// @@protoc_insertion_point(field_release:enterprise_management.BrowserReport.browser_version)
if (!has_browser_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return browser_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BrowserReport::set_allocated_browser_version(std::string* browser_version) {
if (browser_version != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
browser_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), browser_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserReport.browser_version)
}

// optional .enterprise_management.Channel channel = 2;
inline bool BrowserReport::has_channel() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BrowserReport::clear_channel() {
channel_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::Channel BrowserReport::channel() const {
// @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.channel)
return static_cast< ::enterprise_management::Channel >(channel_);
}
inline void BrowserReport::set_channel(::enterprise_management::Channel value) {
assert(::enterprise_management::Channel_IsValid(value));
_has_bits_[0] |= 0x00000008u;
channel_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.channel)
}

// optional string executable_path = 3;
inline bool BrowserReport::has_executable_path() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrowserReport::clear_executable_path() {
executable_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BrowserReport::executable_path() const {
// @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.executable_path)
return executable_path_.GetNoArena();
}
inline void BrowserReport::set_executable_path(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
executable_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.executable_path)
}
inline void BrowserReport::set_executable_path(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
executable_path_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BrowserReport.executable_path)
}
inline void BrowserReport::set_executable_path(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
executable_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BrowserReport.executable_path)
}
inline void BrowserReport::set_executable_path(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
executable_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BrowserReport.executable_path)
}
inline std::string* BrowserReport::mutable_executable_path() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.executable_path)
return executable_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BrowserReport::release_executable_path() {
// @@protoc_insertion_point(field_release:enterprise_management.BrowserReport.executable_path)
if (!has_executable_path()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return executable_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BrowserReport::set_allocated_executable_path(std::string* executable_path) {
if (executable_path != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
executable_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), executable_path);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserReport.executable_path)
}

// repeated .enterprise_management.ChromeUserProfileReport chrome_user_profile_reports = 4;
inline int BrowserReport::chrome_user_profile_reports_size() const {
return chrome_user_profile_reports_.size();
}
inline void BrowserReport::clear_chrome_user_profile_reports() {
chrome_user_profile_reports_.Clear();
}
inline ::enterprise_management::ChromeUserProfileReport* BrowserReport::mutable_chrome_user_profile_reports(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.chrome_user_profile_reports)
return chrome_user_profile_reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >*
BrowserReport::mutable_chrome_user_profile_reports() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.BrowserReport.chrome_user_profile_reports)
return &chrome_user_profile_reports_;
}
inline const ::enterprise_management::ChromeUserProfileReport& BrowserReport::chrome_user_profile_reports(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.chrome_user_profile_reports)
return chrome_user_profile_reports_.Get(index);
}
inline ::enterprise_management::ChromeUserProfileReport* BrowserReport::add_chrome_user_profile_reports() {
// @@protoc_insertion_point(field_add:enterprise_management.BrowserReport.chrome_user_profile_reports)
return chrome_user_profile_reports_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >&
BrowserReport::chrome_user_profile_reports() const {
// @@protoc_insertion_point(field_list:enterprise_management.BrowserReport.chrome_user_profile_reports)
return chrome_user_profile_reports_;
}

// repeated .enterprise_management.ChromeUserProfileInfo chrome_user_profile_infos = 6;
inline int BrowserReport::chrome_user_profile_infos_size() const {
return chrome_user_profile_infos_.size();
}
inline void BrowserReport::clear_chrome_user_profile_infos() {
chrome_user_profile_infos_.Clear();
}
inline ::enterprise_management::ChromeUserProfileInfo* BrowserReport::mutable_chrome_user_profile_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.chrome_user_profile_infos)
return chrome_user_profile_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >*
BrowserReport::mutable_chrome_user_profile_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.BrowserReport.chrome_user_profile_infos)
return &chrome_user_profile_infos_;
}
inline const ::enterprise_management::ChromeUserProfileInfo& BrowserReport::chrome_user_profile_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.chrome_user_profile_infos)
return chrome_user_profile_infos_.Get(index);
}
inline ::enterprise_management::ChromeUserProfileInfo* BrowserReport::add_chrome_user_profile_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.BrowserReport.chrome_user_profile_infos)
return chrome_user_profile_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >&
BrowserReport::chrome_user_profile_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.BrowserReport.chrome_user_profile_infos)
return chrome_user_profile_infos_;
}

// repeated .enterprise_management.Plugin plugins = 7;
inline int BrowserReport::plugins_size() const {
return plugins_.size();
}
inline void BrowserReport::clear_plugins() {
plugins_.Clear();
}
inline ::enterprise_management::Plugin* BrowserReport::mutable_plugins(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.plugins)
return plugins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >*
BrowserReport::mutable_plugins() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.BrowserReport.plugins)
return &plugins_;
}
inline const ::enterprise_management::Plugin& BrowserReport::plugins(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.plugins)
return plugins_.Get(index);
}
inline ::enterprise_management::Plugin* BrowserReport::add_plugins() {
// @@protoc_insertion_point(field_add:enterprise_management.BrowserReport.plugins)
return plugins_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >&
BrowserReport::plugins() const {
// @@protoc_insertion_point(field_list:enterprise_management.BrowserReport.plugins)
return plugins_;
}

// optional string installed_browser_version = 8;
inline bool BrowserReport::has_installed_browser_version() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BrowserReport::clear_installed_browser_version() {
installed_browser_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BrowserReport::installed_browser_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.installed_browser_version)
return installed_browser_version_.GetNoArena();
}
inline void BrowserReport::set_installed_browser_version(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
installed_browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.installed_browser_version)
}
inline void BrowserReport::set_installed_browser_version(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
installed_browser_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.BrowserReport.installed_browser_version)
}
inline void BrowserReport::set_installed_browser_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
installed_browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.BrowserReport.installed_browser_version)
}
inline void BrowserReport::set_installed_browser_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
installed_browser_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.BrowserReport.installed_browser_version)
}
inline std::string* BrowserReport::mutable_installed_browser_version() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.installed_browser_version)
return installed_browser_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BrowserReport::release_installed_browser_version() {
// @@protoc_insertion_point(field_release:enterprise_management.BrowserReport.installed_browser_version)
if (!has_installed_browser_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return installed_browser_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BrowserReport::set_allocated_installed_browser_version(std::string* installed_browser_version) {
if (installed_browser_version != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
installed_browser_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), installed_browser_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserReport.installed_browser_version)
}

// -------------------------------------------------------------------

// OSReport

// optional string name = 1;
inline bool OSReport::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OSReport::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OSReport::name() const {
// @@protoc_insertion_point(field_get:enterprise_management.OSReport.name)
return name_.GetNoArena();
}
inline void OSReport::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.OSReport.name)
}
inline void OSReport::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.OSReport.name)
}
inline void OSReport::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.OSReport.name)
}
inline void OSReport::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.OSReport.name)
}
inline std::string* OSReport::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.OSReport.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OSReport::release_name() {
// @@protoc_insertion_point(field_release:enterprise_management.OSReport.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OSReport::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.OSReport.name)
}

// optional string arch = 2;
inline bool OSReport::has_arch() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OSReport::clear_arch() {
arch_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OSReport::arch() const {
// @@protoc_insertion_point(field_get:enterprise_management.OSReport.arch)
return arch_.GetNoArena();
}
inline void OSReport::set_arch(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
arch_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.OSReport.arch)
}
inline void OSReport::set_arch(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
arch_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.OSReport.arch)
}
inline void OSReport::set_arch(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
arch_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.OSReport.arch)
}
inline void OSReport::set_arch(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
arch_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.OSReport.arch)
}
inline std::string* OSReport::mutable_arch() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.OSReport.arch)
return arch_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OSReport::release_arch() {
// @@protoc_insertion_point(field_release:enterprise_management.OSReport.arch)
if (!has_arch()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return arch_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OSReport::set_allocated_arch(std::string* arch) {
if (arch != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
arch_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arch);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.OSReport.arch)
}

// optional string version = 3;
inline bool OSReport::has_version() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OSReport::clear_version() {
version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OSReport::version() const {
// @@protoc_insertion_point(field_get:enterprise_management.OSReport.version)
return version_.GetNoArena();
}
inline void OSReport::set_version(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.OSReport.version)
}
inline void OSReport::set_version(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.OSReport.version)
}
inline void OSReport::set_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.OSReport.version)
}
inline void OSReport::set_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.OSReport.version)
}
inline std::string* OSReport::mutable_version() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.OSReport.version)
return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OSReport::release_version() {
// @@protoc_insertion_point(field_release:enterprise_management.OSReport.version)
if (!has_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OSReport::set_allocated_version(std::string* version) {
if (version != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.OSReport.version)
}

// -------------------------------------------------------------------

// ChromeDesktopReportRequest

// optional string machine_name = 1;
inline bool ChromeDesktopReportRequest::has_machine_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeDesktopReportRequest::clear_machine_name() {
machine_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeDesktopReportRequest::machine_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.machine_name)
return machine_name_.GetNoArena();
}
inline void ChromeDesktopReportRequest::set_machine_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.machine_name)
}
inline void ChromeDesktopReportRequest::set_machine_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeDesktopReportRequest.machine_name)
}
inline void ChromeDesktopReportRequest::set_machine_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeDesktopReportRequest.machine_name)
}
inline void ChromeDesktopReportRequest::set_machine_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeDesktopReportRequest.machine_name)
}
inline std::string* ChromeDesktopReportRequest::mutable_machine_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.machine_name)
return machine_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeDesktopReportRequest::release_machine_name() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.machine_name)
if (!has_machine_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return machine_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeDesktopReportRequest::set_allocated_machine_name(std::string* machine_name) {
if (machine_name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
machine_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.machine_name)
}

// optional string os_info = 2;
inline bool ChromeDesktopReportRequest::has_os_info() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromeDesktopReportRequest::clear_os_info() {
os_info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeDesktopReportRequest::os_info() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_info)
return os_info_.GetNoArena();
}
inline void ChromeDesktopReportRequest::set_os_info(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
os_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.os_info)
}
inline void ChromeDesktopReportRequest::set_os_info(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
os_info_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeDesktopReportRequest.os_info)
}
inline void ChromeDesktopReportRequest::set_os_info(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
os_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeDesktopReportRequest.os_info)
}
inline void ChromeDesktopReportRequest::set_os_info(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
os_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeDesktopReportRequest.os_info)
}
inline std::string* ChromeDesktopReportRequest::mutable_os_info() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_info)
return os_info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeDesktopReportRequest::release_os_info() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_info)
if (!has_os_info()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return os_info_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeDesktopReportRequest::set_allocated_os_info(std::string* os_info) {
if (os_info != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
os_info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_info);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_info)
}

// optional string os_user = 3;
inline bool ChromeDesktopReportRequest::has_os_user() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChromeDesktopReportRequest::clear_os_user() {
os_user_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ChromeDesktopReportRequest::os_user() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_user)
return os_user_.GetNoArena();
}
inline void ChromeDesktopReportRequest::set_os_user(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
os_user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.os_user)
}
inline void ChromeDesktopReportRequest::set_os_user(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
os_user_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeDesktopReportRequest.os_user)
}
inline void ChromeDesktopReportRequest::set_os_user(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
os_user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeDesktopReportRequest.os_user)
}
inline void ChromeDesktopReportRequest::set_os_user(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
os_user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeDesktopReportRequest.os_user)
}
inline std::string* ChromeDesktopReportRequest::mutable_os_user() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_user)
return os_user_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeDesktopReportRequest::release_os_user() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_user)
if (!has_os_user()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return os_user_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeDesktopReportRequest::set_allocated_os_user(std::string* os_user) {
if (os_user != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
os_user_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_user);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_user)
}

// optional .enterprise_management.BrowserReport browser_report = 4;
inline bool ChromeDesktopReportRequest::has_browser_report() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChromeDesktopReportRequest::clear_browser_report() {
if (browser_report_ != nullptr) browser_report_->Clear();
_has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::BrowserReport& ChromeDesktopReportRequest::browser_report() const {
const ::enterprise_management::BrowserReport* p = browser_report_;
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.browser_report)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::BrowserReport*>(
&::enterprise_management::_BrowserReport_default_instance_);
}
inline ::enterprise_management::BrowserReport* ChromeDesktopReportRequest::release_browser_report() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.browser_report)
_has_bits_[0] &= ~0x00000040u;
::enterprise_management::BrowserReport* temp = browser_report_;
browser_report_ = nullptr;
return temp;
}
inline ::enterprise_management::BrowserReport* ChromeDesktopReportRequest::mutable_browser_report() {
_has_bits_[0] |= 0x00000040u;
if (browser_report_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::BrowserReport>(GetArenaNoVirtual());
browser_report_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.browser_report)
return browser_report_;
}
inline void ChromeDesktopReportRequest::set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete browser_report_;
}
if (browser_report) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
browser_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, browser_report, submessage_arena);
}
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
browser_report_ = browser_report;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.browser_report)
}

// optional string serial_number = 5;
inline bool ChromeDesktopReportRequest::has_serial_number() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChromeDesktopReportRequest::clear_serial_number() {
serial_number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ChromeDesktopReportRequest::serial_number() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.serial_number)
return serial_number_.GetNoArena();
}
inline void ChromeDesktopReportRequest::set_serial_number(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.serial_number)
}
inline void ChromeDesktopReportRequest::set_serial_number(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
serial_number_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeDesktopReportRequest.serial_number)
}
inline void ChromeDesktopReportRequest::set_serial_number(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeDesktopReportRequest.serial_number)
}
inline void ChromeDesktopReportRequest::set_serial_number(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeDesktopReportRequest.serial_number)
}
inline std::string* ChromeDesktopReportRequest::mutable_serial_number() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.serial_number)
return serial_number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeDesktopReportRequest::release_serial_number() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.serial_number)
if (!has_serial_number()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return serial_number_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeDesktopReportRequest::set_allocated_serial_number(std::string* serial_number) {
if (serial_number != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
serial_number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.serial_number)
}

// optional string computer_name = 6;
inline bool ChromeDesktopReportRequest::has_computer_name() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChromeDesktopReportRequest::clear_computer_name() {
computer_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ChromeDesktopReportRequest::computer_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.computer_name)
return computer_name_.GetNoArena();
}
inline void ChromeDesktopReportRequest::set_computer_name(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
computer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.computer_name)
}
inline void ChromeDesktopReportRequest::set_computer_name(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
computer_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeDesktopReportRequest.computer_name)
}
inline void ChromeDesktopReportRequest::set_computer_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
computer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeDesktopReportRequest.computer_name)
}
inline void ChromeDesktopReportRequest::set_computer_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
computer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeDesktopReportRequest.computer_name)
}
inline std::string* ChromeDesktopReportRequest::mutable_computer_name() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.computer_name)
return computer_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeDesktopReportRequest::release_computer_name() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.computer_name)
if (!has_computer_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return computer_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeDesktopReportRequest::set_allocated_computer_name(std::string* computer_name) {
if (computer_name != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
computer_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), computer_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.computer_name)
}

// optional .enterprise_management.OSReport os_report = 7;
inline bool ChromeDesktopReportRequest::has_os_report() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChromeDesktopReportRequest::clear_os_report() {
if (os_report_ != nullptr) os_report_->Clear();
_has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::OSReport& ChromeDesktopReportRequest::os_report() const {
const ::enterprise_management::OSReport* p = os_report_;
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_report)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::OSReport*>(
&::enterprise_management::_OSReport_default_instance_);
}
inline ::enterprise_management::OSReport* ChromeDesktopReportRequest::release_os_report() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_report)
_has_bits_[0] &= ~0x00000080u;
::enterprise_management::OSReport* temp = os_report_;
os_report_ = nullptr;
return temp;
}
inline ::enterprise_management::OSReport* ChromeDesktopReportRequest::mutable_os_report() {
_has_bits_[0] |= 0x00000080u;
if (os_report_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::OSReport>(GetArenaNoVirtual());
os_report_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_report)
return os_report_;
}
inline void ChromeDesktopReportRequest::set_allocated_os_report(::enterprise_management::OSReport* os_report) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete os_report_;
}
if (os_report) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
os_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, os_report, submessage_arena);
}
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
os_report_ = os_report;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_report)
}

// optional string os_user_name = 8;
inline bool ChromeDesktopReportRequest::has_os_user_name() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChromeDesktopReportRequest::clear_os_user_name() {
os_user_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ChromeDesktopReportRequest::os_user_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_user_name)
return os_user_name_.GetNoArena();
}
inline void ChromeDesktopReportRequest::set_os_user_name(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
os_user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.os_user_name)
}
inline void ChromeDesktopReportRequest::set_os_user_name(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
os_user_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChromeDesktopReportRequest.os_user_name)
}
inline void ChromeDesktopReportRequest::set_os_user_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
os_user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChromeDesktopReportRequest.os_user_name)
}
inline void ChromeDesktopReportRequest::set_os_user_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
os_user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChromeDesktopReportRequest.os_user_name)
}
inline std::string* ChromeDesktopReportRequest::mutable_os_user_name() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_user_name)
return os_user_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChromeDesktopReportRequest::release_os_user_name() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_user_name)
if (!has_os_user_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return os_user_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeDesktopReportRequest::set_allocated_os_user_name(std::string* os_user_name) {
if (os_user_name != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
os_user_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_user_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_user_name)
}

// -------------------------------------------------------------------

// ChromeOsUserReportRequest

// optional .enterprise_management.BrowserReport browser_report = 1;
inline bool ChromeOsUserReportRequest::has_browser_report() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeOsUserReportRequest::clear_browser_report() {
if (browser_report_ != nullptr) browser_report_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::BrowserReport& ChromeOsUserReportRequest::browser_report() const {
const ::enterprise_management::BrowserReport* p = browser_report_;
// @@protoc_insertion_point(field_get:enterprise_management.ChromeOsUserReportRequest.browser_report)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::BrowserReport*>(
&::enterprise_management::_BrowserReport_default_instance_);
}
inline ::enterprise_management::BrowserReport* ChromeOsUserReportRequest::release_browser_report() {
// @@protoc_insertion_point(field_release:enterprise_management.ChromeOsUserReportRequest.browser_report)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::BrowserReport* temp = browser_report_;
browser_report_ = nullptr;
return temp;
}
inline ::enterprise_management::BrowserReport* ChromeOsUserReportRequest::mutable_browser_report() {
_has_bits_[0] |= 0x00000001u;
if (browser_report_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::BrowserReport>(GetArenaNoVirtual());
browser_report_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeOsUserReportRequest.browser_report)
return browser_report_;
}
inline void ChromeOsUserReportRequest::set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete browser_report_;
}
if (browser_report) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
browser_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, browser_report, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
browser_report_ = browser_report;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeOsUserReportRequest.browser_report)
}

// repeated .enterprise_management.AndroidAppInfo android_app_infos = 2;
inline int ChromeOsUserReportRequest::android_app_infos_size() const {
return android_app_infos_.size();
}
inline void ChromeOsUserReportRequest::clear_android_app_infos() {
android_app_infos_.Clear();
}
inline ::enterprise_management::AndroidAppInfo* ChromeOsUserReportRequest::mutable_android_app_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
return android_app_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >*
ChromeOsUserReportRequest::mutable_android_app_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
return &android_app_infos_;
}
inline const ::enterprise_management::AndroidAppInfo& ChromeOsUserReportRequest::android_app_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
return android_app_infos_.Get(index);
}
inline ::enterprise_management::AndroidAppInfo* ChromeOsUserReportRequest::add_android_app_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
return android_app_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >&
ChromeOsUserReportRequest::android_app_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
return android_app_infos_;
}

// -------------------------------------------------------------------

// PolicyValueValidationIssue

// optional string policy_name = 1;
inline bool PolicyValueValidationIssue::has_policy_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyValueValidationIssue::clear_policy_name() {
policy_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyValueValidationIssue::policy_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyValueValidationIssue.policy_name)
return policy_name_.GetNoArena();
}
inline void PolicyValueValidationIssue::set_policy_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
policy_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyValueValidationIssue.policy_name)
}
inline void PolicyValueValidationIssue::set_policy_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
policy_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyValueValidationIssue.policy_name)
}
inline void PolicyValueValidationIssue::set_policy_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
policy_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyValueValidationIssue.policy_name)
}
inline void PolicyValueValidationIssue::set_policy_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
policy_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyValueValidationIssue.policy_name)
}
inline std::string* PolicyValueValidationIssue::mutable_policy_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValueValidationIssue.policy_name)
return policy_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyValueValidationIssue::release_policy_name() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyValueValidationIssue.policy_name)
if (!has_policy_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return policy_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyValueValidationIssue::set_allocated_policy_name(std::string* policy_name) {
if (policy_name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
policy_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValueValidationIssue.policy_name)
}

// optional .enterprise_management.PolicyValueValidationIssue.ValueValidationIssueSeverity severity = 2;
inline bool PolicyValueValidationIssue::has_severity() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyValueValidationIssue::clear_severity() {
severity_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::severity() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyValueValidationIssue.severity)
return static_cast< ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity >(severity_);
}
inline void PolicyValueValidationIssue::set_severity(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity value) {
assert(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(value));
_has_bits_[0] |= 0x00000004u;
severity_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyValueValidationIssue.severity)
}

// optional string debug_message = 3;
inline bool PolicyValueValidationIssue::has_debug_message() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyValueValidationIssue::clear_debug_message() {
debug_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyValueValidationIssue::debug_message() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyValueValidationIssue.debug_message)
return debug_message_.GetNoArena();
}
inline void PolicyValueValidationIssue::set_debug_message(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
debug_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyValueValidationIssue.debug_message)
}
inline void PolicyValueValidationIssue::set_debug_message(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
debug_message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyValueValidationIssue.debug_message)
}
inline void PolicyValueValidationIssue::set_debug_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
debug_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyValueValidationIssue.debug_message)
}
inline void PolicyValueValidationIssue::set_debug_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
debug_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyValueValidationIssue.debug_message)
}
inline std::string* PolicyValueValidationIssue::mutable_debug_message() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValueValidationIssue.debug_message)
return debug_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyValueValidationIssue::release_debug_message() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyValueValidationIssue.debug_message)
if (!has_debug_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return debug_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyValueValidationIssue::set_allocated_debug_message(std::string* debug_message) {
if (debug_message != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
debug_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), debug_message);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValueValidationIssue.debug_message)
}

// -------------------------------------------------------------------

// PolicyValidationReportRequest

// optional string policy_type = 1;
inline bool PolicyValidationReportRequest::has_policy_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyValidationReportRequest::clear_policy_type() {
policy_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyValidationReportRequest::policy_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.policy_type)
return policy_type_.GetNoArena();
}
inline void PolicyValidationReportRequest::set_policy_type(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyValidationReportRequest.policy_type)
}
inline void PolicyValidationReportRequest::set_policy_type(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyValidationReportRequest.policy_type)
}
inline void PolicyValidationReportRequest::set_policy_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyValidationReportRequest.policy_type)
}
inline void PolicyValidationReportRequest::set_policy_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
policy_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyValidationReportRequest.policy_type)
}
inline std::string* PolicyValidationReportRequest::mutable_policy_type() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValidationReportRequest.policy_type)
return policy_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyValidationReportRequest::release_policy_type() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyValidationReportRequest.policy_type)
if (!has_policy_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return policy_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyValidationReportRequest::set_allocated_policy_type(std::string* policy_type) {
if (policy_type != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
policy_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_type);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValidationReportRequest.policy_type)
}

// optional string policy_token = 2;
inline bool PolicyValidationReportRequest::has_policy_token() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyValidationReportRequest::clear_policy_token() {
policy_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyValidationReportRequest::policy_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.policy_token)
return policy_token_.GetNoArena();
}
inline void PolicyValidationReportRequest::set_policy_token(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
policy_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PolicyValidationReportRequest.policy_token)
}
inline void PolicyValidationReportRequest::set_policy_token(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
policy_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PolicyValidationReportRequest.policy_token)
}
inline void PolicyValidationReportRequest::set_policy_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
policy_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PolicyValidationReportRequest.policy_token)
}
inline void PolicyValidationReportRequest::set_policy_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
policy_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyValidationReportRequest.policy_token)
}
inline std::string* PolicyValidationReportRequest::mutable_policy_token() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValidationReportRequest.policy_token)
return policy_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PolicyValidationReportRequest::release_policy_token() {
// @@protoc_insertion_point(field_release:enterprise_management.PolicyValidationReportRequest.policy_token)
if (!has_policy_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return policy_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyValidationReportRequest::set_allocated_policy_token(std::string* policy_token) {
if (policy_token != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
policy_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValidationReportRequest.policy_token)
}

// optional .enterprise_management.PolicyValidationReportRequest.ValidationResultType validation_result_type = 3;
inline bool PolicyValidationReportRequest::has_validation_result_type() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyValidationReportRequest::clear_validation_result_type() {
validation_result_type_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::validation_result_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.validation_result_type)
return static_cast< ::enterprise_management::PolicyValidationReportRequest_ValidationResultType >(validation_result_type_);
}
inline void PolicyValidationReportRequest::set_validation_result_type(::enterprise_management::PolicyValidationReportRequest_ValidationResultType value) {
assert(::enterprise_management::PolicyValidationReportRequest_ValidationResultType_IsValid(value));
_has_bits_[0] |= 0x00000004u;
validation_result_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.PolicyValidationReportRequest.validation_result_type)
}

// repeated .enterprise_management.PolicyValueValidationIssue policy_value_validation_issues = 4;
inline int PolicyValidationReportRequest::policy_value_validation_issues_size() const {
return policy_value_validation_issues_.size();
}
inline void PolicyValidationReportRequest::clear_policy_value_validation_issues() {
policy_value_validation_issues_.Clear();
}
inline ::enterprise_management::PolicyValueValidationIssue* PolicyValidationReportRequest::mutable_policy_value_validation_issues(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
return policy_value_validation_issues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >*
PolicyValidationReportRequest::mutable_policy_value_validation_issues() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
return &policy_value_validation_issues_;
}
inline const ::enterprise_management::PolicyValueValidationIssue& PolicyValidationReportRequest::policy_value_validation_issues(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
return policy_value_validation_issues_.Get(index);
}
inline ::enterprise_management::PolicyValueValidationIssue* PolicyValidationReportRequest::add_policy_value_validation_issues() {
// @@protoc_insertion_point(field_add:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
return policy_value_validation_issues_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >&
PolicyValidationReportRequest::policy_value_validation_issues() const {
// @@protoc_insertion_point(field_list:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
return policy_value_validation_issues_;
}

// -------------------------------------------------------------------

// PolicyValidationReportResponse

// -------------------------------------------------------------------

// AndroidStatus

// optional string status_payload = 1;
inline bool AndroidStatus::has_status_payload() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidStatus::clear_status_payload() {
status_payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidStatus::status_payload() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidStatus.status_payload)
return status_payload_.GetNoArena();
}
inline void AndroidStatus::set_status_payload(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
status_payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AndroidStatus.status_payload)
}
inline void AndroidStatus::set_status_payload(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
status_payload_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AndroidStatus.status_payload)
}
inline void AndroidStatus::set_status_payload(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
status_payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AndroidStatus.status_payload)
}
inline void AndroidStatus::set_status_payload(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
status_payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidStatus.status_payload)
}
inline std::string* AndroidStatus::mutable_status_payload() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AndroidStatus.status_payload)
return status_payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AndroidStatus::release_status_payload() {
// @@protoc_insertion_point(field_release:enterprise_management.AndroidStatus.status_payload)
if (!has_status_payload()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return status_payload_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidStatus::set_allocated_status_payload(std::string* status_payload) {
if (status_payload != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
status_payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status_payload);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidStatus.status_payload)
}

// optional string droid_guard_info = 2;
inline bool AndroidStatus::has_droid_guard_info() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidStatus::clear_droid_guard_info() {
droid_guard_info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AndroidStatus::droid_guard_info() const {
// @@protoc_insertion_point(field_get:enterprise_management.AndroidStatus.droid_guard_info)
return droid_guard_info_.GetNoArena();
}
inline void AndroidStatus::set_droid_guard_info(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
droid_guard_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AndroidStatus.droid_guard_info)
}
inline void AndroidStatus::set_droid_guard_info(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
droid_guard_info_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AndroidStatus.droid_guard_info)
}
inline void AndroidStatus::set_droid_guard_info(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
droid_guard_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AndroidStatus.droid_guard_info)
}
inline void AndroidStatus::set_droid_guard_info(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
droid_guard_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidStatus.droid_guard_info)
}
inline std::string* AndroidStatus::mutable_droid_guard_info() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AndroidStatus.droid_guard_info)
return droid_guard_info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AndroidStatus::release_droid_guard_info() {
// @@protoc_insertion_point(field_release:enterprise_management.AndroidStatus.droid_guard_info)
if (!has_droid_guard_info()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return droid_guard_info_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidStatus::set_allocated_droid_guard_info(std::string* droid_guard_info) {
if (droid_guard_info != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
droid_guard_info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), droid_guard_info);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidStatus.droid_guard_info)
}

// -------------------------------------------------------------------

// CrostiniApp

// optional string app_name = 1;
inline bool CrostiniApp::has_app_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrostiniApp::clear_app_name() {
app_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrostiniApp::app_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.app_name)
return app_name_.GetNoArena();
}
inline void CrostiniApp::set_app_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.app_name)
}
inline void CrostiniApp::set_app_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
app_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrostiniApp.app_name)
}
inline void CrostiniApp::set_app_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrostiniApp.app_name)
}
inline void CrostiniApp::set_app_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
app_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrostiniApp.app_name)
}
inline std::string* CrostiniApp::mutable_app_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.app_name)
return app_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrostiniApp::release_app_name() {
// @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.app_name)
if (!has_app_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return app_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrostiniApp::set_allocated_app_name(std::string* app_name) {
if (app_name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
app_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.app_name)
}

// optional .enterprise_management.CrostiniAppType app_type = 2;
inline bool CrostiniApp::has_app_type() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CrostiniApp::clear_app_type() {
app_type_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::CrostiniAppType CrostiniApp::app_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.app_type)
return static_cast< ::enterprise_management::CrostiniAppType >(app_type_);
}
inline void CrostiniApp::set_app_type(::enterprise_management::CrostiniAppType value) {
assert(::enterprise_management::CrostiniAppType_IsValid(value));
_has_bits_[0] |= 0x00000020u;
app_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.app_type)
}

// optional int64 last_launch_time_window_start_timestamp = 3;
inline bool CrostiniApp::has_last_launch_time_window_start_timestamp() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CrostiniApp::clear_last_launch_time_window_start_timestamp() {
last_launch_time_window_start_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CrostiniApp::last_launch_time_window_start_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.last_launch_time_window_start_timestamp)
return last_launch_time_window_start_timestamp_;
}
inline void CrostiniApp::set_last_launch_time_window_start_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000010u;
last_launch_time_window_start_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.last_launch_time_window_start_timestamp)
}

// optional string package_name = 4;
inline bool CrostiniApp::has_package_name() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrostiniApp::clear_package_name() {
package_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CrostiniApp::package_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.package_name)
return package_name_.GetNoArena();
}
inline void CrostiniApp::set_package_name(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.package_name)
}
inline void CrostiniApp::set_package_name(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
package_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrostiniApp.package_name)
}
inline void CrostiniApp::set_package_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrostiniApp.package_name)
}
inline void CrostiniApp::set_package_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrostiniApp.package_name)
}
inline std::string* CrostiniApp::mutable_package_name() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.package_name)
return package_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrostiniApp::release_package_name() {
// @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.package_name)
if (!has_package_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return package_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrostiniApp::set_allocated_package_name(std::string* package_name) {
if (package_name != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
package_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.package_name)
}

// optional string package_version = 5;
inline bool CrostiniApp::has_package_version() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrostiniApp::clear_package_version() {
package_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CrostiniApp::package_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.package_version)
return package_version_.GetNoArena();
}
inline void CrostiniApp::set_package_version(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
package_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.package_version)
}
inline void CrostiniApp::set_package_version(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
package_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrostiniApp.package_version)
}
inline void CrostiniApp::set_package_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
package_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrostiniApp.package_version)
}
inline void CrostiniApp::set_package_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
package_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrostiniApp.package_version)
}
inline std::string* CrostiniApp::mutable_package_version() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.package_version)
return package_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrostiniApp::release_package_version() {
// @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.package_version)
if (!has_package_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return package_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrostiniApp::set_allocated_package_version(std::string* package_version) {
if (package_version != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
package_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.package_version)
}

// optional string package_hash = 6;
inline bool CrostiniApp::has_package_hash() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CrostiniApp::clear_package_hash() {
package_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CrostiniApp::package_hash() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.package_hash)
return package_hash_.GetNoArena();
}
inline void CrostiniApp::set_package_hash(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
package_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.package_hash)
}
inline void CrostiniApp::set_package_hash(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
package_hash_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrostiniApp.package_hash)
}
inline void CrostiniApp::set_package_hash(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
package_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrostiniApp.package_hash)
}
inline void CrostiniApp::set_package_hash(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
package_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrostiniApp.package_hash)
}
inline std::string* CrostiniApp::mutable_package_hash() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.package_hash)
return package_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrostiniApp::release_package_hash() {
// @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.package_hash)
if (!has_package_hash()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return package_hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrostiniApp::set_allocated_package_hash(std::string* package_hash) {
if (package_hash != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
package_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package_hash);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.package_hash)
}

// -------------------------------------------------------------------

// CrostiniStatus

// optional int64 last_launch_time_window_start_timestamp = 1;
inline bool CrostiniStatus::has_last_launch_time_window_start_timestamp() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrostiniStatus::clear_last_launch_time_window_start_timestamp() {
last_launch_time_window_start_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CrostiniStatus::last_launch_time_window_start_timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.last_launch_time_window_start_timestamp)
return last_launch_time_window_start_timestamp_;
}
inline void CrostiniStatus::set_last_launch_time_window_start_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
last_launch_time_window_start_timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniStatus.last_launch_time_window_start_timestamp)
}

// optional string last_launch_vm_image_version = 2;
inline bool CrostiniStatus::has_last_launch_vm_image_version() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrostiniStatus::clear_last_launch_vm_image_version() {
last_launch_vm_image_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrostiniStatus::last_launch_vm_image_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
return last_launch_vm_image_version_.GetNoArena();
}
inline void CrostiniStatus::set_last_launch_vm_image_version(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
last_launch_vm_image_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
}
inline void CrostiniStatus::set_last_launch_vm_image_version(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
last_launch_vm_image_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
}
inline void CrostiniStatus::set_last_launch_vm_image_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
last_launch_vm_image_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
}
inline void CrostiniStatus::set_last_launch_vm_image_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
last_launch_vm_image_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
}
inline std::string* CrostiniStatus::mutable_last_launch_vm_image_version() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
return last_launch_vm_image_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrostiniStatus::release_last_launch_vm_image_version() {
// @@protoc_insertion_point(field_release:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
if (!has_last_launch_vm_image_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return last_launch_vm_image_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrostiniStatus::set_allocated_last_launch_vm_image_version(std::string* last_launch_vm_image_version) {
if (last_launch_vm_image_version != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
last_launch_vm_image_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_launch_vm_image_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
}

// optional string last_launch_vm_kernel_version = 3;
inline bool CrostiniStatus::has_last_launch_vm_kernel_version() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrostiniStatus::clear_last_launch_vm_kernel_version() {
last_launch_vm_kernel_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CrostiniStatus::last_launch_vm_kernel_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
return last_launch_vm_kernel_version_.GetNoArena();
}
inline void CrostiniStatus::set_last_launch_vm_kernel_version(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
last_launch_vm_kernel_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
}
inline void CrostiniStatus::set_last_launch_vm_kernel_version(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
last_launch_vm_kernel_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
}
inline void CrostiniStatus::set_last_launch_vm_kernel_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
last_launch_vm_kernel_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
}
inline void CrostiniStatus::set_last_launch_vm_kernel_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
last_launch_vm_kernel_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
}
inline std::string* CrostiniStatus::mutable_last_launch_vm_kernel_version() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
return last_launch_vm_kernel_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrostiniStatus::release_last_launch_vm_kernel_version() {
// @@protoc_insertion_point(field_release:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
if (!has_last_launch_vm_kernel_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return last_launch_vm_kernel_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrostiniStatus::set_allocated_last_launch_vm_kernel_version(std::string* last_launch_vm_kernel_version) {
if (last_launch_vm_kernel_version != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
last_launch_vm_kernel_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_launch_vm_kernel_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
}

// repeated .enterprise_management.CrostiniApp installed_apps = 4;
inline int CrostiniStatus::installed_apps_size() const {
return installed_apps_.size();
}
inline void CrostiniStatus::clear_installed_apps() {
installed_apps_.Clear();
}
inline ::enterprise_management::CrostiniApp* CrostiniStatus::mutable_installed_apps(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniStatus.installed_apps)
return installed_apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >*
CrostiniStatus::mutable_installed_apps() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.CrostiniStatus.installed_apps)
return &installed_apps_;
}
inline const ::enterprise_management::CrostiniApp& CrostiniStatus::installed_apps(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.installed_apps)
return installed_apps_.Get(index);
}
inline ::enterprise_management::CrostiniApp* CrostiniStatus::add_installed_apps() {
// @@protoc_insertion_point(field_add:enterprise_management.CrostiniStatus.installed_apps)
return installed_apps_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >&
CrostiniStatus::installed_apps() const {
// @@protoc_insertion_point(field_list:enterprise_management.CrostiniStatus.installed_apps)
return installed_apps_;
}

// -------------------------------------------------------------------

// SessionStatusReportRequest

// optional string device_local_account_id = 4;
inline bool SessionStatusReportRequest::has_device_local_account_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStatusReportRequest::clear_device_local_account_id() {
device_local_account_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionStatusReportRequest::device_local_account_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.device_local_account_id)
return device_local_account_id_.GetNoArena();
}
inline void SessionStatusReportRequest::set_device_local_account_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
device_local_account_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline void SessionStatusReportRequest::set_device_local_account_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
device_local_account_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline void SessionStatusReportRequest::set_device_local_account_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
device_local_account_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline void SessionStatusReportRequest::set_device_local_account_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
device_local_account_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline std::string* SessionStatusReportRequest::mutable_device_local_account_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.device_local_account_id)
return device_local_account_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionStatusReportRequest::release_device_local_account_id() {
// @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.device_local_account_id)
if (!has_device_local_account_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return device_local_account_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportRequest::set_allocated_device_local_account_id(std::string* device_local_account_id) {
if (device_local_account_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
device_local_account_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_local_account_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}

// repeated .enterprise_management.AppStatus installed_apps = 5;
inline int SessionStatusReportRequest::installed_apps_size() const {
return installed_apps_.size();
}
inline void SessionStatusReportRequest::clear_installed_apps() {
installed_apps_.Clear();
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::mutable_installed_apps(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.installed_apps)
return installed_apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >*
SessionStatusReportRequest::mutable_installed_apps() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.installed_apps)
return &installed_apps_;
}
inline const ::enterprise_management::AppStatus& SessionStatusReportRequest::installed_apps(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.installed_apps)
return installed_apps_.Get(index);
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::add_installed_apps() {
// @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.installed_apps)
return installed_apps_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >&
SessionStatusReportRequest::installed_apps() const {
// @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.installed_apps)
return installed_apps_;
}

// optional .enterprise_management.AndroidStatus android_status = 7;
inline bool SessionStatusReportRequest::has_android_status() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionStatusReportRequest::clear_android_status() {
if (android_status_ != nullptr) android_status_->Clear();
_has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::AndroidStatus& SessionStatusReportRequest::android_status() const {
const ::enterprise_management::AndroidStatus* p = android_status_;
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.android_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::AndroidStatus*>(
&::enterprise_management::_AndroidStatus_default_instance_);
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::release_android_status() {
// @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.android_status)
_has_bits_[0] &= ~0x00000008u;
::enterprise_management::AndroidStatus* temp = android_status_;
android_status_ = nullptr;
return temp;
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::mutable_android_status() {
_has_bits_[0] |= 0x00000008u;
if (android_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::AndroidStatus>(GetArenaNoVirtual());
android_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.android_status)
return android_status_;
}
inline void SessionStatusReportRequest::set_allocated_android_status(::enterprise_management::AndroidStatus* android_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete android_status_;
}
if (android_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
android_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, android_status, submessage_arena);
}
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
android_status_ = android_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.android_status)
}

// optional string user_dm_token = 8;
inline bool SessionStatusReportRequest::has_user_dm_token() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStatusReportRequest::clear_user_dm_token() {
user_dm_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SessionStatusReportRequest::user_dm_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.user_dm_token)
return user_dm_token_.GetNoArena();
}
inline void SessionStatusReportRequest::set_user_dm_token(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
user_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.user_dm_token)
}
inline void SessionStatusReportRequest::set_user_dm_token(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
user_dm_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SessionStatusReportRequest.user_dm_token)
}
inline void SessionStatusReportRequest::set_user_dm_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
user_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportRequest.user_dm_token)
}
inline void SessionStatusReportRequest::set_user_dm_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
user_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportRequest.user_dm_token)
}
inline std::string* SessionStatusReportRequest::mutable_user_dm_token() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.user_dm_token)
return user_dm_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionStatusReportRequest::release_user_dm_token() {
// @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.user_dm_token)
if (!has_user_dm_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return user_dm_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportRequest::set_allocated_user_dm_token(std::string* user_dm_token) {
if (user_dm_token != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
user_dm_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_dm_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.user_dm_token)
}

// optional string time_zone = 9;
inline bool SessionStatusReportRequest::has_time_zone() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionStatusReportRequest::clear_time_zone() {
time_zone_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SessionStatusReportRequest::time_zone() const {
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.time_zone)
return time_zone_.GetNoArena();
}
inline void SessionStatusReportRequest::set_time_zone(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
time_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.time_zone)
}
inline void SessionStatusReportRequest::set_time_zone(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
time_zone_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SessionStatusReportRequest.time_zone)
}
inline void SessionStatusReportRequest::set_time_zone(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
time_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportRequest.time_zone)
}
inline void SessionStatusReportRequest::set_time_zone(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
time_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportRequest.time_zone)
}
inline std::string* SessionStatusReportRequest::mutable_time_zone() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.time_zone)
return time_zone_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionStatusReportRequest::release_time_zone() {
// @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.time_zone)
if (!has_time_zone()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return time_zone_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportRequest::set_allocated_time_zone(std::string* time_zone) {
if (time_zone != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
time_zone_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time_zone);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.time_zone)
}

// optional .enterprise_management.CrostiniStatus crostini_status = 10;
inline bool SessionStatusReportRequest::has_crostini_status() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionStatusReportRequest::clear_crostini_status() {
if (crostini_status_ != nullptr) crostini_status_->Clear();
_has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::CrostiniStatus& SessionStatusReportRequest::crostini_status() const {
const ::enterprise_management::CrostiniStatus* p = crostini_status_;
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.crostini_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CrostiniStatus*>(
&::enterprise_management::_CrostiniStatus_default_instance_);
}
inline ::enterprise_management::CrostiniStatus* SessionStatusReportRequest::release_crostini_status() {
// @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.crostini_status)
_has_bits_[0] &= ~0x00000010u;
::enterprise_management::CrostiniStatus* temp = crostini_status_;
crostini_status_ = nullptr;
return temp;
}
inline ::enterprise_management::CrostiniStatus* SessionStatusReportRequest::mutable_crostini_status() {
_has_bits_[0] |= 0x00000010u;
if (crostini_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CrostiniStatus>(GetArenaNoVirtual());
crostini_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.crostini_status)
return crostini_status_;
}
inline void SessionStatusReportRequest::set_allocated_crostini_status(::enterprise_management::CrostiniStatus* crostini_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete crostini_status_;
}
if (crostini_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
crostini_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, crostini_status, submessage_arena);
}
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
crostini_status_ = crostini_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.crostini_status)
}

// repeated .enterprise_management.AppInfo app_infos = 11;
inline int SessionStatusReportRequest::app_infos_size() const {
return app_infos_.size();
}
inline void SessionStatusReportRequest::clear_app_infos() {
app_infos_.Clear();
}
inline ::enterprise_management::AppInfo* SessionStatusReportRequest::mutable_app_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.app_infos)
return app_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >*
SessionStatusReportRequest::mutable_app_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.app_infos)
return &app_infos_;
}
inline const ::enterprise_management::AppInfo& SessionStatusReportRequest::app_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.app_infos)
return app_infos_.Get(index);
}
inline ::enterprise_management::AppInfo* SessionStatusReportRequest::add_app_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.app_infos)
return app_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >&
SessionStatusReportRequest::app_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.app_infos)
return app_infos_;
}

// -------------------------------------------------------------------

// DeviceStatusReportResponse

// optional int32 error_code = 1;
inline bool DeviceStatusReportResponse::has_error_code() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStatusReportResponse::clear_error_code() {
error_code_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceStatusReportResponse::error_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportResponse.error_code)
return error_code_;
}
inline void DeviceStatusReportResponse::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
error_code_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool DeviceStatusReportResponse::has_error_message() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStatusReportResponse::clear_error_message() {
error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStatusReportResponse::error_message() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportResponse.error_message)
return error_message_.GetNoArena();
}
inline void DeviceStatusReportResponse::set_error_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline void DeviceStatusReportResponse::set_error_message(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline void DeviceStatusReportResponse::set_error_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline void DeviceStatusReportResponse::set_error_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline std::string* DeviceStatusReportResponse::mutable_error_message() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportResponse.error_message)
return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceStatusReportResponse::release_error_message() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportResponse.error_message)
if (!has_error_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return error_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportResponse::set_allocated_error_message(std::string* error_message) {
if (error_message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// ChromeDesktopReportResponse

// -------------------------------------------------------------------

// ChromeOsUserReportResponse

// -------------------------------------------------------------------

// SessionStatusReportResponse

// optional int32 error_code = 1;
inline bool SessionStatusReportResponse::has_error_code() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStatusReportResponse::clear_error_code() {
error_code_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SessionStatusReportResponse::error_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportResponse.error_code)
return error_code_;
}
inline void SessionStatusReportResponse::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
error_code_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool SessionStatusReportResponse::has_error_message() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStatusReportResponse::clear_error_message() {
error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionStatusReportResponse::error_message() const {
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportResponse.error_message)
return error_message_.GetNoArena();
}
inline void SessionStatusReportResponse::set_error_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportResponse.error_message)
}
inline void SessionStatusReportResponse::set_error_message(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SessionStatusReportResponse.error_message)
}
inline void SessionStatusReportResponse::set_error_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportResponse.error_message)
}
inline void SessionStatusReportResponse::set_error_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportResponse.error_message)
}
inline std::string* SessionStatusReportResponse::mutable_error_message() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportResponse.error_message)
return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionStatusReportResponse::release_error_message() {
// @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportResponse.error_message)
if (!has_error_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return error_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportResponse::set_allocated_error_message(std::string* error_message) {
if (error_message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// DeviceAutoEnrollmentRequest

// optional int64 remainder = 1;
inline bool DeviceAutoEnrollmentRequest::has_remainder() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAutoEnrollmentRequest::clear_remainder() {
remainder_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeviceAutoEnrollmentRequest::remainder() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.remainder)
return remainder_;
}
inline void DeviceAutoEnrollmentRequest::set_remainder(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
remainder_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.remainder)
}

// optional int64 modulus = 2;
inline bool DeviceAutoEnrollmentRequest::has_modulus() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAutoEnrollmentRequest::clear_modulus() {
modulus_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeviceAutoEnrollmentRequest::modulus() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.modulus)
return modulus_;
}
inline void DeviceAutoEnrollmentRequest::set_modulus(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
modulus_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.modulus)
}

// optional .enterprise_management.DeviceAutoEnrollmentRequest.EnrollmentCheckType enrollment_check_type = 3 [default = ENROLLMENT_CHECK_TYPE_FRE];
inline bool DeviceAutoEnrollmentRequest::has_enrollment_check_type() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceAutoEnrollmentRequest::clear_enrollment_check_type() {
enrollment_check_type_ = 1;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::enrollment_check_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.enrollment_check_type)
return static_cast< ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType >(enrollment_check_type_);
}
inline void DeviceAutoEnrollmentRequest::set_enrollment_check_type(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType value) {
assert(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(value));
_has_bits_[0] |= 0x00000004u;
enrollment_check_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.enrollment_check_type)
}

// -------------------------------------------------------------------

// DeviceAutoEnrollmentResponse

// optional int64 expected_modulus = 1;
inline bool DeviceAutoEnrollmentResponse::has_expected_modulus() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAutoEnrollmentResponse::clear_expected_modulus() {
expected_modulus_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeviceAutoEnrollmentResponse::expected_modulus() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentResponse.expected_modulus)
return expected_modulus_;
}
inline void DeviceAutoEnrollmentResponse::set_expected_modulus(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
expected_modulus_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.expected_modulus)
}

// repeated bytes hashes = 2;
inline int DeviceAutoEnrollmentResponse::hashes_size() const {
return hashes_.size();
}
inline void DeviceAutoEnrollmentResponse::clear_hashes() {
hashes_.Clear();
}
inline const std::string& DeviceAutoEnrollmentResponse::hashes(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
return hashes_.Get(index);
}
inline std::string* DeviceAutoEnrollmentResponse::mutable_hashes(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
return hashes_.Mutable(index);
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
hashes_.Mutable(index)->assign(value);
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
hashes_.Mutable(index)->assign(std::move(value));
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
hashes_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, const void* value, size_t size) {
hashes_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline std::string* DeviceAutoEnrollmentResponse::add_hashes() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
return hashes_.Add();
}
inline void DeviceAutoEnrollmentResponse::add_hashes(const std::string& value) {
hashes_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::add_hashes(std::string&& value) {
hashes_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::add_hashes(const char* value) {
GOOGLE_DCHECK(value != nullptr);
hashes_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::add_hashes(const void* value, size_t size) {
hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceAutoEnrollmentResponse::hashes() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
return hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceAutoEnrollmentResponse::mutable_hashes() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
return &hashes_;
}

// -------------------------------------------------------------------

// DeviceStateRetrievalRequest

// optional bytes server_backed_state_key = 1;
inline bool DeviceStateRetrievalRequest::has_server_backed_state_key() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStateRetrievalRequest::clear_server_backed_state_key() {
server_backed_state_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStateRetrievalRequest::server_backed_state_key() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
return server_backed_state_key_.GetNoArena();
}
inline void DeviceStateRetrievalRequest::set_server_backed_state_key(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
server_backed_state_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline void DeviceStateRetrievalRequest::set_server_backed_state_key(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
server_backed_state_key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline void DeviceStateRetrievalRequest::set_server_backed_state_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
server_backed_state_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline void DeviceStateRetrievalRequest::set_server_backed_state_key(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
server_backed_state_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline std::string* DeviceStateRetrievalRequest::mutable_server_backed_state_key() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
return server_backed_state_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceStateRetrievalRequest::release_server_backed_state_key() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
if (!has_server_backed_state_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return server_backed_state_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStateRetrievalRequest::set_allocated_server_backed_state_key(std::string* server_backed_state_key) {
if (server_backed_state_key != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
server_backed_state_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_backed_state_key);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}

// -------------------------------------------------------------------

// DeviceStateKeyUpdateRequest

// repeated bytes server_backed_state_keys = 1;
inline int DeviceStateKeyUpdateRequest::server_backed_state_keys_size() const {
return server_backed_state_keys_.size();
}
inline void DeviceStateKeyUpdateRequest::clear_server_backed_state_keys() {
server_backed_state_keys_.Clear();
}
inline const std::string& DeviceStateKeyUpdateRequest::server_backed_state_keys(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
return server_backed_state_keys_.Get(index);
}
inline std::string* DeviceStateKeyUpdateRequest::mutable_server_backed_state_keys(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
return server_backed_state_keys_.Mutable(index);
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
server_backed_state_keys_.Mutable(index)->assign(value);
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
server_backed_state_keys_.Mutable(index)->assign(std::move(value));
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
server_backed_state_keys_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, const void* value, size_t size) {
server_backed_state_keys_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline std::string* DeviceStateKeyUpdateRequest::add_server_backed_state_keys() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
return server_backed_state_keys_.Add();
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(const std::string& value) {
server_backed_state_keys_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(std::string&& value) {
server_backed_state_keys_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(const char* value) {
GOOGLE_DCHECK(value != nullptr);
server_backed_state_keys_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(const void* value, size_t size) {
server_backed_state_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceStateKeyUpdateRequest::server_backed_state_keys() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
return server_backed_state_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceStateKeyUpdateRequest::mutable_server_backed_state_keys() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
return &server_backed_state_keys_;
}

// -------------------------------------------------------------------

// DeviceStateRetrievalResponse

// optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
inline bool DeviceStateRetrievalResponse::has_restore_mode() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceStateRetrievalResponse::clear_restore_mode() {
restore_mode_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::restore_mode() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.restore_mode)
return static_cast< ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode >(restore_mode_);
}
inline void DeviceStateRetrievalResponse::set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value) {
assert(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode_IsValid(value));
_has_bits_[0] |= 0x00000004u;
restore_mode_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalResponse.restore_mode)
}

// optional string management_domain = 2;
inline bool DeviceStateRetrievalResponse::has_management_domain() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStateRetrievalResponse::clear_management_domain() {
management_domain_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStateRetrievalResponse::management_domain() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.management_domain)
return management_domain_.GetNoArena();
}
inline void DeviceStateRetrievalResponse::set_management_domain(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline void DeviceStateRetrievalResponse::set_management_domain(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline void DeviceStateRetrievalResponse::set_management_domain(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline void DeviceStateRetrievalResponse::set_management_domain(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline std::string* DeviceStateRetrievalResponse::mutable_management_domain() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.management_domain)
return management_domain_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceStateRetrievalResponse::release_management_domain() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.management_domain)
if (!has_management_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return management_domain_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStateRetrievalResponse::set_allocated_management_domain(std::string* management_domain) {
if (management_domain != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
management_domain_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), management_domain);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}

// optional .enterprise_management.DisabledState disabled_state = 3;
inline bool DeviceStateRetrievalResponse::has_disabled_state() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStateRetrievalResponse::clear_disabled_state() {
if (disabled_state_ != nullptr) disabled_state_->Clear();
_has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DisabledState& DeviceStateRetrievalResponse::disabled_state() const {
const ::enterprise_management::DisabledState* p = disabled_state_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DisabledState*>(
&::enterprise_management::_DisabledState_default_instance_);
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::release_disabled_state() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
_has_bits_[0] &= ~0x00000002u;
::enterprise_management::DisabledState* temp = disabled_state_;
disabled_state_ = nullptr;
return temp;
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::mutable_disabled_state() {
_has_bits_[0] |= 0x00000002u;
if (disabled_state_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DisabledState>(GetArenaNoVirtual());
disabled_state_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
return disabled_state_;
}
inline void DeviceStateRetrievalResponse::set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete disabled_state_;
}
if (disabled_state) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
disabled_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, disabled_state, submessage_arena);
}
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
disabled_state_ = disabled_state;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
}

// -------------------------------------------------------------------

// DeviceInitialEnrollmentStateRequest

// optional string serial_number = 1;
inline bool DeviceInitialEnrollmentStateRequest::has_serial_number() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInitialEnrollmentStateRequest::clear_serial_number() {
serial_number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInitialEnrollmentStateRequest::serial_number() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
return serial_number_.GetNoArena();
}
inline void DeviceInitialEnrollmentStateRequest::set_serial_number(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
}
inline void DeviceInitialEnrollmentStateRequest::set_serial_number(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
serial_number_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
}
inline void DeviceInitialEnrollmentStateRequest::set_serial_number(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
}
inline void DeviceInitialEnrollmentStateRequest::set_serial_number(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
}
inline std::string* DeviceInitialEnrollmentStateRequest::mutable_serial_number() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
return serial_number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInitialEnrollmentStateRequest::release_serial_number() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
if (!has_serial_number()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return serial_number_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInitialEnrollmentStateRequest::set_allocated_serial_number(std::string* serial_number) {
if (serial_number != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
serial_number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
}

// optional string brand_code = 2;
inline bool DeviceInitialEnrollmentStateRequest::has_brand_code() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInitialEnrollmentStateRequest::clear_brand_code() {
brand_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceInitialEnrollmentStateRequest::brand_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
return brand_code_.GetNoArena();
}
inline void DeviceInitialEnrollmentStateRequest::set_brand_code(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
brand_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
}
inline void DeviceInitialEnrollmentStateRequest::set_brand_code(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
brand_code_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
}
inline void DeviceInitialEnrollmentStateRequest::set_brand_code(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
brand_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
}
inline void DeviceInitialEnrollmentStateRequest::set_brand_code(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
brand_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
}
inline std::string* DeviceInitialEnrollmentStateRequest::mutable_brand_code() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
return brand_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInitialEnrollmentStateRequest::release_brand_code() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
if (!has_brand_code()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return brand_code_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInitialEnrollmentStateRequest::set_allocated_brand_code(std::string* brand_code) {
if (brand_code != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
brand_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brand_code);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
}

// -------------------------------------------------------------------

// DeviceInitialEnrollmentStateResponse

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse.InitialEnrollmentMode initial_enrollment_mode = 1 [default = INITIAL_ENROLLMENT_MODE_NONE];
inline bool DeviceInitialEnrollmentStateResponse::has_initial_enrollment_mode() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInitialEnrollmentStateResponse::clear_initial_enrollment_mode() {
initial_enrollment_mode_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::initial_enrollment_mode() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.initial_enrollment_mode)
return static_cast< ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode >(initial_enrollment_mode_);
}
inline void DeviceInitialEnrollmentStateResponse::set_initial_enrollment_mode(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value) {
assert(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(value));
_has_bits_[0] |= 0x00000002u;
initial_enrollment_mode_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.initial_enrollment_mode)
}

// optional string management_domain = 2;
inline bool DeviceInitialEnrollmentStateResponse::has_management_domain() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInitialEnrollmentStateResponse::clear_management_domain() {
management_domain_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInitialEnrollmentStateResponse::management_domain() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
return management_domain_.GetNoArena();
}
inline void DeviceInitialEnrollmentStateResponse::set_management_domain(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
}
inline void DeviceInitialEnrollmentStateResponse::set_management_domain(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
}
inline void DeviceInitialEnrollmentStateResponse::set_management_domain(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
}
inline void DeviceInitialEnrollmentStateResponse::set_management_domain(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
management_domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
}
inline std::string* DeviceInitialEnrollmentStateResponse::mutable_management_domain() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
return management_domain_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInitialEnrollmentStateResponse::release_management_domain() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
if (!has_management_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return management_domain_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInitialEnrollmentStateResponse::set_allocated_management_domain(std::string* management_domain) {
if (management_domain != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
management_domain_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), management_domain);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
}

// optional bool is_license_packaged_with_device = 3;
inline bool DeviceInitialEnrollmentStateResponse::has_is_license_packaged_with_device() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceInitialEnrollmentStateResponse::clear_is_license_packaged_with_device() {
is_license_packaged_with_device_ = false;
_has_bits_[0] &= ~0x00000004u;
}
inline bool DeviceInitialEnrollmentStateResponse::is_license_packaged_with_device() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.is_license_packaged_with_device)
return is_license_packaged_with_device_;
}
inline void DeviceInitialEnrollmentStateResponse::set_is_license_packaged_with_device(bool value) {
_has_bits_[0] |= 0x00000004u;
is_license_packaged_with_device_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.is_license_packaged_with_device)
}

// -------------------------------------------------------------------

// DevicePairingRequest

// optional string host_device_id = 1;
inline bool DevicePairingRequest::has_host_device_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DevicePairingRequest::clear_host_device_id() {
host_device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DevicePairingRequest::host_device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DevicePairingRequest.host_device_id)
return host_device_id_.GetNoArena();
}
inline void DevicePairingRequest::set_host_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DevicePairingRequest.host_device_id)
}
inline void DevicePairingRequest::set_host_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DevicePairingRequest.host_device_id)
}
inline void DevicePairingRequest::set_host_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DevicePairingRequest.host_device_id)
}
inline void DevicePairingRequest::set_host_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DevicePairingRequest.host_device_id)
}
inline std::string* DevicePairingRequest::mutable_host_device_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DevicePairingRequest.host_device_id)
return host_device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DevicePairingRequest::release_host_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DevicePairingRequest.host_device_id)
if (!has_host_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return host_device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DevicePairingRequest::set_allocated_host_device_id(std::string* host_device_id) {
if (host_device_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
host_device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePairingRequest.host_device_id)
}

// optional string controller_device_id = 2;
inline bool DevicePairingRequest::has_controller_device_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DevicePairingRequest::clear_controller_device_id() {
controller_device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DevicePairingRequest::controller_device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DevicePairingRequest.controller_device_id)
return controller_device_id_.GetNoArena();
}
inline void DevicePairingRequest::set_controller_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline void DevicePairingRequest::set_controller_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline void DevicePairingRequest::set_controller_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline void DevicePairingRequest::set_controller_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline std::string* DevicePairingRequest::mutable_controller_device_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DevicePairingRequest.controller_device_id)
return controller_device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DevicePairingRequest::release_controller_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DevicePairingRequest.controller_device_id)
if (!has_controller_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return controller_device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DevicePairingRequest::set_allocated_controller_device_id(std::string* controller_device_id) {
if (controller_device_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
controller_device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePairingRequest.controller_device_id)
}

// -------------------------------------------------------------------

// DevicePairingResponse

// optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
inline bool DevicePairingResponse::has_status_code() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DevicePairingResponse::clear_status_code() {
status_code_ = 1;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DevicePairingResponse_StatusCode DevicePairingResponse::status_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.DevicePairingResponse.status_code)
return static_cast< ::enterprise_management::DevicePairingResponse_StatusCode >(status_code_);
}
inline void DevicePairingResponse::set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value) {
assert(::enterprise_management::DevicePairingResponse_StatusCode_IsValid(value));
_has_bits_[0] |= 0x00000001u;
status_code_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DevicePairingResponse.status_code)
}

// -------------------------------------------------------------------

// CheckDevicePairingRequest

// optional string host_device_id = 1;
inline bool CheckDevicePairingRequest::has_host_device_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckDevicePairingRequest::clear_host_device_id() {
host_device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckDevicePairingRequest::host_device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingRequest.host_device_id)
return host_device_id_.GetNoArena();
}
inline void CheckDevicePairingRequest::set_host_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline void CheckDevicePairingRequest::set_host_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline void CheckDevicePairingRequest::set_host_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline void CheckDevicePairingRequest::set_host_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
host_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline std::string* CheckDevicePairingRequest::mutable_host_device_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CheckDevicePairingRequest.host_device_id)
return host_device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckDevicePairingRequest::release_host_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.CheckDevicePairingRequest.host_device_id)
if (!has_host_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return host_device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckDevicePairingRequest::set_allocated_host_device_id(std::string* host_device_id) {
if (host_device_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
host_device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CheckDevicePairingRequest.host_device_id)
}

// optional string controller_device_id = 2;
inline bool CheckDevicePairingRequest::has_controller_device_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckDevicePairingRequest::clear_controller_device_id() {
controller_device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CheckDevicePairingRequest::controller_device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingRequest.controller_device_id)
return controller_device_id_.GetNoArena();
}
inline void CheckDevicePairingRequest::set_controller_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline void CheckDevicePairingRequest::set_controller_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline void CheckDevicePairingRequest::set_controller_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline void CheckDevicePairingRequest::set_controller_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
controller_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline std::string* CheckDevicePairingRequest::mutable_controller_device_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CheckDevicePairingRequest.controller_device_id)
return controller_device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckDevicePairingRequest::release_controller_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.CheckDevicePairingRequest.controller_device_id)
if (!has_controller_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return controller_device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckDevicePairingRequest::set_allocated_controller_device_id(std::string* controller_device_id) {
if (controller_device_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
controller_device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}

// -------------------------------------------------------------------

// CheckDevicePairingResponse

// optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
inline bool CheckDevicePairingResponse::has_status_code() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckDevicePairingResponse::clear_status_code() {
status_code_ = 1;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::status_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingResponse.status_code)
return static_cast< ::enterprise_management::CheckDevicePairingResponse_StatusCode >(status_code_);
}
inline void CheckDevicePairingResponse::set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value) {
assert(::enterprise_management::CheckDevicePairingResponse_StatusCode_IsValid(value));
_has_bits_[0] |= 0x00000001u;
status_code_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingResponse.status_code)
}

// -------------------------------------------------------------------

// RemoteCommand

// optional .enterprise_management.RemoteCommand.Type type = 1;
inline bool RemoteCommand::has_type() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoteCommand::clear_type() {
type_ = -1;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::RemoteCommand_Type RemoteCommand::type() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.type)
return static_cast< ::enterprise_management::RemoteCommand_Type >(type_);
}
inline void RemoteCommand::set_type(::enterprise_management::RemoteCommand_Type value) {
assert(::enterprise_management::RemoteCommand_Type_IsValid(value));
_has_bits_[0] |= 0x00000010u;
type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.type)
}

// optional int64 command_id = 2;
inline bool RemoteCommand::has_command_id() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteCommand::clear_command_id() {
command_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteCommand::command_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.command_id)
return command_id_;
}
inline void RemoteCommand::set_command_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
command_id_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.command_id)
}

// optional int64 age_of_command = 3;
inline bool RemoteCommand::has_age_of_command() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteCommand::clear_age_of_command() {
age_of_command_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteCommand::age_of_command() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.age_of_command)
return age_of_command_;
}
inline void RemoteCommand::set_age_of_command(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000008u;
age_of_command_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.age_of_command)
}

// optional string payload = 4;
inline bool RemoteCommand::has_payload() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteCommand::clear_payload() {
payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoteCommand::payload() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.payload)
return payload_.GetNoArena();
}
inline void RemoteCommand::set_payload(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.payload)
}
inline void RemoteCommand::set_payload(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RemoteCommand.payload)
}
inline void RemoteCommand::set_payload(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RemoteCommand.payload)
}
inline void RemoteCommand::set_payload(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RemoteCommand.payload)
}
inline std::string* RemoteCommand::mutable_payload() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommand.payload)
return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RemoteCommand::release_payload() {
// @@protoc_insertion_point(field_release:enterprise_management.RemoteCommand.payload)
if (!has_payload()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return payload_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteCommand::set_allocated_payload(std::string* payload) {
if (payload != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommand.payload)
}

// optional string target_device_id = 5;
inline bool RemoteCommand::has_target_device_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteCommand::clear_target_device_id() {
target_device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RemoteCommand::target_device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.target_device_id)
return target_device_id_.GetNoArena();
}
inline void RemoteCommand::set_target_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
target_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.target_device_id)
}
inline void RemoteCommand::set_target_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
target_device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RemoteCommand.target_device_id)
}
inline void RemoteCommand::set_target_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
target_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RemoteCommand.target_device_id)
}
inline void RemoteCommand::set_target_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
target_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RemoteCommand.target_device_id)
}
inline std::string* RemoteCommand::mutable_target_device_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommand.target_device_id)
return target_device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RemoteCommand::release_target_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.RemoteCommand.target_device_id)
if (!has_target_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return target_device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteCommand::set_allocated_target_device_id(std::string* target_device_id) {
if (target_device_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
target_device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommand.target_device_id)
}

// -------------------------------------------------------------------

// RemoteCommandResult

// optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
inline bool RemoteCommandResult::has_result() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteCommandResult::clear_result() {
result_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::RemoteCommandResult_ResultType RemoteCommandResult::result() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.result)
return static_cast< ::enterprise_management::RemoteCommandResult_ResultType >(result_);
}
inline void RemoteCommandResult::set_result(::enterprise_management::RemoteCommandResult_ResultType value) {
assert(::enterprise_management::RemoteCommandResult_ResultType_IsValid(value));
_has_bits_[0] |= 0x00000008u;
result_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.result)
}

// optional int64 command_id = 2;
inline bool RemoteCommandResult::has_command_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteCommandResult::clear_command_id() {
command_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteCommandResult::command_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.command_id)
return command_id_;
}
inline void RemoteCommandResult::set_command_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
command_id_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.command_id)
}

// optional int64 timestamp = 3;
inline bool RemoteCommandResult::has_timestamp() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteCommandResult::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteCommandResult::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.timestamp)
return timestamp_;
}
inline void RemoteCommandResult::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.timestamp)
}

// optional string payload = 4;
inline bool RemoteCommandResult::has_payload() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteCommandResult::clear_payload() {
payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoteCommandResult::payload() const {
// @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.payload)
return payload_.GetNoArena();
}
inline void RemoteCommandResult::set_payload(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.payload)
}
inline void RemoteCommandResult::set_payload(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RemoteCommandResult.payload)
}
inline void RemoteCommandResult::set_payload(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RemoteCommandResult.payload)
}
inline void RemoteCommandResult::set_payload(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RemoteCommandResult.payload)
}
inline std::string* RemoteCommandResult::mutable_payload() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommandResult.payload)
return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RemoteCommandResult::release_payload() {
// @@protoc_insertion_point(field_release:enterprise_management.RemoteCommandResult.payload)
if (!has_payload()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return payload_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteCommandResult::set_allocated_payload(std::string* payload) {
if (payload != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommandResult.payload)
}

// -------------------------------------------------------------------

// DeviceRemoteCommandRequest

// optional int64 last_command_unique_id = 1;
inline bool DeviceRemoteCommandRequest::has_last_command_unique_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRemoteCommandRequest::clear_last_command_unique_id() {
last_command_unique_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeviceRemoteCommandRequest::last_command_unique_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.last_command_unique_id)
return last_command_unique_id_;
}
inline void DeviceRemoteCommandRequest::set_last_command_unique_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
last_command_unique_id_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRemoteCommandRequest.last_command_unique_id)
}

// repeated .enterprise_management.RemoteCommandResult command_results = 2;
inline int DeviceRemoteCommandRequest::command_results_size() const {
return command_results_.size();
}
inline void DeviceRemoteCommandRequest::clear_command_results() {
command_results_.Clear();
}
inline ::enterprise_management::RemoteCommandResult* DeviceRemoteCommandRequest::mutable_command_results(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandRequest.command_results)
return command_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >*
DeviceRemoteCommandRequest::mutable_command_results() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandRequest.command_results)
return &command_results_;
}
inline const ::enterprise_management::RemoteCommandResult& DeviceRemoteCommandRequest::command_results(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.command_results)
return command_results_.Get(index);
}
inline ::enterprise_management::RemoteCommandResult* DeviceRemoteCommandRequest::add_command_results() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandRequest.command_results)
return command_results_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >&
DeviceRemoteCommandRequest::command_results() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandRequest.command_results)
return command_results_;
}

// optional bool send_secure_commands = 3;
inline bool DeviceRemoteCommandRequest::has_send_secure_commands() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceRemoteCommandRequest::clear_send_secure_commands() {
send_secure_commands_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool DeviceRemoteCommandRequest::send_secure_commands() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.send_secure_commands)
return send_secure_commands_;
}
inline void DeviceRemoteCommandRequest::set_send_secure_commands(bool value) {
_has_bits_[0] |= 0x00000002u;
send_secure_commands_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRemoteCommandRequest.send_secure_commands)
}

// optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 4;
inline bool DeviceRemoteCommandRequest::has_signature_type() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceRemoteCommandRequest::clear_signature_type() {
signature_type_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType DeviceRemoteCommandRequest::signature_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.signature_type)
return static_cast< ::enterprise_management::PolicyFetchRequest_SignatureType >(signature_type_);
}
inline void DeviceRemoteCommandRequest::set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
assert(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(value));
_has_bits_[0] |= 0x00000004u;
signature_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRemoteCommandRequest.signature_type)
}

// -------------------------------------------------------------------

// DeviceRemoteCommandResponse

// repeated .enterprise_management.RemoteCommand commands = 1;
inline int DeviceRemoteCommandResponse::commands_size() const {
return commands_.size();
}
inline void DeviceRemoteCommandResponse::clear_commands() {
commands_.Clear();
}
inline ::enterprise_management::RemoteCommand* DeviceRemoteCommandResponse::mutable_commands(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandResponse.commands)
return commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >*
DeviceRemoteCommandResponse::mutable_commands() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandResponse.commands)
return &commands_;
}
inline const ::enterprise_management::RemoteCommand& DeviceRemoteCommandResponse::commands(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandResponse.commands)
return commands_.Get(index);
}
inline ::enterprise_management::RemoteCommand* DeviceRemoteCommandResponse::add_commands() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandResponse.commands)
return commands_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >&
DeviceRemoteCommandResponse::commands() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandResponse.commands)
return commands_;
}

// repeated .enterprise_management.SignedData secure_commands = 2;
inline int DeviceRemoteCommandResponse::secure_commands_size() const {
return secure_commands_.size();
}
inline void DeviceRemoteCommandResponse::clear_secure_commands() {
secure_commands_.Clear();
}
inline ::enterprise_management::SignedData* DeviceRemoteCommandResponse::mutable_secure_commands(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
return secure_commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >*
DeviceRemoteCommandResponse::mutable_secure_commands() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
return &secure_commands_;
}
inline const ::enterprise_management::SignedData& DeviceRemoteCommandResponse::secure_commands(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
return secure_commands_.Get(index);
}
inline ::enterprise_management::SignedData* DeviceRemoteCommandResponse::add_secure_commands() {
// @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
return secure_commands_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >&
DeviceRemoteCommandResponse::secure_commands() const {
// @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
return secure_commands_;
}

// -------------------------------------------------------------------

// DeviceAttributeUpdatePermissionRequest

// -------------------------------------------------------------------

// DeviceAttributeUpdatePermissionResponse

// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
inline bool DeviceAttributeUpdatePermissionResponse::has_result() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAttributeUpdatePermissionResponse::clear_result() {
result_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::result() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdatePermissionResponse.result)
return static_cast< ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType >(result_);
}
inline void DeviceAttributeUpdatePermissionResponse::set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value) {
assert(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(value));
_has_bits_[0] |= 0x00000001u;
result_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdatePermissionResponse.result)
}

// -------------------------------------------------------------------

// DeviceAttributeUpdateRequest

// optional string asset_id = 1;
inline bool DeviceAttributeUpdateRequest::has_asset_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAttributeUpdateRequest::clear_asset_id() {
asset_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceAttributeUpdateRequest::asset_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
return asset_id_.GetNoArena();
}
inline void DeviceAttributeUpdateRequest::set_asset_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
asset_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline void DeviceAttributeUpdateRequest::set_asset_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
asset_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline void DeviceAttributeUpdateRequest::set_asset_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
asset_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline void DeviceAttributeUpdateRequest::set_asset_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
asset_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline std::string* DeviceAttributeUpdateRequest::mutable_asset_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
return asset_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceAttributeUpdateRequest::release_asset_id() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
if (!has_asset_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return asset_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceAttributeUpdateRequest::set_allocated_asset_id(std::string* asset_id) {
if (asset_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
asset_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}

// optional string location = 2;
inline bool DeviceAttributeUpdateRequest::has_location() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAttributeUpdateRequest::clear_location() {
location_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceAttributeUpdateRequest::location() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateRequest.location)
return location_.GetNoArena();
}
inline void DeviceAttributeUpdateRequest::set_location(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline void DeviceAttributeUpdateRequest::set_location(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
location_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline void DeviceAttributeUpdateRequest::set_location(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline void DeviceAttributeUpdateRequest::set_location(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline std::string* DeviceAttributeUpdateRequest::mutable_location() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAttributeUpdateRequest.location)
return location_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceAttributeUpdateRequest::release_location() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceAttributeUpdateRequest.location)
if (!has_location()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return location_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceAttributeUpdateRequest::set_allocated_location(std::string* location) {
if (location != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
location_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceAttributeUpdateRequest.location)
}

// -------------------------------------------------------------------

// DeviceAttributeUpdateResponse

// optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
inline bool DeviceAttributeUpdateResponse::has_result() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAttributeUpdateResponse::clear_result() {
result_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::result() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateResponse.result)
return static_cast< ::enterprise_management::DeviceAttributeUpdateResponse_ResultType >(result_);
}
inline void DeviceAttributeUpdateResponse::set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value) {
assert(::enterprise_management::DeviceAttributeUpdateResponse_ResultType_IsValid(value));
_has_bits_[0] |= 0x00000001u;
result_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateResponse.result)
}

// -------------------------------------------------------------------

// GcmIdUpdateRequest

// optional string gcm_id = 1;
inline bool GcmIdUpdateRequest::has_gcm_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GcmIdUpdateRequest::clear_gcm_id() {
gcm_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GcmIdUpdateRequest::gcm_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.GcmIdUpdateRequest.gcm_id)
return gcm_id_.GetNoArena();
}
inline void GcmIdUpdateRequest::set_gcm_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
gcm_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline void GcmIdUpdateRequest::set_gcm_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
gcm_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline void GcmIdUpdateRequest::set_gcm_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
gcm_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline void GcmIdUpdateRequest::set_gcm_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
gcm_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline std::string* GcmIdUpdateRequest::mutable_gcm_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.GcmIdUpdateRequest.gcm_id)
return gcm_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GcmIdUpdateRequest::release_gcm_id() {
// @@protoc_insertion_point(field_release:enterprise_management.GcmIdUpdateRequest.gcm_id)
if (!has_gcm_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return gcm_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GcmIdUpdateRequest::set_allocated_gcm_id(std::string* gcm_id) {
if (gcm_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
gcm_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gcm_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.GcmIdUpdateRequest.gcm_id)
}

// -------------------------------------------------------------------

// GcmIdUpdateResponse

// -------------------------------------------------------------------

// CheckAndroidManagementRequest

// -------------------------------------------------------------------

// CheckAndroidManagementResponse

// -------------------------------------------------------------------

// CertificateBasedDeviceRegisterRequest

// optional .enterprise_management.SignedData signed_request = 1;
inline bool CertificateBasedDeviceRegisterRequest::has_signed_request() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertificateBasedDeviceRegisterRequest::clear_signed_request() {
if (signed_request_ != nullptr) signed_request_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::SignedData& CertificateBasedDeviceRegisterRequest::signed_request() const {
const ::enterprise_management::SignedData* p = signed_request_;
// @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::SignedData*>(
&::enterprise_management::_SignedData_default_instance_);
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::release_signed_request() {
// @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::SignedData* temp = signed_request_;
signed_request_ = nullptr;
return temp;
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::mutable_signed_request() {
_has_bits_[0] |= 0x00000001u;
if (signed_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::SignedData>(GetArenaNoVirtual());
signed_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
return signed_request_;
}
inline void CertificateBasedDeviceRegisterRequest::set_allocated_signed_request(::enterprise_management::SignedData* signed_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete signed_request_;
}
if (signed_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
signed_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, signed_request, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
signed_request_ = signed_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
}

// -------------------------------------------------------------------

// DeviceRegisterConfiguration

// optional string device_owner = 1;
inline bool DeviceRegisterConfiguration::has_device_owner() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRegisterConfiguration::clear_device_owner() {
device_owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterConfiguration::device_owner() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterConfiguration.device_owner)
return device_owner_.GetNoArena();
}
inline void DeviceRegisterConfiguration::set_device_owner(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
device_owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterConfiguration.device_owner)
}
inline void DeviceRegisterConfiguration::set_device_owner(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
device_owner_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceRegisterConfiguration.device_owner)
}
inline void DeviceRegisterConfiguration::set_device_owner(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
device_owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterConfiguration.device_owner)
}
inline void DeviceRegisterConfiguration::set_device_owner(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
device_owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterConfiguration.device_owner)
}
inline std::string* DeviceRegisterConfiguration::mutable_device_owner() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterConfiguration.device_owner)
return device_owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceRegisterConfiguration::release_device_owner() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterConfiguration.device_owner)
if (!has_device_owner()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return device_owner_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterConfiguration::set_allocated_device_owner(std::string* device_owner) {
if (device_owner != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
device_owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_owner);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterConfiguration.device_owner)
}

// -------------------------------------------------------------------

// CertificateBasedDeviceRegistrationData

// optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
inline bool CertificateBasedDeviceRegistrationData::has_certificate_type() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CertificateBasedDeviceRegistrationData::clear_certificate_type() {
certificate_type_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::certificate_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.certificate_type)
return static_cast< ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType >(certificate_type_);
}
inline void CertificateBasedDeviceRegistrationData::set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value) {
assert(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType_IsValid(value));
_has_bits_[0] |= 0x00000008u;
certificate_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CertificateBasedDeviceRegistrationData.certificate_type)
}

// optional bytes device_certificate = 2;
inline bool CertificateBasedDeviceRegistrationData::has_device_certificate() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertificateBasedDeviceRegistrationData::clear_device_certificate() {
device_certificate_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertificateBasedDeviceRegistrationData::device_certificate() const {
// @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
return device_certificate_.GetNoArena();
}
inline void CertificateBasedDeviceRegistrationData::set_device_certificate(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline void CertificateBasedDeviceRegistrationData::set_device_certificate(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline void CertificateBasedDeviceRegistrationData::set_device_certificate(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline void CertificateBasedDeviceRegistrationData::set_device_certificate(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
device_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline std::string* CertificateBasedDeviceRegistrationData::mutable_device_certificate() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
return device_certificate_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CertificateBasedDeviceRegistrationData::release_device_certificate() {
// @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
if (!has_device_certificate()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return device_certificate_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_certificate(std::string* device_certificate) {
if (device_certificate != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
device_certificate_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_certificate);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}

// optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
inline bool CertificateBasedDeviceRegistrationData::has_device_register_request() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CertificateBasedDeviceRegistrationData::clear_device_register_request() {
if (device_register_request_ != nullptr) device_register_request_->Clear();
_has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DeviceRegisterRequest& CertificateBasedDeviceRegistrationData::device_register_request() const {
const ::enterprise_management::DeviceRegisterRequest* p = device_register_request_;
// @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceRegisterRequest*>(
&::enterprise_management::_DeviceRegisterRequest_default_instance_);
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::release_device_register_request() {
// @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
_has_bits_[0] &= ~0x00000002u;
::enterprise_management::DeviceRegisterRequest* temp = device_register_request_;
device_register_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::mutable_device_register_request() {
_has_bits_[0] |= 0x00000002u;
if (device_register_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterRequest>(GetArenaNoVirtual());
device_register_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
return device_register_request_;
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_register_request(::enterprise_management::DeviceRegisterRequest* device_register_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_register_request_;
}
if (device_register_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_register_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_register_request, submessage_arena);
}
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
device_register_request_ = device_register_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
}

// optional .enterprise_management.DeviceRegisterConfiguration device_register_configuration = 4;
inline bool CertificateBasedDeviceRegistrationData::has_device_register_configuration() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CertificateBasedDeviceRegistrationData::clear_device_register_configuration() {
if (device_register_configuration_ != nullptr) device_register_configuration_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::DeviceRegisterConfiguration& CertificateBasedDeviceRegistrationData::device_register_configuration() const {
const ::enterprise_management::DeviceRegisterConfiguration* p = device_register_configuration_;
// @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceRegisterConfiguration*>(
&::enterprise_management::_DeviceRegisterConfiguration_default_instance_);
}
inline ::enterprise_management::DeviceRegisterConfiguration* CertificateBasedDeviceRegistrationData::release_device_register_configuration() {
// @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
_has_bits_[0] &= ~0x00000004u;
::enterprise_management::DeviceRegisterConfiguration* temp = device_register_configuration_;
device_register_configuration_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceRegisterConfiguration* CertificateBasedDeviceRegistrationData::mutable_device_register_configuration() {
_has_bits_[0] |= 0x00000004u;
if (device_register_configuration_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterConfiguration>(GetArenaNoVirtual());
device_register_configuration_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
return device_register_configuration_;
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_register_configuration(::enterprise_management::DeviceRegisterConfiguration* device_register_configuration) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_register_configuration_;
}
if (device_register_configuration) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_register_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_register_configuration, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
device_register_configuration_ = device_register_configuration;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
}

// -------------------------------------------------------------------

// RegisterBrowserRequest

// optional string machine_name = 1;
inline bool RegisterBrowserRequest::has_machine_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterBrowserRequest::clear_machine_name() {
machine_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterBrowserRequest::machine_name() const {
// @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.machine_name)
return machine_name_.GetNoArena();
}
inline void RegisterBrowserRequest::set_machine_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.machine_name)
}
inline void RegisterBrowserRequest::set_machine_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RegisterBrowserRequest.machine_name)
}
inline void RegisterBrowserRequest::set_machine_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RegisterBrowserRequest.machine_name)
}
inline void RegisterBrowserRequest::set_machine_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
machine_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RegisterBrowserRequest.machine_name)
}
inline std::string* RegisterBrowserRequest::mutable_machine_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.machine_name)
return machine_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegisterBrowserRequest::release_machine_name() {
// @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.machine_name)
if (!has_machine_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return machine_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterBrowserRequest::set_allocated_machine_name(std::string* machine_name) {
if (machine_name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
machine_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_name);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.machine_name)
}

// optional string os_platform = 2;
inline bool RegisterBrowserRequest::has_os_platform() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterBrowserRequest::clear_os_platform() {
os_platform_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegisterBrowserRequest::os_platform() const {
// @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.os_platform)
return os_platform_.GetNoArena();
}
inline void RegisterBrowserRequest::set_os_platform(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
os_platform_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.os_platform)
}
inline void RegisterBrowserRequest::set_os_platform(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
os_platform_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RegisterBrowserRequest.os_platform)
}
inline void RegisterBrowserRequest::set_os_platform(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
os_platform_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RegisterBrowserRequest.os_platform)
}
inline void RegisterBrowserRequest::set_os_platform(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
os_platform_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RegisterBrowserRequest.os_platform)
}
inline std::string* RegisterBrowserRequest::mutable_os_platform() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.os_platform)
return os_platform_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegisterBrowserRequest::release_os_platform() {
// @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.os_platform)
if (!has_os_platform()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return os_platform_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterBrowserRequest::set_allocated_os_platform(std::string* os_platform) {
if (os_platform != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
os_platform_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_platform);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.os_platform)
}

// optional string os_version = 3;
inline bool RegisterBrowserRequest::has_os_version() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterBrowserRequest::clear_os_version() {
os_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegisterBrowserRequest::os_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.os_version)
return os_version_.GetNoArena();
}
inline void RegisterBrowserRequest::set_os_version(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.os_version)
}
inline void RegisterBrowserRequest::set_os_version(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RegisterBrowserRequest.os_version)
}
inline void RegisterBrowserRequest::set_os_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RegisterBrowserRequest.os_version)
}
inline void RegisterBrowserRequest::set_os_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RegisterBrowserRequest.os_version)
}
inline std::string* RegisterBrowserRequest::mutable_os_version() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.os_version)
return os_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegisterBrowserRequest::release_os_version() {
// @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.os_version)
if (!has_os_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return os_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterBrowserRequest::set_allocated_os_version(std::string* os_version) {
if (os_version != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
os_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.os_version)
}

// -------------------------------------------------------------------

// ActiveDirectoryEnrollPlayUserRequest

// optional string auth_session_id = 1;
inline bool ActiveDirectoryEnrollPlayUserRequest::has_auth_session_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveDirectoryEnrollPlayUserRequest::clear_auth_session_id() {
auth_session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryEnrollPlayUserRequest::auth_session_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
return auth_session_id_.GetNoArena();
}
inline void ActiveDirectoryEnrollPlayUserRequest::set_auth_session_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
auth_session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
}
inline void ActiveDirectoryEnrollPlayUserRequest::set_auth_session_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
auth_session_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
}
inline void ActiveDirectoryEnrollPlayUserRequest::set_auth_session_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
auth_session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
}
inline void ActiveDirectoryEnrollPlayUserRequest::set_auth_session_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
auth_session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
}
inline std::string* ActiveDirectoryEnrollPlayUserRequest::mutable_auth_session_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
return auth_session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActiveDirectoryEnrollPlayUserRequest::release_auth_session_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
if (!has_auth_session_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return auth_session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActiveDirectoryEnrollPlayUserRequest::set_allocated_auth_session_id(std::string* auth_session_id) {
if (auth_session_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
auth_session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_session_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
}

// -------------------------------------------------------------------

// ActiveDirectoryEnrollPlayUserResponse

// optional string enrollment_token = 1;
inline bool ActiveDirectoryEnrollPlayUserResponse::has_enrollment_token() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveDirectoryEnrollPlayUserResponse::clear_enrollment_token() {
enrollment_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryEnrollPlayUserResponse::enrollment_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
return enrollment_token_.GetNoArena();
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_enrollment_token(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
enrollment_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_enrollment_token(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
enrollment_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_enrollment_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
enrollment_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_enrollment_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
enrollment_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::mutable_enrollment_token() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
return enrollment_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::release_enrollment_token() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
if (!has_enrollment_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return enrollment_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_allocated_enrollment_token(std::string* enrollment_token) {
if (enrollment_token != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
enrollment_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollment_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
}

// optional string user_id = 2;
inline bool ActiveDirectoryEnrollPlayUserResponse::has_user_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveDirectoryEnrollPlayUserResponse::clear_user_id() {
user_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActiveDirectoryEnrollPlayUserResponse::user_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
return user_id_.GetNoArena();
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_user_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
user_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_user_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
user_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_user_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
user_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_user_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
user_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::mutable_user_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
return user_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::release_user_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
if (!has_user_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return user_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_allocated_user_id(std::string* user_id) {
if (user_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
user_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
}

// optional .enterprise_management.SamlParametersProto saml_parameters = 3;
inline bool ActiveDirectoryEnrollPlayUserResponse::has_saml_parameters() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActiveDirectoryEnrollPlayUserResponse::clear_saml_parameters() {
if (saml_parameters_ != nullptr) saml_parameters_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::SamlParametersProto& ActiveDirectoryEnrollPlayUserResponse::saml_parameters() const {
const ::enterprise_management::SamlParametersProto* p = saml_parameters_;
// @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::SamlParametersProto*>(
&::enterprise_management::_SamlParametersProto_default_instance_);
}
inline ::enterprise_management::SamlParametersProto* ActiveDirectoryEnrollPlayUserResponse::release_saml_parameters() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
_has_bits_[0] &= ~0x00000004u;
::enterprise_management::SamlParametersProto* temp = saml_parameters_;
saml_parameters_ = nullptr;
return temp;
}
inline ::enterprise_management::SamlParametersProto* ActiveDirectoryEnrollPlayUserResponse::mutable_saml_parameters() {
_has_bits_[0] |= 0x00000004u;
if (saml_parameters_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::SamlParametersProto>(GetArenaNoVirtual());
saml_parameters_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
return saml_parameters_;
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete saml_parameters_;
}
if (saml_parameters) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
saml_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, saml_parameters, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
saml_parameters_ = saml_parameters;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
}

// -------------------------------------------------------------------

// SamlParametersProto

// optional string auth_redirect_url = 1;
inline bool SamlParametersProto::has_auth_redirect_url() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SamlParametersProto::clear_auth_redirect_url() {
auth_redirect_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SamlParametersProto::auth_redirect_url() const {
// @@protoc_insertion_point(field_get:enterprise_management.SamlParametersProto.auth_redirect_url)
return auth_redirect_url_.GetNoArena();
}
inline void SamlParametersProto::set_auth_redirect_url(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SamlParametersProto.auth_redirect_url)
}
inline void SamlParametersProto::set_auth_redirect_url(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SamlParametersProto.auth_redirect_url)
}
inline void SamlParametersProto::set_auth_redirect_url(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SamlParametersProto.auth_redirect_url)
}
inline void SamlParametersProto::set_auth_redirect_url(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SamlParametersProto.auth_redirect_url)
}
inline std::string* SamlParametersProto::mutable_auth_redirect_url() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SamlParametersProto.auth_redirect_url)
return auth_redirect_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SamlParametersProto::release_auth_redirect_url() {
// @@protoc_insertion_point(field_release:enterprise_management.SamlParametersProto.auth_redirect_url)
if (!has_auth_redirect_url()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return auth_redirect_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SamlParametersProto::set_allocated_auth_redirect_url(std::string* auth_redirect_url) {
if (auth_redirect_url != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
auth_redirect_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_redirect_url);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SamlParametersProto.auth_redirect_url)
}

// optional string auth_session_id = 2;
inline bool SamlParametersProto::has_auth_session_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SamlParametersProto::clear_auth_session_id() {
auth_session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SamlParametersProto::auth_session_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.SamlParametersProto.auth_session_id)
return auth_session_id_.GetNoArena();
}
inline void SamlParametersProto::set_auth_session_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
auth_session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.SamlParametersProto.auth_session_id)
}
inline void SamlParametersProto::set_auth_session_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
auth_session_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.SamlParametersProto.auth_session_id)
}
inline void SamlParametersProto::set_auth_session_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
auth_session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.SamlParametersProto.auth_session_id)
}
inline void SamlParametersProto::set_auth_session_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
auth_session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.SamlParametersProto.auth_session_id)
}
inline std::string* SamlParametersProto::mutable_auth_session_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.SamlParametersProto.auth_session_id)
return auth_session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SamlParametersProto::release_auth_session_id() {
// @@protoc_insertion_point(field_release:enterprise_management.SamlParametersProto.auth_session_id)
if (!has_auth_session_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return auth_session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SamlParametersProto::set_allocated_auth_session_id(std::string* auth_session_id) {
if (auth_session_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
auth_session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_session_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.SamlParametersProto.auth_session_id)
}

// -------------------------------------------------------------------

// PublicSamlUserRequest

// optional string account_id = 1;
inline bool PublicSamlUserRequest::has_account_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicSamlUserRequest::clear_account_id() {
account_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublicSamlUserRequest::account_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.PublicSamlUserRequest.account_id)
return account_id_.GetNoArena();
}
inline void PublicSamlUserRequest::set_account_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
account_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.PublicSamlUserRequest.account_id)
}
inline void PublicSamlUserRequest::set_account_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
account_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.PublicSamlUserRequest.account_id)
}
inline void PublicSamlUserRequest::set_account_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
account_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.PublicSamlUserRequest.account_id)
}
inline void PublicSamlUserRequest::set_account_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
account_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.PublicSamlUserRequest.account_id)
}
inline std::string* PublicSamlUserRequest::mutable_account_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.PublicSamlUserRequest.account_id)
return account_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicSamlUserRequest::release_account_id() {
// @@protoc_insertion_point(field_release:enterprise_management.PublicSamlUserRequest.account_id)
if (!has_account_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return account_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicSamlUserRequest::set_allocated_account_id(std::string* account_id) {
if (account_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
account_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicSamlUserRequest.account_id)
}

// -------------------------------------------------------------------

// PublicSamlUserResponse

// optional .enterprise_management.SamlParametersProto saml_parameters = 1;
inline bool PublicSamlUserResponse::has_saml_parameters() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicSamlUserResponse::clear_saml_parameters() {
if (saml_parameters_ != nullptr) saml_parameters_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::SamlParametersProto& PublicSamlUserResponse::saml_parameters() const {
const ::enterprise_management::SamlParametersProto* p = saml_parameters_;
// @@protoc_insertion_point(field_get:enterprise_management.PublicSamlUserResponse.saml_parameters)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::SamlParametersProto*>(
&::enterprise_management::_SamlParametersProto_default_instance_);
}
inline ::enterprise_management::SamlParametersProto* PublicSamlUserResponse::release_saml_parameters() {
// @@protoc_insertion_point(field_release:enterprise_management.PublicSamlUserResponse.saml_parameters)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::SamlParametersProto* temp = saml_parameters_;
saml_parameters_ = nullptr;
return temp;
}
inline ::enterprise_management::SamlParametersProto* PublicSamlUserResponse::mutable_saml_parameters() {
_has_bits_[0] |= 0x00000001u;
if (saml_parameters_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::SamlParametersProto>(GetArenaNoVirtual());
saml_parameters_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.PublicSamlUserResponse.saml_parameters)
return saml_parameters_;
}
inline void PublicSamlUserResponse::set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete saml_parameters_;
}
if (saml_parameters) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
saml_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, saml_parameters, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
saml_parameters_ = saml_parameters;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicSamlUserResponse.saml_parameters)
}

// -------------------------------------------------------------------

// ActiveDirectoryPlayActivityRequest

// optional string user_id = 1;
inline bool ActiveDirectoryPlayActivityRequest::has_user_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveDirectoryPlayActivityRequest::clear_user_id() {
user_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryPlayActivityRequest::user_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
return user_id_.GetNoArena();
}
inline void ActiveDirectoryPlayActivityRequest::set_user_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
user_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
}
inline void ActiveDirectoryPlayActivityRequest::set_user_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
user_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
}
inline void ActiveDirectoryPlayActivityRequest::set_user_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
user_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
}
inline void ActiveDirectoryPlayActivityRequest::set_user_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
user_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
}
inline std::string* ActiveDirectoryPlayActivityRequest::mutable_user_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
return user_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActiveDirectoryPlayActivityRequest::release_user_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
if (!has_user_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return user_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActiveDirectoryPlayActivityRequest::set_allocated_user_id(std::string* user_id) {
if (user_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
user_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
}

// -------------------------------------------------------------------

// ActiveDirectoryPlayActivityResponse

// -------------------------------------------------------------------

// CheckDeviceLicenseRequest

// -------------------------------------------------------------------

// LicenseAvailability

// optional .enterprise_management.LicenseType license_type_deprecated = 1 [deprecated = true];
inline bool LicenseAvailability::has_license_type_deprecated() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseAvailability::clear_license_type_deprecated() {
if (license_type_deprecated_ != nullptr) license_type_deprecated_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::LicenseType& LicenseAvailability::license_type_deprecated() const {
const ::enterprise_management::LicenseType* p = license_type_deprecated_;
// @@protoc_insertion_point(field_get:enterprise_management.LicenseAvailability.license_type_deprecated)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::LicenseType*>(
&::enterprise_management::_LicenseType_default_instance_);
}
inline ::enterprise_management::LicenseType* LicenseAvailability::release_license_type_deprecated() {
// @@protoc_insertion_point(field_release:enterprise_management.LicenseAvailability.license_type_deprecated)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::LicenseType* temp = license_type_deprecated_;
license_type_deprecated_ = nullptr;
return temp;
}
inline ::enterprise_management::LicenseType* LicenseAvailability::mutable_license_type_deprecated() {
_has_bits_[0] |= 0x00000001u;
if (license_type_deprecated_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::LicenseType>(GetArenaNoVirtual());
license_type_deprecated_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.LicenseAvailability.license_type_deprecated)
return license_type_deprecated_;
}
inline void LicenseAvailability::set_allocated_license_type_deprecated(::enterprise_management::LicenseType* license_type_deprecated) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete license_type_deprecated_;
}
if (license_type_deprecated) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
license_type_deprecated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, license_type_deprecated, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
license_type_deprecated_ = license_type_deprecated;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.LicenseAvailability.license_type_deprecated)
}

// optional int32 available_licenses_deprecated = 2 [deprecated = true];
inline bool LicenseAvailability::has_available_licenses_deprecated() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseAvailability::clear_available_licenses_deprecated() {
available_licenses_deprecated_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LicenseAvailability::available_licenses_deprecated() const {
// @@protoc_insertion_point(field_get:enterprise_management.LicenseAvailability.available_licenses_deprecated)
return available_licenses_deprecated_;
}
inline void LicenseAvailability::set_available_licenses_deprecated(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
available_licenses_deprecated_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.LicenseAvailability.available_licenses_deprecated)
}

// -------------------------------------------------------------------

// CheckDeviceLicenseResponse

// optional .enterprise_management.CheckDeviceLicenseResponse.LicenseSelectionMode license_selection_mode_deprecated = 1 [deprecated = true];
inline bool CheckDeviceLicenseResponse::has_license_selection_mode_deprecated() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckDeviceLicenseResponse::clear_license_selection_mode_deprecated() {
license_selection_mode_deprecated_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::license_selection_mode_deprecated() const {
// @@protoc_insertion_point(field_get:enterprise_management.CheckDeviceLicenseResponse.license_selection_mode_deprecated)
return static_cast< ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode >(license_selection_mode_deprecated_);
}
inline void CheckDeviceLicenseResponse::set_license_selection_mode_deprecated(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode value) {
assert(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(value));
_has_bits_[0] |= 0x00000001u;
license_selection_mode_deprecated_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.CheckDeviceLicenseResponse.license_selection_mode_deprecated)
}

// repeated .enterprise_management.LicenseAvailability license_availabilities_deprecated = 2 [deprecated = true];
inline int CheckDeviceLicenseResponse::license_availabilities_deprecated_size() const {
return license_availabilities_deprecated_.size();
}
inline void CheckDeviceLicenseResponse::clear_license_availabilities_deprecated() {
license_availabilities_deprecated_.Clear();
}
inline ::enterprise_management::LicenseAvailability* CheckDeviceLicenseResponse::mutable_license_availabilities_deprecated(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
return license_availabilities_deprecated_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >*
CheckDeviceLicenseResponse::mutable_license_availabilities_deprecated() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
return &license_availabilities_deprecated_;
}
inline const ::enterprise_management::LicenseAvailability& CheckDeviceLicenseResponse::license_availabilities_deprecated(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
return license_availabilities_deprecated_.Get(index);
}
inline ::enterprise_management::LicenseAvailability* CheckDeviceLicenseResponse::add_license_availabilities_deprecated() {
// @@protoc_insertion_point(field_add:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
return license_availabilities_deprecated_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >&
CheckDeviceLicenseResponse::license_availabilities_deprecated() const {
// @@protoc_insertion_point(field_list:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
return license_availabilities_deprecated_;
}

// -------------------------------------------------------------------

// ActiveDirectoryUserSigninRequest

// -------------------------------------------------------------------

// ActiveDirectoryUserSigninResponse

// optional string auth_redirect_url = 1;
inline bool ActiveDirectoryUserSigninResponse::has_auth_redirect_url() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveDirectoryUserSigninResponse::clear_auth_redirect_url() {
auth_redirect_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryUserSigninResponse::auth_redirect_url() const {
// @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
return auth_redirect_url_.GetNoArena();
}
inline void ActiveDirectoryUserSigninResponse::set_auth_redirect_url(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
}
inline void ActiveDirectoryUserSigninResponse::set_auth_redirect_url(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
}
inline void ActiveDirectoryUserSigninResponse::set_auth_redirect_url(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
}
inline void ActiveDirectoryUserSigninResponse::set_auth_redirect_url(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
auth_redirect_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
}
inline std::string* ActiveDirectoryUserSigninResponse::mutable_auth_redirect_url() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
return auth_redirect_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActiveDirectoryUserSigninResponse::release_auth_redirect_url() {
// @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
if (!has_auth_redirect_url()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return auth_redirect_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActiveDirectoryUserSigninResponse::set_allocated_auth_redirect_url(std::string* auth_redirect_url) {
if (auth_redirect_url != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
auth_redirect_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_redirect_url);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
}

// -------------------------------------------------------------------

// TpmVersionInfo

// optional uint32 family = 1;
inline bool TpmVersionInfo::has_family() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TpmVersionInfo::clear_family() {
family_ = 0u;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TpmVersionInfo::family() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.family)
return family_;
}
inline void TpmVersionInfo::set_family(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000004u;
family_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.family)
}

// optional uint64 spec_level = 2;
inline bool TpmVersionInfo::has_spec_level() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TpmVersionInfo::clear_spec_level() {
spec_level_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TpmVersionInfo::spec_level() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.spec_level)
return spec_level_;
}
inline void TpmVersionInfo::set_spec_level(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000002u;
spec_level_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.spec_level)
}

// optional uint32 manufacturer = 3;
inline bool TpmVersionInfo::has_manufacturer() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TpmVersionInfo::clear_manufacturer() {
manufacturer_ = 0u;
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TpmVersionInfo::manufacturer() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.manufacturer)
return manufacturer_;
}
inline void TpmVersionInfo::set_manufacturer(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000008u;
manufacturer_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.manufacturer)
}

// optional uint32 tpm_model = 4;
inline bool TpmVersionInfo::has_tpm_model() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TpmVersionInfo::clear_tpm_model() {
tpm_model_ = 0u;
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TpmVersionInfo::tpm_model() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.tpm_model)
return tpm_model_;
}
inline void TpmVersionInfo::set_tpm_model(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000020u;
tpm_model_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.tpm_model)
}

// optional uint64 firmware_version = 5;
inline bool TpmVersionInfo::has_firmware_version() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TpmVersionInfo::clear_firmware_version() {
firmware_version_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TpmVersionInfo::firmware_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.firmware_version)
return firmware_version_;
}
inline void TpmVersionInfo::set_firmware_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000010u;
firmware_version_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.firmware_version)
}

// optional string vendor_specific = 6;
inline bool TpmVersionInfo::has_vendor_specific() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TpmVersionInfo::clear_vendor_specific() {
vendor_specific_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TpmVersionInfo::vendor_specific() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.vendor_specific)
return vendor_specific_.GetNoArena();
}
inline void TpmVersionInfo::set_vendor_specific(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
vendor_specific_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.vendor_specific)
}
inline void TpmVersionInfo::set_vendor_specific(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
vendor_specific_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.TpmVersionInfo.vendor_specific)
}
inline void TpmVersionInfo::set_vendor_specific(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
vendor_specific_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.TpmVersionInfo.vendor_specific)
}
inline void TpmVersionInfo::set_vendor_specific(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
vendor_specific_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.TpmVersionInfo.vendor_specific)
}
inline std::string* TpmVersionInfo::mutable_vendor_specific() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.TpmVersionInfo.vendor_specific)
return vendor_specific_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TpmVersionInfo::release_vendor_specific() {
// @@protoc_insertion_point(field_release:enterprise_management.TpmVersionInfo.vendor_specific)
if (!has_vendor_specific()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return vendor_specific_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TpmVersionInfo::set_allocated_vendor_specific(std::string* vendor_specific) {
if (vendor_specific != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
vendor_specific_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vendor_specific);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.TpmVersionInfo.vendor_specific)
}

// -------------------------------------------------------------------

// TpmStatusInfo

// optional bool enabled = 1;
inline bool TpmStatusInfo::has_enabled() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TpmStatusInfo::clear_enabled() {
enabled_ = false;
_has_bits_[0] &= ~0x00000001u;
}
inline bool TpmStatusInfo::enabled() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.enabled)
return enabled_;
}
inline void TpmStatusInfo::set_enabled(bool value) {
_has_bits_[0] |= 0x00000001u;
enabled_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.enabled)
}

// optional bool owned = 2;
inline bool TpmStatusInfo::has_owned() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TpmStatusInfo::clear_owned() {
owned_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool TpmStatusInfo::owned() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.owned)
return owned_;
}
inline void TpmStatusInfo::set_owned(bool value) {
_has_bits_[0] |= 0x00000002u;
owned_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.owned)
}

// optional bool tpm_initialized = 3;
inline bool TpmStatusInfo::has_tpm_initialized() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TpmStatusInfo::clear_tpm_initialized() {
tpm_initialized_ = false;
_has_bits_[0] &= ~0x00000004u;
}
inline bool TpmStatusInfo::tpm_initialized() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.tpm_initialized)
return tpm_initialized_;
}
inline void TpmStatusInfo::set_tpm_initialized(bool value) {
_has_bits_[0] |= 0x00000004u;
tpm_initialized_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.tpm_initialized)
}

// optional bool attestation_prepared = 4;
inline bool TpmStatusInfo::has_attestation_prepared() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TpmStatusInfo::clear_attestation_prepared() {
attestation_prepared_ = false;
_has_bits_[0] &= ~0x00000008u;
}
inline bool TpmStatusInfo::attestation_prepared() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.attestation_prepared)
return attestation_prepared_;
}
inline void TpmStatusInfo::set_attestation_prepared(bool value) {
_has_bits_[0] |= 0x00000008u;
attestation_prepared_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.attestation_prepared)
}

// optional bool attestation_enrolled = 5;
inline bool TpmStatusInfo::has_attestation_enrolled() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TpmStatusInfo::clear_attestation_enrolled() {
attestation_enrolled_ = false;
_has_bits_[0] &= ~0x00000040u;
}
inline bool TpmStatusInfo::attestation_enrolled() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.attestation_enrolled)
return attestation_enrolled_;
}
inline void TpmStatusInfo::set_attestation_enrolled(bool value) {
_has_bits_[0] |= 0x00000040u;
attestation_enrolled_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.attestation_enrolled)
}

// optional int32 dictionary_attack_counter = 6;
inline bool TpmStatusInfo::has_dictionary_attack_counter() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TpmStatusInfo::clear_dictionary_attack_counter() {
dictionary_attack_counter_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TpmStatusInfo::dictionary_attack_counter() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_counter)
return dictionary_attack_counter_;
}
inline void TpmStatusInfo::set_dictionary_attack_counter(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000010u;
dictionary_attack_counter_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_counter)
}

// optional int32 dictionary_attack_threshold = 7;
inline bool TpmStatusInfo::has_dictionary_attack_threshold() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TpmStatusInfo::clear_dictionary_attack_threshold() {
dictionary_attack_threshold_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TpmStatusInfo::dictionary_attack_threshold() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_threshold)
return dictionary_attack_threshold_;
}
inline void TpmStatusInfo::set_dictionary_attack_threshold(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000020u;
dictionary_attack_threshold_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_threshold)
}

// optional bool dictionary_attack_lockout_in_effect = 8;
inline bool TpmStatusInfo::has_dictionary_attack_lockout_in_effect() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TpmStatusInfo::clear_dictionary_attack_lockout_in_effect() {
dictionary_attack_lockout_in_effect_ = false;
_has_bits_[0] &= ~0x00000080u;
}
inline bool TpmStatusInfo::dictionary_attack_lockout_in_effect() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_in_effect)
return dictionary_attack_lockout_in_effect_;
}
inline void TpmStatusInfo::set_dictionary_attack_lockout_in_effect(bool value) {
_has_bits_[0] |= 0x00000080u;
dictionary_attack_lockout_in_effect_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_in_effect)
}

// optional int32 dictionary_attack_lockout_seconds_remaining = 9;
inline bool TpmStatusInfo::has_dictionary_attack_lockout_seconds_remaining() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TpmStatusInfo::clear_dictionary_attack_lockout_seconds_remaining() {
dictionary_attack_lockout_seconds_remaining_ = 0;
_has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TpmStatusInfo::dictionary_attack_lockout_seconds_remaining() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_seconds_remaining)
return dictionary_attack_lockout_seconds_remaining_;
}
inline void TpmStatusInfo::set_dictionary_attack_lockout_seconds_remaining(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000200u;
dictionary_attack_lockout_seconds_remaining_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_seconds_remaining)
}

// optional bool boot_lockbox_finalized = 10;
inline bool TpmStatusInfo::has_boot_lockbox_finalized() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TpmStatusInfo::clear_boot_lockbox_finalized() {
boot_lockbox_finalized_ = false;
_has_bits_[0] &= ~0x00000100u;
}
inline bool TpmStatusInfo::boot_lockbox_finalized() const {
// @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.boot_lockbox_finalized)
return boot_lockbox_finalized_;
}
inline void TpmStatusInfo::set_boot_lockbox_finalized(bool value) {
_has_bits_[0] |= 0x00000100u;
boot_lockbox_finalized_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.boot_lockbox_finalized)
}

// -------------------------------------------------------------------

// SystemState

// repeated .enterprise_management.VolumeInfo volume_infos = 1;
inline int SystemState::volume_infos_size() const {
return volume_infos_.size();
}
inline void SystemState::clear_volume_infos() {
volume_infos_.Clear();
}
inline ::enterprise_management::VolumeInfo* SystemState::mutable_volume_infos(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.SystemState.volume_infos)
return volume_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
SystemState::mutable_volume_infos() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.SystemState.volume_infos)
return &volume_infos_;
}
inline const ::enterprise_management::VolumeInfo& SystemState::volume_infos(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.SystemState.volume_infos)
return volume_infos_.Get(index);
}
inline ::enterprise_management::VolumeInfo* SystemState::add_volume_infos() {
// @@protoc_insertion_point(field_add:enterprise_management.SystemState.volume_infos)
return volume_infos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
SystemState::volume_infos() const {
// @@protoc_insertion_point(field_list:enterprise_management.SystemState.volume_infos)
return volume_infos_;
}

// -------------------------------------------------------------------

// ExtensionInstallReportLogEvent

// optional int64 timestamp = 1;
inline bool ExtensionInstallReportLogEvent::has_timestamp() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionInstallReportLogEvent::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtensionInstallReportLogEvent::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.timestamp)
return timestamp_;
}
inline void ExtensionInstallReportLogEvent::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.timestamp)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.EventType event_type = 2;
inline bool ExtensionInstallReportLogEvent::has_event_type() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtensionInstallReportLogEvent::clear_event_type() {
event_type_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::event_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.event_type)
return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_EventType >(event_type_);
}
inline void ExtensionInstallReportLogEvent::set_event_type(::enterprise_management::ExtensionInstallReportLogEvent_EventType value) {
assert(::enterprise_management::ExtensionInstallReportLogEvent_EventType_IsValid(value));
_has_bits_[0] |= 0x00000004u;
event_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.event_type)
}

// optional int64 stateful_total = 3;
inline bool ExtensionInstallReportLogEvent::has_stateful_total() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtensionInstallReportLogEvent::clear_stateful_total() {
stateful_total_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtensionInstallReportLogEvent::stateful_total() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.stateful_total)
return stateful_total_;
}
inline void ExtensionInstallReportLogEvent::set_stateful_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
stateful_total_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.stateful_total)
}

// optional int64 stateful_free = 4;
inline bool ExtensionInstallReportLogEvent::has_stateful_free() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtensionInstallReportLogEvent::clear_stateful_free() {
stateful_free_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtensionInstallReportLogEvent::stateful_free() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.stateful_free)
return stateful_free_;
}
inline void ExtensionInstallReportLogEvent::set_stateful_free(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000010u;
stateful_free_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.stateful_free)
}

// optional bool online = 5;
inline bool ExtensionInstallReportLogEvent::has_online() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtensionInstallReportLogEvent::clear_online() {
online_ = false;
_has_bits_[0] &= ~0x00000008u;
}
inline bool ExtensionInstallReportLogEvent::online() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.online)
return online_;
}
inline void ExtensionInstallReportLogEvent::set_online(bool value) {
_has_bits_[0] |= 0x00000008u;
online_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.online)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.SessionStateChangeType session_state_change_type = 6;
inline bool ExtensionInstallReportLogEvent::has_session_state_change_type() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtensionInstallReportLogEvent::clear_session_state_change_type() {
session_state_change_type_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::session_state_change_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.session_state_change_type)
return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType >(session_state_change_type_);
}
inline void ExtensionInstallReportLogEvent::set_session_state_change_type(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType value) {
assert(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(value));
_has_bits_[0] |= 0x00000020u;
session_state_change_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.session_state_change_type)
}

// -------------------------------------------------------------------

// AppInstallReportLogEvent

// optional int64 timestamp = 1;
inline bool AppInstallReportLogEvent::has_timestamp() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppInstallReportLogEvent::clear_timestamp() {
timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppInstallReportLogEvent::timestamp() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.timestamp)
return timestamp_;
}
inline void AppInstallReportLogEvent::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
timestamp_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.timestamp)
}

// optional .enterprise_management.AppInstallReportLogEvent.EventType event_type = 2;
inline bool AppInstallReportLogEvent::has_event_type() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppInstallReportLogEvent::clear_event_type() {
event_type_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::AppInstallReportLogEvent_EventType AppInstallReportLogEvent::event_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.event_type)
return static_cast< ::enterprise_management::AppInstallReportLogEvent_EventType >(event_type_);
}
inline void AppInstallReportLogEvent::set_event_type(::enterprise_management::AppInstallReportLogEvent_EventType value) {
assert(::enterprise_management::AppInstallReportLogEvent_EventType_IsValid(value));
_has_bits_[0] |= 0x00000008u;
event_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.event_type)
}

// optional int64 stateful_total = 3;
inline bool AppInstallReportLogEvent::has_stateful_total() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppInstallReportLogEvent::clear_stateful_total() {
stateful_total_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppInstallReportLogEvent::stateful_total() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.stateful_total)
return stateful_total_;
}
inline void AppInstallReportLogEvent::set_stateful_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
stateful_total_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.stateful_total)
}

// optional int64 stateful_free = 4;
inline bool AppInstallReportLogEvent::has_stateful_free() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppInstallReportLogEvent::clear_stateful_free() {
stateful_free_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppInstallReportLogEvent::stateful_free() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.stateful_free)
return stateful_free_;
}
inline void AppInstallReportLogEvent::set_stateful_free(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000020u;
stateful_free_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.stateful_free)
}

// optional int32 clouddps_response = 5;
inline bool AppInstallReportLogEvent::has_clouddps_response() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppInstallReportLogEvent::clear_clouddps_response() {
clouddps_response_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppInstallReportLogEvent::clouddps_response() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.clouddps_response)
return clouddps_response_;
}
inline void AppInstallReportLogEvent::set_clouddps_response(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000010u;
clouddps_response_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.clouddps_response)
}

// optional string phonesky_log = 6;
inline bool AppInstallReportLogEvent::has_phonesky_log() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppInstallReportLogEvent::clear_phonesky_log() {
phonesky_log_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInstallReportLogEvent::phonesky_log() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.phonesky_log)
return phonesky_log_.GetNoArena();
}
inline void AppInstallReportLogEvent::set_phonesky_log(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
phonesky_log_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.phonesky_log)
}
inline void AppInstallReportLogEvent::set_phonesky_log(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
phonesky_log_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppInstallReportLogEvent.phonesky_log)
}
inline void AppInstallReportLogEvent::set_phonesky_log(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
phonesky_log_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppInstallReportLogEvent.phonesky_log)
}
inline void AppInstallReportLogEvent::set_phonesky_log(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
phonesky_log_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppInstallReportLogEvent.phonesky_log)
}
inline std::string* AppInstallReportLogEvent::mutable_phonesky_log() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReportLogEvent.phonesky_log)
return phonesky_log_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppInstallReportLogEvent::release_phonesky_log() {
// @@protoc_insertion_point(field_release:enterprise_management.AppInstallReportLogEvent.phonesky_log)
if (!has_phonesky_log()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return phonesky_log_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppInstallReportLogEvent::set_allocated_phonesky_log(std::string* phonesky_log) {
if (phonesky_log != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
phonesky_log_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phonesky_log);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInstallReportLogEvent.phonesky_log)
}

// optional bool online = 7;
inline bool AppInstallReportLogEvent::has_online() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppInstallReportLogEvent::clear_online() {
online_ = false;
_has_bits_[0] &= ~0x00000040u;
}
inline bool AppInstallReportLogEvent::online() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.online)
return online_;
}
inline void AppInstallReportLogEvent::set_online(bool value) {
_has_bits_[0] |= 0x00000040u;
online_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.online)
}

// optional .enterprise_management.AppInstallReportLogEvent.SessionStateChangeType session_state_change_type = 8;
inline bool AppInstallReportLogEvent::has_session_state_change_type() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppInstallReportLogEvent::clear_session_state_change_type() {
session_state_change_type_ = 0;
_has_bits_[0] &= ~0x00000080u;
}
inline ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::session_state_change_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.session_state_change_type)
return static_cast< ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType >(session_state_change_type_);
}
inline void AppInstallReportLogEvent::set_session_state_change_type(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType value) {
assert(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType_IsValid(value));
_has_bits_[0] |= 0x00000080u;
session_state_change_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.session_state_change_type)
}

// optional int64 android_id = 9;
inline bool AppInstallReportLogEvent::has_android_id() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppInstallReportLogEvent::clear_android_id() {
android_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppInstallReportLogEvent::android_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.android_id)
return android_id_;
}
inline void AppInstallReportLogEvent::set_android_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000100u;
android_id_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.android_id)
}

// -------------------------------------------------------------------

// ExtensionInstallReport

// optional string extension_id = 1;
inline bool ExtensionInstallReport::has_extension_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionInstallReport::clear_extension_id() {
extension_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionInstallReport::extension_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReport.extension_id)
return extension_id_.GetNoArena();
}
inline void ExtensionInstallReport::set_extension_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReport.extension_id)
}
inline void ExtensionInstallReport::set_extension_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ExtensionInstallReport.extension_id)
}
inline void ExtensionInstallReport::set_extension_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ExtensionInstallReport.extension_id)
}
inline void ExtensionInstallReport::set_extension_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
extension_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ExtensionInstallReport.extension_id)
}
inline std::string* ExtensionInstallReport::mutable_extension_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionInstallReport.extension_id)
return extension_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ExtensionInstallReport::release_extension_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ExtensionInstallReport.extension_id)
if (!has_extension_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return extension_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionInstallReport::set_allocated_extension_id(std::string* extension_id) {
if (extension_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
extension_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ExtensionInstallReport.extension_id)
}

// optional bool incomplete = 2;
inline bool ExtensionInstallReport::has_incomplete() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtensionInstallReport::clear_incomplete() {
incomplete_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool ExtensionInstallReport::incomplete() const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReport.incomplete)
return incomplete_;
}
inline void ExtensionInstallReport::set_incomplete(bool value) {
_has_bits_[0] |= 0x00000002u;
incomplete_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReport.incomplete)
}

// repeated .enterprise_management.ExtensionInstallReportLogEvent logs = 3;
inline int ExtensionInstallReport::logs_size() const {
return logs_.size();
}
inline void ExtensionInstallReport::clear_logs() {
logs_.Clear();
}
inline ::enterprise_management::ExtensionInstallReportLogEvent* ExtensionInstallReport::mutable_logs(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionInstallReport.logs)
return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >*
ExtensionInstallReport::mutable_logs() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ExtensionInstallReport.logs)
return &logs_;
}
inline const ::enterprise_management::ExtensionInstallReportLogEvent& ExtensionInstallReport::logs(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReport.logs)
return logs_.Get(index);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent* ExtensionInstallReport::add_logs() {
// @@protoc_insertion_point(field_add:enterprise_management.ExtensionInstallReport.logs)
return logs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >&
ExtensionInstallReport::logs() const {
// @@protoc_insertion_point(field_list:enterprise_management.ExtensionInstallReport.logs)
return logs_;
}

// -------------------------------------------------------------------

// AppInstallReport

// optional string package = 1;
inline bool AppInstallReport::has_package() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppInstallReport::clear_package() {
package_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInstallReport::package() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReport.package)
return package_.GetNoArena();
}
inline void AppInstallReport::set_package(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReport.package)
}
inline void AppInstallReport::set_package(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
package_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.AppInstallReport.package)
}
inline void AppInstallReport::set_package(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.AppInstallReport.package)
}
inline void AppInstallReport::set_package(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.AppInstallReport.package)
}
inline std::string* AppInstallReport::mutable_package() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReport.package)
return package_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppInstallReport::release_package() {
// @@protoc_insertion_point(field_release:enterprise_management.AppInstallReport.package)
if (!has_package()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return package_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppInstallReport::set_allocated_package(std::string* package) {
if (package != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
package_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInstallReport.package)
}

// optional bool incomplete = 2;
inline bool AppInstallReport::has_incomplete() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppInstallReport::clear_incomplete() {
incomplete_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool AppInstallReport::incomplete() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReport.incomplete)
return incomplete_;
}
inline void AppInstallReport::set_incomplete(bool value) {
_has_bits_[0] |= 0x00000002u;
incomplete_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppInstallReport.incomplete)
}

// repeated .enterprise_management.AppInstallReportLogEvent logs = 3;
inline int AppInstallReport::logs_size() const {
return logs_.size();
}
inline void AppInstallReport::clear_logs() {
logs_.Clear();
}
inline ::enterprise_management::AppInstallReportLogEvent* AppInstallReport::mutable_logs(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReport.logs)
return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >*
AppInstallReport::mutable_logs() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.AppInstallReport.logs)
return &logs_;
}
inline const ::enterprise_management::AppInstallReportLogEvent& AppInstallReport::logs(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReport.logs)
return logs_.Get(index);
}
inline ::enterprise_management::AppInstallReportLogEvent* AppInstallReport::add_logs() {
// @@protoc_insertion_point(field_add:enterprise_management.AppInstallReport.logs)
return logs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >&
AppInstallReport::logs() const {
// @@protoc_insertion_point(field_list:enterprise_management.AppInstallReport.logs)
return logs_;
}

// -------------------------------------------------------------------

// AppInstallReportRequest

// repeated .enterprise_management.AppInstallReport app_install_reports = 1;
inline int AppInstallReportRequest::app_install_reports_size() const {
return app_install_reports_.size();
}
inline void AppInstallReportRequest::clear_app_install_reports() {
app_install_reports_.Clear();
}
inline ::enterprise_management::AppInstallReport* AppInstallReportRequest::mutable_app_install_reports(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReportRequest.app_install_reports)
return app_install_reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >*
AppInstallReportRequest::mutable_app_install_reports() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.AppInstallReportRequest.app_install_reports)
return &app_install_reports_;
}
inline const ::enterprise_management::AppInstallReport& AppInstallReportRequest::app_install_reports(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportRequest.app_install_reports)
return app_install_reports_.Get(index);
}
inline ::enterprise_management::AppInstallReport* AppInstallReportRequest::add_app_install_reports() {
// @@protoc_insertion_point(field_add:enterprise_management.AppInstallReportRequest.app_install_reports)
return app_install_reports_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >&
AppInstallReportRequest::app_install_reports() const {
// @@protoc_insertion_point(field_list:enterprise_management.AppInstallReportRequest.app_install_reports)
return app_install_reports_;
}

// -------------------------------------------------------------------

// ExtensionInstallReportRequest

// repeated .enterprise_management.ExtensionInstallReport extension_install_reports = 1;
inline int ExtensionInstallReportRequest::extension_install_reports_size() const {
return extension_install_reports_.size();
}
inline void ExtensionInstallReportRequest::clear_extension_install_reports() {
extension_install_reports_.Clear();
}
inline ::enterprise_management::ExtensionInstallReport* ExtensionInstallReportRequest::mutable_extension_install_reports(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
return extension_install_reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >*
ExtensionInstallReportRequest::mutable_extension_install_reports() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
return &extension_install_reports_;
}
inline const ::enterprise_management::ExtensionInstallReport& ExtensionInstallReportRequest::extension_install_reports(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
return extension_install_reports_.Get(index);
}
inline ::enterprise_management::ExtensionInstallReport* ExtensionInstallReportRequest::add_extension_install_reports() {
// @@protoc_insertion_point(field_add:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
return extension_install_reports_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >&
ExtensionInstallReportRequest::extension_install_reports() const {
// @@protoc_insertion_point(field_list:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
return extension_install_reports_;
}

// -------------------------------------------------------------------

// AppInstallReportResponse

// -------------------------------------------------------------------

// RefreshAccountRequest

// optional .enterprise_management.RefreshAccountRequest.AccountType account_type = 1;
inline bool RefreshAccountRequest::has_account_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefreshAccountRequest::clear_account_type() {
account_type_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::RefreshAccountRequest_AccountType RefreshAccountRequest::account_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.RefreshAccountRequest.account_type)
return static_cast< ::enterprise_management::RefreshAccountRequest_AccountType >(account_type_);
}
inline void RefreshAccountRequest::set_account_type(::enterprise_management::RefreshAccountRequest_AccountType value) {
assert(::enterprise_management::RefreshAccountRequest_AccountType_IsValid(value));
_has_bits_[0] |= 0x00000001u;
account_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RefreshAccountRequest.account_type)
}

// -------------------------------------------------------------------

// RefreshAccountResponse

// -------------------------------------------------------------------

// RsuLookupKeyUploadRequest

// optional bytes board_id = 1;
inline bool RsuLookupKeyUploadRequest::has_board_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RsuLookupKeyUploadRequest::clear_board_id() {
board_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RsuLookupKeyUploadRequest::board_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.RsuLookupKeyUploadRequest.board_id)
return board_id_.GetNoArena();
}
inline void RsuLookupKeyUploadRequest::set_board_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
board_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RsuLookupKeyUploadRequest.board_id)
}
inline void RsuLookupKeyUploadRequest::set_board_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
board_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RsuLookupKeyUploadRequest.board_id)
}
inline void RsuLookupKeyUploadRequest::set_board_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
board_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RsuLookupKeyUploadRequest.board_id)
}
inline void RsuLookupKeyUploadRequest::set_board_id(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
board_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RsuLookupKeyUploadRequest.board_id)
}
inline std::string* RsuLookupKeyUploadRequest::mutable_board_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RsuLookupKeyUploadRequest.board_id)
return board_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RsuLookupKeyUploadRequest::release_board_id() {
// @@protoc_insertion_point(field_release:enterprise_management.RsuLookupKeyUploadRequest.board_id)
if (!has_board_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return board_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RsuLookupKeyUploadRequest::set_allocated_board_id(std::string* board_id) {
if (board_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
board_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), board_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RsuLookupKeyUploadRequest.board_id)
}

// optional bytes cr50_hashed_device_id = 2;
inline bool RsuLookupKeyUploadRequest::has_cr50_hashed_device_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RsuLookupKeyUploadRequest::clear_cr50_hashed_device_id() {
cr50_hashed_device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RsuLookupKeyUploadRequest::cr50_hashed_device_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
return cr50_hashed_device_id_.GetNoArena();
}
inline void RsuLookupKeyUploadRequest::set_cr50_hashed_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
cr50_hashed_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
}
inline void RsuLookupKeyUploadRequest::set_cr50_hashed_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
cr50_hashed_device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
}
inline void RsuLookupKeyUploadRequest::set_cr50_hashed_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
cr50_hashed_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
}
inline void RsuLookupKeyUploadRequest::set_cr50_hashed_device_id(const void* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
cr50_hashed_device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
}
inline std::string* RsuLookupKeyUploadRequest::mutable_cr50_hashed_device_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
return cr50_hashed_device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RsuLookupKeyUploadRequest::release_cr50_hashed_device_id() {
// @@protoc_insertion_point(field_release:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
if (!has_cr50_hashed_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return cr50_hashed_device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RsuLookupKeyUploadRequest::set_allocated_cr50_hashed_device_id(std::string* cr50_hashed_device_id) {
if (cr50_hashed_device_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
cr50_hashed_device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cr50_hashed_device_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
}

// -------------------------------------------------------------------

// RsuLookupKeyUploadResponse

// optional bool rsu_lookup_key_updated = 1;
inline bool RsuLookupKeyUploadResponse::has_rsu_lookup_key_updated() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RsuLookupKeyUploadResponse::clear_rsu_lookup_key_updated() {
rsu_lookup_key_updated_ = false;
_has_bits_[0] &= ~0x00000001u;
}
inline bool RsuLookupKeyUploadResponse::rsu_lookup_key_updated() const {
// @@protoc_insertion_point(field_get:enterprise_management.RsuLookupKeyUploadResponse.rsu_lookup_key_updated)
return rsu_lookup_key_updated_;
}
inline void RsuLookupKeyUploadResponse::set_rsu_lookup_key_updated(bool value) {
_has_bits_[0] |= 0x00000001u;
rsu_lookup_key_updated_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.RsuLookupKeyUploadResponse.rsu_lookup_key_updated)
}

// -------------------------------------------------------------------

// App

// optional string app_id = 1;
inline bool App::has_app_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void App::clear_app_id() {
app_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& App::app_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.App.app_id)
return app_id_.GetNoArena();
}
inline void App::set_app_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.App.app_id)
}
inline void App::set_app_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.App.app_id)
}
inline void App::set_app_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.App.app_id)
}
inline void App::set_app_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.App.app_id)
}
inline std::string* App::mutable_app_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.App.app_id)
return app_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* App::release_app_id() {
// @@protoc_insertion_point(field_release:enterprise_management.App.app_id)
if (!has_app_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return app_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void App::set_allocated_app_id(std::string* app_id) {
if (app_id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
app_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.App.app_id)
}

// optional .enterprise_management.App.AppType app_type = 2;
inline bool App::has_app_type() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void App::clear_app_type() {
app_type_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::App_AppType App::app_type() const {
// @@protoc_insertion_point(field_get:enterprise_management.App.app_type)
return static_cast< ::enterprise_management::App_AppType >(app_type_);
}
inline void App::set_app_type(::enterprise_management::App_AppType value) {
assert(::enterprise_management::App_AppType_IsValid(value));
_has_bits_[0] |= 0x00000002u;
app_type_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.App.app_type)
}

// repeated string additional_app_id = 3;
inline int App::additional_app_id_size() const {
return additional_app_id_.size();
}
inline void App::clear_additional_app_id() {
additional_app_id_.Clear();
}
inline const std::string& App::additional_app_id(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.App.additional_app_id)
return additional_app_id_.Get(index);
}
inline std::string* App::mutable_additional_app_id(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.App.additional_app_id)
return additional_app_id_.Mutable(index);
}
inline void App::set_additional_app_id(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:enterprise_management.App.additional_app_id)
additional_app_id_.Mutable(index)->assign(value);
}
inline void App::set_additional_app_id(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:enterprise_management.App.additional_app_id)
additional_app_id_.Mutable(index)->assign(std::move(value));
}
inline void App::set_additional_app_id(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
additional_app_id_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:enterprise_management.App.additional_app_id)
}
inline void App::set_additional_app_id(int index, const char* value, size_t size) {
additional_app_id_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:enterprise_management.App.additional_app_id)
}
inline std::string* App::add_additional_app_id() {
// @@protoc_insertion_point(field_add_mutable:enterprise_management.App.additional_app_id)
return additional_app_id_.Add();
}
inline void App::add_additional_app_id(const std::string& value) {
additional_app_id_.Add()->assign(value);
// @@protoc_insertion_point(field_add:enterprise_management.App.additional_app_id)
}
inline void App::add_additional_app_id(std::string&& value) {
additional_app_id_.Add(std::move(value));
// @@protoc_insertion_point(field_add:enterprise_management.App.additional_app_id)
}
inline void App::add_additional_app_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
additional_app_id_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:enterprise_management.App.additional_app_id)
}
inline void App::add_additional_app_id(const char* value, size_t size) {
additional_app_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:enterprise_management.App.additional_app_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
App::additional_app_id() const {
// @@protoc_insertion_point(field_list:enterprise_management.App.additional_app_id)
return additional_app_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
App::mutable_additional_app_id() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.App.additional_app_id)
return &additional_app_id_;
}

// -------------------------------------------------------------------

// AppActivity

// optional .enterprise_management.App app_info = 1;
inline bool AppActivity::has_app_info() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppActivity::clear_app_info() {
if (app_info_ != nullptr) app_info_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::App& AppActivity::app_info() const {
const ::enterprise_management::App* p = app_info_;
// @@protoc_insertion_point(field_get:enterprise_management.AppActivity.app_info)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::App*>(
&::enterprise_management::_App_default_instance_);
}
inline ::enterprise_management::App* AppActivity::release_app_info() {
// @@protoc_insertion_point(field_release:enterprise_management.AppActivity.app_info)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::App* temp = app_info_;
app_info_ = nullptr;
return temp;
}
inline ::enterprise_management::App* AppActivity::mutable_app_info() {
_has_bits_[0] |= 0x00000001u;
if (app_info_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::App>(GetArenaNoVirtual());
app_info_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.AppActivity.app_info)
return app_info_;
}
inline void AppActivity::set_allocated_app_info(::enterprise_management::App* app_info) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete app_info_;
}
if (app_info) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
app_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, app_info, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
app_info_ = app_info;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.AppActivity.app_info)
}

// repeated .enterprise_management.TimePeriod active_time_periods = 2;
inline int AppActivity::active_time_periods_size() const {
return active_time_periods_.size();
}
inline void AppActivity::clear_active_time_periods() {
active_time_periods_.Clear();
}
inline ::enterprise_management::TimePeriod* AppActivity::mutable_active_time_periods(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.AppActivity.active_time_periods)
return active_time_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
AppActivity::mutable_active_time_periods() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.AppActivity.active_time_periods)
return &active_time_periods_;
}
inline const ::enterprise_management::TimePeriod& AppActivity::active_time_periods(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.AppActivity.active_time_periods)
return active_time_periods_.Get(index);
}
inline ::enterprise_management::TimePeriod* AppActivity::add_active_time_periods() {
// @@protoc_insertion_point(field_add:enterprise_management.AppActivity.active_time_periods)
return active_time_periods_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
AppActivity::active_time_periods() const {
// @@protoc_insertion_point(field_list:enterprise_management.AppActivity.active_time_periods)
return active_time_periods_;
}

// optional int64 populated_at = 3;
inline bool AppActivity::has_populated_at() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppActivity::clear_populated_at() {
populated_at_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppActivity::populated_at() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppActivity.populated_at)
return populated_at_;
}
inline void AppActivity::set_populated_at(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
populated_at_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppActivity.populated_at)
}

// optional .enterprise_management.AppActivity.AppState app_state = 4;
inline bool AppActivity::has_app_state() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppActivity::clear_app_state() {
app_state_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::AppActivity_AppState AppActivity::app_state() const {
// @@protoc_insertion_point(field_get:enterprise_management.AppActivity.app_state)
return static_cast< ::enterprise_management::AppActivity_AppState >(app_state_);
}
inline void AppActivity::set_app_state(::enterprise_management::AppActivity_AppState value) {
assert(::enterprise_management::AppActivity_AppState_IsValid(value));
_has_bits_[0] |= 0x00000004u;
app_state_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.AppActivity.app_state)
}

// -------------------------------------------------------------------

// ScreenTimeSpan

// optional .enterprise_management.TimePeriod time_period = 1;
inline bool ScreenTimeSpan::has_time_period() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScreenTimeSpan::clear_time_period() {
if (time_period_ != nullptr) time_period_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::TimePeriod& ScreenTimeSpan::time_period() const {
const ::enterprise_management::TimePeriod* p = time_period_;
// @@protoc_insertion_point(field_get:enterprise_management.ScreenTimeSpan.time_period)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::TimePeriod*>(
&::enterprise_management::_TimePeriod_default_instance_);
}
inline ::enterprise_management::TimePeriod* ScreenTimeSpan::release_time_period() {
// @@protoc_insertion_point(field_release:enterprise_management.ScreenTimeSpan.time_period)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::TimePeriod* temp = time_period_;
time_period_ = nullptr;
return temp;
}
inline ::enterprise_management::TimePeriod* ScreenTimeSpan::mutable_time_period() {
_has_bits_[0] |= 0x00000001u;
if (time_period_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::TimePeriod>(GetArenaNoVirtual());
time_period_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ScreenTimeSpan.time_period)
return time_period_;
}
inline void ScreenTimeSpan::set_allocated_time_period(::enterprise_management::TimePeriod* time_period) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete time_period_;
}
if (time_period) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
time_period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, time_period, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
time_period_ = time_period;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ScreenTimeSpan.time_period)
}

// optional int64 active_duration_ms = 2;
inline bool ScreenTimeSpan::has_active_duration_ms() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScreenTimeSpan::clear_active_duration_ms() {
active_duration_ms_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScreenTimeSpan::active_duration_ms() const {
// @@protoc_insertion_point(field_get:enterprise_management.ScreenTimeSpan.active_duration_ms)
return active_duration_ms_;
}
inline void ScreenTimeSpan::set_active_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000002u;
active_duration_ms_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ScreenTimeSpan.active_duration_ms)
}

// -------------------------------------------------------------------

// ChildStatusReportRequest

// optional string user_dm_token = 1;
inline bool ChildStatusReportRequest::has_user_dm_token() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChildStatusReportRequest::clear_user_dm_token() {
user_dm_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChildStatusReportRequest::user_dm_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.user_dm_token)
return user_dm_token_.GetNoArena();
}
inline void ChildStatusReportRequest::set_user_dm_token(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
user_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.user_dm_token)
}
inline void ChildStatusReportRequest::set_user_dm_token(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
user_dm_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChildStatusReportRequest.user_dm_token)
}
inline void ChildStatusReportRequest::set_user_dm_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
user_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChildStatusReportRequest.user_dm_token)
}
inline void ChildStatusReportRequest::set_user_dm_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
user_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChildStatusReportRequest.user_dm_token)
}
inline std::string* ChildStatusReportRequest::mutable_user_dm_token() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.user_dm_token)
return user_dm_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChildStatusReportRequest::release_user_dm_token() {
// @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.user_dm_token)
if (!has_user_dm_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return user_dm_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChildStatusReportRequest::set_allocated_user_dm_token(std::string* user_dm_token) {
if (user_dm_token != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
user_dm_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_dm_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.user_dm_token)
}

// optional int64 timestamp_ms = 2;
inline bool ChildStatusReportRequest::has_timestamp_ms() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChildStatusReportRequest::clear_timestamp_ms() {
timestamp_ms_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ChildStatusReportRequest::timestamp_ms() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.timestamp_ms)
return timestamp_ms_;
}
inline void ChildStatusReportRequest::set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000020u;
timestamp_ms_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.timestamp_ms)
}

// optional string time_zone = 3;
inline bool ChildStatusReportRequest::has_time_zone() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChildStatusReportRequest::clear_time_zone() {
time_zone_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChildStatusReportRequest::time_zone() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.time_zone)
return time_zone_.GetNoArena();
}
inline void ChildStatusReportRequest::set_time_zone(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
time_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.time_zone)
}
inline void ChildStatusReportRequest::set_time_zone(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
time_zone_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChildStatusReportRequest.time_zone)
}
inline void ChildStatusReportRequest::set_time_zone(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
time_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChildStatusReportRequest.time_zone)
}
inline void ChildStatusReportRequest::set_time_zone(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
time_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChildStatusReportRequest.time_zone)
}
inline std::string* ChildStatusReportRequest::mutable_time_zone() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.time_zone)
return time_zone_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChildStatusReportRequest::release_time_zone() {
// @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.time_zone)
if (!has_time_zone()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return time_zone_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChildStatusReportRequest::set_allocated_time_zone(std::string* time_zone) {
if (time_zone != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
time_zone_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time_zone);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.time_zone)
}

// repeated .enterprise_management.ScreenTimeSpan screen_time_span = 4;
inline int ChildStatusReportRequest::screen_time_span_size() const {
return screen_time_span_.size();
}
inline void ChildStatusReportRequest::clear_screen_time_span() {
screen_time_span_.Clear();
}
inline ::enterprise_management::ScreenTimeSpan* ChildStatusReportRequest::mutable_screen_time_span(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.screen_time_span)
return screen_time_span_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >*
ChildStatusReportRequest::mutable_screen_time_span() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChildStatusReportRequest.screen_time_span)
return &screen_time_span_;
}
inline const ::enterprise_management::ScreenTimeSpan& ChildStatusReportRequest::screen_time_span(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.screen_time_span)
return screen_time_span_.Get(index);
}
inline ::enterprise_management::ScreenTimeSpan* ChildStatusReportRequest::add_screen_time_span() {
// @@protoc_insertion_point(field_add:enterprise_management.ChildStatusReportRequest.screen_time_span)
return screen_time_span_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >&
ChildStatusReportRequest::screen_time_span() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChildStatusReportRequest.screen_time_span)
return screen_time_span_;
}

// optional .enterprise_management.AndroidStatus android_status = 5;
inline bool ChildStatusReportRequest::has_android_status() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChildStatusReportRequest::clear_android_status() {
if (android_status_ != nullptr) android_status_->Clear();
_has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::AndroidStatus& ChildStatusReportRequest::android_status() const {
const ::enterprise_management::AndroidStatus* p = android_status_;
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.android_status)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::AndroidStatus*>(
&::enterprise_management::_AndroidStatus_default_instance_);
}
inline ::enterprise_management::AndroidStatus* ChildStatusReportRequest::release_android_status() {
// @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.android_status)
_has_bits_[0] &= ~0x00000010u;
::enterprise_management::AndroidStatus* temp = android_status_;
android_status_ = nullptr;
return temp;
}
inline ::enterprise_management::AndroidStatus* ChildStatusReportRequest::mutable_android_status() {
_has_bits_[0] |= 0x00000010u;
if (android_status_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::AndroidStatus>(GetArenaNoVirtual());
android_status_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.android_status)
return android_status_;
}
inline void ChildStatusReportRequest::set_allocated_android_status(::enterprise_management::AndroidStatus* android_status) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete android_status_;
}
if (android_status) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
android_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, android_status, submessage_arena);
}
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
android_status_ = android_status;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.android_status)
}

// optional string os_version = 6;
inline bool ChildStatusReportRequest::has_os_version() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChildStatusReportRequest::clear_os_version() {
os_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ChildStatusReportRequest::os_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.os_version)
return os_version_.GetNoArena();
}
inline void ChildStatusReportRequest::set_os_version(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.os_version)
}
inline void ChildStatusReportRequest::set_os_version(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChildStatusReportRequest.os_version)
}
inline void ChildStatusReportRequest::set_os_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChildStatusReportRequest.os_version)
}
inline void ChildStatusReportRequest::set_os_version(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
os_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChildStatusReportRequest.os_version)
}
inline std::string* ChildStatusReportRequest::mutable_os_version() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.os_version)
return os_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChildStatusReportRequest::release_os_version() {
// @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.os_version)
if (!has_os_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return os_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChildStatusReportRequest::set_allocated_os_version(std::string* os_version) {
if (os_version != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
os_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.os_version)
}

// optional string boot_mode = 7;
inline bool ChildStatusReportRequest::has_boot_mode() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChildStatusReportRequest::clear_boot_mode() {
boot_mode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ChildStatusReportRequest::boot_mode() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.boot_mode)
return boot_mode_.GetNoArena();
}
inline void ChildStatusReportRequest::set_boot_mode(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
boot_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.boot_mode)
}
inline void ChildStatusReportRequest::set_boot_mode(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
boot_mode_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChildStatusReportRequest.boot_mode)
}
inline void ChildStatusReportRequest::set_boot_mode(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
boot_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChildStatusReportRequest.boot_mode)
}
inline void ChildStatusReportRequest::set_boot_mode(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
boot_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChildStatusReportRequest.boot_mode)
}
inline std::string* ChildStatusReportRequest::mutable_boot_mode() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.boot_mode)
return boot_mode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChildStatusReportRequest::release_boot_mode() {
// @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.boot_mode)
if (!has_boot_mode()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return boot_mode_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChildStatusReportRequest::set_allocated_boot_mode(std::string* boot_mode) {
if (boot_mode != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
boot_mode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), boot_mode);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.boot_mode)
}

// repeated .enterprise_management.AppActivity app_activity = 8;
inline int ChildStatusReportRequest::app_activity_size() const {
return app_activity_.size();
}
inline void ChildStatusReportRequest::clear_app_activity() {
app_activity_.Clear();
}
inline ::enterprise_management::AppActivity* ChildStatusReportRequest::mutable_app_activity(int index) {
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.app_activity)
return app_activity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >*
ChildStatusReportRequest::mutable_app_activity() {
// @@protoc_insertion_point(field_mutable_list:enterprise_management.ChildStatusReportRequest.app_activity)
return &app_activity_;
}
inline const ::enterprise_management::AppActivity& ChildStatusReportRequest::app_activity(int index) const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.app_activity)
return app_activity_.Get(index);
}
inline ::enterprise_management::AppActivity* ChildStatusReportRequest::add_app_activity() {
// @@protoc_insertion_point(field_add:enterprise_management.ChildStatusReportRequest.app_activity)
return app_activity_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >&
ChildStatusReportRequest::app_activity() const {
// @@protoc_insertion_point(field_list:enterprise_management.ChildStatusReportRequest.app_activity)
return app_activity_;
}

// -------------------------------------------------------------------

// ChildStatusReportResponse

// optional int32 error_code = 1;
inline bool ChildStatusReportResponse::has_error_code() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChildStatusReportResponse::clear_error_code() {
error_code_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChildStatusReportResponse::error_code() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportResponse.error_code)
return error_code_;
}
inline void ChildStatusReportResponse::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
error_code_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool ChildStatusReportResponse::has_error_message() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChildStatusReportResponse::clear_error_message() {
error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChildStatusReportResponse::error_message() const {
// @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportResponse.error_message)
return error_message_.GetNoArena();
}
inline void ChildStatusReportResponse::set_error_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportResponse.error_message)
}
inline void ChildStatusReportResponse::set_error_message(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ChildStatusReportResponse.error_message)
}
inline void ChildStatusReportResponse::set_error_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ChildStatusReportResponse.error_message)
}
inline void ChildStatusReportResponse::set_error_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ChildStatusReportResponse.error_message)
}
inline std::string* ChildStatusReportResponse::mutable_error_message() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportResponse.error_message)
return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChildStatusReportResponse::release_error_message() {
// @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportResponse.error_message)
if (!has_error_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return error_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChildStatusReportResponse::set_allocated_error_message(std::string* error_message) {
if (error_message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// StartCsrRequest

// -------------------------------------------------------------------

// StartCsrResponse

// optional string invalidation_topic = 1;
inline bool StartCsrResponse::has_invalidation_topic() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartCsrResponse::clear_invalidation_topic() {
invalidation_topic_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StartCsrResponse::invalidation_topic() const {
// @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.invalidation_topic)
return invalidation_topic_.GetNoArena();
}
inline void StartCsrResponse::set_invalidation_topic(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.invalidation_topic)
}
inline void StartCsrResponse::set_invalidation_topic(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
invalidation_topic_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.StartCsrResponse.invalidation_topic)
}
inline void StartCsrResponse::set_invalidation_topic(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.StartCsrResponse.invalidation_topic)
}
inline void StartCsrResponse::set_invalidation_topic(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
invalidation_topic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.StartCsrResponse.invalidation_topic)
}
inline std::string* StartCsrResponse::mutable_invalidation_topic() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.StartCsrResponse.invalidation_topic)
return invalidation_topic_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StartCsrResponse::release_invalidation_topic() {
// @@protoc_insertion_point(field_release:enterprise_management.StartCsrResponse.invalidation_topic)
if (!has_invalidation_topic()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return invalidation_topic_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StartCsrResponse::set_allocated_invalidation_topic(std::string* invalidation_topic) {
if (invalidation_topic != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
invalidation_topic_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invalidation_topic);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.StartCsrResponse.invalidation_topic)
}

// optional bytes va_challenge = 2;
inline bool StartCsrResponse::has_va_challenge() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartCsrResponse::clear_va_challenge() {
va_challenge_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StartCsrResponse::va_challenge() const {
// @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.va_challenge)
return va_challenge_.GetNoArena();
}
inline void StartCsrResponse::set_va_challenge(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
va_challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.va_challenge)
}
inline void StartCsrResponse::set_va_challenge(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
va_challenge_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.StartCsrResponse.va_challenge)
}
inline void StartCsrResponse::set_va_challenge(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
va_challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.StartCsrResponse.va_challenge)
}
inline void StartCsrResponse::set_va_challenge(const void* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
va_challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.StartCsrResponse.va_challenge)
}
inline std::string* StartCsrResponse::mutable_va_challenge() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.StartCsrResponse.va_challenge)
return va_challenge_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StartCsrResponse::release_va_challenge() {
// @@protoc_insertion_point(field_release:enterprise_management.StartCsrResponse.va_challenge)
if (!has_va_challenge()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return va_challenge_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StartCsrResponse::set_allocated_va_challenge(std::string* va_challenge) {
if (va_challenge != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
va_challenge_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), va_challenge);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.StartCsrResponse.va_challenge)
}

// optional .enterprise_management.HashingAlgorithm hashing_algorithm = 5;
inline bool StartCsrResponse::has_hashing_algorithm() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartCsrResponse::clear_hashing_algorithm() {
hashing_algorithm_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::HashingAlgorithm StartCsrResponse::hashing_algorithm() const {
// @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.hashing_algorithm)
return static_cast< ::enterprise_management::HashingAlgorithm >(hashing_algorithm_);
}
inline void StartCsrResponse::set_hashing_algorithm(::enterprise_management::HashingAlgorithm value) {
assert(::enterprise_management::HashingAlgorithm_IsValid(value));
_has_bits_[0] |= 0x00000010u;
hashing_algorithm_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.hashing_algorithm)
}

// optional .enterprise_management.SigningAlgorithm signing_algorithm = 3;
inline bool StartCsrResponse::has_signing_algorithm() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartCsrResponse::clear_signing_algorithm() {
signing_algorithm_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::SigningAlgorithm StartCsrResponse::signing_algorithm() const {
// @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.signing_algorithm)
return static_cast< ::enterprise_management::SigningAlgorithm >(signing_algorithm_);
}
inline void StartCsrResponse::set_signing_algorithm(::enterprise_management::SigningAlgorithm value) {
assert(::enterprise_management::SigningAlgorithm_IsValid(value));
_has_bits_[0] |= 0x00000008u;
signing_algorithm_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.signing_algorithm)
}

// optional bytes data_to_sign = 4;
inline bool StartCsrResponse::has_data_to_sign() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartCsrResponse::clear_data_to_sign() {
data_to_sign_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StartCsrResponse::data_to_sign() const {
// @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.data_to_sign)
return data_to_sign_.GetNoArena();
}
inline void StartCsrResponse::set_data_to_sign(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
data_to_sign_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.data_to_sign)
}
inline void StartCsrResponse::set_data_to_sign(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
data_to_sign_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.StartCsrResponse.data_to_sign)
}
inline void StartCsrResponse::set_data_to_sign(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
data_to_sign_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.StartCsrResponse.data_to_sign)
}
inline void StartCsrResponse::set_data_to_sign(const void* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
data_to_sign_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.StartCsrResponse.data_to_sign)
}
inline std::string* StartCsrResponse::mutable_data_to_sign() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.StartCsrResponse.data_to_sign)
return data_to_sign_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StartCsrResponse::release_data_to_sign() {
// @@protoc_insertion_point(field_release:enterprise_management.StartCsrResponse.data_to_sign)
if (!has_data_to_sign()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return data_to_sign_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StartCsrResponse::set_allocated_data_to_sign(std::string* data_to_sign) {
if (data_to_sign != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
data_to_sign_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_to_sign);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.StartCsrResponse.data_to_sign)
}

// -------------------------------------------------------------------

// FinishCsrRequest

// optional bytes va_challenge_response = 1;
inline bool FinishCsrRequest::has_va_challenge_response() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishCsrRequest::clear_va_challenge_response() {
va_challenge_response_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FinishCsrRequest::va_challenge_response() const {
// @@protoc_insertion_point(field_get:enterprise_management.FinishCsrRequest.va_challenge_response)
return va_challenge_response_.GetNoArena();
}
inline void FinishCsrRequest::set_va_challenge_response(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
va_challenge_response_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.FinishCsrRequest.va_challenge_response)
}
inline void FinishCsrRequest::set_va_challenge_response(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
va_challenge_response_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.FinishCsrRequest.va_challenge_response)
}
inline void FinishCsrRequest::set_va_challenge_response(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
va_challenge_response_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.FinishCsrRequest.va_challenge_response)
}
inline void FinishCsrRequest::set_va_challenge_response(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
va_challenge_response_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.FinishCsrRequest.va_challenge_response)
}
inline std::string* FinishCsrRequest::mutable_va_challenge_response() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.FinishCsrRequest.va_challenge_response)
return va_challenge_response_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FinishCsrRequest::release_va_challenge_response() {
// @@protoc_insertion_point(field_release:enterprise_management.FinishCsrRequest.va_challenge_response)
if (!has_va_challenge_response()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return va_challenge_response_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FinishCsrRequest::set_allocated_va_challenge_response(std::string* va_challenge_response) {
if (va_challenge_response != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
va_challenge_response_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), va_challenge_response);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.FinishCsrRequest.va_challenge_response)
}

// optional bytes signature = 2;
inline bool FinishCsrRequest::has_signature() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinishCsrRequest::clear_signature() {
signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FinishCsrRequest::signature() const {
// @@protoc_insertion_point(field_get:enterprise_management.FinishCsrRequest.signature)
return signature_.GetNoArena();
}
inline void FinishCsrRequest::set_signature(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.FinishCsrRequest.signature)
}
inline void FinishCsrRequest::set_signature(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.FinishCsrRequest.signature)
}
inline void FinishCsrRequest::set_signature(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.FinishCsrRequest.signature)
}
inline void FinishCsrRequest::set_signature(const void* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.FinishCsrRequest.signature)
}
inline std::string* FinishCsrRequest::mutable_signature() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.FinishCsrRequest.signature)
return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FinishCsrRequest::release_signature() {
// @@protoc_insertion_point(field_release:enterprise_management.FinishCsrRequest.signature)
if (!has_signature()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FinishCsrRequest::set_allocated_signature(std::string* signature) {
if (signature != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.FinishCsrRequest.signature)
}

// -------------------------------------------------------------------

// FinishCsrResponse

// -------------------------------------------------------------------

// DownloadCertRequest

// -------------------------------------------------------------------

// DownloadCertResponse

// optional string pem_encoded_certificate = 1;
inline bool DownloadCertResponse::has_pem_encoded_certificate() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadCertResponse::clear_pem_encoded_certificate() {
pem_encoded_certificate_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DownloadCertResponse::pem_encoded_certificate() const {
// @@protoc_insertion_point(field_get:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
return pem_encoded_certificate_.GetNoArena();
}
inline void DownloadCertResponse::set_pem_encoded_certificate(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
pem_encoded_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
}
inline void DownloadCertResponse::set_pem_encoded_certificate(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
pem_encoded_certificate_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
}
inline void DownloadCertResponse::set_pem_encoded_certificate(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
pem_encoded_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
}
inline void DownloadCertResponse::set_pem_encoded_certificate(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
pem_encoded_certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
}
inline std::string* DownloadCertResponse::mutable_pem_encoded_certificate() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
return pem_encoded_certificate_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadCertResponse::release_pem_encoded_certificate() {
// @@protoc_insertion_point(field_release:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
if (!has_pem_encoded_certificate()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return pem_encoded_certificate_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadCertResponse::set_allocated_pem_encoded_certificate(std::string* pem_encoded_certificate) {
if (pem_encoded_certificate != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
pem_encoded_certificate_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pem_encoded_certificate);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
}

// -------------------------------------------------------------------

// ClientCertificateProvisioningRequest

// optional string certificate_scope = 1;
inline bool ClientCertificateProvisioningRequest::has_certificate_scope() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCertificateProvisioningRequest::clear_certificate_scope() {
certificate_scope_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientCertificateProvisioningRequest::certificate_scope() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
return certificate_scope_.GetNoArena();
}
inline void ClientCertificateProvisioningRequest::set_certificate_scope(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
certificate_scope_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
}
inline void ClientCertificateProvisioningRequest::set_certificate_scope(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
certificate_scope_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
}
inline void ClientCertificateProvisioningRequest::set_certificate_scope(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
certificate_scope_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
}
inline void ClientCertificateProvisioningRequest::set_certificate_scope(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
certificate_scope_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_certificate_scope() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
return certificate_scope_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientCertificateProvisioningRequest::release_certificate_scope() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
if (!has_certificate_scope()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return certificate_scope_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientCertificateProvisioningRequest::set_allocated_certificate_scope(std::string* certificate_scope) {
if (certificate_scope != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
certificate_scope_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), certificate_scope);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
}

// optional string cert_profile_id = 2;
inline bool ClientCertificateProvisioningRequest::has_cert_profile_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientCertificateProvisioningRequest::clear_cert_profile_id() {
cert_profile_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientCertificateProvisioningRequest::cert_profile_id() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
return cert_profile_id_.GetNoArena();
}
inline void ClientCertificateProvisioningRequest::set_cert_profile_id(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
cert_profile_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
}
inline void ClientCertificateProvisioningRequest::set_cert_profile_id(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
cert_profile_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
}
inline void ClientCertificateProvisioningRequest::set_cert_profile_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
cert_profile_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
}
inline void ClientCertificateProvisioningRequest::set_cert_profile_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
cert_profile_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_cert_profile_id() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
return cert_profile_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientCertificateProvisioningRequest::release_cert_profile_id() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
if (!has_cert_profile_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return cert_profile_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientCertificateProvisioningRequest::set_allocated_cert_profile_id(std::string* cert_profile_id) {
if (cert_profile_id != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
cert_profile_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cert_profile_id);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
}

// optional bytes public_key = 3;
inline bool ClientCertificateProvisioningRequest::has_public_key() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientCertificateProvisioningRequest::clear_public_key() {
public_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientCertificateProvisioningRequest::public_key() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.public_key)
return public_key_.GetNoArena();
}
inline void ClientCertificateProvisioningRequest::set_public_key(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.public_key)
}
inline void ClientCertificateProvisioningRequest::set_public_key(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
public_key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ClientCertificateProvisioningRequest.public_key)
}
inline void ClientCertificateProvisioningRequest::set_public_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ClientCertificateProvisioningRequest.public_key)
}
inline void ClientCertificateProvisioningRequest::set_public_key(const void* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ClientCertificateProvisioningRequest.public_key)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_public_key() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.public_key)
return public_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientCertificateProvisioningRequest::release_public_key() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.public_key)
if (!has_public_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return public_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientCertificateProvisioningRequest::set_allocated_public_key(std::string* public_key) {
if (public_key != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
public_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.public_key)
}

// optional string device_dm_token = 4;
inline bool ClientCertificateProvisioningRequest::has_device_dm_token() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientCertificateProvisioningRequest::clear_device_dm_token() {
device_dm_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientCertificateProvisioningRequest::device_dm_token() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
return device_dm_token_.GetNoArena();
}
inline void ClientCertificateProvisioningRequest::set_device_dm_token(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
device_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
}
inline void ClientCertificateProvisioningRequest::set_device_dm_token(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
device_dm_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
}
inline void ClientCertificateProvisioningRequest::set_device_dm_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
device_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
}
inline void ClientCertificateProvisioningRequest::set_device_dm_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
device_dm_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_device_dm_token() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
return device_dm_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientCertificateProvisioningRequest::release_device_dm_token() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
if (!has_device_dm_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return device_dm_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientCertificateProvisioningRequest::set_allocated_device_dm_token(std::string* device_dm_token) {
if (device_dm_token != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
device_dm_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_dm_token);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
}

// optional .enterprise_management.StartCsrRequest start_csr_request = 5;
inline bool ClientCertificateProvisioningRequest::has_start_csr_request() const {
return request_case() == kStartCsrRequest;
}
inline void ClientCertificateProvisioningRequest::set_has_start_csr_request() {
_oneof_case_[0] = kStartCsrRequest;
}
inline void ClientCertificateProvisioningRequest::clear_start_csr_request() {
if (has_start_csr_request()) {
delete request_.start_csr_request_;
clear_has_request();
}
}
inline ::enterprise_management::StartCsrRequest* ClientCertificateProvisioningRequest::release_start_csr_request() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
if (has_start_csr_request()) {
clear_has_request();
::enterprise_management::StartCsrRequest* temp = request_.start_csr_request_;
request_.start_csr_request_ = nullptr;
return temp;
} else {
return nullptr;
}
}
inline const ::enterprise_management::StartCsrRequest& ClientCertificateProvisioningRequest::start_csr_request() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
return has_start_csr_request()
? *request_.start_csr_request_
: *reinterpret_cast< ::enterprise_management::StartCsrRequest*>(&::enterprise_management::_StartCsrRequest_default_instance_);
}
inline ::enterprise_management::StartCsrRequest* ClientCertificateProvisioningRequest::mutable_start_csr_request() {
if (!has_start_csr_request()) {
clear_request();
set_has_start_csr_request();
request_.start_csr_request_ = CreateMaybeMessage< ::enterprise_management::StartCsrRequest >(
GetArenaNoVirtual());
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
return request_.start_csr_request_;
}

// optional .enterprise_management.FinishCsrRequest finish_csr_request = 6;
inline bool ClientCertificateProvisioningRequest::has_finish_csr_request() const {
return request_case() == kFinishCsrRequest;
}
inline void ClientCertificateProvisioningRequest::set_has_finish_csr_request() {
_oneof_case_[0] = kFinishCsrRequest;
}
inline void ClientCertificateProvisioningRequest::clear_finish_csr_request() {
if (has_finish_csr_request()) {
delete request_.finish_csr_request_;
clear_has_request();
}
}
inline ::enterprise_management::FinishCsrRequest* ClientCertificateProvisioningRequest::release_finish_csr_request() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
if (has_finish_csr_request()) {
clear_has_request();
::enterprise_management::FinishCsrRequest* temp = request_.finish_csr_request_;
request_.finish_csr_request_ = nullptr;
return temp;
} else {
return nullptr;
}
}
inline const ::enterprise_management::FinishCsrRequest& ClientCertificateProvisioningRequest::finish_csr_request() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
return has_finish_csr_request()
? *request_.finish_csr_request_
: *reinterpret_cast< ::enterprise_management::FinishCsrRequest*>(&::enterprise_management::_FinishCsrRequest_default_instance_);
}
inline ::enterprise_management::FinishCsrRequest* ClientCertificateProvisioningRequest::mutable_finish_csr_request() {
if (!has_finish_csr_request()) {
clear_request();
set_has_finish_csr_request();
request_.finish_csr_request_ = CreateMaybeMessage< ::enterprise_management::FinishCsrRequest >(
GetArenaNoVirtual());
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
return request_.finish_csr_request_;
}

// optional .enterprise_management.DownloadCertRequest download_cert_request = 7;
inline bool ClientCertificateProvisioningRequest::has_download_cert_request() const {
return request_case() == kDownloadCertRequest;
}
inline void ClientCertificateProvisioningRequest::set_has_download_cert_request() {
_oneof_case_[0] = kDownloadCertRequest;
}
inline void ClientCertificateProvisioningRequest::clear_download_cert_request() {
if (has_download_cert_request()) {
delete request_.download_cert_request_;
clear_has_request();
}
}
inline ::enterprise_management::DownloadCertRequest* ClientCertificateProvisioningRequest::release_download_cert_request() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
if (has_download_cert_request()) {
clear_has_request();
::enterprise_management::DownloadCertRequest* temp = request_.download_cert_request_;
request_.download_cert_request_ = nullptr;
return temp;
} else {
return nullptr;
}
}
inline const ::enterprise_management::DownloadCertRequest& ClientCertificateProvisioningRequest::download_cert_request() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
return has_download_cert_request()
? *request_.download_cert_request_
: *reinterpret_cast< ::enterprise_management::DownloadCertRequest*>(&::enterprise_management::_DownloadCertRequest_default_instance_);
}
inline ::enterprise_management::DownloadCertRequest* ClientCertificateProvisioningRequest::mutable_download_cert_request() {
if (!has_download_cert_request()) {
clear_request();
set_has_download_cert_request();
request_.download_cert_request_ = CreateMaybeMessage< ::enterprise_management::DownloadCertRequest >(
GetArenaNoVirtual());
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
return request_.download_cert_request_;
}

// optional bytes policy_version = 8;
inline bool ClientCertificateProvisioningRequest::has_policy_version() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientCertificateProvisioningRequest::clear_policy_version() {
policy_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ClientCertificateProvisioningRequest::policy_version() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
return policy_version_.GetNoArena();
}
inline void ClientCertificateProvisioningRequest::set_policy_version(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
policy_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
}
inline void ClientCertificateProvisioningRequest::set_policy_version(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
policy_version_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
}
inline void ClientCertificateProvisioningRequest::set_policy_version(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
policy_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
}
inline void ClientCertificateProvisioningRequest::set_policy_version(const void* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
policy_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_policy_version() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
return policy_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientCertificateProvisioningRequest::release_policy_version() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
if (!has_policy_version()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return policy_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientCertificateProvisioningRequest::set_allocated_policy_version(std::string* policy_version) {
if (policy_version != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
policy_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_version);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
}

inline bool ClientCertificateProvisioningRequest::has_request() const {
return request_case() != REQUEST_NOT_SET;
}
inline void ClientCertificateProvisioningRequest::clear_has_request() {
_oneof_case_[0] = REQUEST_NOT_SET;
}
inline ClientCertificateProvisioningRequest::RequestCase ClientCertificateProvisioningRequest::request_case() const {
return ClientCertificateProvisioningRequest::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientCertificateProvisioningResponse

// optional int64 try_again_later = 1;
inline bool ClientCertificateProvisioningResponse::has_try_again_later() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCertificateProvisioningResponse::clear_try_again_later() {
try_again_later_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClientCertificateProvisioningResponse::try_again_later() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.try_again_later)
return try_again_later_;
}
inline void ClientCertificateProvisioningResponse::set_try_again_later(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000001u;
try_again_later_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningResponse.try_again_later)
}

// optional .enterprise_management.ClientCertificateProvisioningResponse.Error error = 2;
inline bool ClientCertificateProvisioningResponse::has_error() const {
return response_case() == kError;
}
inline void ClientCertificateProvisioningResponse::set_has_error() {
_oneof_case_[0] = kError;
}
inline void ClientCertificateProvisioningResponse::clear_error() {
if (has_error()) {
response_.error_ = 0;
clear_has_response();
}
}
inline ::enterprise_management::ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::error() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.error)
if (has_error()) {
return static_cast< ::enterprise_management::ClientCertificateProvisioningResponse_Error >(response_.error_);
}
return static_cast< ::enterprise_management::ClientCertificateProvisioningResponse_Error >(0);
}
inline void ClientCertificateProvisioningResponse::set_error(::enterprise_management::ClientCertificateProvisioningResponse_Error value) {
assert(::enterprise_management::ClientCertificateProvisioningResponse_Error_IsValid(value));
if (!has_error()) {
clear_response();
set_has_error();
}
response_.error_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningResponse.error)
}

// optional .enterprise_management.StartCsrResponse start_csr_response = 3;
inline bool ClientCertificateProvisioningResponse::has_start_csr_response() const {
return response_case() == kStartCsrResponse;
}
inline void ClientCertificateProvisioningResponse::set_has_start_csr_response() {
_oneof_case_[0] = kStartCsrResponse;
}
inline void ClientCertificateProvisioningResponse::clear_start_csr_response() {
if (has_start_csr_response()) {
delete response_.start_csr_response_;
clear_has_response();
}
}
inline ::enterprise_management::StartCsrResponse* ClientCertificateProvisioningResponse::release_start_csr_response() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
if (has_start_csr_response()) {
clear_has_response();
::enterprise_management::StartCsrResponse* temp = response_.start_csr_response_;
response_.start_csr_response_ = nullptr;
return temp;
} else {
return nullptr;
}
}
inline const ::enterprise_management::StartCsrResponse& ClientCertificateProvisioningResponse::start_csr_response() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
return has_start_csr_response()
? *response_.start_csr_response_
: *reinterpret_cast< ::enterprise_management::StartCsrResponse*>(&::enterprise_management::_StartCsrResponse_default_instance_);
}
inline ::enterprise_management::StartCsrResponse* ClientCertificateProvisioningResponse::mutable_start_csr_response() {
if (!has_start_csr_response()) {
clear_response();
set_has_start_csr_response();
response_.start_csr_response_ = CreateMaybeMessage< ::enterprise_management::StartCsrResponse >(
GetArenaNoVirtual());
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
return response_.start_csr_response_;
}

// optional .enterprise_management.FinishCsrResponse finish_csr_response = 4;
inline bool ClientCertificateProvisioningResponse::has_finish_csr_response() const {
return response_case() == kFinishCsrResponse;
}
inline void ClientCertificateProvisioningResponse::set_has_finish_csr_response() {
_oneof_case_[0] = kFinishCsrResponse;
}
inline void ClientCertificateProvisioningResponse::clear_finish_csr_response() {
if (has_finish_csr_response()) {
delete response_.finish_csr_response_;
clear_has_response();
}
}
inline ::enterprise_management::FinishCsrResponse* ClientCertificateProvisioningResponse::release_finish_csr_response() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
if (has_finish_csr_response()) {
clear_has_response();
::enterprise_management::FinishCsrResponse* temp = response_.finish_csr_response_;
response_.finish_csr_response_ = nullptr;
return temp;
} else {
return nullptr;
}
}
inline const ::enterprise_management::FinishCsrResponse& ClientCertificateProvisioningResponse::finish_csr_response() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
return has_finish_csr_response()
? *response_.finish_csr_response_
: *reinterpret_cast< ::enterprise_management::FinishCsrResponse*>(&::enterprise_management::_FinishCsrResponse_default_instance_);
}
inline ::enterprise_management::FinishCsrResponse* ClientCertificateProvisioningResponse::mutable_finish_csr_response() {
if (!has_finish_csr_response()) {
clear_response();
set_has_finish_csr_response();
response_.finish_csr_response_ = CreateMaybeMessage< ::enterprise_management::FinishCsrResponse >(
GetArenaNoVirtual());
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
return response_.finish_csr_response_;
}

// optional .enterprise_management.DownloadCertResponse download_cert_response = 5;
inline bool ClientCertificateProvisioningResponse::has_download_cert_response() const {
return response_case() == kDownloadCertResponse;
}
inline void ClientCertificateProvisioningResponse::set_has_download_cert_response() {
_oneof_case_[0] = kDownloadCertResponse;
}
inline void ClientCertificateProvisioningResponse::clear_download_cert_response() {
if (has_download_cert_response()) {
delete response_.download_cert_response_;
clear_has_response();
}
}
inline ::enterprise_management::DownloadCertResponse* ClientCertificateProvisioningResponse::release_download_cert_response() {
// @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
if (has_download_cert_response()) {
clear_has_response();
::enterprise_management::DownloadCertResponse* temp = response_.download_cert_response_;
response_.download_cert_response_ = nullptr;
return temp;
} else {
return nullptr;
}
}
inline const ::enterprise_management::DownloadCertResponse& ClientCertificateProvisioningResponse::download_cert_response() const {
// @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
return has_download_cert_response()
? *response_.download_cert_response_
: *reinterpret_cast< ::enterprise_management::DownloadCertResponse*>(&::enterprise_management::_DownloadCertResponse_default_instance_);
}
inline ::enterprise_management::DownloadCertResponse* ClientCertificateProvisioningResponse::mutable_download_cert_response() {
if (!has_download_cert_response()) {
clear_response();
set_has_download_cert_response();
response_.download_cert_response_ = CreateMaybeMessage< ::enterprise_management::DownloadCertResponse >(
GetArenaNoVirtual());
}
// @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
return response_.download_cert_response_;
}

inline bool ClientCertificateProvisioningResponse::has_response() const {
return response_case() != RESPONSE_NOT_SET;
}
inline void ClientCertificateProvisioningResponse::clear_has_response() {
_oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ClientCertificateProvisioningResponse::ResponseCase ClientCertificateProvisioningResponse::response_case() const {
return ClientCertificateProvisioningResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DeviceManagementRequest

// optional .enterprise_management.DeviceRegisterRequest register_request = 1;
inline bool DeviceManagementRequest::has_register_request() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceManagementRequest::clear_register_request() {
if (register_request_ != nullptr) register_request_->Clear();
_has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DeviceRegisterRequest& DeviceManagementRequest::register_request() const {
const ::enterprise_management::DeviceRegisterRequest* p = register_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.register_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceRegisterRequest*>(
&::enterprise_management::_DeviceRegisterRequest_default_instance_);
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::release_register_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.register_request)
_has_bits_[0] &= ~0x00000001u;
::enterprise_management::DeviceRegisterRequest* temp = register_request_;
register_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::mutable_register_request() {
_has_bits_[0] |= 0x00000001u;
if (register_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterRequest>(GetArenaNoVirtual());
register_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.register_request)
return register_request_;
}
inline void DeviceManagementRequest::set_allocated_register_request(::enterprise_management::DeviceRegisterRequest* register_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete register_request_;
}
if (register_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
register_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, register_request, submessage_arena);
}
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
register_request_ = register_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.register_request)
}

// optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
inline bool DeviceManagementRequest::has_unregister_request() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceManagementRequest::clear_unregister_request() {
if (unregister_request_ != nullptr) unregister_request_->Clear();
_has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DeviceUnregisterRequest& DeviceManagementRequest::unregister_request() const {
const ::enterprise_management::DeviceUnregisterRequest* p = unregister_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.unregister_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceUnregisterRequest*>(
&::enterprise_management::_DeviceUnregisterRequest_default_instance_);
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::release_unregister_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.unregister_request)
_has_bits_[0] &= ~0x00000002u;
::enterprise_management::DeviceUnregisterRequest* temp = unregister_request_;
unregister_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::mutable_unregister_request() {
_has_bits_[0] |= 0x00000002u;
if (unregister_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceUnregisterRequest>(GetArenaNoVirtual());
unregister_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.unregister_request)
return unregister_request_;
}
inline void DeviceManagementRequest::set_allocated_unregister_request(::enterprise_management::DeviceUnregisterRequest* unregister_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete unregister_request_;
}
if (unregister_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
unregister_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, unregister_request, submessage_arena);
}
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
unregister_request_ = unregister_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.unregister_request)
}

// optional .enterprise_management.DevicePolicyRequest policy_request = 3;
inline bool DeviceManagementRequest::has_policy_request() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceManagementRequest::clear_policy_request() {
if (policy_request_ != nullptr) policy_request_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::DevicePolicyRequest& DeviceManagementRequest::policy_request() const {
const ::enterprise_management::DevicePolicyRequest* p = policy_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.policy_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DevicePolicyRequest*>(
&::enterprise_management::_DevicePolicyRequest_default_instance_);
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::release_policy_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.policy_request)
_has_bits_[0] &= ~0x00000004u;
::enterprise_management::DevicePolicyRequest* temp = policy_request_;
policy_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::mutable_policy_request() {
_has_bits_[0] |= 0x00000004u;
if (policy_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DevicePolicyRequest>(GetArenaNoVirtual());
policy_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.policy_request)
return policy_request_;
}
inline void DeviceManagementRequest::set_allocated_policy_request(::enterprise_management::DevicePolicyRequest* policy_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete policy_request_;
}
if (policy_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
policy_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, policy_request, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
policy_request_ = policy_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.policy_request)
}

// optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
inline bool DeviceManagementRequest::has_device_status_report_request() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceManagementRequest::clear_device_status_report_request() {
if (device_status_report_request_ != nullptr) device_status_report_request_->Clear();
_has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::DeviceStatusReportRequest& DeviceManagementRequest::device_status_report_request() const {
const ::enterprise_management::DeviceStatusReportRequest* p = device_status_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_status_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceStatusReportRequest*>(
&::enterprise_management::_DeviceStatusReportRequest_default_instance_);
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::release_device_status_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_status_report_request)
_has_bits_[0] &= ~0x00000008u;
::enterprise_management::DeviceStatusReportRequest* temp = device_status_report_request_;
device_status_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::mutable_device_status_report_request() {
_has_bits_[0] |= 0x00000008u;
if (device_status_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceStatusReportRequest>(GetArenaNoVirtual());
device_status_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_status_report_request)
return device_status_report_request_;
}
inline void DeviceManagementRequest::set_allocated_device_status_report_request(::enterprise_management::DeviceStatusReportRequest* device_status_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_status_report_request_;
}
if (device_status_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_status_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_status_report_request, submessage_arena);
}
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
device_status_report_request_ = device_status_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_status_report_request)
}

// optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
inline bool DeviceManagementRequest::has_session_status_report_request() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceManagementRequest::clear_session_status_report_request() {
if (session_status_report_request_ != nullptr) session_status_report_request_->Clear();
_has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::SessionStatusReportRequest& DeviceManagementRequest::session_status_report_request() const {
const ::enterprise_management::SessionStatusReportRequest* p = session_status_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.session_status_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::SessionStatusReportRequest*>(
&::enterprise_management::_SessionStatusReportRequest_default_instance_);
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::release_session_status_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.session_status_report_request)
_has_bits_[0] &= ~0x00000010u;
::enterprise_management::SessionStatusReportRequest* temp = session_status_report_request_;
session_status_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::mutable_session_status_report_request() {
_has_bits_[0] |= 0x00000010u;
if (session_status_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::SessionStatusReportRequest>(GetArenaNoVirtual());
session_status_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.session_status_report_request)
return session_status_report_request_;
}
inline void DeviceManagementRequest::set_allocated_session_status_report_request(::enterprise_management::SessionStatusReportRequest* session_status_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete session_status_report_request_;
}
if (session_status_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
session_status_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, session_status_report_request, submessage_arena);
}
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
session_status_report_request_ = session_status_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.session_status_report_request)
}

// optional .enterprise_management.ChildStatusReportRequest child_status_report_request = 30;
inline bool DeviceManagementRequest::has_child_status_report_request() const {
return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void DeviceManagementRequest::clear_child_status_report_request() {
if (child_status_report_request_ != nullptr) child_status_report_request_->Clear();
_has_bits_[0] &= ~0x10000000u;
}
inline const ::enterprise_management::ChildStatusReportRequest& DeviceManagementRequest::child_status_report_request() const {
const ::enterprise_management::ChildStatusReportRequest* p = child_status_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.child_status_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ChildStatusReportRequest*>(
&::enterprise_management::_ChildStatusReportRequest_default_instance_);
}
inline ::enterprise_management::ChildStatusReportRequest* DeviceManagementRequest::release_child_status_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.child_status_report_request)
_has_bits_[0] &= ~0x10000000u;
::enterprise_management::ChildStatusReportRequest* temp = child_status_report_request_;
child_status_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ChildStatusReportRequest* DeviceManagementRequest::mutable_child_status_report_request() {
_has_bits_[0] |= 0x10000000u;
if (child_status_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ChildStatusReportRequest>(GetArenaNoVirtual());
child_status_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.child_status_report_request)
return child_status_report_request_;
}
inline void DeviceManagementRequest::set_allocated_child_status_report_request(::enterprise_management::ChildStatusReportRequest* child_status_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete child_status_report_request_;
}
if (child_status_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
child_status_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, child_status_report_request, submessage_arena);
}
_has_bits_[0] |= 0x10000000u;
} else {
_has_bits_[0] &= ~0x10000000u;
}
child_status_report_request_ = child_status_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.child_status_report_request)
}

// optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
inline bool DeviceManagementRequest::has_auto_enrollment_request() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceManagementRequest::clear_auto_enrollment_request() {
if (auto_enrollment_request_ != nullptr) auto_enrollment_request_->Clear();
_has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::DeviceAutoEnrollmentRequest& DeviceManagementRequest::auto_enrollment_request() const {
const ::enterprise_management::DeviceAutoEnrollmentRequest* p = auto_enrollment_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceAutoEnrollmentRequest*>(
&::enterprise_management::_DeviceAutoEnrollmentRequest_default_instance_);
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::release_auto_enrollment_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
_has_bits_[0] &= ~0x00000020u;
::enterprise_management::DeviceAutoEnrollmentRequest* temp = auto_enrollment_request_;
auto_enrollment_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::mutable_auto_enrollment_request() {
_has_bits_[0] |= 0x00000020u;
if (auto_enrollment_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentRequest>(GetArenaNoVirtual());
auto_enrollment_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
return auto_enrollment_request_;
}
inline void DeviceManagementRequest::set_allocated_auto_enrollment_request(::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete auto_enrollment_request_;
}
if (auto_enrollment_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
auto_enrollment_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, auto_enrollment_request, submessage_arena);
}
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
auto_enrollment_request_ = auto_enrollment_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
}

// optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
inline bool DeviceManagementRequest::has_cert_upload_request() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceManagementRequest::clear_cert_upload_request() {
if (cert_upload_request_ != nullptr) cert_upload_request_->Clear();
_has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::DeviceCertUploadRequest& DeviceManagementRequest::cert_upload_request() const {
const ::enterprise_management::DeviceCertUploadRequest* p = cert_upload_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.cert_upload_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceCertUploadRequest*>(
&::enterprise_management::_DeviceCertUploadRequest_default_instance_);
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::release_cert_upload_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.cert_upload_request)
_has_bits_[0] &= ~0x00000040u;
::enterprise_management::DeviceCertUploadRequest* temp = cert_upload_request_;
cert_upload_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::mutable_cert_upload_request() {
_has_bits_[0] |= 0x00000040u;
if (cert_upload_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceCertUploadRequest>(GetArenaNoVirtual());
cert_upload_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.cert_upload_request)
return cert_upload_request_;
}
inline void DeviceManagementRequest::set_allocated_cert_upload_request(::enterprise_management::DeviceCertUploadRequest* cert_upload_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete cert_upload_request_;
}
if (cert_upload_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
cert_upload_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, cert_upload_request, submessage_arena);
}
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
cert_upload_request_ = cert_upload_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.cert_upload_request)
}

// optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
inline bool DeviceManagementRequest::has_service_api_access_request() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceManagementRequest::clear_service_api_access_request() {
if (service_api_access_request_ != nullptr) service_api_access_request_->Clear();
_has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::DeviceServiceApiAccessRequest& DeviceManagementRequest::service_api_access_request() const {
const ::enterprise_management::DeviceServiceApiAccessRequest* p = service_api_access_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.service_api_access_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceServiceApiAccessRequest*>(
&::enterprise_management::_DeviceServiceApiAccessRequest_default_instance_);
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::release_service_api_access_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.service_api_access_request)
_has_bits_[0] &= ~0x00000080u;
::enterprise_management::DeviceServiceApiAccessRequest* temp = service_api_access_request_;
service_api_access_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::mutable_service_api_access_request() {
_has_bits_[0] |= 0x00000080u;
if (service_api_access_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessRequest>(GetArenaNoVirtual());
service_api_access_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.service_api_access_request)
return service_api_access_request_;
}
inline void DeviceManagementRequest::set_allocated_service_api_access_request(::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete service_api_access_request_;
}
if (service_api_access_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
service_api_access_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, service_api_access_request, submessage_arena);
}
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
service_api_access_request_ = service_api_access_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.service_api_access_request)
}

// optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
inline bool DeviceManagementRequest::has_device_state_retrieval_request() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceManagementRequest::clear_device_state_retrieval_request() {
if (device_state_retrieval_request_ != nullptr) device_state_retrieval_request_->Clear();
_has_bits_[0] &= ~0x00000100u;
}
inline const ::enterprise_management::DeviceStateRetrievalRequest& DeviceManagementRequest::device_state_retrieval_request() const {
const ::enterprise_management::DeviceStateRetrievalRequest* p = device_state_retrieval_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceStateRetrievalRequest*>(
&::enterprise_management::_DeviceStateRetrievalRequest_default_instance_);
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::release_device_state_retrieval_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
_has_bits_[0] &= ~0x00000100u;
::enterprise_management::DeviceStateRetrievalRequest* temp = device_state_retrieval_request_;
device_state_retrieval_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::mutable_device_state_retrieval_request() {
_has_bits_[0] |= 0x00000100u;
if (device_state_retrieval_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalRequest>(GetArenaNoVirtual());
device_state_retrieval_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
return device_state_retrieval_request_;
}
inline void DeviceManagementRequest::set_allocated_device_state_retrieval_request(::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_state_retrieval_request_;
}
if (device_state_retrieval_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_state_retrieval_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_state_retrieval_request, submessage_arena);
}
_has_bits_[0] |= 0x00000100u;
} else {
_has_bits_[0] &= ~0x00000100u;
}
device_state_retrieval_request_ = device_state_retrieval_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
}

// optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
inline bool DeviceManagementRequest::has_device_state_key_update_request() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceManagementRequest::clear_device_state_key_update_request() {
if (device_state_key_update_request_ != nullptr) device_state_key_update_request_->Clear();
_has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::DeviceStateKeyUpdateRequest& DeviceManagementRequest::device_state_key_update_request() const {
const ::enterprise_management::DeviceStateKeyUpdateRequest* p = device_state_key_update_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceStateKeyUpdateRequest*>(
&::enterprise_management::_DeviceStateKeyUpdateRequest_default_instance_);
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::release_device_state_key_update_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
_has_bits_[0] &= ~0x00000200u;
::enterprise_management::DeviceStateKeyUpdateRequest* temp = device_state_key_update_request_;
device_state_key_update_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::mutable_device_state_key_update_request() {
_has_bits_[0] |= 0x00000200u;
if (device_state_key_update_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceStateKeyUpdateRequest>(GetArenaNoVirtual());
device_state_key_update_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
return device_state_key_update_request_;
}
inline void DeviceManagementRequest::set_allocated_device_state_key_update_request(::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_state_key_update_request_;
}
if (device_state_key_update_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_state_key_update_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_state_key_update_request, submessage_arena);
}
_has_bits_[0] |= 0x00000200u;
} else {
_has_bits_[0] &= ~0x00000200u;
}
device_state_key_update_request_ = device_state_key_update_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
}

// optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
inline bool DeviceManagementRequest::has_device_pairing_request() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceManagementRequest::clear_device_pairing_request() {
if (device_pairing_request_ != nullptr) device_pairing_request_->Clear();
_has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::DevicePairingRequest& DeviceManagementRequest::device_pairing_request() const {
const ::enterprise_management::DevicePairingRequest* p = device_pairing_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_pairing_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DevicePairingRequest*>(
&::enterprise_management::_DevicePairingRequest_default_instance_);
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::release_device_pairing_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_pairing_request)
_has_bits_[0] &= ~0x00000400u;
::enterprise_management::DevicePairingRequest* temp = device_pairing_request_;
device_pairing_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::mutable_device_pairing_request() {
_has_bits_[0] |= 0x00000400u;
if (device_pairing_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DevicePairingRequest>(GetArenaNoVirtual());
device_pairing_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_pairing_request)
return device_pairing_request_;
}
inline void DeviceManagementRequest::set_allocated_device_pairing_request(::enterprise_management::DevicePairingRequest* device_pairing_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_pairing_request_;
}
if (device_pairing_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_pairing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_pairing_request, submessage_arena);
}
_has_bits_[0] |= 0x00000400u;
} else {
_has_bits_[0] &= ~0x00000400u;
}
device_pairing_request_ = device_pairing_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_pairing_request)
}

// optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
inline bool DeviceManagementRequest::has_check_device_pairing_request() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceManagementRequest::clear_check_device_pairing_request() {
if (check_device_pairing_request_ != nullptr) check_device_pairing_request_->Clear();
_has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::CheckDevicePairingRequest& DeviceManagementRequest::check_device_pairing_request() const {
const ::enterprise_management::CheckDevicePairingRequest* p = check_device_pairing_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CheckDevicePairingRequest*>(
&::enterprise_management::_CheckDevicePairingRequest_default_instance_);
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::release_check_device_pairing_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
_has_bits_[0] &= ~0x00000800u;
::enterprise_management::CheckDevicePairingRequest* temp = check_device_pairing_request_;
check_device_pairing_request_ = nullptr;
return temp;
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::mutable_check_device_pairing_request() {
_has_bits_[0] |= 0x00000800u;
if (check_device_pairing_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CheckDevicePairingRequest>(GetArenaNoVirtual());
check_device_pairing_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
return check_device_pairing_request_;
}
inline void DeviceManagementRequest::set_allocated_check_device_pairing_request(::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete check_device_pairing_request_;
}
if (check_device_pairing_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
check_device_pairing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, check_device_pairing_request, submessage_arena);
}
_has_bits_[0] |= 0x00000800u;
} else {
_has_bits_[0] &= ~0x00000800u;
}
check_device_pairing_request_ = check_device_pairing_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
}

// optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
inline bool DeviceManagementRequest::has_remote_command_request() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceManagementRequest::clear_remote_command_request() {
if (remote_command_request_ != nullptr) remote_command_request_->Clear();
_has_bits_[0] &= ~0x00001000u;
}
inline const ::enterprise_management::DeviceRemoteCommandRequest& DeviceManagementRequest::remote_command_request() const {
const ::enterprise_management::DeviceRemoteCommandRequest* p = remote_command_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.remote_command_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceRemoteCommandRequest*>(
&::enterprise_management::_DeviceRemoteCommandRequest_default_instance_);
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::release_remote_command_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.remote_command_request)
_has_bits_[0] &= ~0x00001000u;
::enterprise_management::DeviceRemoteCommandRequest* temp = remote_command_request_;
remote_command_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::mutable_remote_command_request() {
_has_bits_[0] |= 0x00001000u;
if (remote_command_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandRequest>(GetArenaNoVirtual());
remote_command_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.remote_command_request)
return remote_command_request_;
}
inline void DeviceManagementRequest::set_allocated_remote_command_request(::enterprise_management::DeviceRemoteCommandRequest* remote_command_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete remote_command_request_;
}
if (remote_command_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
remote_command_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, remote_command_request, submessage_arena);
}
_has_bits_[0] |= 0x00001000u;
} else {
_has_bits_[0] &= ~0x00001000u;
}
remote_command_request_ = remote_command_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.remote_command_request)
}

// optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
inline bool DeviceManagementRequest::has_device_attribute_update_permission_request() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceManagementRequest::clear_device_attribute_update_permission_request() {
if (device_attribute_update_permission_request_ != nullptr) device_attribute_update_permission_request_->Clear();
_has_bits_[0] &= ~0x00002000u;
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& DeviceManagementRequest::device_attribute_update_permission_request() const {
const ::enterprise_management::DeviceAttributeUpdatePermissionRequest* p = device_attribute_update_permission_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdatePermissionRequest*>(
&::enterprise_management::_DeviceAttributeUpdatePermissionRequest_default_instance_);
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::release_device_attribute_update_permission_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
_has_bits_[0] &= ~0x00002000u;
::enterprise_management::DeviceAttributeUpdatePermissionRequest* temp = device_attribute_update_permission_request_;
device_attribute_update_permission_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::mutable_device_attribute_update_permission_request() {
_has_bits_[0] |= 0x00002000u;
if (device_attribute_update_permission_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionRequest>(GetArenaNoVirtual());
device_attribute_update_permission_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
return device_attribute_update_permission_request_;
}
inline void DeviceManagementRequest::set_allocated_device_attribute_update_permission_request(::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_attribute_update_permission_request_;
}
if (device_attribute_update_permission_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_attribute_update_permission_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_attribute_update_permission_request, submessage_arena);
}
_has_bits_[0] |= 0x00002000u;
} else {
_has_bits_[0] &= ~0x00002000u;
}
device_attribute_update_permission_request_ = device_attribute_update_permission_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
}

// optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
inline bool DeviceManagementRequest::has_device_attribute_update_request() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceManagementRequest::clear_device_attribute_update_request() {
if (device_attribute_update_request_ != nullptr) device_attribute_update_request_->Clear();
_has_bits_[0] &= ~0x00004000u;
}
inline const ::enterprise_management::DeviceAttributeUpdateRequest& DeviceManagementRequest::device_attribute_update_request() const {
const ::enterprise_management::DeviceAttributeUpdateRequest* p = device_attribute_update_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdateRequest*>(
&::enterprise_management::_DeviceAttributeUpdateRequest_default_instance_);
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::release_device_attribute_update_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
_has_bits_[0] &= ~0x00004000u;
::enterprise_management::DeviceAttributeUpdateRequest* temp = device_attribute_update_request_;
device_attribute_update_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::mutable_device_attribute_update_request() {
_has_bits_[0] |= 0x00004000u;
if (device_attribute_update_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateRequest>(GetArenaNoVirtual());
device_attribute_update_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
return device_attribute_update_request_;
}
inline void DeviceManagementRequest::set_allocated_device_attribute_update_request(::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_attribute_update_request_;
}
if (device_attribute_update_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_attribute_update_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_attribute_update_request, submessage_arena);
}
_has_bits_[0] |= 0x00004000u;
} else {
_has_bits_[0] &= ~0x00004000u;
}
device_attribute_update_request_ = device_attribute_update_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
}

// optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
inline bool DeviceManagementRequest::has_gcm_id_update_request() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceManagementRequest::clear_gcm_id_update_request() {
if (gcm_id_update_request_ != nullptr) gcm_id_update_request_->Clear();
_has_bits_[0] &= ~0x00008000u;
}
inline const ::enterprise_management::GcmIdUpdateRequest& DeviceManagementRequest::gcm_id_update_request() const {
const ::enterprise_management::GcmIdUpdateRequest* p = gcm_id_update_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::GcmIdUpdateRequest*>(
&::enterprise_management::_GcmIdUpdateRequest_default_instance_);
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::release_gcm_id_update_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
_has_bits_[0] &= ~0x00008000u;
::enterprise_management::GcmIdUpdateRequest* temp = gcm_id_update_request_;
gcm_id_update_request_ = nullptr;
return temp;
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::mutable_gcm_id_update_request() {
_has_bits_[0] |= 0x00008000u;
if (gcm_id_update_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::GcmIdUpdateRequest>(GetArenaNoVirtual());
gcm_id_update_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
return gcm_id_update_request_;
}
inline void DeviceManagementRequest::set_allocated_gcm_id_update_request(::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete gcm_id_update_request_;
}
if (gcm_id_update_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
gcm_id_update_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, gcm_id_update_request, submessage_arena);
}
_has_bits_[0] |= 0x00008000u;
} else {
_has_bits_[0] &= ~0x00008000u;
}
gcm_id_update_request_ = gcm_id_update_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
}

// optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
inline bool DeviceManagementRequest::has_check_android_management_request() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceManagementRequest::clear_check_android_management_request() {
if (check_android_management_request_ != nullptr) check_android_management_request_->Clear();
_has_bits_[0] &= ~0x00010000u;
}
inline const ::enterprise_management::CheckAndroidManagementRequest& DeviceManagementRequest::check_android_management_request() const {
const ::enterprise_management::CheckAndroidManagementRequest* p = check_android_management_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_android_management_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CheckAndroidManagementRequest*>(
&::enterprise_management::_CheckAndroidManagementRequest_default_instance_);
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::release_check_android_management_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_android_management_request)
_has_bits_[0] &= ~0x00010000u;
::enterprise_management::CheckAndroidManagementRequest* temp = check_android_management_request_;
check_android_management_request_ = nullptr;
return temp;
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::mutable_check_android_management_request() {
_has_bits_[0] |= 0x00010000u;
if (check_android_management_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CheckAndroidManagementRequest>(GetArenaNoVirtual());
check_android_management_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_android_management_request)
return check_android_management_request_;
}
inline void DeviceManagementRequest::set_allocated_check_android_management_request(::enterprise_management::CheckAndroidManagementRequest* check_android_management_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete check_android_management_request_;
}
if (check_android_management_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
check_android_management_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, check_android_management_request, submessage_arena);
}
_has_bits_[0] |= 0x00010000u;
} else {
_has_bits_[0] &= ~0x00010000u;
}
check_android_management_request_ = check_android_management_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_android_management_request)
}

// optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
inline bool DeviceManagementRequest::has_certificate_based_register_request() const {
return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceManagementRequest::clear_certificate_based_register_request() {
if (certificate_based_register_request_ != nullptr) certificate_based_register_request_->Clear();
_has_bits_[0] &= ~0x00020000u;
}
inline const ::enterprise_management::CertificateBasedDeviceRegisterRequest& DeviceManagementRequest::certificate_based_register_request() const {
const ::enterprise_management::CertificateBasedDeviceRegisterRequest* p = certificate_based_register_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CertificateBasedDeviceRegisterRequest*>(
&::enterprise_management::_CertificateBasedDeviceRegisterRequest_default_instance_);
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::release_certificate_based_register_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
_has_bits_[0] &= ~0x00020000u;
::enterprise_management::CertificateBasedDeviceRegisterRequest* temp = certificate_based_register_request_;
certificate_based_register_request_ = nullptr;
return temp;
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::mutable_certificate_based_register_request() {
_has_bits_[0] |= 0x00020000u;
if (certificate_based_register_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CertificateBasedDeviceRegisterRequest>(GetArenaNoVirtual());
certificate_based_register_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
return certificate_based_register_request_;
}
inline void DeviceManagementRequest::set_allocated_certificate_based_register_request(::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete certificate_based_register_request_;
}
if (certificate_based_register_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
certificate_based_register_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, certificate_based_register_request, submessage_arena);
}
_has_bits_[0] |= 0x00020000u;
} else {
_has_bits_[0] &= ~0x00020000u;
}
certificate_based_register_request_ = certificate_based_register_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
}

// optional .enterprise_management.ActiveDirectoryEnrollPlayUserRequest active_directory_enroll_play_user_request = 19;
inline bool DeviceManagementRequest::has_active_directory_enroll_play_user_request() const {
return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DeviceManagementRequest::clear_active_directory_enroll_play_user_request() {
if (active_directory_enroll_play_user_request_ != nullptr) active_directory_enroll_play_user_request_->Clear();
_has_bits_[0] &= ~0x00040000u;
}
inline const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest& DeviceManagementRequest::active_directory_enroll_play_user_request() const {
const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* p = active_directory_enroll_play_user_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest*>(
&::enterprise_management::_ActiveDirectoryEnrollPlayUserRequest_default_instance_);
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* DeviceManagementRequest::release_active_directory_enroll_play_user_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
_has_bits_[0] &= ~0x00040000u;
::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* temp = active_directory_enroll_play_user_request_;
active_directory_enroll_play_user_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* DeviceManagementRequest::mutable_active_directory_enroll_play_user_request() {
_has_bits_[0] |= 0x00040000u;
if (active_directory_enroll_play_user_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserRequest>(GetArenaNoVirtual());
active_directory_enroll_play_user_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
return active_directory_enroll_play_user_request_;
}
inline void DeviceManagementRequest::set_allocated_active_directory_enroll_play_user_request(::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete active_directory_enroll_play_user_request_;
}
if (active_directory_enroll_play_user_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
active_directory_enroll_play_user_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, active_directory_enroll_play_user_request, submessage_arena);
}
_has_bits_[0] |= 0x00040000u;
} else {
_has_bits_[0] &= ~0x00040000u;
}
active_directory_enroll_play_user_request_ = active_directory_enroll_play_user_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
}

// optional .enterprise_management.ActiveDirectoryPlayActivityRequest active_directory_play_activity_request = 20;
inline bool DeviceManagementRequest::has_active_directory_play_activity_request() const {
return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DeviceManagementRequest::clear_active_directory_play_activity_request() {
if (active_directory_play_activity_request_ != nullptr) active_directory_play_activity_request_->Clear();
_has_bits_[0] &= ~0x00080000u;
}
inline const ::enterprise_management::ActiveDirectoryPlayActivityRequest& DeviceManagementRequest::active_directory_play_activity_request() const {
const ::enterprise_management::ActiveDirectoryPlayActivityRequest* p = active_directory_play_activity_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ActiveDirectoryPlayActivityRequest*>(
&::enterprise_management::_ActiveDirectoryPlayActivityRequest_default_instance_);
}
inline ::enterprise_management::ActiveDirectoryPlayActivityRequest* DeviceManagementRequest::release_active_directory_play_activity_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
_has_bits_[0] &= ~0x00080000u;
::enterprise_management::ActiveDirectoryPlayActivityRequest* temp = active_directory_play_activity_request_;
active_directory_play_activity_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityRequest* DeviceManagementRequest::mutable_active_directory_play_activity_request() {
_has_bits_[0] |= 0x00080000u;
if (active_directory_play_activity_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityRequest>(GetArenaNoVirtual());
active_directory_play_activity_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
return active_directory_play_activity_request_;
}
inline void DeviceManagementRequest::set_allocated_active_directory_play_activity_request(::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete active_directory_play_activity_request_;
}
if (active_directory_play_activity_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
active_directory_play_activity_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, active_directory_play_activity_request, submessage_arena);
}
_has_bits_[0] |= 0x00080000u;
} else {
_has_bits_[0] &= ~0x00080000u;
}
active_directory_play_activity_request_ = active_directory_play_activity_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
}

// optional .enterprise_management.CheckDeviceLicenseRequest check_device_license_request_deprecated = 21 [deprecated = true];
inline bool DeviceManagementRequest::has_check_device_license_request_deprecated() const {
return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DeviceManagementRequest::clear_check_device_license_request_deprecated() {
if (check_device_license_request_deprecated_ != nullptr) check_device_license_request_deprecated_->Clear();
_has_bits_[0] &= ~0x00100000u;
}
inline const ::enterprise_management::CheckDeviceLicenseRequest& DeviceManagementRequest::check_device_license_request_deprecated() const {
const ::enterprise_management::CheckDeviceLicenseRequest* p = check_device_license_request_deprecated_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CheckDeviceLicenseRequest*>(
&::enterprise_management::_CheckDeviceLicenseRequest_default_instance_);
}
inline ::enterprise_management::CheckDeviceLicenseRequest* DeviceManagementRequest::release_check_device_license_request_deprecated() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
_has_bits_[0] &= ~0x00100000u;
::enterprise_management::CheckDeviceLicenseRequest* temp = check_device_license_request_deprecated_;
check_device_license_request_deprecated_ = nullptr;
return temp;
}
inline ::enterprise_management::CheckDeviceLicenseRequest* DeviceManagementRequest::mutable_check_device_license_request_deprecated() {
_has_bits_[0] |= 0x00100000u;
if (check_device_license_request_deprecated_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseRequest>(GetArenaNoVirtual());
check_device_license_request_deprecated_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
return check_device_license_request_deprecated_;
}
inline void DeviceManagementRequest::set_allocated_check_device_license_request_deprecated(::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete check_device_license_request_deprecated_;
}
if (check_device_license_request_deprecated) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
check_device_license_request_deprecated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, check_device_license_request_deprecated, submessage_arena);
}
_has_bits_[0] |= 0x00100000u;
} else {
_has_bits_[0] &= ~0x00100000u;
}
check_device_license_request_deprecated_ = check_device_license_request_deprecated;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
}

// optional .enterprise_management.ActiveDirectoryUserSigninRequest active_directory_user_signin_request = 22;
inline bool DeviceManagementRequest::has_active_directory_user_signin_request() const {
return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DeviceManagementRequest::clear_active_directory_user_signin_request() {
if (active_directory_user_signin_request_ != nullptr) active_directory_user_signin_request_->Clear();
_has_bits_[0] &= ~0x00200000u;
}
inline const ::enterprise_management::ActiveDirectoryUserSigninRequest& DeviceManagementRequest::active_directory_user_signin_request() const {
const ::enterprise_management::ActiveDirectoryUserSigninRequest* p = active_directory_user_signin_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ActiveDirectoryUserSigninRequest*>(
&::enterprise_management::_ActiveDirectoryUserSigninRequest_default_instance_);
}
inline ::enterprise_management::ActiveDirectoryUserSigninRequest* DeviceManagementRequest::release_active_directory_user_signin_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
_has_bits_[0] &= ~0x00200000u;
::enterprise_management::ActiveDirectoryUserSigninRequest* temp = active_directory_user_signin_request_;
active_directory_user_signin_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ActiveDirectoryUserSigninRequest* DeviceManagementRequest::mutable_active_directory_user_signin_request() {
_has_bits_[0] |= 0x00200000u;
if (active_directory_user_signin_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninRequest>(GetArenaNoVirtual());
active_directory_user_signin_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
return active_directory_user_signin_request_;
}
inline void DeviceManagementRequest::set_allocated_active_directory_user_signin_request(::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete active_directory_user_signin_request_;
}
if (active_directory_user_signin_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
active_directory_user_signin_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, active_directory_user_signin_request, submessage_arena);
}
_has_bits_[0] |= 0x00200000u;
} else {
_has_bits_[0] &= ~0x00200000u;
}
active_directory_user_signin_request_ = active_directory_user_signin_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
}

// optional .enterprise_management.RegisterBrowserRequest register_browser_request = 23;
inline bool DeviceManagementRequest::has_register_browser_request() const {
return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DeviceManagementRequest::clear_register_browser_request() {
if (register_browser_request_ != nullptr) register_browser_request_->Clear();
_has_bits_[0] &= ~0x00400000u;
}
inline const ::enterprise_management::RegisterBrowserRequest& DeviceManagementRequest::register_browser_request() const {
const ::enterprise_management::RegisterBrowserRequest* p = register_browser_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.register_browser_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::RegisterBrowserRequest*>(
&::enterprise_management::_RegisterBrowserRequest_default_instance_);
}
inline ::enterprise_management::RegisterBrowserRequest* DeviceManagementRequest::release_register_browser_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.register_browser_request)
_has_bits_[0] &= ~0x00400000u;
::enterprise_management::RegisterBrowserRequest* temp = register_browser_request_;
register_browser_request_ = nullptr;
return temp;
}
inline ::enterprise_management::RegisterBrowserRequest* DeviceManagementRequest::mutable_register_browser_request() {
_has_bits_[0] |= 0x00400000u;
if (register_browser_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::RegisterBrowserRequest>(GetArenaNoVirtual());
register_browser_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.register_browser_request)
return register_browser_request_;
}
inline void DeviceManagementRequest::set_allocated_register_browser_request(::enterprise_management::RegisterBrowserRequest* register_browser_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete register_browser_request_;
}
if (register_browser_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
register_browser_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, register_browser_request, submessage_arena);
}
_has_bits_[0] |= 0x00400000u;
} else {
_has_bits_[0] &= ~0x00400000u;
}
register_browser_request_ = register_browser_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.register_browser_request)
}

// optional .enterprise_management.AppInstallReportRequest app_install_report_request = 25;
inline bool DeviceManagementRequest::has_app_install_report_request() const {
return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DeviceManagementRequest::clear_app_install_report_request() {
if (app_install_report_request_ != nullptr) app_install_report_request_->Clear();
_has_bits_[0] &= ~0x00800000u;
}
inline const ::enterprise_management::AppInstallReportRequest& DeviceManagementRequest::app_install_report_request() const {
const ::enterprise_management::AppInstallReportRequest* p = app_install_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.app_install_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::AppInstallReportRequest*>(
&::enterprise_management::_AppInstallReportRequest_default_instance_);
}
inline ::enterprise_management::AppInstallReportRequest* DeviceManagementRequest::release_app_install_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.app_install_report_request)
_has_bits_[0] &= ~0x00800000u;
::enterprise_management::AppInstallReportRequest* temp = app_install_report_request_;
app_install_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::AppInstallReportRequest* DeviceManagementRequest::mutable_app_install_report_request() {
_has_bits_[0] |= 0x00800000u;
if (app_install_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::AppInstallReportRequest>(GetArenaNoVirtual());
app_install_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.app_install_report_request)
return app_install_report_request_;
}
inline void DeviceManagementRequest::set_allocated_app_install_report_request(::enterprise_management::AppInstallReportRequest* app_install_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete app_install_report_request_;
}
if (app_install_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
app_install_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, app_install_report_request, submessage_arena);
}
_has_bits_[0] |= 0x00800000u;
} else {
_has_bits_[0] &= ~0x00800000u;
}
app_install_report_request_ = app_install_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.app_install_report_request)
}

// optional .enterprise_management.ChromeDesktopReportRequest chrome_desktop_report_request = 26;
inline bool DeviceManagementRequest::has_chrome_desktop_report_request() const {
return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DeviceManagementRequest::clear_chrome_desktop_report_request() {
if (chrome_desktop_report_request_ != nullptr) chrome_desktop_report_request_->Clear();
_has_bits_[0] &= ~0x01000000u;
}
inline const ::enterprise_management::ChromeDesktopReportRequest& DeviceManagementRequest::chrome_desktop_report_request() const {
const ::enterprise_management::ChromeDesktopReportRequest* p = chrome_desktop_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ChromeDesktopReportRequest*>(
&::enterprise_management::_ChromeDesktopReportRequest_default_instance_);
}
inline ::enterprise_management::ChromeDesktopReportRequest* DeviceManagementRequest::release_chrome_desktop_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
_has_bits_[0] &= ~0x01000000u;
::enterprise_management::ChromeDesktopReportRequest* temp = chrome_desktop_report_request_;
chrome_desktop_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ChromeDesktopReportRequest* DeviceManagementRequest::mutable_chrome_desktop_report_request() {
_has_bits_[0] |= 0x01000000u;
if (chrome_desktop_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ChromeDesktopReportRequest>(GetArenaNoVirtual());
chrome_desktop_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
return chrome_desktop_report_request_;
}
inline void DeviceManagementRequest::set_allocated_chrome_desktop_report_request(::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete chrome_desktop_report_request_;
}
if (chrome_desktop_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
chrome_desktop_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, chrome_desktop_report_request, submessage_arena);
}
_has_bits_[0] |= 0x01000000u;
} else {
_has_bits_[0] &= ~0x01000000u;
}
chrome_desktop_report_request_ = chrome_desktop_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
}

// optional .enterprise_management.PolicyValidationReportRequest policy_validation_report_request = 27;
inline bool DeviceManagementRequest::has_policy_validation_report_request() const {
return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DeviceManagementRequest::clear_policy_validation_report_request() {
if (policy_validation_report_request_ != nullptr) policy_validation_report_request_->Clear();
_has_bits_[0] &= ~0x02000000u;
}
inline const ::enterprise_management::PolicyValidationReportRequest& DeviceManagementRequest::policy_validation_report_request() const {
const ::enterprise_management::PolicyValidationReportRequest* p = policy_validation_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::PolicyValidationReportRequest*>(
&::enterprise_management::_PolicyValidationReportRequest_default_instance_);
}
inline ::enterprise_management::PolicyValidationReportRequest* DeviceManagementRequest::release_policy_validation_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
_has_bits_[0] &= ~0x02000000u;
::enterprise_management::PolicyValidationReportRequest* temp = policy_validation_report_request_;
policy_validation_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::PolicyValidationReportRequest* DeviceManagementRequest::mutable_policy_validation_report_request() {
_has_bits_[0] |= 0x02000000u;
if (policy_validation_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::PolicyValidationReportRequest>(GetArenaNoVirtual());
policy_validation_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
return policy_validation_report_request_;
}
inline void DeviceManagementRequest::set_allocated_policy_validation_report_request(::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete policy_validation_report_request_;
}
if (policy_validation_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
policy_validation_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, policy_validation_report_request, submessage_arena);
}
_has_bits_[0] |= 0x02000000u;
} else {
_has_bits_[0] &= ~0x02000000u;
}
policy_validation_report_request_ = policy_validation_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
}

// optional .enterprise_management.DeviceInitialEnrollmentStateRequest device_initial_enrollment_state_request = 28;
inline bool DeviceManagementRequest::has_device_initial_enrollment_state_request() const {
return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DeviceManagementRequest::clear_device_initial_enrollment_state_request() {
if (device_initial_enrollment_state_request_ != nullptr) device_initial_enrollment_state_request_->Clear();
_has_bits_[0] &= ~0x04000000u;
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateRequest& DeviceManagementRequest::device_initial_enrollment_state_request() const {
const ::enterprise_management::DeviceInitialEnrollmentStateRequest* p = device_initial_enrollment_state_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceInitialEnrollmentStateRequest*>(
&::enterprise_management::_DeviceInitialEnrollmentStateRequest_default_instance_);
}
inline ::enterprise_management::DeviceInitialEnrollmentStateRequest* DeviceManagementRequest::release_device_initial_enrollment_state_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
_has_bits_[0] &= ~0x04000000u;
::enterprise_management::DeviceInitialEnrollmentStateRequest* temp = device_initial_enrollment_state_request_;
device_initial_enrollment_state_request_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateRequest* DeviceManagementRequest::mutable_device_initial_enrollment_state_request() {
_has_bits_[0] |= 0x04000000u;
if (device_initial_enrollment_state_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateRequest>(GetArenaNoVirtual());
device_initial_enrollment_state_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
return device_initial_enrollment_state_request_;
}
inline void DeviceManagementRequest::set_allocated_device_initial_enrollment_state_request(::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_initial_enrollment_state_request_;
}
if (device_initial_enrollment_state_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_initial_enrollment_state_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_initial_enrollment_state_request, submessage_arena);
}
_has_bits_[0] |= 0x04000000u;
} else {
_has_bits_[0] &= ~0x04000000u;
}
device_initial_enrollment_state_request_ = device_initial_enrollment_state_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
}

// optional .enterprise_management.RefreshAccountRequest refresh_account_request = 29;
inline bool DeviceManagementRequest::has_refresh_account_request() const {
return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void DeviceManagementRequest::clear_refresh_account_request() {
if (refresh_account_request_ != nullptr) refresh_account_request_->Clear();
_has_bits_[0] &= ~0x08000000u;
}
inline const ::enterprise_management::RefreshAccountRequest& DeviceManagementRequest::refresh_account_request() const {
const ::enterprise_management::RefreshAccountRequest* p = refresh_account_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.refresh_account_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::RefreshAccountRequest*>(
&::enterprise_management::_RefreshAccountRequest_default_instance_);
}
inline ::enterprise_management::RefreshAccountRequest* DeviceManagementRequest::release_refresh_account_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.refresh_account_request)
_has_bits_[0] &= ~0x08000000u;
::enterprise_management::RefreshAccountRequest* temp = refresh_account_request_;
refresh_account_request_ = nullptr;
return temp;
}
inline ::enterprise_management::RefreshAccountRequest* DeviceManagementRequest::mutable_refresh_account_request() {
_has_bits_[0] |= 0x08000000u;
if (refresh_account_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::RefreshAccountRequest>(GetArenaNoVirtual());
refresh_account_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.refresh_account_request)
return refresh_account_request_;
}
inline void DeviceManagementRequest::set_allocated_refresh_account_request(::enterprise_management::RefreshAccountRequest* refresh_account_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete refresh_account_request_;
}
if (refresh_account_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
refresh_account_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, refresh_account_request, submessage_arena);
}
_has_bits_[0] |= 0x08000000u;
} else {
_has_bits_[0] &= ~0x08000000u;
}
refresh_account_request_ = refresh_account_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.refresh_account_request)
}

// optional .enterprise_management.RsuLookupKeyUploadRequest rsu_lookup_key_upload_request = 31;
inline bool DeviceManagementRequest::has_rsu_lookup_key_upload_request() const {
return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void DeviceManagementRequest::clear_rsu_lookup_key_upload_request() {
if (rsu_lookup_key_upload_request_ != nullptr) rsu_lookup_key_upload_request_->Clear();
_has_bits_[0] &= ~0x20000000u;
}
inline const ::enterprise_management::RsuLookupKeyUploadRequest& DeviceManagementRequest::rsu_lookup_key_upload_request() const {
const ::enterprise_management::RsuLookupKeyUploadRequest* p = rsu_lookup_key_upload_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::RsuLookupKeyUploadRequest*>(
&::enterprise_management::_RsuLookupKeyUploadRequest_default_instance_);
}
inline ::enterprise_management::RsuLookupKeyUploadRequest* DeviceManagementRequest::release_rsu_lookup_key_upload_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
_has_bits_[0] &= ~0x20000000u;
::enterprise_management::RsuLookupKeyUploadRequest* temp = rsu_lookup_key_upload_request_;
rsu_lookup_key_upload_request_ = nullptr;
return temp;
}
inline ::enterprise_management::RsuLookupKeyUploadRequest* DeviceManagementRequest::mutable_rsu_lookup_key_upload_request() {
_has_bits_[0] |= 0x20000000u;
if (rsu_lookup_key_upload_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadRequest>(GetArenaNoVirtual());
rsu_lookup_key_upload_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
return rsu_lookup_key_upload_request_;
}
inline void DeviceManagementRequest::set_allocated_rsu_lookup_key_upload_request(::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete rsu_lookup_key_upload_request_;
}
if (rsu_lookup_key_upload_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
rsu_lookup_key_upload_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, rsu_lookup_key_upload_request, submessage_arena);
}
_has_bits_[0] |= 0x20000000u;
} else {
_has_bits_[0] &= ~0x20000000u;
}
rsu_lookup_key_upload_request_ = rsu_lookup_key_upload_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
}

// optional .enterprise_management.PublicSamlUserRequest public_saml_user_request = 32;
inline bool DeviceManagementRequest::has_public_saml_user_request() const {
return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void DeviceManagementRequest::clear_public_saml_user_request() {
if (public_saml_user_request_ != nullptr) public_saml_user_request_->Clear();
_has_bits_[0] &= ~0x40000000u;
}
inline const ::enterprise_management::PublicSamlUserRequest& DeviceManagementRequest::public_saml_user_request() const {
const ::enterprise_management::PublicSamlUserRequest* p = public_saml_user_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.public_saml_user_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::PublicSamlUserRequest*>(
&::enterprise_management::_PublicSamlUserRequest_default_instance_);
}
inline ::enterprise_management::PublicSamlUserRequest* DeviceManagementRequest::release_public_saml_user_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.public_saml_user_request)
_has_bits_[0] &= ~0x40000000u;
::enterprise_management::PublicSamlUserRequest* temp = public_saml_user_request_;
public_saml_user_request_ = nullptr;
return temp;
}
inline ::enterprise_management::PublicSamlUserRequest* DeviceManagementRequest::mutable_public_saml_user_request() {
_has_bits_[0] |= 0x40000000u;
if (public_saml_user_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::PublicSamlUserRequest>(GetArenaNoVirtual());
public_saml_user_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.public_saml_user_request)
return public_saml_user_request_;
}
inline void DeviceManagementRequest::set_allocated_public_saml_user_request(::enterprise_management::PublicSamlUserRequest* public_saml_user_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete public_saml_user_request_;
}
if (public_saml_user_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
public_saml_user_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, public_saml_user_request, submessage_arena);
}
_has_bits_[0] |= 0x40000000u;
} else {
_has_bits_[0] &= ~0x40000000u;
}
public_saml_user_request_ = public_saml_user_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.public_saml_user_request)
}

// optional .enterprise_management.ChromeOsUserReportRequest chrome_os_user_report_request = 33;
inline bool DeviceManagementRequest::has_chrome_os_user_report_request() const {
return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void DeviceManagementRequest::clear_chrome_os_user_report_request() {
if (chrome_os_user_report_request_ != nullptr) chrome_os_user_report_request_->Clear();
_has_bits_[0] &= ~0x80000000u;
}
inline const ::enterprise_management::ChromeOsUserReportRequest& DeviceManagementRequest::chrome_os_user_report_request() const {
const ::enterprise_management::ChromeOsUserReportRequest* p = chrome_os_user_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ChromeOsUserReportRequest*>(
&::enterprise_management::_ChromeOsUserReportRequest_default_instance_);
}
inline ::enterprise_management::ChromeOsUserReportRequest* DeviceManagementRequest::release_chrome_os_user_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
_has_bits_[0] &= ~0x80000000u;
::enterprise_management::ChromeOsUserReportRequest* temp = chrome_os_user_report_request_;
chrome_os_user_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ChromeOsUserReportRequest* DeviceManagementRequest::mutable_chrome_os_user_report_request() {
_has_bits_[0] |= 0x80000000u;
if (chrome_os_user_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ChromeOsUserReportRequest>(GetArenaNoVirtual());
chrome_os_user_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
return chrome_os_user_report_request_;
}
inline void DeviceManagementRequest::set_allocated_chrome_os_user_report_request(::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete chrome_os_user_report_request_;
}
if (chrome_os_user_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
chrome_os_user_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, chrome_os_user_report_request, submessage_arena);
}
_has_bits_[0] |= 0x80000000u;
} else {
_has_bits_[0] &= ~0x80000000u;
}
chrome_os_user_report_request_ = chrome_os_user_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
}

// optional .enterprise_management.ClientCertificateProvisioningRequest client_certificate_provisioning_request = 34;
inline bool DeviceManagementRequest::has_client_certificate_provisioning_request() const {
return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void DeviceManagementRequest::clear_client_certificate_provisioning_request() {
if (client_certificate_provisioning_request_ != nullptr) client_certificate_provisioning_request_->Clear();
_has_bits_[1] &= ~0x00000001u;
}
inline const ::enterprise_management::ClientCertificateProvisioningRequest& DeviceManagementRequest::client_certificate_provisioning_request() const {
const ::enterprise_management::ClientCertificateProvisioningRequest* p = client_certificate_provisioning_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ClientCertificateProvisioningRequest*>(
&::enterprise_management::_ClientCertificateProvisioningRequest_default_instance_);
}
inline ::enterprise_management::ClientCertificateProvisioningRequest* DeviceManagementRequest::release_client_certificate_provisioning_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
_has_bits_[1] &= ~0x00000001u;
::enterprise_management::ClientCertificateProvisioningRequest* temp = client_certificate_provisioning_request_;
client_certificate_provisioning_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ClientCertificateProvisioningRequest* DeviceManagementRequest::mutable_client_certificate_provisioning_request() {
_has_bits_[1] |= 0x00000001u;
if (client_certificate_provisioning_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningRequest>(GetArenaNoVirtual());
client_certificate_provisioning_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
return client_certificate_provisioning_request_;
}
inline void DeviceManagementRequest::set_allocated_client_certificate_provisioning_request(::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete client_certificate_provisioning_request_;
}
if (client_certificate_provisioning_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
client_certificate_provisioning_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, client_certificate_provisioning_request, submessage_arena);
}
_has_bits_[1] |= 0x00000001u;
} else {
_has_bits_[1] &= ~0x00000001u;
}
client_certificate_provisioning_request_ = client_certificate_provisioning_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
}

// optional .enterprise_management.ExtensionInstallReportRequest extension_install_report_request = 35;
inline bool DeviceManagementRequest::has_extension_install_report_request() const {
return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void DeviceManagementRequest::clear_extension_install_report_request() {
if (extension_install_report_request_ != nullptr) extension_install_report_request_->Clear();
_has_bits_[1] &= ~0x00000002u;
}
inline const ::enterprise_management::ExtensionInstallReportRequest& DeviceManagementRequest::extension_install_report_request() const {
const ::enterprise_management::ExtensionInstallReportRequest* p = extension_install_report_request_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.extension_install_report_request)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ExtensionInstallReportRequest*>(
&::enterprise_management::_ExtensionInstallReportRequest_default_instance_);
}
inline ::enterprise_management::ExtensionInstallReportRequest* DeviceManagementRequest::release_extension_install_report_request() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.extension_install_report_request)
_has_bits_[1] &= ~0x00000002u;
::enterprise_management::ExtensionInstallReportRequest* temp = extension_install_report_request_;
extension_install_report_request_ = nullptr;
return temp;
}
inline ::enterprise_management::ExtensionInstallReportRequest* DeviceManagementRequest::mutable_extension_install_report_request() {
_has_bits_[1] |= 0x00000002u;
if (extension_install_report_request_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ExtensionInstallReportRequest>(GetArenaNoVirtual());
extension_install_report_request_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.extension_install_report_request)
return extension_install_report_request_;
}
inline void DeviceManagementRequest::set_allocated_extension_install_report_request(::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete extension_install_report_request_;
}
if (extension_install_report_request) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
extension_install_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, extension_install_report_request, submessage_arena);
}
_has_bits_[1] |= 0x00000002u;
} else {
_has_bits_[1] &= ~0x00000002u;
}
extension_install_report_request_ = extension_install_report_request;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.extension_install_report_request)
}

// -------------------------------------------------------------------

// DeviceManagementResponse

// optional string error_message = 2;
inline bool DeviceManagementResponse::has_error_message() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceManagementResponse::clear_error_message() {
error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceManagementResponse::error_message() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.error_message)
return error_message_.GetNoArena();
}
inline void DeviceManagementResponse::set_error_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:enterprise_management.DeviceManagementResponse.error_message)
}
inline void DeviceManagementResponse::set_error_message(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:enterprise_management.DeviceManagementResponse.error_message)
}
inline void DeviceManagementResponse::set_error_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:enterprise_management.DeviceManagementResponse.error_message)
}
inline void DeviceManagementResponse::set_error_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceManagementResponse.error_message)
}
inline std::string* DeviceManagementResponse::mutable_error_message() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.error_message)
return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceManagementResponse::release_error_message() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.error_message)
if (!has_error_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return error_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceManagementResponse::set_allocated_error_message(std::string* error_message) {
if (error_message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.error_message)
}

// optional .enterprise_management.DeviceRegisterResponse register_response = 3;
inline bool DeviceManagementResponse::has_register_response() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceManagementResponse::clear_register_response() {
if (register_response_ != nullptr) register_response_->Clear();
_has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DeviceRegisterResponse& DeviceManagementResponse::register_response() const {
const ::enterprise_management::DeviceRegisterResponse* p = register_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.register_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceRegisterResponse*>(
&::enterprise_management::_DeviceRegisterResponse_default_instance_);
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::release_register_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.register_response)
_has_bits_[0] &= ~0x00000002u;
::enterprise_management::DeviceRegisterResponse* temp = register_response_;
register_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::mutable_register_response() {
_has_bits_[0] |= 0x00000002u;
if (register_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterResponse>(GetArenaNoVirtual());
register_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.register_response)
return register_response_;
}
inline void DeviceManagementResponse::set_allocated_register_response(::enterprise_management::DeviceRegisterResponse* register_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete register_response_;
}
if (register_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
register_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, register_response, submessage_arena);
}
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
register_response_ = register_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.register_response)
}

// optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
inline bool DeviceManagementResponse::has_unregister_response() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceManagementResponse::clear_unregister_response() {
if (unregister_response_ != nullptr) unregister_response_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::DeviceUnregisterResponse& DeviceManagementResponse::unregister_response() const {
const ::enterprise_management::DeviceUnregisterResponse* p = unregister_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.unregister_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceUnregisterResponse*>(
&::enterprise_management::_DeviceUnregisterResponse_default_instance_);
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::release_unregister_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.unregister_response)
_has_bits_[0] &= ~0x00000004u;
::enterprise_management::DeviceUnregisterResponse* temp = unregister_response_;
unregister_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::mutable_unregister_response() {
_has_bits_[0] |= 0x00000004u;
if (unregister_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceUnregisterResponse>(GetArenaNoVirtual());
unregister_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.unregister_response)
return unregister_response_;
}
inline void DeviceManagementResponse::set_allocated_unregister_response(::enterprise_management::DeviceUnregisterResponse* unregister_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete unregister_response_;
}
if (unregister_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
unregister_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, unregister_response, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
unregister_response_ = unregister_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.unregister_response)
}

// optional .enterprise_management.DevicePolicyResponse policy_response = 5;
inline bool DeviceManagementResponse::has_policy_response() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceManagementResponse::clear_policy_response() {
if (policy_response_ != nullptr) policy_response_->Clear();
_has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::DevicePolicyResponse& DeviceManagementResponse::policy_response() const {
const ::enterprise_management::DevicePolicyResponse* p = policy_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.policy_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DevicePolicyResponse*>(
&::enterprise_management::_DevicePolicyResponse_default_instance_);
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::release_policy_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.policy_response)
_has_bits_[0] &= ~0x00000008u;
::enterprise_management::DevicePolicyResponse* temp = policy_response_;
policy_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::mutable_policy_response() {
_has_bits_[0] |= 0x00000008u;
if (policy_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DevicePolicyResponse>(GetArenaNoVirtual());
policy_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.policy_response)
return policy_response_;
}
inline void DeviceManagementResponse::set_allocated_policy_response(::enterprise_management::DevicePolicyResponse* policy_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete policy_response_;
}
if (policy_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
policy_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, policy_response, submessage_arena);
}
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
policy_response_ = policy_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.policy_response)
}

// optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
inline bool DeviceManagementResponse::has_device_status_report_response() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceManagementResponse::clear_device_status_report_response() {
if (device_status_report_response_ != nullptr) device_status_report_response_->Clear();
_has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::DeviceStatusReportResponse& DeviceManagementResponse::device_status_report_response() const {
const ::enterprise_management::DeviceStatusReportResponse* p = device_status_report_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_status_report_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceStatusReportResponse*>(
&::enterprise_management::_DeviceStatusReportResponse_default_instance_);
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::release_device_status_report_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_status_report_response)
_has_bits_[0] &= ~0x00000010u;
::enterprise_management::DeviceStatusReportResponse* temp = device_status_report_response_;
device_status_report_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::mutable_device_status_report_response() {
_has_bits_[0] |= 0x00000010u;
if (device_status_report_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceStatusReportResponse>(GetArenaNoVirtual());
device_status_report_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_status_report_response)
return device_status_report_response_;
}
inline void DeviceManagementResponse::set_allocated_device_status_report_response(::enterprise_management::DeviceStatusReportResponse* device_status_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_status_report_response_;
}
if (device_status_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_status_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_status_report_response, submessage_arena);
}
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
device_status_report_response_ = device_status_report_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_status_report_response)
}

// optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
inline bool DeviceManagementResponse::has_session_status_report_response() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceManagementResponse::clear_session_status_report_response() {
if (session_status_report_response_ != nullptr) session_status_report_response_->Clear();
_has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::SessionStatusReportResponse& DeviceManagementResponse::session_status_report_response() const {
const ::enterprise_management::SessionStatusReportResponse* p = session_status_report_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.session_status_report_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::SessionStatusReportResponse*>(
&::enterprise_management::_SessionStatusReportResponse_default_instance_);
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::release_session_status_report_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.session_status_report_response)
_has_bits_[0] &= ~0x00000020u;
::enterprise_management::SessionStatusReportResponse* temp = session_status_report_response_;
session_status_report_response_ = nullptr;
return temp;
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::mutable_session_status_report_response() {
_has_bits_[0] |= 0x00000020u;
if (session_status_report_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::SessionStatusReportResponse>(GetArenaNoVirtual());
session_status_report_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.session_status_report_response)
return session_status_report_response_;
}
inline void DeviceManagementResponse::set_allocated_session_status_report_response(::enterprise_management::SessionStatusReportResponse* session_status_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete session_status_report_response_;
}
if (session_status_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
session_status_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, session_status_report_response, submessage_arena);
}
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
session_status_report_response_ = session_status_report_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.session_status_report_response)
}

// optional .enterprise_management.ChildStatusReportResponse child_status_report_response = 29;
inline bool DeviceManagementResponse::has_child_status_report_response() const {
return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DeviceManagementResponse::clear_child_status_report_response() {
if (child_status_report_response_ != nullptr) child_status_report_response_->Clear();
_has_bits_[0] &= ~0x04000000u;
}
inline const ::enterprise_management::ChildStatusReportResponse& DeviceManagementResponse::child_status_report_response() const {
const ::enterprise_management::ChildStatusReportResponse* p = child_status_report_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.child_status_report_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ChildStatusReportResponse*>(
&::enterprise_management::_ChildStatusReportResponse_default_instance_);
}
inline ::enterprise_management::ChildStatusReportResponse* DeviceManagementResponse::release_child_status_report_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.child_status_report_response)
_has_bits_[0] &= ~0x04000000u;
::enterprise_management::ChildStatusReportResponse* temp = child_status_report_response_;
child_status_report_response_ = nullptr;
return temp;
}
inline ::enterprise_management::ChildStatusReportResponse* DeviceManagementResponse::mutable_child_status_report_response() {
_has_bits_[0] |= 0x04000000u;
if (child_status_report_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ChildStatusReportResponse>(GetArenaNoVirtual());
child_status_report_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.child_status_report_response)
return child_status_report_response_;
}
inline void DeviceManagementResponse::set_allocated_child_status_report_response(::enterprise_management::ChildStatusReportResponse* child_status_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete child_status_report_response_;
}
if (child_status_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
child_status_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, child_status_report_response, submessage_arena);
}
_has_bits_[0] |= 0x04000000u;
} else {
_has_bits_[0] &= ~0x04000000u;
}
child_status_report_response_ = child_status_report_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.child_status_report_response)
}

// optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
inline bool DeviceManagementResponse::has_auto_enrollment_response() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceManagementResponse::clear_auto_enrollment_response() {
if (auto_enrollment_response_ != nullptr) auto_enrollment_response_->Clear();
_has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::DeviceAutoEnrollmentResponse& DeviceManagementResponse::auto_enrollment_response() const {
const ::enterprise_management::DeviceAutoEnrollmentResponse* p = auto_enrollment_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceAutoEnrollmentResponse*>(
&::enterprise_management::_DeviceAutoEnrollmentResponse_default_instance_);
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::release_auto_enrollment_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
_has_bits_[0] &= ~0x00000040u;
::enterprise_management::DeviceAutoEnrollmentResponse* temp = auto_enrollment_response_;
auto_enrollment_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::mutable_auto_enrollment_response() {
_has_bits_[0] |= 0x00000040u;
if (auto_enrollment_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentResponse>(GetArenaNoVirtual());
auto_enrollment_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
return auto_enrollment_response_;
}
inline void DeviceManagementResponse::set_allocated_auto_enrollment_response(::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete auto_enrollment_response_;
}
if (auto_enrollment_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
auto_enrollment_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, auto_enrollment_response, submessage_arena);
}
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
auto_enrollment_response_ = auto_enrollment_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
}

// optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
inline bool DeviceManagementResponse::has_cert_upload_response() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceManagementResponse::clear_cert_upload_response() {
if (cert_upload_response_ != nullptr) cert_upload_response_->Clear();
_has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::DeviceCertUploadResponse& DeviceManagementResponse::cert_upload_response() const {
const ::enterprise_management::DeviceCertUploadResponse* p = cert_upload_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.cert_upload_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceCertUploadResponse*>(
&::enterprise_management::_DeviceCertUploadResponse_default_instance_);
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::release_cert_upload_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.cert_upload_response)
_has_bits_[0] &= ~0x00000080u;
::enterprise_management::DeviceCertUploadResponse* temp = cert_upload_response_;
cert_upload_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::mutable_cert_upload_response() {
_has_bits_[0] |= 0x00000080u;
if (cert_upload_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceCertUploadResponse>(GetArenaNoVirtual());
cert_upload_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.cert_upload_response)
return cert_upload_response_;
}
inline void DeviceManagementResponse::set_allocated_cert_upload_response(::enterprise_management::DeviceCertUploadResponse* cert_upload_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete cert_upload_response_;
}
if (cert_upload_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
cert_upload_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, cert_upload_response, submessage_arena);
}
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
cert_upload_response_ = cert_upload_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.cert_upload_response)
}

// optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
inline bool DeviceManagementResponse::has_service_api_access_response() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceManagementResponse::clear_service_api_access_response() {
if (service_api_access_response_ != nullptr) service_api_access_response_->Clear();
_has_bits_[0] &= ~0x00000100u;
}
inline const ::enterprise_management::DeviceServiceApiAccessResponse& DeviceManagementResponse::service_api_access_response() const {
const ::enterprise_management::DeviceServiceApiAccessResponse* p = service_api_access_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.service_api_access_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceServiceApiAccessResponse*>(
&::enterprise_management::_DeviceServiceApiAccessResponse_default_instance_);
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::release_service_api_access_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.service_api_access_response)
_has_bits_[0] &= ~0x00000100u;
::enterprise_management::DeviceServiceApiAccessResponse* temp = service_api_access_response_;
service_api_access_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::mutable_service_api_access_response() {
_has_bits_[0] |= 0x00000100u;
if (service_api_access_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessResponse>(GetArenaNoVirtual());
service_api_access_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.service_api_access_response)
return service_api_access_response_;
}
inline void DeviceManagementResponse::set_allocated_service_api_access_response(::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete service_api_access_response_;
}
if (service_api_access_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
service_api_access_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, service_api_access_response, submessage_arena);
}
_has_bits_[0] |= 0x00000100u;
} else {
_has_bits_[0] &= ~0x00000100u;
}
service_api_access_response_ = service_api_access_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.service_api_access_response)
}

// optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
inline bool DeviceManagementResponse::has_device_state_retrieval_response() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceManagementResponse::clear_device_state_retrieval_response() {
if (device_state_retrieval_response_ != nullptr) device_state_retrieval_response_->Clear();
_has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::DeviceStateRetrievalResponse& DeviceManagementResponse::device_state_retrieval_response() const {
const ::enterprise_management::DeviceStateRetrievalResponse* p = device_state_retrieval_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceStateRetrievalResponse*>(
&::enterprise_management::_DeviceStateRetrievalResponse_default_instance_);
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::release_device_state_retrieval_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
_has_bits_[0] &= ~0x00000200u;
::enterprise_management::DeviceStateRetrievalResponse* temp = device_state_retrieval_response_;
device_state_retrieval_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::mutable_device_state_retrieval_response() {
_has_bits_[0] |= 0x00000200u;
if (device_state_retrieval_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalResponse>(GetArenaNoVirtual());
device_state_retrieval_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
return device_state_retrieval_response_;
}
inline void DeviceManagementResponse::set_allocated_device_state_retrieval_response(::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_state_retrieval_response_;
}
if (device_state_retrieval_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_state_retrieval_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_state_retrieval_response, submessage_arena);
}
_has_bits_[0] |= 0x00000200u;
} else {
_has_bits_[0] &= ~0x00000200u;
}
device_state_retrieval_response_ = device_state_retrieval_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
}

// optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
inline bool DeviceManagementResponse::has_device_pairing_response() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceManagementResponse::clear_device_pairing_response() {
if (device_pairing_response_ != nullptr) device_pairing_response_->Clear();
_has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::DevicePairingResponse& DeviceManagementResponse::device_pairing_response() const {
const ::enterprise_management::DevicePairingResponse* p = device_pairing_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_pairing_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DevicePairingResponse*>(
&::enterprise_management::_DevicePairingResponse_default_instance_);
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::release_device_pairing_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_pairing_response)
_has_bits_[0] &= ~0x00000400u;
::enterprise_management::DevicePairingResponse* temp = device_pairing_response_;
device_pairing_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::mutable_device_pairing_response() {
_has_bits_[0] |= 0x00000400u;
if (device_pairing_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DevicePairingResponse>(GetArenaNoVirtual());
device_pairing_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_pairing_response)
return device_pairing_response_;
}
inline void DeviceManagementResponse::set_allocated_device_pairing_response(::enterprise_management::DevicePairingResponse* device_pairing_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_pairing_response_;
}
if (device_pairing_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_pairing_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_pairing_response, submessage_arena);
}
_has_bits_[0] |= 0x00000400u;
} else {
_has_bits_[0] &= ~0x00000400u;
}
device_pairing_response_ = device_pairing_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_pairing_response)
}

// optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
inline bool DeviceManagementResponse::has_check_device_pairing_response() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceManagementResponse::clear_check_device_pairing_response() {
if (check_device_pairing_response_ != nullptr) check_device_pairing_response_->Clear();
_has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::CheckDevicePairingResponse& DeviceManagementResponse::check_device_pairing_response() const {
const ::enterprise_management::CheckDevicePairingResponse* p = check_device_pairing_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CheckDevicePairingResponse*>(
&::enterprise_management::_CheckDevicePairingResponse_default_instance_);
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::release_check_device_pairing_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
_has_bits_[0] &= ~0x00000800u;
::enterprise_management::CheckDevicePairingResponse* temp = check_device_pairing_response_;
check_device_pairing_response_ = nullptr;
return temp;
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::mutable_check_device_pairing_response() {
_has_bits_[0] |= 0x00000800u;
if (check_device_pairing_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CheckDevicePairingResponse>(GetArenaNoVirtual());
check_device_pairing_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
return check_device_pairing_response_;
}
inline void DeviceManagementResponse::set_allocated_check_device_pairing_response(::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete check_device_pairing_response_;
}
if (check_device_pairing_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
check_device_pairing_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, check_device_pairing_response, submessage_arena);
}
_has_bits_[0] |= 0x00000800u;
} else {
_has_bits_[0] &= ~0x00000800u;
}
check_device_pairing_response_ = check_device_pairing_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
}

// optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
inline bool DeviceManagementResponse::has_remote_command_response() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceManagementResponse::clear_remote_command_response() {
if (remote_command_response_ != nullptr) remote_command_response_->Clear();
_has_bits_[0] &= ~0x00001000u;
}
inline const ::enterprise_management::DeviceRemoteCommandResponse& DeviceManagementResponse::remote_command_response() const {
const ::enterprise_management::DeviceRemoteCommandResponse* p = remote_command_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.remote_command_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceRemoteCommandResponse*>(
&::enterprise_management::_DeviceRemoteCommandResponse_default_instance_);
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::release_remote_command_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.remote_command_response)
_has_bits_[0] &= ~0x00001000u;
::enterprise_management::DeviceRemoteCommandResponse* temp = remote_command_response_;
remote_command_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::mutable_remote_command_response() {
_has_bits_[0] |= 0x00001000u;
if (remote_command_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandResponse>(GetArenaNoVirtual());
remote_command_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.remote_command_response)
return remote_command_response_;
}
inline void DeviceManagementResponse::set_allocated_remote_command_response(::enterprise_management::DeviceRemoteCommandResponse* remote_command_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete remote_command_response_;
}
if (remote_command_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
remote_command_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, remote_command_response, submessage_arena);
}
_has_bits_[0] |= 0x00001000u;
} else {
_has_bits_[0] &= ~0x00001000u;
}
remote_command_response_ = remote_command_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.remote_command_response)
}

// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
inline bool DeviceManagementResponse::has_device_attribute_update_permission_response() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceManagementResponse::clear_device_attribute_update_permission_response() {
if (device_attribute_update_permission_response_ != nullptr) device_attribute_update_permission_response_->Clear();
_has_bits_[0] &= ~0x00002000u;
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& DeviceManagementResponse::device_attribute_update_permission_response() const {
const ::enterprise_management::DeviceAttributeUpdatePermissionResponse* p = device_attribute_update_permission_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdatePermissionResponse*>(
&::enterprise_management::_DeviceAttributeUpdatePermissionResponse_default_instance_);
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::release_device_attribute_update_permission_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
_has_bits_[0] &= ~0x00002000u;
::enterprise_management::DeviceAttributeUpdatePermissionResponse* temp = device_attribute_update_permission_response_;
device_attribute_update_permission_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::mutable_device_attribute_update_permission_response() {
_has_bits_[0] |= 0x00002000u;
if (device_attribute_update_permission_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionResponse>(GetArenaNoVirtual());
device_attribute_update_permission_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
return device_attribute_update_permission_response_;
}
inline void DeviceManagementResponse::set_allocated_device_attribute_update_permission_response(::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_attribute_update_permission_response_;
}
if (device_attribute_update_permission_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_attribute_update_permission_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_attribute_update_permission_response, submessage_arena);
}
_has_bits_[0] |= 0x00002000u;
} else {
_has_bits_[0] &= ~0x00002000u;
}
device_attribute_update_permission_response_ = device_attribute_update_permission_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
}

// optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
inline bool DeviceManagementResponse::has_device_attribute_update_response() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceManagementResponse::clear_device_attribute_update_response() {
if (device_attribute_update_response_ != nullptr) device_attribute_update_response_->Clear();
_has_bits_[0] &= ~0x00004000u;
}
inline const ::enterprise_management::DeviceAttributeUpdateResponse& DeviceManagementResponse::device_attribute_update_response() const {
const ::enterprise_management::DeviceAttributeUpdateResponse* p = device_attribute_update_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdateResponse*>(
&::enterprise_management::_DeviceAttributeUpdateResponse_default_instance_);
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::release_device_attribute_update_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
_has_bits_[0] &= ~0x00004000u;
::enterprise_management::DeviceAttributeUpdateResponse* temp = device_attribute_update_response_;
device_attribute_update_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::mutable_device_attribute_update_response() {
_has_bits_[0] |= 0x00004000u;
if (device_attribute_update_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateResponse>(GetArenaNoVirtual());
device_attribute_update_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
return device_attribute_update_response_;
}
inline void DeviceManagementResponse::set_allocated_device_attribute_update_response(::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_attribute_update_response_;
}
if (device_attribute_update_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_attribute_update_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_attribute_update_response, submessage_arena);
}
_has_bits_[0] |= 0x00004000u;
} else {
_has_bits_[0] &= ~0x00004000u;
}
device_attribute_update_response_ = device_attribute_update_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
}

// optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
inline bool DeviceManagementResponse::has_gcm_id_update_response() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceManagementResponse::clear_gcm_id_update_response() {
if (gcm_id_update_response_ != nullptr) gcm_id_update_response_->Clear();
_has_bits_[0] &= ~0x00008000u;
}
inline const ::enterprise_management::GcmIdUpdateResponse& DeviceManagementResponse::gcm_id_update_response() const {
const ::enterprise_management::GcmIdUpdateResponse* p = gcm_id_update_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::GcmIdUpdateResponse*>(
&::enterprise_management::_GcmIdUpdateResponse_default_instance_);
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::release_gcm_id_update_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
_has_bits_[0] &= ~0x00008000u;
::enterprise_management::GcmIdUpdateResponse* temp = gcm_id_update_response_;
gcm_id_update_response_ = nullptr;
return temp;
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::mutable_gcm_id_update_response() {
_has_bits_[0] |= 0x00008000u;
if (gcm_id_update_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::GcmIdUpdateResponse>(GetArenaNoVirtual());
gcm_id_update_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
return gcm_id_update_response_;
}
inline void DeviceManagementResponse::set_allocated_gcm_id_update_response(::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete gcm_id_update_response_;
}
if (gcm_id_update_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
gcm_id_update_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, gcm_id_update_response, submessage_arena);
}
_has_bits_[0] |= 0x00008000u;
} else {
_has_bits_[0] &= ~0x00008000u;
}
gcm_id_update_response_ = gcm_id_update_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
}

// optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
inline bool DeviceManagementResponse::has_check_android_management_response() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceManagementResponse::clear_check_android_management_response() {
if (check_android_management_response_ != nullptr) check_android_management_response_->Clear();
_has_bits_[0] &= ~0x00010000u;
}
inline const ::enterprise_management::CheckAndroidManagementResponse& DeviceManagementResponse::check_android_management_response() const {
const ::enterprise_management::CheckAndroidManagementResponse* p = check_android_management_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_android_management_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CheckAndroidManagementResponse*>(
&::enterprise_management::_CheckAndroidManagementResponse_default_instance_);
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::release_check_android_management_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_android_management_response)
_has_bits_[0] &= ~0x00010000u;
::enterprise_management::CheckAndroidManagementResponse* temp = check_android_management_response_;
check_android_management_response_ = nullptr;
return temp;
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::mutable_check_android_management_response() {
_has_bits_[0] |= 0x00010000u;
if (check_android_management_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CheckAndroidManagementResponse>(GetArenaNoVirtual());
check_android_management_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_android_management_response)
return check_android_management_response_;
}
inline void DeviceManagementResponse::set_allocated_check_android_management_response(::enterprise_management::CheckAndroidManagementResponse* check_android_management_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete check_android_management_response_;
}
if (check_android_management_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
check_android_management_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, check_android_management_response, submessage_arena);
}
_has_bits_[0] |= 0x00010000u;
} else {
_has_bits_[0] &= ~0x00010000u;
}
check_android_management_response_ = check_android_management_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_android_management_response)
}

// optional .enterprise_management.ActiveDirectoryEnrollPlayUserResponse active_directory_enroll_play_user_response = 19;
inline bool DeviceManagementResponse::has_active_directory_enroll_play_user_response() const {
return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceManagementResponse::clear_active_directory_enroll_play_user_response() {
if (active_directory_enroll_play_user_response_ != nullptr) active_directory_enroll_play_user_response_->Clear();
_has_bits_[0] &= ~0x00020000u;
}
inline const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse& DeviceManagementResponse::active_directory_enroll_play_user_response() const {
const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* p = active_directory_enroll_play_user_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse*>(
&::enterprise_management::_ActiveDirectoryEnrollPlayUserResponse_default_instance_);
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* DeviceManagementResponse::release_active_directory_enroll_play_user_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
_has_bits_[0] &= ~0x00020000u;
::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* temp = active_directory_enroll_play_user_response_;
active_directory_enroll_play_user_response_ = nullptr;
return temp;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* DeviceManagementResponse::mutable_active_directory_enroll_play_user_response() {
_has_bits_[0] |= 0x00020000u;
if (active_directory_enroll_play_user_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserResponse>(GetArenaNoVirtual());
active_directory_enroll_play_user_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
return active_directory_enroll_play_user_response_;
}
inline void DeviceManagementResponse::set_allocated_active_directory_enroll_play_user_response(::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete active_directory_enroll_play_user_response_;
}
if (active_directory_enroll_play_user_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
active_directory_enroll_play_user_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, active_directory_enroll_play_user_response, submessage_arena);
}
_has_bits_[0] |= 0x00020000u;
} else {
_has_bits_[0] &= ~0x00020000u;
}
active_directory_enroll_play_user_response_ = active_directory_enroll_play_user_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
}

// optional .enterprise_management.ActiveDirectoryPlayActivityResponse active_directory_play_activity_response = 20;
inline bool DeviceManagementResponse::has_active_directory_play_activity_response() const {
return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DeviceManagementResponse::clear_active_directory_play_activity_response() {
if (active_directory_play_activity_response_ != nullptr) active_directory_play_activity_response_->Clear();
_has_bits_[0] &= ~0x00040000u;
}
inline const ::enterprise_management::ActiveDirectoryPlayActivityResponse& DeviceManagementResponse::active_directory_play_activity_response() const {
const ::enterprise_management::ActiveDirectoryPlayActivityResponse* p = active_directory_play_activity_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ActiveDirectoryPlayActivityResponse*>(
&::enterprise_management::_ActiveDirectoryPlayActivityResponse_default_instance_);
}
inline ::enterprise_management::ActiveDirectoryPlayActivityResponse* DeviceManagementResponse::release_active_directory_play_activity_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
_has_bits_[0] &= ~0x00040000u;
::enterprise_management::ActiveDirectoryPlayActivityResponse* temp = active_directory_play_activity_response_;
active_directory_play_activity_response_ = nullptr;
return temp;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityResponse* DeviceManagementResponse::mutable_active_directory_play_activity_response() {
_has_bits_[0] |= 0x00040000u;
if (active_directory_play_activity_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityResponse>(GetArenaNoVirtual());
active_directory_play_activity_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
return active_directory_play_activity_response_;
}
inline void DeviceManagementResponse::set_allocated_active_directory_play_activity_response(::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete active_directory_play_activity_response_;
}
if (active_directory_play_activity_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
active_directory_play_activity_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, active_directory_play_activity_response, submessage_arena);
}
_has_bits_[0] |= 0x00040000u;
} else {
_has_bits_[0] &= ~0x00040000u;
}
active_directory_play_activity_response_ = active_directory_play_activity_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
}

// optional .enterprise_management.CheckDeviceLicenseResponse check_device_license_response_deprecated = 21 [deprecated = true];
inline bool DeviceManagementResponse::has_check_device_license_response_deprecated() const {
return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DeviceManagementResponse::clear_check_device_license_response_deprecated() {
if (check_device_license_response_deprecated_ != nullptr) check_device_license_response_deprecated_->Clear();
_has_bits_[0] &= ~0x00080000u;
}
inline const ::enterprise_management::CheckDeviceLicenseResponse& DeviceManagementResponse::check_device_license_response_deprecated() const {
const ::enterprise_management::CheckDeviceLicenseResponse* p = check_device_license_response_deprecated_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::CheckDeviceLicenseResponse*>(
&::enterprise_management::_CheckDeviceLicenseResponse_default_instance_);
}
inline ::enterprise_management::CheckDeviceLicenseResponse* DeviceManagementResponse::release_check_device_license_response_deprecated() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
_has_bits_[0] &= ~0x00080000u;
::enterprise_management::CheckDeviceLicenseResponse* temp = check_device_license_response_deprecated_;
check_device_license_response_deprecated_ = nullptr;
return temp;
}
inline ::enterprise_management::CheckDeviceLicenseResponse* DeviceManagementResponse::mutable_check_device_license_response_deprecated() {
_has_bits_[0] |= 0x00080000u;
if (check_device_license_response_deprecated_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseResponse>(GetArenaNoVirtual());
check_device_license_response_deprecated_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
return check_device_license_response_deprecated_;
}
inline void DeviceManagementResponse::set_allocated_check_device_license_response_deprecated(::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete check_device_license_response_deprecated_;
}
if (check_device_license_response_deprecated) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
check_device_license_response_deprecated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, check_device_license_response_deprecated, submessage_arena);
}
_has_bits_[0] |= 0x00080000u;
} else {
_has_bits_[0] &= ~0x00080000u;
}
check_device_license_response_deprecated_ = check_device_license_response_deprecated;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
}

// optional .enterprise_management.ActiveDirectoryUserSigninResponse active_directory_user_signin_response = 22;
inline bool DeviceManagementResponse::has_active_directory_user_signin_response() const {
return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DeviceManagementResponse::clear_active_directory_user_signin_response() {
if (active_directory_user_signin_response_ != nullptr) active_directory_user_signin_response_->Clear();
_has_bits_[0] &= ~0x00100000u;
}
inline const ::enterprise_management::ActiveDirectoryUserSigninResponse& DeviceManagementResponse::active_directory_user_signin_response() const {
const ::enterprise_management::ActiveDirectoryUserSigninResponse* p = active_directory_user_signin_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ActiveDirectoryUserSigninResponse*>(
&::enterprise_management::_ActiveDirectoryUserSigninResponse_default_instance_);
}
inline ::enterprise_management::ActiveDirectoryUserSigninResponse* DeviceManagementResponse::release_active_directory_user_signin_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
_has_bits_[0] &= ~0x00100000u;
::enterprise_management::ActiveDirectoryUserSigninResponse* temp = active_directory_user_signin_response_;
active_directory_user_signin_response_ = nullptr;
return temp;
}
inline ::enterprise_management::ActiveDirectoryUserSigninResponse* DeviceManagementResponse::mutable_active_directory_user_signin_response() {
_has_bits_[0] |= 0x00100000u;
if (active_directory_user_signin_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninResponse>(GetArenaNoVirtual());
active_directory_user_signin_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
return active_directory_user_signin_response_;
}
inline void DeviceManagementResponse::set_allocated_active_directory_user_signin_response(::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete active_directory_user_signin_response_;
}
if (active_directory_user_signin_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
active_directory_user_signin_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, active_directory_user_signin_response, submessage_arena);
}
_has_bits_[0] |= 0x00100000u;
} else {
_has_bits_[0] &= ~0x00100000u;
}
active_directory_user_signin_response_ = active_directory_user_signin_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
}

// optional .enterprise_management.ChromeDesktopReportResponse chrome_desktop_report_response = 23;
inline bool DeviceManagementResponse::has_chrome_desktop_report_response() const {
return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DeviceManagementResponse::clear_chrome_desktop_report_response() {
if (chrome_desktop_report_response_ != nullptr) chrome_desktop_report_response_->Clear();
_has_bits_[0] &= ~0x00200000u;
}
inline const ::enterprise_management::ChromeDesktopReportResponse& DeviceManagementResponse::chrome_desktop_report_response() const {
const ::enterprise_management::ChromeDesktopReportResponse* p = chrome_desktop_report_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ChromeDesktopReportResponse*>(
&::enterprise_management::_ChromeDesktopReportResponse_default_instance_);
}
inline ::enterprise_management::ChromeDesktopReportResponse* DeviceManagementResponse::release_chrome_desktop_report_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
_has_bits_[0] &= ~0x00200000u;
::enterprise_management::ChromeDesktopReportResponse* temp = chrome_desktop_report_response_;
chrome_desktop_report_response_ = nullptr;
return temp;
}
inline ::enterprise_management::ChromeDesktopReportResponse* DeviceManagementResponse::mutable_chrome_desktop_report_response() {
_has_bits_[0] |= 0x00200000u;
if (chrome_desktop_report_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ChromeDesktopReportResponse>(GetArenaNoVirtual());
chrome_desktop_report_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
return chrome_desktop_report_response_;
}
inline void DeviceManagementResponse::set_allocated_chrome_desktop_report_response(::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete chrome_desktop_report_response_;
}
if (chrome_desktop_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
chrome_desktop_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, chrome_desktop_report_response, submessage_arena);
}
_has_bits_[0] |= 0x00200000u;
} else {
_has_bits_[0] &= ~0x00200000u;
}
chrome_desktop_report_response_ = chrome_desktop_report_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
}

// optional .enterprise_management.AppInstallReportResponse app_install_report_response = 25;
inline bool DeviceManagementResponse::has_app_install_report_response() const {
return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DeviceManagementResponse::clear_app_install_report_response() {
if (app_install_report_response_ != nullptr) app_install_report_response_->Clear();
_has_bits_[0] &= ~0x00400000u;
}
inline const ::enterprise_management::AppInstallReportResponse& DeviceManagementResponse::app_install_report_response() const {
const ::enterprise_management::AppInstallReportResponse* p = app_install_report_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.app_install_report_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::AppInstallReportResponse*>(
&::enterprise_management::_AppInstallReportResponse_default_instance_);
}
inline ::enterprise_management::AppInstallReportResponse* DeviceManagementResponse::release_app_install_report_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.app_install_report_response)
_has_bits_[0] &= ~0x00400000u;
::enterprise_management::AppInstallReportResponse* temp = app_install_report_response_;
app_install_report_response_ = nullptr;
return temp;
}
inline ::enterprise_management::AppInstallReportResponse* DeviceManagementResponse::mutable_app_install_report_response() {
_has_bits_[0] |= 0x00400000u;
if (app_install_report_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::AppInstallReportResponse>(GetArenaNoVirtual());
app_install_report_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.app_install_report_response)
return app_install_report_response_;
}
inline void DeviceManagementResponse::set_allocated_app_install_report_response(::enterprise_management::AppInstallReportResponse* app_install_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete app_install_report_response_;
}
if (app_install_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
app_install_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, app_install_report_response, submessage_arena);
}
_has_bits_[0] |= 0x00400000u;
} else {
_has_bits_[0] &= ~0x00400000u;
}
app_install_report_response_ = app_install_report_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.app_install_report_response)
}

// optional .enterprise_management.PolicyValidationReportResponse policy_validation_report_response = 26;
inline bool DeviceManagementResponse::has_policy_validation_report_response() const {
return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DeviceManagementResponse::clear_policy_validation_report_response() {
if (policy_validation_report_response_ != nullptr) policy_validation_report_response_->Clear();
_has_bits_[0] &= ~0x00800000u;
}
inline const ::enterprise_management::PolicyValidationReportResponse& DeviceManagementResponse::policy_validation_report_response() const {
const ::enterprise_management::PolicyValidationReportResponse* p = policy_validation_report_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::PolicyValidationReportResponse*>(
&::enterprise_management::_PolicyValidationReportResponse_default_instance_);
}
inline ::enterprise_management::PolicyValidationReportResponse* DeviceManagementResponse::release_policy_validation_report_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
_has_bits_[0] &= ~0x00800000u;
::enterprise_management::PolicyValidationReportResponse* temp = policy_validation_report_response_;
policy_validation_report_response_ = nullptr;
return temp;
}
inline ::enterprise_management::PolicyValidationReportResponse* DeviceManagementResponse::mutable_policy_validation_report_response() {
_has_bits_[0] |= 0x00800000u;
if (policy_validation_report_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::PolicyValidationReportResponse>(GetArenaNoVirtual());
policy_validation_report_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
return policy_validation_report_response_;
}
inline void DeviceManagementResponse::set_allocated_policy_validation_report_response(::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete policy_validation_report_response_;
}
if (policy_validation_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
policy_validation_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, policy_validation_report_response, submessage_arena);
}
_has_bits_[0] |= 0x00800000u;
} else {
_has_bits_[0] &= ~0x00800000u;
}
policy_validation_report_response_ = policy_validation_report_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
}

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse device_initial_enrollment_state_response = 27;
inline bool DeviceManagementResponse::has_device_initial_enrollment_state_response() const {
return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DeviceManagementResponse::clear_device_initial_enrollment_state_response() {
if (device_initial_enrollment_state_response_ != nullptr) device_initial_enrollment_state_response_->Clear();
_has_bits_[0] &= ~0x01000000u;
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateResponse& DeviceManagementResponse::device_initial_enrollment_state_response() const {
const ::enterprise_management::DeviceInitialEnrollmentStateResponse* p = device_initial_enrollment_state_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::DeviceInitialEnrollmentStateResponse*>(
&::enterprise_management::_DeviceInitialEnrollmentStateResponse_default_instance_);
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceManagementResponse::release_device_initial_enrollment_state_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
_has_bits_[0] &= ~0x01000000u;
::enterprise_management::DeviceInitialEnrollmentStateResponse* temp = device_initial_enrollment_state_response_;
device_initial_enrollment_state_response_ = nullptr;
return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceManagementResponse::mutable_device_initial_enrollment_state_response() {
_has_bits_[0] |= 0x01000000u;
if (device_initial_enrollment_state_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateResponse>(GetArenaNoVirtual());
device_initial_enrollment_state_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
return device_initial_enrollment_state_response_;
}
inline void DeviceManagementResponse::set_allocated_device_initial_enrollment_state_response(::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete device_initial_enrollment_state_response_;
}
if (device_initial_enrollment_state_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
device_initial_enrollment_state_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, device_initial_enrollment_state_response, submessage_arena);
}
_has_bits_[0] |= 0x01000000u;
} else {
_has_bits_[0] &= ~0x01000000u;
}
device_initial_enrollment_state_response_ = device_initial_enrollment_state_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
}

// optional .enterprise_management.RefreshAccountResponse refresh_account_response = 28;
inline bool DeviceManagementResponse::has_refresh_account_response() const {
return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DeviceManagementResponse::clear_refresh_account_response() {
if (refresh_account_response_ != nullptr) refresh_account_response_->Clear();
_has_bits_[0] &= ~0x02000000u;
}
inline const ::enterprise_management::RefreshAccountResponse& DeviceManagementResponse::refresh_account_response() const {
const ::enterprise_management::RefreshAccountResponse* p = refresh_account_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.refresh_account_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::RefreshAccountResponse*>(
&::enterprise_management::_RefreshAccountResponse_default_instance_);
}
inline ::enterprise_management::RefreshAccountResponse* DeviceManagementResponse::release_refresh_account_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.refresh_account_response)
_has_bits_[0] &= ~0x02000000u;
::enterprise_management::RefreshAccountResponse* temp = refresh_account_response_;
refresh_account_response_ = nullptr;
return temp;
}
inline ::enterprise_management::RefreshAccountResponse* DeviceManagementResponse::mutable_refresh_account_response() {
_has_bits_[0] |= 0x02000000u;
if (refresh_account_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::RefreshAccountResponse>(GetArenaNoVirtual());
refresh_account_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.refresh_account_response)
return refresh_account_response_;
}
inline void DeviceManagementResponse::set_allocated_refresh_account_response(::enterprise_management::RefreshAccountResponse* refresh_account_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete refresh_account_response_;
}
if (refresh_account_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
refresh_account_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, refresh_account_response, submessage_arena);
}
_has_bits_[0] |= 0x02000000u;
} else {
_has_bits_[0] &= ~0x02000000u;
}
refresh_account_response_ = refresh_account_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.refresh_account_response)
}

// optional .enterprise_management.RsuLookupKeyUploadResponse rsu_lookup_key_upload_response = 30;
inline bool DeviceManagementResponse::has_rsu_lookup_key_upload_response() const {
return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void DeviceManagementResponse::clear_rsu_lookup_key_upload_response() {
if (rsu_lookup_key_upload_response_ != nullptr) rsu_lookup_key_upload_response_->Clear();
_has_bits_[0] &= ~0x08000000u;
}
inline const ::enterprise_management::RsuLookupKeyUploadResponse& DeviceManagementResponse::rsu_lookup_key_upload_response() const {
const ::enterprise_management::RsuLookupKeyUploadResponse* p = rsu_lookup_key_upload_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::RsuLookupKeyUploadResponse*>(
&::enterprise_management::_RsuLookupKeyUploadResponse_default_instance_);
}
inline ::enterprise_management::RsuLookupKeyUploadResponse* DeviceManagementResponse::release_rsu_lookup_key_upload_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
_has_bits_[0] &= ~0x08000000u;
::enterprise_management::RsuLookupKeyUploadResponse* temp = rsu_lookup_key_upload_response_;
rsu_lookup_key_upload_response_ = nullptr;
return temp;
}
inline ::enterprise_management::RsuLookupKeyUploadResponse* DeviceManagementResponse::mutable_rsu_lookup_key_upload_response() {
_has_bits_[0] |= 0x08000000u;
if (rsu_lookup_key_upload_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadResponse>(GetArenaNoVirtual());
rsu_lookup_key_upload_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
return rsu_lookup_key_upload_response_;
}
inline void DeviceManagementResponse::set_allocated_rsu_lookup_key_upload_response(::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete rsu_lookup_key_upload_response_;
}
if (rsu_lookup_key_upload_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
rsu_lookup_key_upload_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, rsu_lookup_key_upload_response, submessage_arena);
}
_has_bits_[0] |= 0x08000000u;
} else {
_has_bits_[0] &= ~0x08000000u;
}
rsu_lookup_key_upload_response_ = rsu_lookup_key_upload_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
}

// optional .enterprise_management.PublicSamlUserResponse public_saml_user_response = 31;
inline bool DeviceManagementResponse::has_public_saml_user_response() const {
return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void DeviceManagementResponse::clear_public_saml_user_response() {
if (public_saml_user_response_ != nullptr) public_saml_user_response_->Clear();
_has_bits_[0] &= ~0x10000000u;
}
inline const ::enterprise_management::PublicSamlUserResponse& DeviceManagementResponse::public_saml_user_response() const {
const ::enterprise_management::PublicSamlUserResponse* p = public_saml_user_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.public_saml_user_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::PublicSamlUserResponse*>(
&::enterprise_management::_PublicSamlUserResponse_default_instance_);
}
inline ::enterprise_management::PublicSamlUserResponse* DeviceManagementResponse::release_public_saml_user_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.public_saml_user_response)
_has_bits_[0] &= ~0x10000000u;
::enterprise_management::PublicSamlUserResponse* temp = public_saml_user_response_;
public_saml_user_response_ = nullptr;
return temp;
}
inline ::enterprise_management::PublicSamlUserResponse* DeviceManagementResponse::mutable_public_saml_user_response() {
_has_bits_[0] |= 0x10000000u;
if (public_saml_user_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::PublicSamlUserResponse>(GetArenaNoVirtual());
public_saml_user_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.public_saml_user_response)
return public_saml_user_response_;
}
inline void DeviceManagementResponse::set_allocated_public_saml_user_response(::enterprise_management::PublicSamlUserResponse* public_saml_user_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete public_saml_user_response_;
}
if (public_saml_user_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
public_saml_user_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, public_saml_user_response, submessage_arena);
}
_has_bits_[0] |= 0x10000000u;
} else {
_has_bits_[0] &= ~0x10000000u;
}
public_saml_user_response_ = public_saml_user_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.public_saml_user_response)
}

// optional .enterprise_management.ChromeOsUserReportResponse chrome_os_user_report_response = 32;
inline bool DeviceManagementResponse::has_chrome_os_user_report_response() const {
return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void DeviceManagementResponse::clear_chrome_os_user_report_response() {
if (chrome_os_user_report_response_ != nullptr) chrome_os_user_report_response_->Clear();
_has_bits_[0] &= ~0x20000000u;
}
inline const ::enterprise_management::ChromeOsUserReportResponse& DeviceManagementResponse::chrome_os_user_report_response() const {
const ::enterprise_management::ChromeOsUserReportResponse* p = chrome_os_user_report_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ChromeOsUserReportResponse*>(
&::enterprise_management::_ChromeOsUserReportResponse_default_instance_);
}
inline ::enterprise_management::ChromeOsUserReportResponse* DeviceManagementResponse::release_chrome_os_user_report_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
_has_bits_[0] &= ~0x20000000u;
::enterprise_management::ChromeOsUserReportResponse* temp = chrome_os_user_report_response_;
chrome_os_user_report_response_ = nullptr;
return temp;
}
inline ::enterprise_management::ChromeOsUserReportResponse* DeviceManagementResponse::mutable_chrome_os_user_report_response() {
_has_bits_[0] |= 0x20000000u;
if (chrome_os_user_report_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ChromeOsUserReportResponse>(GetArenaNoVirtual());
chrome_os_user_report_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
return chrome_os_user_report_response_;
}
inline void DeviceManagementResponse::set_allocated_chrome_os_user_report_response(::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete chrome_os_user_report_response_;
}
if (chrome_os_user_report_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
chrome_os_user_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, chrome_os_user_report_response, submessage_arena);
}
_has_bits_[0] |= 0x20000000u;
} else {
_has_bits_[0] &= ~0x20000000u;
}
chrome_os_user_report_response_ = chrome_os_user_report_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
}

// optional .enterprise_management.ClientCertificateProvisioningResponse client_certificate_provisioning_response = 33;
inline bool DeviceManagementResponse::has_client_certificate_provisioning_response() const {
return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void DeviceManagementResponse::clear_client_certificate_provisioning_response() {
if (client_certificate_provisioning_response_ != nullptr) client_certificate_provisioning_response_->Clear();
_has_bits_[0] &= ~0x40000000u;
}
inline const ::enterprise_management::ClientCertificateProvisioningResponse& DeviceManagementResponse::client_certificate_provisioning_response() const {
const ::enterprise_management::ClientCertificateProvisioningResponse* p = client_certificate_provisioning_response_;
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
return p != nullptr ? *p : *reinterpret_cast<const ::enterprise_management::ClientCertificateProvisioningResponse*>(
&::enterprise_management::_ClientCertificateProvisioningResponse_default_instance_);
}
inline ::enterprise_management::ClientCertificateProvisioningResponse* DeviceManagementResponse::release_client_certificate_provisioning_response() {
// @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
_has_bits_[0] &= ~0x40000000u;
::enterprise_management::ClientCertificateProvisioningResponse* temp = client_certificate_provisioning_response_;
client_certificate_provisioning_response_ = nullptr;
return temp;
}
inline ::enterprise_management::ClientCertificateProvisioningResponse* DeviceManagementResponse::mutable_client_certificate_provisioning_response() {
_has_bits_[0] |= 0x40000000u;
if (client_certificate_provisioning_response_ == nullptr) {
auto* p = CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningResponse>(GetArenaNoVirtual());
client_certificate_provisioning_response_ = p;
}
// @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
return client_certificate_provisioning_response_;
}
inline void DeviceManagementResponse::set_allocated_client_certificate_provisioning_response(::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete client_certificate_provisioning_response_;
}
if (client_certificate_provisioning_response) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
client_certificate_provisioning_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, client_certificate_provisioning_response, submessage_arena);
}
_has_bits_[0] |= 0x40000000u;
} else {
_has_bits_[0] &= ~0x40000000u;
}
client_certificate_provisioning_response_ = client_certificate_provisioning_response;
// @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
}

// -------------------------------------------------------------------

// DeviceStateRetrievalInfo

// optional bool has_initial_state = 1;
inline bool DeviceStateRetrievalInfo::has_has_initial_state() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStateRetrievalInfo::clear_has_initial_state() {
has_initial_state_ = false;
_has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceStateRetrievalInfo::has_initial_state() const {
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalInfo.has_initial_state)
return has_initial_state_;
}
inline void DeviceStateRetrievalInfo::set_has_initial_state(bool value) {
_has_bits_[0] |= 0x00000001u;
has_initial_state_ = value;
// @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalInfo.has_initial_state)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace enterprise_management

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::enterprise_management::LicenseType_LicenseTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterRequest_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterRequest_Flavor> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterRequest_Lifetime> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterResponse_DeviceMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceCertUploadRequest_CertificateType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyFetchRequest_SignatureType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceState_DeviceMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyData_AssociationState> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyData_ManagementMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyData_MarketSegment> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::NetworkInterface_NetworkDeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::NetworkState_ConnectionState> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceUser_UserType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PowerStatus_PowerSource> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CpuInfo_Architecture> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CrashReportInfo_CrashReportUploadStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::OsUpdateStatus_UpdateStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInfo_AppType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInfo_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AndroidAppInfo_AndroidAppStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AndroidAppInfo_InstalledSource> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Extension_ExtensionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Extension_InstallType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Policy_PolicyLevel> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Policy_PolicyScope> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Policy_PolicySource> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyValidationReportRequest_ValidationResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DevicePairingResponse_StatusCode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CheckDevicePairingResponse_StatusCode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::RemoteCommand_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::RemoteCommandResult_ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceAttributeUpdateResponse_ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInstallReportLogEvent_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::RefreshAccountRequest_AccountType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::App_AppType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppActivity_AppState> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ClientCertificateProvisioningResponse_Error> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Channel> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CrostiniAppType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::HashingAlgorithm> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::SigningAlgorithm> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_device_5fmanagement_5fbackend_2eproto
