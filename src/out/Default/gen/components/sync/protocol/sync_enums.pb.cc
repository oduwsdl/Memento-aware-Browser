// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/sync_enums.proto

#include "components/sync/protocol/sync_enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace sync_pb {
class SyncEnumsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SyncEnums> _instance;
} _SyncEnums_default_instance_;
}  // namespace sync_pb
static void InitDefaultsscc_info_SyncEnums_components_2fsync_2fprotocol_2fsync_5fenums_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sync_pb::_SyncEnums_default_instance_;
    new (ptr) ::sync_pb::SyncEnums();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sync_pb::SyncEnums::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SyncEnums_components_2fsync_2fprotocol_2fsync_5fenums_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SyncEnums_components_2fsync_2fprotocol_2fsync_5fenums_2eproto}, {}};

namespace sync_pb {
bool SyncEnums_SingletonDebugEventType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncEnums_SingletonDebugEventType_strings[15] = {};

static const char SyncEnums_SingletonDebugEventType_names[] =
  "ACTIONABLE_ERROR"
  "BOOTSTRAP_TOKEN_UPDATED"
  "CONFIGURE_COMPLETE"
  "CONNECTION_STATUS_CHANGE"
  "ENCRYPTED_TYPES_CHANGED"
  "ENCRYPTION_COMPLETE"
  "INITIALIZATION_COMPLETE"
  "KEYSTORE_TOKEN_UPDATED"
  "PASSPHRASE_ACCEPTED"
  "PASSPHRASE_REQUIRED"
  "PASSPHRASE_TYPE_CHANGED"
  "STOP_SYNCING_PERMANENTLY"
  "TRUSTED_VAULT_KEY_ACCEPTED"
  "TRUSTED_VAULT_KEY_REQUIRED"
  "UPDATED_TOKEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncEnums_SingletonDebugEventType_entries[] = {
  { {SyncEnums_SingletonDebugEventType_names + 0, 16}, 8 },
  { {SyncEnums_SingletonDebugEventType_names + 16, 23}, 13 },
  { {SyncEnums_SingletonDebugEventType_names + 39, 18}, 12 },
  { {SyncEnums_SingletonDebugEventType_names + 57, 24}, 1 },
  { {SyncEnums_SingletonDebugEventType_names + 81, 23}, 9 },
  { {SyncEnums_SingletonDebugEventType_names + 104, 19}, 7 },
  { {SyncEnums_SingletonDebugEventType_names + 123, 23}, 5 },
  { {SyncEnums_SingletonDebugEventType_names + 146, 22}, 11 },
  { {SyncEnums_SingletonDebugEventType_names + 168, 19}, 4 },
  { {SyncEnums_SingletonDebugEventType_names + 187, 19}, 3 },
  { {SyncEnums_SingletonDebugEventType_names + 206, 23}, 10 },
  { {SyncEnums_SingletonDebugEventType_names + 229, 24}, 6 },
  { {SyncEnums_SingletonDebugEventType_names + 253, 26}, 15 },
  { {SyncEnums_SingletonDebugEventType_names + 279, 26}, 14 },
  { {SyncEnums_SingletonDebugEventType_names + 305, 13}, 2 },
};

static const int SyncEnums_SingletonDebugEventType_entries_by_number[] = {
  3, // 1 -> CONNECTION_STATUS_CHANGE
  14, // 2 -> UPDATED_TOKEN
  9, // 3 -> PASSPHRASE_REQUIRED
  8, // 4 -> PASSPHRASE_ACCEPTED
  6, // 5 -> INITIALIZATION_COMPLETE
  11, // 6 -> STOP_SYNCING_PERMANENTLY
  5, // 7 -> ENCRYPTION_COMPLETE
  0, // 8 -> ACTIONABLE_ERROR
  4, // 9 -> ENCRYPTED_TYPES_CHANGED
  10, // 10 -> PASSPHRASE_TYPE_CHANGED
  7, // 11 -> KEYSTORE_TOKEN_UPDATED
  2, // 12 -> CONFIGURE_COMPLETE
  1, // 13 -> BOOTSTRAP_TOKEN_UPDATED
  13, // 14 -> TRUSTED_VAULT_KEY_REQUIRED
  12, // 15 -> TRUSTED_VAULT_KEY_ACCEPTED
};

const std::string& SyncEnums_SingletonDebugEventType_Name(
    SyncEnums_SingletonDebugEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncEnums_SingletonDebugEventType_entries,
          SyncEnums_SingletonDebugEventType_entries_by_number,
          15, SyncEnums_SingletonDebugEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncEnums_SingletonDebugEventType_entries,
      SyncEnums_SingletonDebugEventType_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncEnums_SingletonDebugEventType_strings[idx].get();
}
bool SyncEnums_SingletonDebugEventType_Parse(
    const std::string& name, SyncEnums_SingletonDebugEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncEnums_SingletonDebugEventType_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<SyncEnums_SingletonDebugEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SyncEnums_SingletonDebugEventType SyncEnums::CONNECTION_STATUS_CHANGE;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::UPDATED_TOKEN;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::PASSPHRASE_REQUIRED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::PASSPHRASE_ACCEPTED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::INITIALIZATION_COMPLETE;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::STOP_SYNCING_PERMANENTLY;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::ENCRYPTION_COMPLETE;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::ACTIONABLE_ERROR;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::ENCRYPTED_TYPES_CHANGED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::PASSPHRASE_TYPE_CHANGED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::KEYSTORE_TOKEN_UPDATED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::CONFIGURE_COMPLETE;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::BOOTSTRAP_TOKEN_UPDATED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::TRUSTED_VAULT_KEY_REQUIRED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::TRUSTED_VAULT_KEY_ACCEPTED;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::SingletonDebugEventType_MIN;
constexpr SyncEnums_SingletonDebugEventType SyncEnums::SingletonDebugEventType_MAX;
constexpr int SyncEnums::SingletonDebugEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool SyncEnums_PageTransition_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncEnums_PageTransition_strings[11] = {};

static const char SyncEnums_PageTransition_names[] =
  "AUTO_BOOKMARK"
  "AUTO_SUBFRAME"
  "AUTO_TOPLEVEL"
  "FORM_SUBMIT"
  "GENERATED"
  "KEYWORD"
  "KEYWORD_GENERATED"
  "LINK"
  "MANUAL_SUBFRAME"
  "RELOAD"
  "TYPED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncEnums_PageTransition_entries[] = {
  { {SyncEnums_PageTransition_names + 0, 13}, 2 },
  { {SyncEnums_PageTransition_names + 13, 13}, 3 },
  { {SyncEnums_PageTransition_names + 26, 13}, 6 },
  { {SyncEnums_PageTransition_names + 39, 11}, 7 },
  { {SyncEnums_PageTransition_names + 50, 9}, 5 },
  { {SyncEnums_PageTransition_names + 59, 7}, 9 },
  { {SyncEnums_PageTransition_names + 66, 17}, 10 },
  { {SyncEnums_PageTransition_names + 83, 4}, 0 },
  { {SyncEnums_PageTransition_names + 87, 15}, 4 },
  { {SyncEnums_PageTransition_names + 102, 6}, 8 },
  { {SyncEnums_PageTransition_names + 108, 5}, 1 },
};

static const int SyncEnums_PageTransition_entries_by_number[] = {
  7, // 0 -> LINK
  10, // 1 -> TYPED
  0, // 2 -> AUTO_BOOKMARK
  1, // 3 -> AUTO_SUBFRAME
  8, // 4 -> MANUAL_SUBFRAME
  4, // 5 -> GENERATED
  2, // 6 -> AUTO_TOPLEVEL
  3, // 7 -> FORM_SUBMIT
  9, // 8 -> RELOAD
  5, // 9 -> KEYWORD
  6, // 10 -> KEYWORD_GENERATED
};

const std::string& SyncEnums_PageTransition_Name(
    SyncEnums_PageTransition value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncEnums_PageTransition_entries,
          SyncEnums_PageTransition_entries_by_number,
          11, SyncEnums_PageTransition_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncEnums_PageTransition_entries,
      SyncEnums_PageTransition_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncEnums_PageTransition_strings[idx].get();
}
bool SyncEnums_PageTransition_Parse(
    const std::string& name, SyncEnums_PageTransition* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncEnums_PageTransition_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<SyncEnums_PageTransition>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SyncEnums_PageTransition SyncEnums::LINK;
constexpr SyncEnums_PageTransition SyncEnums::TYPED;
constexpr SyncEnums_PageTransition SyncEnums::AUTO_BOOKMARK;
constexpr SyncEnums_PageTransition SyncEnums::AUTO_SUBFRAME;
constexpr SyncEnums_PageTransition SyncEnums::MANUAL_SUBFRAME;
constexpr SyncEnums_PageTransition SyncEnums::GENERATED;
constexpr SyncEnums_PageTransition SyncEnums::AUTO_TOPLEVEL;
constexpr SyncEnums_PageTransition SyncEnums::FORM_SUBMIT;
constexpr SyncEnums_PageTransition SyncEnums::RELOAD;
constexpr SyncEnums_PageTransition SyncEnums::KEYWORD;
constexpr SyncEnums_PageTransition SyncEnums::KEYWORD_GENERATED;
constexpr SyncEnums_PageTransition SyncEnums::PageTransition_MIN;
constexpr SyncEnums_PageTransition SyncEnums::PageTransition_MAX;
constexpr int SyncEnums::PageTransition_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool SyncEnums_PageTransitionRedirectType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncEnums_PageTransitionRedirectType_strings[2] = {};

static const char SyncEnums_PageTransitionRedirectType_names[] =
  "CLIENT_REDIRECT"
  "SERVER_REDIRECT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncEnums_PageTransitionRedirectType_entries[] = {
  { {SyncEnums_PageTransitionRedirectType_names + 0, 15}, 1 },
  { {SyncEnums_PageTransitionRedirectType_names + 15, 15}, 2 },
};

static const int SyncEnums_PageTransitionRedirectType_entries_by_number[] = {
  0, // 1 -> CLIENT_REDIRECT
  1, // 2 -> SERVER_REDIRECT
};

const std::string& SyncEnums_PageTransitionRedirectType_Name(
    SyncEnums_PageTransitionRedirectType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncEnums_PageTransitionRedirectType_entries,
          SyncEnums_PageTransitionRedirectType_entries_by_number,
          2, SyncEnums_PageTransitionRedirectType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncEnums_PageTransitionRedirectType_entries,
      SyncEnums_PageTransitionRedirectType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncEnums_PageTransitionRedirectType_strings[idx].get();
}
bool SyncEnums_PageTransitionRedirectType_Parse(
    const std::string& name, SyncEnums_PageTransitionRedirectType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncEnums_PageTransitionRedirectType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SyncEnums_PageTransitionRedirectType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SyncEnums_PageTransitionRedirectType SyncEnums::CLIENT_REDIRECT;
constexpr SyncEnums_PageTransitionRedirectType SyncEnums::SERVER_REDIRECT;
constexpr SyncEnums_PageTransitionRedirectType SyncEnums::PageTransitionRedirectType_MIN;
constexpr SyncEnums_PageTransitionRedirectType SyncEnums::PageTransitionRedirectType_MAX;
constexpr int SyncEnums::PageTransitionRedirectType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool SyncEnums_ErrorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 100:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncEnums_ErrorType_strings[16] = {};

static const char SyncEnums_ErrorType_names[] =
  "CLEAR_PENDING"
  "CLIENT_DATA_OBSOLETE"
  "DEPRECATED_ACCESS_DENIED"
  "DEPRECATED_AUTH_EXPIRED"
  "DEPRECATED_AUTH_INVALID"
  "DEPRECATED_USER_NOT_ACTIVATED"
  "DEPRECATED_USER_ROLLBACK"
  "DISABLED_BY_ADMIN"
  "ENCRYPTION_OBSOLETE"
  "MIGRATION_DONE"
  "NOT_MY_BIRTHDAY"
  "PARTIAL_FAILURE"
  "SUCCESS"
  "THROTTLED"
  "TRANSIENT_ERROR"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncEnums_ErrorType_entries[] = {
  { {SyncEnums_ErrorType_names + 0, 13}, 7 },
  { {SyncEnums_ErrorType_names + 13, 20}, 13 },
  { {SyncEnums_ErrorType_names + 33, 24}, 1 },
  { {SyncEnums_ErrorType_names + 57, 23}, 4 },
  { {SyncEnums_ErrorType_names + 80, 23}, 6 },
  { {SyncEnums_ErrorType_names + 103, 29}, 5 },
  { {SyncEnums_ErrorType_names + 132, 24}, 11 },
  { {SyncEnums_ErrorType_names + 156, 17}, 10 },
  { {SyncEnums_ErrorType_names + 173, 19}, 14 },
  { {SyncEnums_ErrorType_names + 192, 14}, 9 },
  { {SyncEnums_ErrorType_names + 206, 15}, 2 },
  { {SyncEnums_ErrorType_names + 221, 15}, 12 },
  { {SyncEnums_ErrorType_names + 236, 7}, 0 },
  { {SyncEnums_ErrorType_names + 243, 9}, 3 },
  { {SyncEnums_ErrorType_names + 252, 15}, 8 },
  { {SyncEnums_ErrorType_names + 267, 7}, 100 },
};

static const int SyncEnums_ErrorType_entries_by_number[] = {
  12, // 0 -> SUCCESS
  2, // 1 -> DEPRECATED_ACCESS_DENIED
  10, // 2 -> NOT_MY_BIRTHDAY
  13, // 3 -> THROTTLED
  3, // 4 -> DEPRECATED_AUTH_EXPIRED
  5, // 5 -> DEPRECATED_USER_NOT_ACTIVATED
  4, // 6 -> DEPRECATED_AUTH_INVALID
  0, // 7 -> CLEAR_PENDING
  14, // 8 -> TRANSIENT_ERROR
  9, // 9 -> MIGRATION_DONE
  7, // 10 -> DISABLED_BY_ADMIN
  6, // 11 -> DEPRECATED_USER_ROLLBACK
  11, // 12 -> PARTIAL_FAILURE
  1, // 13 -> CLIENT_DATA_OBSOLETE
  8, // 14 -> ENCRYPTION_OBSOLETE
  15, // 100 -> UNKNOWN
};

const std::string& SyncEnums_ErrorType_Name(
    SyncEnums_ErrorType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncEnums_ErrorType_entries,
          SyncEnums_ErrorType_entries_by_number,
          16, SyncEnums_ErrorType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncEnums_ErrorType_entries,
      SyncEnums_ErrorType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncEnums_ErrorType_strings[idx].get();
}
bool SyncEnums_ErrorType_Parse(
    const std::string& name, SyncEnums_ErrorType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncEnums_ErrorType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<SyncEnums_ErrorType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SyncEnums_ErrorType SyncEnums::SUCCESS;
constexpr SyncEnums_ErrorType SyncEnums::DEPRECATED_ACCESS_DENIED;
constexpr SyncEnums_ErrorType SyncEnums::NOT_MY_BIRTHDAY;
constexpr SyncEnums_ErrorType SyncEnums::THROTTLED;
constexpr SyncEnums_ErrorType SyncEnums::DEPRECATED_AUTH_EXPIRED;
constexpr SyncEnums_ErrorType SyncEnums::DEPRECATED_USER_NOT_ACTIVATED;
constexpr SyncEnums_ErrorType SyncEnums::DEPRECATED_AUTH_INVALID;
constexpr SyncEnums_ErrorType SyncEnums::CLEAR_PENDING;
constexpr SyncEnums_ErrorType SyncEnums::TRANSIENT_ERROR;
constexpr SyncEnums_ErrorType SyncEnums::MIGRATION_DONE;
constexpr SyncEnums_ErrorType SyncEnums::DISABLED_BY_ADMIN;
constexpr SyncEnums_ErrorType SyncEnums::DEPRECATED_USER_ROLLBACK;
constexpr SyncEnums_ErrorType SyncEnums::PARTIAL_FAILURE;
constexpr SyncEnums_ErrorType SyncEnums::CLIENT_DATA_OBSOLETE;
constexpr SyncEnums_ErrorType SyncEnums::ENCRYPTION_OBSOLETE;
constexpr SyncEnums_ErrorType SyncEnums::UNKNOWN;
constexpr SyncEnums_ErrorType SyncEnums::ErrorType_MIN;
constexpr SyncEnums_ErrorType SyncEnums::ErrorType_MAX;
constexpr int SyncEnums::ErrorType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool SyncEnums_Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncEnums_Action_strings[6] = {};

static const char SyncEnums_Action_names[] =
  "DEPRECATED_CLEAR_USER_DATA_AND_RESYNC"
  "DEPRECATED_DISABLE_SYNC_ON_CLIENT"
  "DEPRECATED_ENABLE_SYNC_ON_ACCOUNT"
  "DEPRECATED_STOP_AND_RESTART_SYNC"
  "UNKNOWN_ACTION"
  "UPGRADE_CLIENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncEnums_Action_entries[] = {
  { {SyncEnums_Action_names + 0, 37}, 1 },
  { {SyncEnums_Action_names + 37, 33}, 4 },
  { {SyncEnums_Action_names + 70, 33}, 2 },
  { {SyncEnums_Action_names + 103, 32}, 3 },
  { {SyncEnums_Action_names + 135, 14}, 5 },
  { {SyncEnums_Action_names + 149, 14}, 0 },
};

static const int SyncEnums_Action_entries_by_number[] = {
  5, // 0 -> UPGRADE_CLIENT
  0, // 1 -> DEPRECATED_CLEAR_USER_DATA_AND_RESYNC
  2, // 2 -> DEPRECATED_ENABLE_SYNC_ON_ACCOUNT
  3, // 3 -> DEPRECATED_STOP_AND_RESTART_SYNC
  1, // 4 -> DEPRECATED_DISABLE_SYNC_ON_CLIENT
  4, // 5 -> UNKNOWN_ACTION
};

const std::string& SyncEnums_Action_Name(
    SyncEnums_Action value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncEnums_Action_entries,
          SyncEnums_Action_entries_by_number,
          6, SyncEnums_Action_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncEnums_Action_entries,
      SyncEnums_Action_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncEnums_Action_strings[idx].get();
}
bool SyncEnums_Action_Parse(
    const std::string& name, SyncEnums_Action* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncEnums_Action_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SyncEnums_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SyncEnums_Action SyncEnums::UPGRADE_CLIENT;
constexpr SyncEnums_Action SyncEnums::DEPRECATED_CLEAR_USER_DATA_AND_RESYNC;
constexpr SyncEnums_Action SyncEnums::DEPRECATED_ENABLE_SYNC_ON_ACCOUNT;
constexpr SyncEnums_Action SyncEnums::DEPRECATED_STOP_AND_RESTART_SYNC;
constexpr SyncEnums_Action SyncEnums::DEPRECATED_DISABLE_SYNC_ON_CLIENT;
constexpr SyncEnums_Action SyncEnums::UNKNOWN_ACTION;
constexpr SyncEnums_Action SyncEnums::Action_MIN;
constexpr SyncEnums_Action SyncEnums::Action_MAX;
constexpr int SyncEnums::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool SyncEnums_DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncEnums_DeviceType_strings[8] = {};

static const char SyncEnums_DeviceType_names[] =
  "TYPE_CROS"
  "TYPE_LINUX"
  "TYPE_MAC"
  "TYPE_OTHER"
  "TYPE_PHONE"
  "TYPE_TABLET"
  "TYPE_UNSET"
  "TYPE_WIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncEnums_DeviceType_entries[] = {
  { {SyncEnums_DeviceType_names + 0, 9}, 4 },
  { {SyncEnums_DeviceType_names + 9, 10}, 3 },
  { {SyncEnums_DeviceType_names + 19, 8}, 2 },
  { {SyncEnums_DeviceType_names + 27, 10}, 5 },
  { {SyncEnums_DeviceType_names + 37, 10}, 6 },
  { {SyncEnums_DeviceType_names + 47, 11}, 7 },
  { {SyncEnums_DeviceType_names + 58, 10}, 0 },
  { {SyncEnums_DeviceType_names + 68, 8}, 1 },
};

static const int SyncEnums_DeviceType_entries_by_number[] = {
  6, // 0 -> TYPE_UNSET
  7, // 1 -> TYPE_WIN
  2, // 2 -> TYPE_MAC
  1, // 3 -> TYPE_LINUX
  0, // 4 -> TYPE_CROS
  3, // 5 -> TYPE_OTHER
  4, // 6 -> TYPE_PHONE
  5, // 7 -> TYPE_TABLET
};

const std::string& SyncEnums_DeviceType_Name(
    SyncEnums_DeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncEnums_DeviceType_entries,
          SyncEnums_DeviceType_entries_by_number,
          8, SyncEnums_DeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncEnums_DeviceType_entries,
      SyncEnums_DeviceType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncEnums_DeviceType_strings[idx].get();
}
bool SyncEnums_DeviceType_Parse(
    const std::string& name, SyncEnums_DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncEnums_DeviceType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<SyncEnums_DeviceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SyncEnums_DeviceType SyncEnums::TYPE_UNSET;
constexpr SyncEnums_DeviceType SyncEnums::TYPE_WIN;
constexpr SyncEnums_DeviceType SyncEnums::TYPE_MAC;
constexpr SyncEnums_DeviceType SyncEnums::TYPE_LINUX;
constexpr SyncEnums_DeviceType SyncEnums::TYPE_CROS;
constexpr SyncEnums_DeviceType SyncEnums::TYPE_OTHER;
constexpr SyncEnums_DeviceType SyncEnums::TYPE_PHONE;
constexpr SyncEnums_DeviceType SyncEnums::TYPE_TABLET;
constexpr SyncEnums_DeviceType SyncEnums::DeviceType_MIN;
constexpr SyncEnums_DeviceType SyncEnums::DeviceType_MAX;
constexpr int SyncEnums::DeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool SyncEnums_GetUpdatesOrigin_IsValid(int value) {
  switch (value) {
    case 0:
    case 4:
    case 7:
    case 8:
    case 9:
    case 10:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncEnums_GetUpdatesOrigin_strings[9] = {};

static const char SyncEnums_GetUpdatesOrigin_names[] =
  "GU_TRIGGER"
  "MIGRATION"
  "NEWLY_SUPPORTED_DATATYPE"
  "NEW_CLIENT"
  "PERIODIC"
  "PROGRAMMATIC"
  "RECONFIGURATION"
  "RETRY"
  "UNKNOWN_ORIGIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncEnums_GetUpdatesOrigin_entries[] = {
  { {SyncEnums_GetUpdatesOrigin_names + 0, 10}, 12 },
  { {SyncEnums_GetUpdatesOrigin_names + 10, 9}, 8 },
  { {SyncEnums_GetUpdatesOrigin_names + 19, 24}, 7 },
  { {SyncEnums_GetUpdatesOrigin_names + 43, 10}, 9 },
  { {SyncEnums_GetUpdatesOrigin_names + 53, 8}, 4 },
  { {SyncEnums_GetUpdatesOrigin_names + 61, 12}, 14 },
  { {SyncEnums_GetUpdatesOrigin_names + 73, 15}, 10 },
  { {SyncEnums_GetUpdatesOrigin_names + 88, 5}, 13 },
  { {SyncEnums_GetUpdatesOrigin_names + 93, 14}, 0 },
};

static const int SyncEnums_GetUpdatesOrigin_entries_by_number[] = {
  8, // 0 -> UNKNOWN_ORIGIN
  4, // 4 -> PERIODIC
  2, // 7 -> NEWLY_SUPPORTED_DATATYPE
  1, // 8 -> MIGRATION
  3, // 9 -> NEW_CLIENT
  6, // 10 -> RECONFIGURATION
  0, // 12 -> GU_TRIGGER
  7, // 13 -> RETRY
  5, // 14 -> PROGRAMMATIC
};

const std::string& SyncEnums_GetUpdatesOrigin_Name(
    SyncEnums_GetUpdatesOrigin value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncEnums_GetUpdatesOrigin_entries,
          SyncEnums_GetUpdatesOrigin_entries_by_number,
          9, SyncEnums_GetUpdatesOrigin_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncEnums_GetUpdatesOrigin_entries,
      SyncEnums_GetUpdatesOrigin_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncEnums_GetUpdatesOrigin_strings[idx].get();
}
bool SyncEnums_GetUpdatesOrigin_Parse(
    const std::string& name, SyncEnums_GetUpdatesOrigin* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncEnums_GetUpdatesOrigin_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<SyncEnums_GetUpdatesOrigin>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::UNKNOWN_ORIGIN;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::PERIODIC;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::NEWLY_SUPPORTED_DATATYPE;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::MIGRATION;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::NEW_CLIENT;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::RECONFIGURATION;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::GU_TRIGGER;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::RETRY;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::PROGRAMMATIC;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::GetUpdatesOrigin_MIN;
constexpr SyncEnums_GetUpdatesOrigin SyncEnums::GetUpdatesOrigin_MAX;
constexpr int SyncEnums::GetUpdatesOrigin_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void SyncEnums::InitAsDefaultInstance() {
}
class SyncEnums::_Internal {
 public:
  using HasBits = decltype(std::declval<SyncEnums>()._has_bits_);
};

SyncEnums::SyncEnums()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sync_pb.SyncEnums)
}
SyncEnums::SyncEnums(const SyncEnums& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sync_pb.SyncEnums)
}

void SyncEnums::SharedCtor() {
}

SyncEnums::~SyncEnums() {
  // @@protoc_insertion_point(destructor:sync_pb.SyncEnums)
  SharedDtor();
}

void SyncEnums::SharedDtor() {
}

void SyncEnums::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SyncEnums& SyncEnums::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SyncEnums_components_2fsync_2fprotocol_2fsync_5fenums_2eproto.base);
  return *internal_default_instance();
}


void SyncEnums::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.SyncEnums)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SyncEnums::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SyncEnums::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sync_pb.SyncEnums)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:sync_pb.SyncEnums)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sync_pb.SyncEnums)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SyncEnums::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sync_pb.SyncEnums)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sync_pb.SyncEnums)
}

size_t SyncEnums::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.SyncEnums)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SyncEnums::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SyncEnums*>(
      &from));
}

void SyncEnums::MergeFrom(const SyncEnums& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SyncEnums)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void SyncEnums::CopyFrom(const SyncEnums& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SyncEnums)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SyncEnums::IsInitialized() const {
  return true;
}

void SyncEnums::InternalSwap(SyncEnums* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

std::string SyncEnums::GetTypeName() const {
  return "sync_pb.SyncEnums";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sync_pb::SyncEnums* Arena::CreateMaybeMessage< ::sync_pb::SyncEnums >(Arena* arena) {
  return Arena::CreateInternal< ::sync_pb::SyncEnums >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
