// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cert_logger.proto

#include "cert_logger.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_cert_5flogger_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_CertLoggerFeaturesInfo_cert_5flogger_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cert_5flogger_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_cert_5flogger_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cert_5flogger_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CertLoggerInterstitialInfo_cert_5flogger_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cert_5flogger_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MacCertEvidenceInfo_cert_5flogger_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cert_5flogger_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MacPlatformDebugInfo_cert_5flogger_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cert_5flogger_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrialVerificationInfo_cert_5flogger_2eproto;
namespace chrome_browser_ssl {
class CertLoggerInterstitialInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CertLoggerInterstitialInfo> _instance;
} _CertLoggerInterstitialInfo_default_instance_;
class CertLoggerFeaturesInfo_NetworkTimeQueryingInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CertLoggerFeaturesInfo_NetworkTimeQueryingInfo> _instance;
} _CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_default_instance_;
class CertLoggerFeaturesInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CertLoggerFeaturesInfo> _instance;
} _CertLoggerFeaturesInfo_default_instance_;
class CertLoggerRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CertLoggerRequest> _instance;
} _CertLoggerRequest_default_instance_;
class MacCertEvidenceInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MacCertEvidenceInfo> _instance;
} _MacCertEvidenceInfo_default_instance_;
class MacPlatformDebugInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MacPlatformDebugInfo> _instance;
} _MacPlatformDebugInfo_default_instance_;
class TrialVerificationInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrialVerificationInfo> _instance;
} _TrialVerificationInfo_default_instance_;
}  // namespace chrome_browser_ssl
static void InitDefaultsscc_info_CertLoggerFeaturesInfo_cert_5flogger_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chrome_browser_ssl::_CertLoggerFeaturesInfo_default_instance_;
    new (ptr) ::chrome_browser_ssl::CertLoggerFeaturesInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chrome_browser_ssl::CertLoggerFeaturesInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_CertLoggerFeaturesInfo_cert_5flogger_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_CertLoggerFeaturesInfo_cert_5flogger_2eproto}, {
      &scc_info_CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_cert_5flogger_2eproto.base,
      &scc_info_TrialVerificationInfo_cert_5flogger_2eproto.base,}};

static void InitDefaultsscc_info_CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_cert_5flogger_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chrome_browser_ssl::_CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_default_instance_;
    new (ptr) ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_cert_5flogger_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_cert_5flogger_2eproto}, {}};

static void InitDefaultsscc_info_CertLoggerInterstitialInfo_cert_5flogger_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chrome_browser_ssl::_CertLoggerInterstitialInfo_default_instance_;
    new (ptr) ::chrome_browser_ssl::CertLoggerInterstitialInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chrome_browser_ssl::CertLoggerInterstitialInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CertLoggerInterstitialInfo_cert_5flogger_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_CertLoggerInterstitialInfo_cert_5flogger_2eproto}, {}};

static void InitDefaultsscc_info_CertLoggerRequest_cert_5flogger_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chrome_browser_ssl::_CertLoggerRequest_default_instance_;
    new (ptr) ::chrome_browser_ssl::CertLoggerRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chrome_browser_ssl::CertLoggerRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_CertLoggerRequest_cert_5flogger_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_CertLoggerRequest_cert_5flogger_2eproto}, {
      &scc_info_CertLoggerInterstitialInfo_cert_5flogger_2eproto.base,
      &scc_info_CertLoggerFeaturesInfo_cert_5flogger_2eproto.base,}};

static void InitDefaultsscc_info_MacCertEvidenceInfo_cert_5flogger_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chrome_browser_ssl::_MacCertEvidenceInfo_default_instance_;
    new (ptr) ::chrome_browser_ssl::MacCertEvidenceInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chrome_browser_ssl::MacCertEvidenceInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MacCertEvidenceInfo_cert_5flogger_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MacCertEvidenceInfo_cert_5flogger_2eproto}, {}};

static void InitDefaultsscc_info_MacPlatformDebugInfo_cert_5flogger_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chrome_browser_ssl::_MacPlatformDebugInfo_default_instance_;
    new (ptr) ::chrome_browser_ssl::MacPlatformDebugInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chrome_browser_ssl::MacPlatformDebugInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MacPlatformDebugInfo_cert_5flogger_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_MacPlatformDebugInfo_cert_5flogger_2eproto}, {
      &scc_info_MacCertEvidenceInfo_cert_5flogger_2eproto.base,}};

static void InitDefaultsscc_info_TrialVerificationInfo_cert_5flogger_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chrome_browser_ssl::_TrialVerificationInfo_default_instance_;
    new (ptr) ::chrome_browser_ssl::TrialVerificationInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chrome_browser_ssl::TrialVerificationInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrialVerificationInfo_cert_5flogger_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TrialVerificationInfo_cert_5flogger_2eproto}, {
      &scc_info_MacPlatformDebugInfo_cert_5flogger_2eproto.base,}};

namespace chrome_browser_ssl {
bool CertLoggerInterstitialInfo_InterstitialReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerInterstitialInfo_InterstitialReason_strings[8] = {};

static const char CertLoggerInterstitialInfo_InterstitialReason_names[] =
  "INTERSTITIAL_BLOCKED_INTERCEPTION"
  "INTERSTITIAL_CAPTIVE_PORTAL"
  "INTERSTITIAL_CLOCK"
  "INTERSTITIAL_LEGACY_TLS"
  "INTERSTITIAL_MITM_SOFTWARE"
  "INTERSTITIAL_SSL"
  "INTERSTITIAL_SUPERFISH"
  "UNKNOWN_INTERSTITIAL_REASON";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerInterstitialInfo_InterstitialReason_entries[] = {
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 0, 33}, 6 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 33, 27}, 2 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 60, 18}, 3 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 78, 23}, 7 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 101, 26}, 5 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 127, 16}, 1 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 143, 22}, 4 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 165, 27}, 0 },
};

static const int CertLoggerInterstitialInfo_InterstitialReason_entries_by_number[] = {
  7, // 0 -> UNKNOWN_INTERSTITIAL_REASON
  5, // 1 -> INTERSTITIAL_SSL
  1, // 2 -> INTERSTITIAL_CAPTIVE_PORTAL
  2, // 3 -> INTERSTITIAL_CLOCK
  6, // 4 -> INTERSTITIAL_SUPERFISH
  4, // 5 -> INTERSTITIAL_MITM_SOFTWARE
  0, // 6 -> INTERSTITIAL_BLOCKED_INTERCEPTION
  3, // 7 -> INTERSTITIAL_LEGACY_TLS
};

const std::string& CertLoggerInterstitialInfo_InterstitialReason_Name(
    CertLoggerInterstitialInfo_InterstitialReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerInterstitialInfo_InterstitialReason_entries,
          CertLoggerInterstitialInfo_InterstitialReason_entries_by_number,
          8, CertLoggerInterstitialInfo_InterstitialReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerInterstitialInfo_InterstitialReason_entries,
      CertLoggerInterstitialInfo_InterstitialReason_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerInterstitialInfo_InterstitialReason_strings[idx].get();
}
bool CertLoggerInterstitialInfo_InterstitialReason_Parse(
    const std::string& name, CertLoggerInterstitialInfo_InterstitialReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerInterstitialInfo_InterstitialReason_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerInterstitialInfo_InterstitialReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::UNKNOWN_INTERSTITIAL_REASON;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_SSL;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_CAPTIVE_PORTAL;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_CLOCK;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_SUPERFISH;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_MITM_SOFTWARE;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_BLOCKED_INTERCEPTION;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_LEGACY_TLS;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::InterstitialReason_MIN;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::InterstitialReason_MAX;
constexpr int CertLoggerInterstitialInfo::InterstitialReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_strings[4] = {};

static const char CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names[] =
  "NETWORK_TIME_FETCHES_BACKGROUND_ONLY"
  "NETWORK_TIME_FETCHES_IN_BACKGROUND_AND_ON_DEMAND"
  "NETWORK_TIME_FETCHES_ON_DEMAND_ONLY"
  "NETWORK_TIME_FETCHES_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries[] = {
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 0, 36}, 1 },
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 36, 48}, 3 },
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 84, 35}, 2 },
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 119, 28}, 0 },
};

static const int CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries_by_number[] = {
  3, // 0 -> NETWORK_TIME_FETCHES_UNKNOWN
  0, // 1 -> NETWORK_TIME_FETCHES_BACKGROUND_ONLY
  2, // 2 -> NETWORK_TIME_FETCHES_ON_DEMAND_ONLY
  1, // 3 -> NETWORK_TIME_FETCHES_IN_BACKGROUND_AND_ON_DEMAND
};

const std::string& CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_Name(
    CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries,
          CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries_by_number,
          4, CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries,
      CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_strings[idx].get();
}
bool CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_Parse(
    const std::string& name, CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_UNKNOWN;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_BACKGROUND_ONLY;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_ON_DEMAND_ONLY;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_IN_BACKGROUND_AND_ON_DEMAND;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NetworkTimeFetchBehavior_MIN;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NetworkTimeFetchBehavior_MAX;
constexpr int CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NetworkTimeFetchBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_strings[3] = {};

static const char CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names[] =
  "ANDROID_AIA_FETCHING_DISABLED"
  "ANDROID_AIA_FETCHING_ENABLED"
  "ANDROID_AIA_FETCHING_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries[] = {
  { {CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names + 0, 29}, 2 },
  { {CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names + 29, 28}, 1 },
  { {CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names + 57, 28}, 0 },
};

static const int CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries_by_number[] = {
  2, // 0 -> ANDROID_AIA_FETCHING_UNKNOWN
  1, // 1 -> ANDROID_AIA_FETCHING_ENABLED
  0, // 2 -> ANDROID_AIA_FETCHING_DISABLED
};

const std::string& CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_Name(
    CertLoggerFeaturesInfo_AndroidAIAFetchingStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries,
          CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries_by_number,
          3, CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries,
      CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_strings[idx].get();
}
bool CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_Parse(
    const std::string& name, CertLoggerFeaturesInfo_AndroidAIAFetchingStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerFeaturesInfo_AndroidAIAFetchingStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::ANDROID_AIA_FETCHING_UNKNOWN;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::ANDROID_AIA_FETCHING_ENABLED;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::ANDROID_AIA_FETCHING_DISABLED;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::AndroidAIAFetchingStatus_MIN;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::AndroidAIAFetchingStatus_MAX;
constexpr int CertLoggerFeaturesInfo::AndroidAIAFetchingStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CertLoggerRequest_CertError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerRequest_CertError_strings[17] = {};

static const char CertLoggerRequest_CertError_names[] =
  "ERR_CERTIFICATE_TRANSPARENCY_REQUIRED"
  "ERR_CERT_AUTHORITY_INVALID"
  "ERR_CERT_COMMON_NAME_INVALID"
  "ERR_CERT_DATE_INVALID"
  "ERR_CERT_INVALID"
  "ERR_CERT_KNOWN_INTERCEPTION_BLOCKED"
  "ERR_CERT_NAME_CONSTRAINT_VIOLATION"
  "ERR_CERT_NON_UNIQUE_NAME"
  "ERR_CERT_NO_REVOCATION_MECHANISM"
  "ERR_CERT_REVOKED"
  "ERR_CERT_SYMANTEC_LEGACY"
  "ERR_CERT_UNABLE_TO_CHECK_REVOCATION"
  "ERR_CERT_VALIDITY_TOO_LONG"
  "ERR_CERT_WEAK_KEY"
  "ERR_CERT_WEAK_SIGNATURE_ALGORITHM"
  "ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN"
  "UNKNOWN_CERT_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerRequest_CertError_entries[] = {
  { {CertLoggerRequest_CertError_names + 0, 37}, 14 },
  { {CertLoggerRequest_CertError_names + 37, 26}, 4 },
  { {CertLoggerRequest_CertError_names + 63, 28}, 5 },
  { {CertLoggerRequest_CertError_names + 91, 21}, 9 },
  { {CertLoggerRequest_CertError_names + 112, 16}, 2 },
  { {CertLoggerRequest_CertError_names + 128, 35}, 16 },
  { {CertLoggerRequest_CertError_names + 163, 34}, 6 },
  { {CertLoggerRequest_CertError_names + 197, 24}, 13 },
  { {CertLoggerRequest_CertError_names + 221, 32}, 12 },
  { {CertLoggerRequest_CertError_names + 253, 16}, 1 },
  { {CertLoggerRequest_CertError_names + 269, 24}, 15 },
  { {CertLoggerRequest_CertError_names + 293, 35}, 11 },
  { {CertLoggerRequest_CertError_names + 328, 26}, 10 },
  { {CertLoggerRequest_CertError_names + 354, 17}, 8 },
  { {CertLoggerRequest_CertError_names + 371, 33}, 7 },
  { {CertLoggerRequest_CertError_names + 404, 36}, 3 },
  { {CertLoggerRequest_CertError_names + 440, 18}, 0 },
};

static const int CertLoggerRequest_CertError_entries_by_number[] = {
  16, // 0 -> UNKNOWN_CERT_ERROR
  9, // 1 -> ERR_CERT_REVOKED
  4, // 2 -> ERR_CERT_INVALID
  15, // 3 -> ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN
  1, // 4 -> ERR_CERT_AUTHORITY_INVALID
  2, // 5 -> ERR_CERT_COMMON_NAME_INVALID
  6, // 6 -> ERR_CERT_NAME_CONSTRAINT_VIOLATION
  14, // 7 -> ERR_CERT_WEAK_SIGNATURE_ALGORITHM
  13, // 8 -> ERR_CERT_WEAK_KEY
  3, // 9 -> ERR_CERT_DATE_INVALID
  12, // 10 -> ERR_CERT_VALIDITY_TOO_LONG
  11, // 11 -> ERR_CERT_UNABLE_TO_CHECK_REVOCATION
  8, // 12 -> ERR_CERT_NO_REVOCATION_MECHANISM
  7, // 13 -> ERR_CERT_NON_UNIQUE_NAME
  0, // 14 -> ERR_CERTIFICATE_TRANSPARENCY_REQUIRED
  10, // 15 -> ERR_CERT_SYMANTEC_LEGACY
  5, // 16 -> ERR_CERT_KNOWN_INTERCEPTION_BLOCKED
};

const std::string& CertLoggerRequest_CertError_Name(
    CertLoggerRequest_CertError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerRequest_CertError_entries,
          CertLoggerRequest_CertError_entries_by_number,
          17, CertLoggerRequest_CertError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerRequest_CertError_entries,
      CertLoggerRequest_CertError_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerRequest_CertError_strings[idx].get();
}
bool CertLoggerRequest_CertError_Parse(
    const std::string& name, CertLoggerRequest_CertError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerRequest_CertError_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerRequest_CertError>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CertLoggerRequest_CertError CertLoggerRequest::UNKNOWN_CERT_ERROR;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_REVOKED;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_AUTHORITY_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_COMMON_NAME_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_NAME_CONSTRAINT_VIOLATION;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_WEAK_SIGNATURE_ALGORITHM;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_WEAK_KEY;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_DATE_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_VALIDITY_TOO_LONG;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_UNABLE_TO_CHECK_REVOCATION;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_NO_REVOCATION_MECHANISM;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_NON_UNIQUE_NAME;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERTIFICATE_TRANSPARENCY_REQUIRED;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_SYMANTEC_LEGACY;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_KNOWN_INTERCEPTION_BLOCKED;
constexpr CertLoggerRequest_CertError CertLoggerRequest::CertError_MIN;
constexpr CertLoggerRequest_CertError CertLoggerRequest::CertError_MAX;
constexpr int CertLoggerRequest::CertError_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CertLoggerRequest_ChromeChannel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerRequest_ChromeChannel_strings[6] = {};

static const char CertLoggerRequest_ChromeChannel_names[] =
  "CHROME_CHANNEL_BETA"
  "CHROME_CHANNEL_CANARY"
  "CHROME_CHANNEL_DEV"
  "CHROME_CHANNEL_NONE"
  "CHROME_CHANNEL_STABLE"
  "CHROME_CHANNEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerRequest_ChromeChannel_entries[] = {
  { {CertLoggerRequest_ChromeChannel_names + 0, 19}, 4 },
  { {CertLoggerRequest_ChromeChannel_names + 19, 21}, 3 },
  { {CertLoggerRequest_ChromeChannel_names + 40, 18}, 2 },
  { {CertLoggerRequest_ChromeChannel_names + 58, 19}, 0 },
  { {CertLoggerRequest_ChromeChannel_names + 77, 21}, 5 },
  { {CertLoggerRequest_ChromeChannel_names + 98, 22}, 1 },
};

static const int CertLoggerRequest_ChromeChannel_entries_by_number[] = {
  3, // 0 -> CHROME_CHANNEL_NONE
  5, // 1 -> CHROME_CHANNEL_UNKNOWN
  2, // 2 -> CHROME_CHANNEL_DEV
  1, // 3 -> CHROME_CHANNEL_CANARY
  0, // 4 -> CHROME_CHANNEL_BETA
  4, // 5 -> CHROME_CHANNEL_STABLE
};

const std::string& CertLoggerRequest_ChromeChannel_Name(
    CertLoggerRequest_ChromeChannel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerRequest_ChromeChannel_entries,
          CertLoggerRequest_ChromeChannel_entries_by_number,
          6, CertLoggerRequest_ChromeChannel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerRequest_ChromeChannel_entries,
      CertLoggerRequest_ChromeChannel_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerRequest_ChromeChannel_strings[idx].get();
}
bool CertLoggerRequest_ChromeChannel_Parse(
    const std::string& name, CertLoggerRequest_ChromeChannel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerRequest_ChromeChannel_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerRequest_ChromeChannel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_NONE;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_UNKNOWN;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_DEV;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_CANARY;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_BETA;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_STABLE;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::ChromeChannel_MIN;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::ChromeChannel_MAX;
constexpr int CertLoggerRequest::ChromeChannel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CertLoggerRequest_CertStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerRequest_CertStatus_strings[6] = {};

static const char CertLoggerRequest_CertStatus_names[] =
  "STATUS_CT_COMPLIANCE_FAILED"
  "STATUS_IS_EV"
  "STATUS_KNOWN_INTERCEPTION_DETECTED"
  "STATUS_REV_CHECKING_ENABLED"
  "STATUS_SHA1_SIGNATURE_PRESENT"
  "UNKNOWN_CERT_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerRequest_CertStatus_entries[] = {
  { {CertLoggerRequest_CertStatus_names + 0, 27}, 4 },
  { {CertLoggerRequest_CertStatus_names + 27, 12}, 1 },
  { {CertLoggerRequest_CertStatus_names + 39, 34}, 5 },
  { {CertLoggerRequest_CertStatus_names + 73, 27}, 2 },
  { {CertLoggerRequest_CertStatus_names + 100, 29}, 3 },
  { {CertLoggerRequest_CertStatus_names + 129, 19}, 0 },
};

static const int CertLoggerRequest_CertStatus_entries_by_number[] = {
  5, // 0 -> UNKNOWN_CERT_STATUS
  1, // 1 -> STATUS_IS_EV
  3, // 2 -> STATUS_REV_CHECKING_ENABLED
  4, // 3 -> STATUS_SHA1_SIGNATURE_PRESENT
  0, // 4 -> STATUS_CT_COMPLIANCE_FAILED
  2, // 5 -> STATUS_KNOWN_INTERCEPTION_DETECTED
};

const std::string& CertLoggerRequest_CertStatus_Name(
    CertLoggerRequest_CertStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerRequest_CertStatus_entries,
          CertLoggerRequest_CertStatus_entries_by_number,
          6, CertLoggerRequest_CertStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerRequest_CertStatus_entries,
      CertLoggerRequest_CertStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerRequest_CertStatus_strings[idx].get();
}
bool CertLoggerRequest_CertStatus_Parse(
    const std::string& name, CertLoggerRequest_CertStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerRequest_CertStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerRequest_CertStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::UNKNOWN_CERT_STATUS;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_IS_EV;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_REV_CHECKING_ENABLED;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_SHA1_SIGNATURE_PRESENT;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_CT_COMPLIANCE_FAILED;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_KNOWN_INTERCEPTION_DETECTED;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::CertStatus_MIN;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::CertStatus_MAX;
constexpr int CertLoggerRequest::CertStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TrialVerificationInfo_VerifyFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrialVerificationInfo_VerifyFlags_strings[8] = {};

static const char TrialVerificationInfo_VerifyFlags_names[] =
  "UNKNOWN_VERIFY_FLAG"
  "VERIFY_CERT_IO_ENABLED"
  "VERIFY_DISABLE_SYMANTEC_ENFORCEMENT"
  "VERIFY_ENABLE_SHA1_LOCAL_ANCHORS"
  "VERIFY_EV_CERT"
  "VERIFY_REV_CHECKING_ENABLED"
  "VERIFY_REV_CHECKING_ENABLED_EV_ONLY"
  "VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrialVerificationInfo_VerifyFlags_entries[] = {
  { {TrialVerificationInfo_VerifyFlags_names + 0, 19}, 0 },
  { {TrialVerificationInfo_VerifyFlags_names + 19, 22}, 3 },
  { {TrialVerificationInfo_VerifyFlags_names + 41, 35}, 7 },
  { {TrialVerificationInfo_VerifyFlags_names + 76, 32}, 6 },
  { {TrialVerificationInfo_VerifyFlags_names + 108, 14}, 2 },
  { {TrialVerificationInfo_VerifyFlags_names + 122, 27}, 1 },
  { {TrialVerificationInfo_VerifyFlags_names + 149, 35}, 4 },
  { {TrialVerificationInfo_VerifyFlags_names + 184, 42}, 5 },
};

static const int TrialVerificationInfo_VerifyFlags_entries_by_number[] = {
  0, // 0 -> UNKNOWN_VERIFY_FLAG
  5, // 1 -> VERIFY_REV_CHECKING_ENABLED
  4, // 2 -> VERIFY_EV_CERT
  1, // 3 -> VERIFY_CERT_IO_ENABLED
  6, // 4 -> VERIFY_REV_CHECKING_ENABLED_EV_ONLY
  7, // 5 -> VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS
  3, // 6 -> VERIFY_ENABLE_SHA1_LOCAL_ANCHORS
  2, // 7 -> VERIFY_DISABLE_SYMANTEC_ENFORCEMENT
};

const std::string& TrialVerificationInfo_VerifyFlags_Name(
    TrialVerificationInfo_VerifyFlags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrialVerificationInfo_VerifyFlags_entries,
          TrialVerificationInfo_VerifyFlags_entries_by_number,
          8, TrialVerificationInfo_VerifyFlags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrialVerificationInfo_VerifyFlags_entries,
      TrialVerificationInfo_VerifyFlags_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrialVerificationInfo_VerifyFlags_strings[idx].get();
}
bool TrialVerificationInfo_VerifyFlags_Parse(
    const std::string& name, TrialVerificationInfo_VerifyFlags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrialVerificationInfo_VerifyFlags_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TrialVerificationInfo_VerifyFlags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::UNKNOWN_VERIFY_FLAG;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_REV_CHECKING_ENABLED;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_EV_CERT;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_CERT_IO_ENABLED;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_REV_CHECKING_ENABLED_EV_ONLY;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_ENABLE_SHA1_LOCAL_ANCHORS;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_DISABLE_SYMANTEC_ENFORCEMENT;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VerifyFlags_MIN;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VerifyFlags_MAX;
constexpr int TrialVerificationInfo::VerifyFlags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TrialVerificationInfo_MacTrustFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrialVerificationInfo_MacTrustFlags_strings[12] = {};

static const char TrialVerificationInfo_MacTrustFlags_names[] =
  "MAC_TRUST_SETTINGS_ARRAY_EMPTY"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_ALLOWED_ERROR"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_APPLICATION"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_KEY_USAGE"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY_STRING"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_RESULT"
  "MAC_TRUST_SETTINGS_DICT_EMPTY"
  "MAC_TRUST_SETTINGS_DICT_INVALID_POLICY_TYPE"
  "MAC_TRUST_SETTINGS_DICT_INVALID_RESULT_TYPE"
  "MAC_TRUST_SETTINGS_DICT_UNKNOWN_KEY"
  "UNKNOWN_MAC_TRUST_FLAG";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrialVerificationInfo_MacTrustFlags_entries[] = {
  { {TrialVerificationInfo_MacTrustFlags_names + 0, 30}, 1 },
  { {TrialVerificationInfo_MacTrustFlags_names + 30, 46}, 11 },
  { {TrialVerificationInfo_MacTrustFlags_names + 76, 44}, 6 },
  { {TrialVerificationInfo_MacTrustFlags_names + 120, 42}, 8 },
  { {TrialVerificationInfo_MacTrustFlags_names + 162, 39}, 4 },
  { {TrialVerificationInfo_MacTrustFlags_names + 201, 46}, 7 },
  { {TrialVerificationInfo_MacTrustFlags_names + 247, 39}, 9 },
  { {TrialVerificationInfo_MacTrustFlags_names + 286, 29}, 2 },
  { {TrialVerificationInfo_MacTrustFlags_names + 315, 43}, 5 },
  { {TrialVerificationInfo_MacTrustFlags_names + 358, 43}, 10 },
  { {TrialVerificationInfo_MacTrustFlags_names + 401, 35}, 3 },
  { {TrialVerificationInfo_MacTrustFlags_names + 436, 22}, 0 },
};

static const int TrialVerificationInfo_MacTrustFlags_entries_by_number[] = {
  11, // 0 -> UNKNOWN_MAC_TRUST_FLAG
  0, // 1 -> MAC_TRUST_SETTINGS_ARRAY_EMPTY
  7, // 2 -> MAC_TRUST_SETTINGS_DICT_EMPTY
  10, // 3 -> MAC_TRUST_SETTINGS_DICT_UNKNOWN_KEY
  4, // 4 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY
  8, // 5 -> MAC_TRUST_SETTINGS_DICT_INVALID_POLICY_TYPE
  2, // 6 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_APPLICATION
  5, // 7 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY_STRING
  3, // 8 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_KEY_USAGE
  6, // 9 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_RESULT
  9, // 10 -> MAC_TRUST_SETTINGS_DICT_INVALID_RESULT_TYPE
  1, // 11 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_ALLOWED_ERROR
};

const std::string& TrialVerificationInfo_MacTrustFlags_Name(
    TrialVerificationInfo_MacTrustFlags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrialVerificationInfo_MacTrustFlags_entries,
          TrialVerificationInfo_MacTrustFlags_entries_by_number,
          12, TrialVerificationInfo_MacTrustFlags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrialVerificationInfo_MacTrustFlags_entries,
      TrialVerificationInfo_MacTrustFlags_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrialVerificationInfo_MacTrustFlags_strings[idx].get();
}
bool TrialVerificationInfo_MacTrustFlags_Parse(
    const std::string& name, TrialVerificationInfo_MacTrustFlags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrialVerificationInfo_MacTrustFlags_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<TrialVerificationInfo_MacTrustFlags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::UNKNOWN_MAC_TRUST_FLAG;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_ARRAY_EMPTY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_EMPTY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_UNKNOWN_KEY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_INVALID_POLICY_TYPE;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_APPLICATION;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY_STRING;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_KEY_USAGE;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_RESULT;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_INVALID_RESULT_TYPE;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_ALLOWED_ERROR;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MacTrustFlags_MIN;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MacTrustFlags_MAX;
constexpr int TrialVerificationInfo::MacTrustFlags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void CertLoggerInterstitialInfo::InitAsDefaultInstance() {
}
class CertLoggerInterstitialInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerInterstitialInfo>()._has_bits_);
  static void set_has_interstitial_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_proceeded(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overridable(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_interstitial_created_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CertLoggerInterstitialInfo::CertLoggerInterstitialInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chrome_browser_ssl.CertLoggerInterstitialInfo)
}
CertLoggerInterstitialInfo::CertLoggerInterstitialInfo(const CertLoggerInterstitialInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&interstitial_reason_, &from.interstitial_reason_,
    static_cast<size_t>(reinterpret_cast<char*>(&interstitial_created_time_usec_) -
    reinterpret_cast<char*>(&interstitial_reason_)) + sizeof(interstitial_created_time_usec_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerInterstitialInfo)
}

void CertLoggerInterstitialInfo::SharedCtor() {
  ::memset(&interstitial_reason_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&interstitial_created_time_usec_) -
      reinterpret_cast<char*>(&interstitial_reason_)) + sizeof(interstitial_created_time_usec_));
}

CertLoggerInterstitialInfo::~CertLoggerInterstitialInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerInterstitialInfo)
  SharedDtor();
}

void CertLoggerInterstitialInfo::SharedDtor() {
}

void CertLoggerInterstitialInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CertLoggerInterstitialInfo& CertLoggerInterstitialInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CertLoggerInterstitialInfo_cert_5flogger_2eproto.base);
  return *internal_default_instance();
}


void CertLoggerInterstitialInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&interstitial_reason_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interstitial_created_time_usec_) -
        reinterpret_cast<char*>(&interstitial_reason_)) + sizeof(interstitial_created_time_usec_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CertLoggerInterstitialInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .chrome_browser_ssl.CertLoggerInterstitialInfo.InterstitialReason interstitial_reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerInterstitialInfo_InterstitialReason_IsValid(val))) {
            set_interstitial_reason(static_cast<::chrome_browser_ssl::CertLoggerInterstitialInfo_InterstitialReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool user_proceeded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_user_proceeded(&has_bits);
          user_proceeded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool overridable = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_overridable(&has_bits);
          overridable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 interstitial_created_time_usec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_interstitial_created_time_usec(&has_bits);
          interstitial_created_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CertLoggerInterstitialInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chrome_browser_ssl.CertLoggerInterstitialInfo.InterstitialReason interstitial_reason = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerInterstitialInfo_InterstitialReason_IsValid(value)) {
            set_interstitial_reason(static_cast< ::chrome_browser_ssl::CertLoggerInterstitialInfo_InterstitialReason >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool user_proceeded = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_user_proceeded(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &user_proceeded_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool overridable = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_overridable(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &overridable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 interstitial_created_time_usec = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_interstitial_created_time_usec(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &interstitial_created_time_usec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chrome_browser_ssl.CertLoggerInterstitialInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chrome_browser_ssl.CertLoggerInterstitialInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CertLoggerInterstitialInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .chrome_browser_ssl.CertLoggerInterstitialInfo.InterstitialReason interstitial_reason = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->interstitial_reason(), output);
  }

  // optional bool user_proceeded = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->user_proceeded(), output);
  }

  // optional bool overridable = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->overridable(), output);
  }

  // optional int64 interstitial_created_time_usec = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->interstitial_created_time_usec(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chrome_browser_ssl.CertLoggerInterstitialInfo)
}

size_t CertLoggerInterstitialInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .chrome_browser_ssl.CertLoggerInterstitialInfo.InterstitialReason interstitial_reason = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->interstitial_reason());
    }

    // optional bool user_proceeded = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool overridable = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int64 interstitial_created_time_usec = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->interstitial_created_time_usec());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerInterstitialInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CertLoggerInterstitialInfo*>(
      &from));
}

void CertLoggerInterstitialInfo::MergeFrom(const CertLoggerInterstitialInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      interstitial_reason_ = from.interstitial_reason_;
    }
    if (cached_has_bits & 0x00000002u) {
      user_proceeded_ = from.user_proceeded_;
    }
    if (cached_has_bits & 0x00000004u) {
      overridable_ = from.overridable_;
    }
    if (cached_has_bits & 0x00000008u) {
      interstitial_created_time_usec_ = from.interstitial_created_time_usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CertLoggerInterstitialInfo::CopyFrom(const CertLoggerInterstitialInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerInterstitialInfo::IsInitialized() const {
  return true;
}

void CertLoggerInterstitialInfo::InternalSwap(CertLoggerInterstitialInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(interstitial_reason_, other->interstitial_reason_);
  swap(user_proceeded_, other->user_proceeded_);
  swap(overridable_, other->overridable_);
  swap(interstitial_created_time_usec_, other->interstitial_created_time_usec_);
}

std::string CertLoggerInterstitialInfo::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerInterstitialInfo";
}


// ===================================================================

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::InitAsDefaultInstance() {
}
class CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerFeaturesInfo_NetworkTimeQueryingInfo>()._has_bits_);
  static void set_has_network_time_queries_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_network_time_query_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
}
CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo(const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&network_time_queries_enabled_, &from.network_time_queries_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&network_time_query_behavior_) -
    reinterpret_cast<char*>(&network_time_queries_enabled_)) + sizeof(network_time_query_behavior_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::SharedCtor() {
  ::memset(&network_time_queries_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&network_time_query_behavior_) -
      reinterpret_cast<char*>(&network_time_queries_enabled_)) + sizeof(network_time_query_behavior_));
}

CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::~CertLoggerFeaturesInfo_NetworkTimeQueryingInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  SharedDtor();
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::SharedDtor() {
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_cert_5flogger_2eproto.base);
  return *internal_default_instance();
}


void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&network_time_queries_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&network_time_query_behavior_) -
        reinterpret_cast<char*>(&network_time_queries_enabled_)) + sizeof(network_time_query_behavior_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool network_time_queries_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_network_time_queries_enabled(&has_bits);
          network_time_queries_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo.NetworkTimeFetchBehavior network_time_query_behavior = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_IsValid(val))) {
            set_network_time_query_behavior(static_cast<::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool network_time_queries_enabled = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_network_time_queries_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &network_time_queries_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo.NetworkTimeFetchBehavior network_time_query_behavior = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_IsValid(value)) {
            set_network_time_query_behavior(static_cast< ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool network_time_queries_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->network_time_queries_enabled(), output);
  }

  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo.NetworkTimeFetchBehavior network_time_query_behavior = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->network_time_query_behavior(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
}

size_t CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool network_time_queries_enabled = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo.NetworkTimeFetchBehavior network_time_query_behavior = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->network_time_query_behavior());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo*>(
      &from));
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::MergeFrom(const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      network_time_queries_enabled_ = from.network_time_queries_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      network_time_query_behavior_ = from.network_time_query_behavior_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CopyFrom(const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::IsInitialized() const {
  return true;
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::InternalSwap(CertLoggerFeaturesInfo_NetworkTimeQueryingInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(network_time_queries_enabled_, other->network_time_queries_enabled_);
  swap(network_time_query_behavior_, other->network_time_query_behavior_);
}

std::string CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo";
}


// ===================================================================

void CertLoggerFeaturesInfo::InitAsDefaultInstance() {
  ::chrome_browser_ssl::_CertLoggerFeaturesInfo_default_instance_._instance.get_mutable()->network_time_querying_info_ = const_cast< ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo*>(
      ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::internal_default_instance());
  ::chrome_browser_ssl::_CertLoggerFeaturesInfo_default_instance_._instance.get_mutable()->trial_verification_info_ = const_cast< ::chrome_browser_ssl::TrialVerificationInfo*>(
      ::chrome_browser_ssl::TrialVerificationInfo::internal_default_instance());
}
class CertLoggerFeaturesInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerFeaturesInfo>()._has_bits_);
  static const ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& network_time_querying_info(const CertLoggerFeaturesInfo* msg);
  static void set_has_network_time_querying_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_android_aia_fetching_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chrome_browser_ssl::TrialVerificationInfo& trial_verification_info(const CertLoggerFeaturesInfo* msg);
  static void set_has_trial_verification_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo&
CertLoggerFeaturesInfo::_Internal::network_time_querying_info(const CertLoggerFeaturesInfo* msg) {
  return *msg->network_time_querying_info_;
}
const ::chrome_browser_ssl::TrialVerificationInfo&
CertLoggerFeaturesInfo::_Internal::trial_verification_info(const CertLoggerFeaturesInfo* msg) {
  return *msg->trial_verification_info_;
}
CertLoggerFeaturesInfo::CertLoggerFeaturesInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chrome_browser_ssl.CertLoggerFeaturesInfo)
}
CertLoggerFeaturesInfo::CertLoggerFeaturesInfo(const CertLoggerFeaturesInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_network_time_querying_info()) {
    network_time_querying_info_ = new ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo(*from.network_time_querying_info_);
  } else {
    network_time_querying_info_ = nullptr;
  }
  if (from.has_trial_verification_info()) {
    trial_verification_info_ = new ::chrome_browser_ssl::TrialVerificationInfo(*from.trial_verification_info_);
  } else {
    trial_verification_info_ = nullptr;
  }
  android_aia_fetching_status_ = from.android_aia_fetching_status_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerFeaturesInfo)
}

void CertLoggerFeaturesInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CertLoggerFeaturesInfo_cert_5flogger_2eproto.base);
  ::memset(&network_time_querying_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&android_aia_fetching_status_) -
      reinterpret_cast<char*>(&network_time_querying_info_)) + sizeof(android_aia_fetching_status_));
}

CertLoggerFeaturesInfo::~CertLoggerFeaturesInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerFeaturesInfo)
  SharedDtor();
}

void CertLoggerFeaturesInfo::SharedDtor() {
  if (this != internal_default_instance()) delete network_time_querying_info_;
  if (this != internal_default_instance()) delete trial_verification_info_;
}

void CertLoggerFeaturesInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CertLoggerFeaturesInfo& CertLoggerFeaturesInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CertLoggerFeaturesInfo_cert_5flogger_2eproto.base);
  return *internal_default_instance();
}


void CertLoggerFeaturesInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(network_time_querying_info_ != nullptr);
      network_time_querying_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(trial_verification_info_ != nullptr);
      trial_verification_info_->Clear();
    }
  }
  android_aia_fetching_status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CertLoggerFeaturesInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo network_time_querying_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_network_time_querying_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.AndroidAIAFetchingStatus android_aia_fetching_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_IsValid(val))) {
            set_android_aia_fetching_status(static_cast<::chrome_browser_ssl::CertLoggerFeaturesInfo_AndroidAIAFetchingStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.TrialVerificationInfo trial_verification_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_trial_verification_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CertLoggerFeaturesInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo network_time_querying_info = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_network_time_querying_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.AndroidAIAFetchingStatus android_aia_fetching_status = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_IsValid(value)) {
            set_android_aia_fetching_status(static_cast< ::chrome_browser_ssl::CertLoggerFeaturesInfo_AndroidAIAFetchingStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chrome_browser_ssl.TrialVerificationInfo trial_verification_info = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_trial_verification_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chrome_browser_ssl.CertLoggerFeaturesInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chrome_browser_ssl.CertLoggerFeaturesInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CertLoggerFeaturesInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo network_time_querying_info = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::network_time_querying_info(this), output);
  }

  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.AndroidAIAFetchingStatus android_aia_fetching_status = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->android_aia_fetching_status(), output);
  }

  // optional .chrome_browser_ssl.TrialVerificationInfo trial_verification_info = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::trial_verification_info(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chrome_browser_ssl.CertLoggerFeaturesInfo)
}

size_t CertLoggerFeaturesInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo network_time_querying_info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *network_time_querying_info_);
    }

    // optional .chrome_browser_ssl.TrialVerificationInfo trial_verification_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trial_verification_info_);
    }

    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.AndroidAIAFetchingStatus android_aia_fetching_status = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->android_aia_fetching_status());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerFeaturesInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CertLoggerFeaturesInfo*>(
      &from));
}

void CertLoggerFeaturesInfo::MergeFrom(const CertLoggerFeaturesInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_network_time_querying_info()->::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::MergeFrom(from.network_time_querying_info());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_trial_verification_info()->::chrome_browser_ssl::TrialVerificationInfo::MergeFrom(from.trial_verification_info());
    }
    if (cached_has_bits & 0x00000004u) {
      android_aia_fetching_status_ = from.android_aia_fetching_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CertLoggerFeaturesInfo::CopyFrom(const CertLoggerFeaturesInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerFeaturesInfo::IsInitialized() const {
  return true;
}

void CertLoggerFeaturesInfo::InternalSwap(CertLoggerFeaturesInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(network_time_querying_info_, other->network_time_querying_info_);
  swap(trial_verification_info_, other->trial_verification_info_);
  swap(android_aia_fetching_status_, other->android_aia_fetching_status_);
}

std::string CertLoggerFeaturesInfo::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerFeaturesInfo";
}


// ===================================================================

void CertLoggerRequest::InitAsDefaultInstance() {
  ::chrome_browser_ssl::_CertLoggerRequest_default_instance_._instance.get_mutable()->interstitial_info_ = const_cast< ::chrome_browser_ssl::CertLoggerInterstitialInfo*>(
      ::chrome_browser_ssl::CertLoggerInterstitialInfo::internal_default_instance());
  ::chrome_browser_ssl::_CertLoggerRequest_default_instance_._instance.get_mutable()->features_info_ = const_cast< ::chrome_browser_ssl::CertLoggerFeaturesInfo*>(
      ::chrome_browser_ssl::CertLoggerFeaturesInfo::internal_default_instance());
}
class CertLoggerRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerRequest>()._has_bits_);
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cert_chain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::chrome_browser_ssl::CertLoggerInterstitialInfo& interstitial_info(const CertLoggerRequest* msg);
  static void set_has_interstitial_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_unverified_cert_chain(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_issued_by_known_root(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::chrome_browser_ssl::CertLoggerFeaturesInfo& features_info(const CertLoggerRequest* msg);
  static void set_has_features_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_retry_upload(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_chrome_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_enterprise_managed(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::chrome_browser_ssl::CertLoggerInterstitialInfo&
CertLoggerRequest::_Internal::interstitial_info(const CertLoggerRequest* msg) {
  return *msg->interstitial_info_;
}
const ::chrome_browser_ssl::CertLoggerFeaturesInfo&
CertLoggerRequest::_Internal::features_info(const CertLoggerRequest* msg) {
  return *msg->features_info_;
}
CertLoggerRequest::CertLoggerRequest()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chrome_browser_ssl.CertLoggerRequest)
}
CertLoggerRequest::CertLoggerRequest(const CertLoggerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      public_key_hash_(from.public_key_hash_),
      pin_(from.pin_),
      cert_error_(from.cert_error_),
      cert_status_(from.cert_status_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hostname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_hostname()) {
    hostname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hostname_);
  }
  cert_chain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_cert_chain()) {
    cert_chain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cert_chain_);
  }
  unverified_cert_chain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_unverified_cert_chain()) {
    unverified_cert_chain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.unverified_cert_chain_);
  }
  if (from.has_interstitial_info()) {
    interstitial_info_ = new ::chrome_browser_ssl::CertLoggerInterstitialInfo(*from.interstitial_info_);
  } else {
    interstitial_info_ = nullptr;
  }
  if (from.has_features_info()) {
    features_info_ = new ::chrome_browser_ssl::CertLoggerFeaturesInfo(*from.features_info_);
  } else {
    features_info_ = nullptr;
  }
  ::memcpy(&time_usec_, &from.time_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&chrome_channel_) -
    reinterpret_cast<char*>(&time_usec_)) + sizeof(chrome_channel_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerRequest)
}

void CertLoggerRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CertLoggerRequest_cert_5flogger_2eproto.base);
  hostname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cert_chain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  unverified_cert_chain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&interstitial_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&chrome_channel_) -
      reinterpret_cast<char*>(&interstitial_info_)) + sizeof(chrome_channel_));
}

CertLoggerRequest::~CertLoggerRequest() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerRequest)
  SharedDtor();
}

void CertLoggerRequest::SharedDtor() {
  hostname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cert_chain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  unverified_cert_chain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete interstitial_info_;
  if (this != internal_default_instance()) delete features_info_;
}

void CertLoggerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CertLoggerRequest& CertLoggerRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CertLoggerRequest_cert_5flogger_2eproto.base);
  return *internal_default_instance();
}


void CertLoggerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  public_key_hash_.Clear();
  pin_.Clear();
  cert_error_.Clear();
  cert_status_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      hostname_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      cert_chain_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      unverified_cert_chain_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(interstitial_info_ != nullptr);
      interstitial_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(features_info_ != nullptr);
      features_info_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&time_usec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_retry_upload_) -
        reinterpret_cast<char*>(&time_usec_)) + sizeof(is_retry_upload_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&is_enterprise_managed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chrome_channel_) -
        reinterpret_cast<char*>(&is_enterprise_managed_)) + sizeof(chrome_channel_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CertLoggerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string hostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_hostname(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string cert_chain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_cert_chain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int64 time_usec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_time_usec(&has_bits);
          time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string public_key_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_public_key_hash(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // repeated string pin = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_pin(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid(val))) {
              add_cert_error(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertError>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 48);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_cert_error(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid, &_internal_metadata_, 6);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerInterstitialInfo interstitial_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_interstitial_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string unverified_cert_chain = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_unverified_cert_chain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_issued_by_known_root = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_is_issued_by_known_root(&has_bits);
          is_issued_by_known_root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo features_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_features_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_retry_upload = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_is_retry_upload(&has_bits);
          is_retry_upload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerRequest.ChromeChannel chrome_channel = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_ChromeChannel_IsValid(val))) {
            set_chrome_channel(static_cast<::chrome_browser_ssl::CertLoggerRequest_ChromeChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool is_enterprise_managed = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_is_enterprise_managed(&has_bits);
          is_enterprise_managed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid(val))) {
              add_cert_status(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertStatus>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 112);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_cert_status(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid, &_internal_metadata_, 14);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CertLoggerRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chrome_browser_ssl.CertLoggerRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string hostname = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string cert_chain = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_cert_chain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int64 time_usec = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_time_usec(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_usec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string public_key_hash = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->add_public_key_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string pin = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->add_pin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid(value)) {
            add_cert_error(static_cast< ::chrome_browser_ssl::CertLoggerRequest_CertError >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 6,
                 ::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid,
                 &unknown_fields_stream,
                 this->mutable_cert_error())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chrome_browser_ssl.CertLoggerInterstitialInfo interstitial_info = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_interstitial_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string unverified_cert_chain = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_unverified_cert_chain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_issued_by_known_root = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_is_issued_by_known_root(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_issued_by_known_root_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo features_info = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_features_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_retry_upload = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_is_retry_upload(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_retry_upload_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chrome_browser_ssl.CertLoggerRequest.ChromeChannel chrome_channel = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerRequest_ChromeChannel_IsValid(value)) {
            set_chrome_channel(static_cast< ::chrome_browser_ssl::CertLoggerRequest_ChromeChannel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(96u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_enterprise_managed = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          _Internal::set_has_is_enterprise_managed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_enterprise_managed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid(value)) {
            add_cert_status(static_cast< ::chrome_browser_ssl::CertLoggerRequest_CertStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (114 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 14,
                 ::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid,
                 &unknown_fields_stream,
                 this->mutable_cert_status())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chrome_browser_ssl.CertLoggerRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chrome_browser_ssl.CertLoggerRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CertLoggerRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chrome_browser_ssl.CertLoggerRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string hostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hostname(), output);
  }

  // required string cert_chain = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->cert_chain(), output);
  }

  // required int64 time_usec = 3;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->time_usec(), output);
  }

  // repeated string public_key_hash = 4;
  for (int i = 0, n = this->public_key_hash_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteString(
      4, this->public_key_hash(i), output);
  }

  // repeated string pin = 5;
  for (int i = 0, n = this->pin_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteString(
      5, this->pin(i), output);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 6;
  for (int i = 0, n = this->cert_error_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->cert_error(i), output);
  }

  // optional .chrome_browser_ssl.CertLoggerInterstitialInfo interstitial_info = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7, _Internal::interstitial_info(this), output);
  }

  // optional string unverified_cert_chain = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->unverified_cert_chain(), output);
  }

  // optional bool is_issued_by_known_root = 9;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(9, this->is_issued_by_known_root(), output);
  }

  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo features_info = 10;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      10, _Internal::features_info(this), output);
  }

  // optional bool is_retry_upload = 11;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(11, this->is_retry_upload(), output);
  }

  // optional .chrome_browser_ssl.CertLoggerRequest.ChromeChannel chrome_channel = 12;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      12, this->chrome_channel(), output);
  }

  // optional bool is_enterprise_managed = 13;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(13, this->is_enterprise_managed(), output);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 14;
  for (int i = 0, n = this->cert_status_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      14, this->cert_status(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chrome_browser_ssl.CertLoggerRequest)
}

size_t CertLoggerRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:chrome_browser_ssl.CertLoggerRequest)
  size_t total_size = 0;

  if (has_hostname()) {
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->hostname());
  }

  if (has_cert_chain()) {
    // required string cert_chain = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->cert_chain());
  }

  if (has_time_usec()) {
    // required int64 time_usec = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->time_usec());
  }

  return total_size;
}
size_t CertLoggerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerRequest)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000023) ^ 0x00000023) == 0) {  // All required fields are present.
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->hostname());

    // required string cert_chain = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->cert_chain());

    // required int64 time_usec = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->time_usec());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string public_key_hash = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->public_key_hash_size());
  for (int i = 0, n = this->public_key_hash_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      this->public_key_hash(i));
  }

  // repeated string pin = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->pin_size());
  for (int i = 0, n = this->pin_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      this->pin(i));
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 6;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->cert_error_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->cert_error(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 14;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->cert_status_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->cert_status(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional string unverified_cert_chain = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->unverified_cert_chain());
    }

    // optional .chrome_browser_ssl.CertLoggerInterstitialInfo interstitial_info = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *interstitial_info_);
    }

    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo features_info = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *features_info_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional bool is_issued_by_known_root = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_retry_upload = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool is_enterprise_managed = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional .chrome_browser_ssl.CertLoggerRequest.ChromeChannel chrome_channel = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->chrome_channel());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CertLoggerRequest*>(
      &from));
}

void CertLoggerRequest::MergeFrom(const CertLoggerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  public_key_hash_.MergeFrom(from.public_key_hash_);
  pin_.MergeFrom(from.pin_);
  cert_error_.MergeFrom(from.cert_error_);
  cert_status_.MergeFrom(from.cert_status_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      hostname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      cert_chain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cert_chain_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      unverified_cert_chain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.unverified_cert_chain_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_interstitial_info()->::chrome_browser_ssl::CertLoggerInterstitialInfo::MergeFrom(from.interstitial_info());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_features_info()->::chrome_browser_ssl::CertLoggerFeaturesInfo::MergeFrom(from.features_info());
    }
    if (cached_has_bits & 0x00000020u) {
      time_usec_ = from.time_usec_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_issued_by_known_root_ = from.is_issued_by_known_root_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_retry_upload_ = from.is_retry_upload_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      is_enterprise_managed_ = from.is_enterprise_managed_;
    }
    if (cached_has_bits & 0x00000200u) {
      chrome_channel_ = from.chrome_channel_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CertLoggerRequest::CopyFrom(const CertLoggerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000023) != 0x00000023) return false;
  return true;
}

void CertLoggerRequest::InternalSwap(CertLoggerRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  public_key_hash_.InternalSwap(CastToBase(&other->public_key_hash_));
  pin_.InternalSwap(CastToBase(&other->pin_));
  cert_error_.InternalSwap(&other->cert_error_);
  cert_status_.InternalSwap(&other->cert_status_);
  hostname_.Swap(&other->hostname_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  cert_chain_.Swap(&other->cert_chain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  unverified_cert_chain_.Swap(&other->unverified_cert_chain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(interstitial_info_, other->interstitial_info_);
  swap(features_info_, other->features_info_);
  swap(time_usec_, other->time_usec_);
  swap(is_issued_by_known_root_, other->is_issued_by_known_root_);
  swap(is_retry_upload_, other->is_retry_upload_);
  swap(is_enterprise_managed_, other->is_enterprise_managed_);
  swap(chrome_channel_, other->chrome_channel_);
}

std::string CertLoggerRequest::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerRequest";
}


// ===================================================================

void MacCertEvidenceInfo::InitAsDefaultInstance() {
}
class MacCertEvidenceInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MacCertEvidenceInfo>()._has_bits_);
  static void set_has_status_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MacCertEvidenceInfo::MacCertEvidenceInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chrome_browser_ssl.MacCertEvidenceInfo)
}
MacCertEvidenceInfo::MacCertEvidenceInfo(const MacCertEvidenceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      status_codes_(from.status_codes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  status_bits_ = from.status_bits_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.MacCertEvidenceInfo)
}

void MacCertEvidenceInfo::SharedCtor() {
  status_bits_ = 0u;
}

MacCertEvidenceInfo::~MacCertEvidenceInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.MacCertEvidenceInfo)
  SharedDtor();
}

void MacCertEvidenceInfo::SharedDtor() {
}

void MacCertEvidenceInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MacCertEvidenceInfo& MacCertEvidenceInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MacCertEvidenceInfo_cert_5flogger_2eproto.base);
  return *internal_default_instance();
}


void MacCertEvidenceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.MacCertEvidenceInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_codes_.Clear();
  status_bits_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MacCertEvidenceInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 status_bits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_status_bits(&has_bits);
          status_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 status_codes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_status_codes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_status_codes(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MacCertEvidenceInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chrome_browser_ssl.MacCertEvidenceInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 status_bits = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_status_bits(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_bits_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 status_codes = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 16u, input, this->mutable_status_codes())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_status_codes())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chrome_browser_ssl.MacCertEvidenceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chrome_browser_ssl.MacCertEvidenceInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MacCertEvidenceInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chrome_browser_ssl.MacCertEvidenceInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 status_bits = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->status_bits(), output);
  }

  // repeated int32 status_codes = 2;
  for (int i = 0, n = this->status_codes_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      2, this->status_codes(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chrome_browser_ssl.MacCertEvidenceInfo)
}

size_t MacCertEvidenceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.MacCertEvidenceInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 status_codes = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->status_codes_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->status_codes_size());
    total_size += data_size;
  }

  // optional uint32 status_bits = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->status_bits());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MacCertEvidenceInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MacCertEvidenceInfo*>(
      &from));
}

void MacCertEvidenceInfo::MergeFrom(const MacCertEvidenceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.MacCertEvidenceInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  status_codes_.MergeFrom(from.status_codes_);
  if (from.has_status_bits()) {
    set_status_bits(from.status_bits());
  }
}

void MacCertEvidenceInfo::CopyFrom(const MacCertEvidenceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.MacCertEvidenceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MacCertEvidenceInfo::IsInitialized() const {
  return true;
}

void MacCertEvidenceInfo::InternalSwap(MacCertEvidenceInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  status_codes_.InternalSwap(&other->status_codes_);
  swap(status_bits_, other->status_bits_);
}

std::string MacCertEvidenceInfo::GetTypeName() const {
  return "chrome_browser_ssl.MacCertEvidenceInfo";
}


// ===================================================================

void MacPlatformDebugInfo::InitAsDefaultInstance() {
}
class MacPlatformDebugInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MacPlatformDebugInfo>()._has_bits_);
  static void set_has_trust_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MacPlatformDebugInfo::MacPlatformDebugInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chrome_browser_ssl.MacPlatformDebugInfo)
}
MacPlatformDebugInfo::MacPlatformDebugInfo(const MacPlatformDebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      status_chain_(from.status_chain_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&trust_result_, &from.trust_result_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_code_) -
    reinterpret_cast<char*>(&trust_result_)) + sizeof(result_code_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.MacPlatformDebugInfo)
}

void MacPlatformDebugInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MacPlatformDebugInfo_cert_5flogger_2eproto.base);
  ::memset(&trust_result_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&result_code_) -
      reinterpret_cast<char*>(&trust_result_)) + sizeof(result_code_));
}

MacPlatformDebugInfo::~MacPlatformDebugInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.MacPlatformDebugInfo)
  SharedDtor();
}

void MacPlatformDebugInfo::SharedDtor() {
}

void MacPlatformDebugInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MacPlatformDebugInfo& MacPlatformDebugInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MacPlatformDebugInfo_cert_5flogger_2eproto.base);
  return *internal_default_instance();
}


void MacPlatformDebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.MacPlatformDebugInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_chain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&trust_result_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_code_) -
        reinterpret_cast<char*>(&trust_result_)) + sizeof(result_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MacPlatformDebugInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 trust_result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_trust_result(&has_bits);
          trust_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.MacCertEvidenceInfo status_chain = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_status_chain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MacPlatformDebugInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chrome_browser_ssl.MacPlatformDebugInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 trust_result = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_trust_result(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trust_result_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_code = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_result_code(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_code_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chrome_browser_ssl.MacCertEvidenceInfo status_chain = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_status_chain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chrome_browser_ssl.MacPlatformDebugInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chrome_browser_ssl.MacPlatformDebugInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MacPlatformDebugInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chrome_browser_ssl.MacPlatformDebugInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 trust_result = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->trust_result(), output);
  }

  // optional int32 result_code = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->result_code(), output);
  }

  // repeated .chrome_browser_ssl.MacCertEvidenceInfo status_chain = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->status_chain_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3,
      this->status_chain(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chrome_browser_ssl.MacPlatformDebugInfo)
}

size_t MacPlatformDebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.MacPlatformDebugInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chrome_browser_ssl.MacCertEvidenceInfo status_chain = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->status_chain_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->status_chain(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 trust_result = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->trust_result());
    }

    // optional int32 result_code = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_code());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MacPlatformDebugInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MacPlatformDebugInfo*>(
      &from));
}

void MacPlatformDebugInfo::MergeFrom(const MacPlatformDebugInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.MacPlatformDebugInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  status_chain_.MergeFrom(from.status_chain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      trust_result_ = from.trust_result_;
    }
    if (cached_has_bits & 0x00000002u) {
      result_code_ = from.result_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MacPlatformDebugInfo::CopyFrom(const MacPlatformDebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.MacPlatformDebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MacPlatformDebugInfo::IsInitialized() const {
  return true;
}

void MacPlatformDebugInfo::InternalSwap(MacPlatformDebugInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&status_chain_)->InternalSwap(CastToBase(&other->status_chain_));
  swap(trust_result_, other->trust_result_);
  swap(result_code_, other->result_code_);
}

std::string MacPlatformDebugInfo::GetTypeName() const {
  return "chrome_browser_ssl.MacPlatformDebugInfo";
}


// ===================================================================

void TrialVerificationInfo::InitAsDefaultInstance() {
  ::chrome_browser_ssl::_TrialVerificationInfo_default_instance_._instance.get_mutable()->mac_platform_debug_info_ = const_cast< ::chrome_browser_ssl::MacPlatformDebugInfo*>(
      ::chrome_browser_ssl::MacPlatformDebugInfo::internal_default_instance());
}
class TrialVerificationInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TrialVerificationInfo>()._has_bits_);
  static void set_has_cert_chain(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_issued_by_known_root(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_trial_verification_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_trial_der_verification_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::chrome_browser_ssl::MacPlatformDebugInfo& mac_platform_debug_info(const TrialVerificationInfo* msg);
  static void set_has_mac_platform_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_stapled_ocsp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sct_list(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::chrome_browser_ssl::MacPlatformDebugInfo&
TrialVerificationInfo::_Internal::mac_platform_debug_info(const TrialVerificationInfo* msg) {
  return *msg->mac_platform_debug_info_;
}
TrialVerificationInfo::TrialVerificationInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chrome_browser_ssl.TrialVerificationInfo)
}
TrialVerificationInfo::TrialVerificationInfo(const TrialVerificationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      public_key_hash_(from.public_key_hash_),
      cert_error_(from.cert_error_),
      cert_status_(from.cert_status_),
      verify_flags_(from.verify_flags_),
      mac_combined_trust_debug_info_(from.mac_combined_trust_debug_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cert_chain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_cert_chain()) {
    cert_chain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cert_chain_);
  }
  trial_der_verification_time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_trial_der_verification_time()) {
    trial_der_verification_time_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.trial_der_verification_time_);
  }
  stapled_ocsp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_stapled_ocsp()) {
    stapled_ocsp_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.stapled_ocsp_);
  }
  sct_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_sct_list()) {
    sct_list_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sct_list_);
  }
  if (from.has_mac_platform_debug_info()) {
    mac_platform_debug_info_ = new ::chrome_browser_ssl::MacPlatformDebugInfo(*from.mac_platform_debug_info_);
  } else {
    mac_platform_debug_info_ = nullptr;
  }
  ::memcpy(&trial_verification_time_usec_, &from.trial_verification_time_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_issued_by_known_root_) -
    reinterpret_cast<char*>(&trial_verification_time_usec_)) + sizeof(is_issued_by_known_root_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.TrialVerificationInfo)
}

void TrialVerificationInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TrialVerificationInfo_cert_5flogger_2eproto.base);
  cert_chain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  trial_der_verification_time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  stapled_ocsp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sct_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&mac_platform_debug_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_issued_by_known_root_) -
      reinterpret_cast<char*>(&mac_platform_debug_info_)) + sizeof(is_issued_by_known_root_));
}

TrialVerificationInfo::~TrialVerificationInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.TrialVerificationInfo)
  SharedDtor();
}

void TrialVerificationInfo::SharedDtor() {
  cert_chain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  trial_der_verification_time_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  stapled_ocsp_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sct_list_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete mac_platform_debug_info_;
}

void TrialVerificationInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrialVerificationInfo& TrialVerificationInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrialVerificationInfo_cert_5flogger_2eproto.base);
  return *internal_default_instance();
}


void TrialVerificationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.TrialVerificationInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  public_key_hash_.Clear();
  cert_error_.Clear();
  cert_status_.Clear();
  verify_flags_.Clear();
  mac_combined_trust_debug_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      cert_chain_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      trial_der_verification_time_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      stapled_ocsp_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      sct_list_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(mac_platform_debug_info_ != nullptr);
      mac_platform_debug_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&trial_verification_time_usec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_issued_by_known_root_) -
        reinterpret_cast<char*>(&trial_verification_time_usec_)) + sizeof(is_issued_by_known_root_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TrialVerificationInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string cert_chain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_cert_chain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string public_key_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_public_key_hash(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid(val))) {
              add_cert_error(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertError>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 24);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_cert_error(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_issued_by_known_root = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_is_issued_by_known_root(&has_bits);
          is_issued_by_known_root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid(val))) {
              add_cert_status(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertStatus>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 40);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_cert_status(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.TrialVerificationInfo.VerifyFlags verify_flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags_IsValid(val))) {
              add_verify_flags(static_cast<::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 48);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_verify_flags(), ptr, ctx, ::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags_IsValid, &_internal_metadata_, 6);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.TrialVerificationInfo.MacTrustFlags mac_combined_trust_debug_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags_IsValid(val))) {
              add_mac_combined_trust_debug_info(static_cast<::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 56);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_mac_combined_trust_debug_info(), ptr, ctx, ::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags_IsValid, &_internal_metadata_, 7);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 trial_verification_time_usec = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_trial_verification_time_usec(&has_bits);
          trial_verification_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string trial_der_verification_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_trial_der_verification_time(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.MacPlatformDebugInfo mac_platform_debug_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_mac_platform_debug_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes stapled_ocsp = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_stapled_ocsp(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes sct_list = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_sct_list(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TrialVerificationInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chrome_browser_ssl.TrialVerificationInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string cert_chain = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_cert_chain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string public_key_hash = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->add_public_key_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid(value)) {
            add_cert_error(static_cast< ::chrome_browser_ssl::CertLoggerRequest_CertError >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 3,
                 ::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid,
                 &unknown_fields_stream,
                 this->mutable_cert_error())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_issued_by_known_root = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_is_issued_by_known_root(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_issued_by_known_root_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid(value)) {
            add_cert_status(static_cast< ::chrome_browser_ssl::CertLoggerRequest_CertStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 5,
                 ::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid,
                 &unknown_fields_stream,
                 this->mutable_cert_status())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chrome_browser_ssl.TrialVerificationInfo.VerifyFlags verify_flags = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags_IsValid(value)) {
            add_verify_flags(static_cast< ::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 6,
                 ::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags_IsValid,
                 &unknown_fields_stream,
                 this->mutable_verify_flags())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chrome_browser_ssl.TrialVerificationInfo.MacTrustFlags mac_combined_trust_debug_info = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags_IsValid(value)) {
            add_mac_combined_trust_debug_info(static_cast< ::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 7,
                 ::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags_IsValid,
                 &unknown_fields_stream,
                 this->mutable_mac_combined_trust_debug_info())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 trial_verification_time_usec = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_trial_verification_time_usec(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &trial_verification_time_usec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string trial_der_verification_time = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_trial_der_verification_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chrome_browser_ssl.MacPlatformDebugInfo mac_platform_debug_info = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_mac_platform_debug_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes stapled_ocsp = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_stapled_ocsp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes sct_list = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (98 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sct_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chrome_browser_ssl.TrialVerificationInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chrome_browser_ssl.TrialVerificationInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TrialVerificationInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chrome_browser_ssl.TrialVerificationInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string cert_chain = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->cert_chain(), output);
  }

  // repeated string public_key_hash = 2;
  for (int i = 0, n = this->public_key_hash_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteString(
      2, this->public_key_hash(i), output);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 3;
  for (int i = 0, n = this->cert_error_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->cert_error(i), output);
  }

  // optional bool is_issued_by_known_root = 4;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->is_issued_by_known_root(), output);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 5;
  for (int i = 0, n = this->cert_status_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      5, this->cert_status(i), output);
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.VerifyFlags verify_flags = 6;
  for (int i = 0, n = this->verify_flags_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->verify_flags(i), output);
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.MacTrustFlags mac_combined_trust_debug_info = 7;
  for (int i = 0, n = this->mac_combined_trust_debug_info_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      7, this->mac_combined_trust_debug_info(i), output);
  }

  // optional int64 trial_verification_time_usec = 8;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(8, this->trial_verification_time_usec(), output);
  }

  // optional string trial_der_verification_time = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->trial_der_verification_time(), output);
  }

  // optional .chrome_browser_ssl.MacPlatformDebugInfo mac_platform_debug_info = 10;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      10, _Internal::mac_platform_debug_info(this), output);
  }

  // optional bytes stapled_ocsp = 11;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->stapled_ocsp(), output);
  }

  // optional bytes sct_list = 12;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      12, this->sct_list(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chrome_browser_ssl.TrialVerificationInfo)
}

size_t TrialVerificationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.TrialVerificationInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string public_key_hash = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->public_key_hash_size());
  for (int i = 0, n = this->public_key_hash_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      this->public_key_hash(i));
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 3;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->cert_error_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->cert_error(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->cert_status_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->cert_status(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.VerifyFlags verify_flags = 6;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->verify_flags_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->verify_flags(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.MacTrustFlags mac_combined_trust_debug_info = 7;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->mac_combined_trust_debug_info_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->mac_combined_trust_debug_info(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string cert_chain = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->cert_chain());
    }

    // optional string trial_der_verification_time = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->trial_der_verification_time());
    }

    // optional bytes stapled_ocsp = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->stapled_ocsp());
    }

    // optional bytes sct_list = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->sct_list());
    }

    // optional .chrome_browser_ssl.MacPlatformDebugInfo mac_platform_debug_info = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mac_platform_debug_info_);
    }

    // optional int64 trial_verification_time_usec = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->trial_verification_time_usec());
    }

    // optional bool is_issued_by_known_root = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrialVerificationInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TrialVerificationInfo*>(
      &from));
}

void TrialVerificationInfo::MergeFrom(const TrialVerificationInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.TrialVerificationInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  public_key_hash_.MergeFrom(from.public_key_hash_);
  cert_error_.MergeFrom(from.cert_error_);
  cert_status_.MergeFrom(from.cert_status_);
  verify_flags_.MergeFrom(from.verify_flags_);
  mac_combined_trust_debug_info_.MergeFrom(from.mac_combined_trust_debug_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      cert_chain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cert_chain_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      trial_der_verification_time_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.trial_der_verification_time_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      stapled_ocsp_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.stapled_ocsp_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      sct_list_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sct_list_);
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_mac_platform_debug_info()->::chrome_browser_ssl::MacPlatformDebugInfo::MergeFrom(from.mac_platform_debug_info());
    }
    if (cached_has_bits & 0x00000020u) {
      trial_verification_time_usec_ = from.trial_verification_time_usec_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_issued_by_known_root_ = from.is_issued_by_known_root_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TrialVerificationInfo::CopyFrom(const TrialVerificationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.TrialVerificationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrialVerificationInfo::IsInitialized() const {
  return true;
}

void TrialVerificationInfo::InternalSwap(TrialVerificationInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  public_key_hash_.InternalSwap(CastToBase(&other->public_key_hash_));
  cert_error_.InternalSwap(&other->cert_error_);
  cert_status_.InternalSwap(&other->cert_status_);
  verify_flags_.InternalSwap(&other->verify_flags_);
  mac_combined_trust_debug_info_.InternalSwap(&other->mac_combined_trust_debug_info_);
  cert_chain_.Swap(&other->cert_chain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  trial_der_verification_time_.Swap(&other->trial_der_verification_time_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  stapled_ocsp_.Swap(&other->stapled_ocsp_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sct_list_.Swap(&other->sct_list_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(mac_platform_debug_info_, other->mac_platform_debug_info_);
  swap(trial_verification_time_usec_, other->trial_verification_time_usec_);
  swap(is_issued_by_known_root_, other->is_issued_by_known_root_);
}

std::string TrialVerificationInfo::GetTypeName() const {
  return "chrome_browser_ssl.TrialVerificationInfo";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace chrome_browser_ssl
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerInterstitialInfo* Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerInterstitialInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chrome_browser_ssl::CertLoggerInterstitialInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo* Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerFeaturesInfo* Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerFeaturesInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chrome_browser_ssl::CertLoggerFeaturesInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerRequest* Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerRequest >(Arena* arena) {
  return Arena::CreateInternal< ::chrome_browser_ssl::CertLoggerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::MacCertEvidenceInfo* Arena::CreateMaybeMessage< ::chrome_browser_ssl::MacCertEvidenceInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chrome_browser_ssl::MacCertEvidenceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::MacPlatformDebugInfo* Arena::CreateMaybeMessage< ::chrome_browser_ssl::MacPlatformDebugInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chrome_browser_ssl::MacPlatformDebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::TrialVerificationInfo* Arena::CreateMaybeMessage< ::chrome_browser_ssl::TrialVerificationInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chrome_browser_ssl::TrialVerificationInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
