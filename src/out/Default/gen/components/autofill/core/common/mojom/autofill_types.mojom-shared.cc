// components/autofill/core/common/mojom/autofill_types.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "components/autofill/core/common/mojom/autofill_types.mojom-shared.h"

#include <utility>

#include "base/logging.h"
#include "base/stl_util.h"  // for base::size()
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"

#include "components/autofill/core/common/mojom/autofill_types.mojom-params-data.h"
namespace autofill {
namespace mojom {

std::ostream& operator<<(std::ostream& os, SubmissionIndicatorEvent value) {
  switch(value) {
    case SubmissionIndicatorEvent::NONE:
      return os << "SubmissionIndicatorEvent::NONE";
    case SubmissionIndicatorEvent::HTML_FORM_SUBMISSION:
      return os << "SubmissionIndicatorEvent::HTML_FORM_SUBMISSION";
    case SubmissionIndicatorEvent::SAME_DOCUMENT_NAVIGATION:
      return os << "SubmissionIndicatorEvent::SAME_DOCUMENT_NAVIGATION";
    case SubmissionIndicatorEvent::XHR_SUCCEEDED:
      return os << "SubmissionIndicatorEvent::XHR_SUCCEEDED";
    case SubmissionIndicatorEvent::FRAME_DETACHED:
      return os << "SubmissionIndicatorEvent::FRAME_DETACHED";
    case SubmissionIndicatorEvent::DOM_MUTATION_AFTER_XHR:
      return os << "SubmissionIndicatorEvent::DOM_MUTATION_AFTER_XHR";
    case SubmissionIndicatorEvent::PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD:
      return os << "SubmissionIndicatorEvent::PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD";
    case SubmissionIndicatorEvent::PROBABLE_FORM_SUBMISSION:
      return os << "SubmissionIndicatorEvent::PROBABLE_FORM_SUBMISSION";
    default:
      return os << "Unknown SubmissionIndicatorEvent value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, PasswordFormFieldPredictionType value) {
  switch(value) {
    case PasswordFormFieldPredictionType::kUsername:
      return os << "PasswordFormFieldPredictionType::kUsername";
    case PasswordFormFieldPredictionType::kCurrentPassword:
      return os << "PasswordFormFieldPredictionType::kCurrentPassword";
    case PasswordFormFieldPredictionType::kNewPassword:
      return os << "PasswordFormFieldPredictionType::kNewPassword";
    case PasswordFormFieldPredictionType::kNotPassword:
      return os << "PasswordFormFieldPredictionType::kNotPassword";
    default:
      return os << "Unknown PasswordFormFieldPredictionType value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, SubmissionSource value) {
  switch(value) {
    case SubmissionSource::NONE:
      return os << "SubmissionSource::NONE";
    case SubmissionSource::SAME_DOCUMENT_NAVIGATION:
      return os << "SubmissionSource::SAME_DOCUMENT_NAVIGATION";
    case SubmissionSource::XHR_SUCCEEDED:
      return os << "SubmissionSource::XHR_SUCCEEDED";
    case SubmissionSource::FRAME_DETACHED:
      return os << "SubmissionSource::FRAME_DETACHED";
    case SubmissionSource::DOM_MUTATION_AFTER_XHR:
      return os << "SubmissionSource::DOM_MUTATION_AFTER_XHR";
    case SubmissionSource::PROBABLY_FORM_SUBMITTED:
      return os << "SubmissionSource::PROBABLY_FORM_SUBMITTED";
    case SubmissionSource::FORM_SUBMISSION:
      return os << "SubmissionSource::FORM_SUBMISSION";
    default:
      return os << "Unknown SubmissionSource value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, FocusedFieldType value) {
  switch(value) {
    case FocusedFieldType::kUnknown:
      return os << "FocusedFieldType::kUnknown";
    case FocusedFieldType::kUnfillableElement:
      return os << "FocusedFieldType::kUnfillableElement";
    case FocusedFieldType::kFillableTextArea:
      return os << "FocusedFieldType::kFillableTextArea";
    case FocusedFieldType::kFillableSearchField:
      return os << "FocusedFieldType::kFillableSearchField";
    case FocusedFieldType::kFillableNonSearchField:
      return os << "FocusedFieldType::kFillableNonSearchField";
    case FocusedFieldType::kFillableUsernameField:
      return os << "FocusedFieldType::kFillableUsernameField";
    case FocusedFieldType::kFillablePasswordField:
      return os << "FocusedFieldType::kFillablePasswordField";
    default:
      return os << "Unknown FocusedFieldType value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, ButtonTitleType value) {
  switch(value) {
    case ButtonTitleType::NONE:
      return os << "ButtonTitleType::NONE";
    case ButtonTitleType::BUTTON_ELEMENT_SUBMIT_TYPE:
      return os << "ButtonTitleType::BUTTON_ELEMENT_SUBMIT_TYPE";
    case ButtonTitleType::BUTTON_ELEMENT_BUTTON_TYPE:
      return os << "ButtonTitleType::BUTTON_ELEMENT_BUTTON_TYPE";
    case ButtonTitleType::INPUT_ELEMENT_SUBMIT_TYPE:
      return os << "ButtonTitleType::INPUT_ELEMENT_SUBMIT_TYPE";
    case ButtonTitleType::INPUT_ELEMENT_BUTTON_TYPE:
      return os << "ButtonTitleType::INPUT_ELEMENT_BUTTON_TYPE";
    case ButtonTitleType::HYPERLINK:
      return os << "ButtonTitleType::HYPERLINK";
    case ButtonTitleType::DIV:
      return os << "ButtonTitleType::DIV";
    case ButtonTitleType::SPAN:
      return os << "ButtonTitleType::SPAN";
    default:
      return os << "Unknown ButtonTitleType value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, AutofillState value) {
  switch(value) {
    case AutofillState::kNoSuggestions:
      return os << "AutofillState::kNoSuggestions";
    case AutofillState::kAutofillAvailable:
      return os << "AutofillState::kAutofillAvailable";
    case AutofillState::kAutocompleteAvailable:
      return os << "AutofillState::kAutocompleteAvailable";
    default:
      return os << "Unknown AutofillState value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, FormFieldData_CheckStatus value) {
  switch(value) {
    case FormFieldData_CheckStatus::kNotCheckable:
      return os << "FormFieldData_CheckStatus::kNotCheckable";
    case FormFieldData_CheckStatus::kCheckableButUnchecked:
      return os << "FormFieldData_CheckStatus::kCheckableButUnchecked";
    case FormFieldData_CheckStatus::kChecked:
      return os << "FormFieldData_CheckStatus::kChecked";
    default:
      return os << "Unknown FormFieldData_CheckStatus value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, FormFieldData_RoleAttribute value) {
  switch(value) {
    case FormFieldData_RoleAttribute::kPresentation:
      return os << "FormFieldData_RoleAttribute::kPresentation";
    case FormFieldData_RoleAttribute::kOther:
      return os << "FormFieldData_RoleAttribute::kOther";
    default:
      return os << "Unknown FormFieldData_RoleAttribute value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, FormFieldData_LabelSource value) {
  switch(value) {
    case FormFieldData_LabelSource::kUnknown:
      return os << "FormFieldData_LabelSource::kUnknown";
    case FormFieldData_LabelSource::kLabelTag:
      return os << "FormFieldData_LabelSource::kLabelTag";
    case FormFieldData_LabelSource::kPTag:
      return os << "FormFieldData_LabelSource::kPTag";
    case FormFieldData_LabelSource::kDivTable:
      return os << "FormFieldData_LabelSource::kDivTable";
    case FormFieldData_LabelSource::kTdTag:
      return os << "FormFieldData_LabelSource::kTdTag";
    case FormFieldData_LabelSource::kDdTag:
      return os << "FormFieldData_LabelSource::kDdTag";
    case FormFieldData_LabelSource::kLiTag:
      return os << "FormFieldData_LabelSource::kLiTag";
    case FormFieldData_LabelSource::kPlaceHolder:
      return os << "FormFieldData_LabelSource::kPlaceHolder";
    case FormFieldData_LabelSource::kAriaLabel:
      return os << "FormFieldData_LabelSource::kAriaLabel";
    case FormFieldData_LabelSource::kCombined:
      return os << "FormFieldData_LabelSource::kCombined";
    case FormFieldData_LabelSource::kValue:
      return os << "FormFieldData_LabelSource::kValue";
    default:
      return os << "Unknown FormFieldData_LabelSource value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, PasswordForm_Scheme value) {
  switch(value) {
    case PasswordForm_Scheme::kHtml:
      return os << "PasswordForm_Scheme::kHtml";
    case PasswordForm_Scheme::kBasic:
      return os << "PasswordForm_Scheme::kBasic";
    case PasswordForm_Scheme::kDigest:
      return os << "PasswordForm_Scheme::kDigest";
    case PasswordForm_Scheme::kOther:
      return os << "PasswordForm_Scheme::kOther";
    case PasswordForm_Scheme::kUsernameOnly:
      return os << "PasswordForm_Scheme::kUsernameOnly";
    default:
      return os << "Unknown PasswordForm_Scheme value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, PasswordForm_Type value) {
  switch(value) {
    case PasswordForm_Type::kManual:
      return os << "PasswordForm_Type::kManual";
    case PasswordForm_Type::kGenerated:
      return os << "PasswordForm_Type::kGenerated";
    case PasswordForm_Type::kApi:
      return os << "PasswordForm_Type::kApi";
    default:
      return os << "Unknown PasswordForm_Type value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, PasswordForm_GenerationUploadStatus value) {
  switch(value) {
    case PasswordForm_GenerationUploadStatus::kNoSignalSent:
      return os << "PasswordForm_GenerationUploadStatus::kNoSignalSent";
    case PasswordForm_GenerationUploadStatus::kPositiveSignalSent:
      return os << "PasswordForm_GenerationUploadStatus::kPositiveSignalSent";
    case PasswordForm_GenerationUploadStatus::kNegativeSignalSent:
      return os << "PasswordForm_GenerationUploadStatus::kNegativeSignalSent";
    case PasswordForm_GenerationUploadStatus::kUnknownStatus:
      return os << "PasswordForm_GenerationUploadStatus::kUnknownStatus";
    default:
      return os << "Unknown PasswordForm_GenerationUploadStatus value: " << static_cast<int32_t>(value);
  }
}

namespace internal {


// static
bool FormRendererId_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FormRendererId_Data* object = static_cast<const FormRendererId_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

FormRendererId_Data::FormRendererId_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool FieldRendererId_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FieldRendererId_Data* object = static_cast<const FieldRendererId_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

FieldRendererId_Data::FieldRendererId_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool FormFieldData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FormFieldData_Data* object = static_cast<const FormFieldData_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 200 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->label, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->label, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->name, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->id_attribute, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->id_attribute, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name_attribute, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->name_attribute, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->value, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->value, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->form_control_type, 6, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams form_control_type_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->form_control_type, validation_context,
                                         &form_control_type_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->autocomplete_attribute, 7, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams autocomplete_attribute_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->autocomplete_attribute, validation_context,
                                         &autocomplete_attribute_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->placeholder, 8, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->placeholder, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->css_classes, 9, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->css_classes, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->aria_label, 10, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->aria_label, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->aria_description, 11, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->aria_description, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->unique_renderer_id, 12, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->unique_renderer_id, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->section, 17, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams section_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->section, validation_context,
                                         &section_validate_params)) {
    return false;
  }


  if (!::autofill::mojom::internal::FormFieldData_CheckStatus_Data
        ::Validate(object->check_status, validation_context))
    return false;


  if (!::autofill::mojom::internal::FormFieldData_RoleAttribute_Data
        ::Validate(object->role, validation_context))
    return false;


  if (!::mojo_base::mojom::internal::TextDirection_Data
        ::Validate(object->text_direction, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->typed_value, 25, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->typed_value, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->option_values, 26, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams option_values_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->option_values, validation_context,
                                         &option_values_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->option_contents, 27, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams option_contents_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->option_contents, validation_context,
                                         &option_contents_validate_params)) {
    return false;
  }


  if (!::autofill::mojom::internal::FormFieldData_LabelSource_Data
        ::Validate(object->label_source, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->bounds, 29, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->bounds, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->datalist_values, 30, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams datalist_values_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->datalist_values, validation_context,
                                         &datalist_values_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->datalist_labels, 31, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams datalist_labels_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->datalist_labels, validation_context,
                                         &datalist_labels_validate_params)) {
    return false;
  }

  return true;
}

FormFieldData_Data::FormFieldData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool ButtonTitleInfo_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ButtonTitleInfo_Data* object = static_cast<const ButtonTitleInfo_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->title, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->title, validation_context))
    return false;


  if (!::autofill::mojom::internal::ButtonTitleType_Data
        ::Validate(object->type, validation_context))
    return false;

  return true;
}

ButtonTitleInfo_Data::ButtonTitleInfo_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool FormData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FormData_Data* object = static_cast<const FormData_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 104 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->id_attribute, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->id_attribute, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name_attribute, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->name_attribute, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->name, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->button_titles, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams button_titles_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->button_titles, validation_context,
                                         &button_titles_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->url, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->url, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->full_url, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->full_url, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->action, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->action, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->main_frame_origin, 9, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->main_frame_origin, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->unique_renderer_id, 12, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->unique_renderer_id, validation_context))
    return false;


  if (!::autofill::mojom::internal::SubmissionIndicatorEvent_Data
        ::Validate(object->submission_event, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->fields, 14, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams fields_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->fields, validation_context,
                                         &fields_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->username_predictions, 15, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams username_predictions_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->username_predictions, validation_context,
                                         &username_predictions_validate_params)) {
    return false;
  }

  return true;
}

FormData_Data::FormData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool FormFieldDataPredictions_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FormFieldDataPredictions_Data* object = static_cast<const FormFieldDataPredictions_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->field, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->field, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->signature, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams signature_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->signature, validation_context,
                                         &signature_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->heuristic_type, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams heuristic_type_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->heuristic_type, validation_context,
                                         &heuristic_type_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->server_type, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams server_type_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->server_type, validation_context,
                                         &server_type_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->overall_type, 5, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams overall_type_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->overall_type, validation_context,
                                         &overall_type_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->parseable_name, 6, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams parseable_name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->parseable_name, validation_context,
                                         &parseable_name_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->section, 7, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams section_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->section, validation_context,
                                         &section_validate_params)) {
    return false;
  }

  return true;
}

FormFieldDataPredictions_Data::FormFieldDataPredictions_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool FormDataPredictions_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FormDataPredictions_Data* object = static_cast<const FormDataPredictions_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->data, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->data, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->signature, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams signature_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->signature, validation_context,
                                         &signature_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->fields, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams fields_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->fields, validation_context,
                                         &fields_validate_params)) {
    return false;
  }

  return true;
}

FormDataPredictions_Data::FormDataPredictions_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PasswordAndMetadata_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PasswordAndMetadata_Data* object = static_cast<const PasswordAndMetadata_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->username, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->username, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->password, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->password, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->realm, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams realm_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->realm, validation_context,
                                         &realm_validate_params)) {
    return false;
  }

  return true;
}

PasswordAndMetadata_Data::PasswordAndMetadata_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PasswordFormFillData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PasswordFormFillData_Data* object = static_cast<const PasswordFormFillData_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 72 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->form_renderer_id, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->form_renderer_id, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->url, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->url, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->action, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->action, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->username_field, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->username_field, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->password_field, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->password_field, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->preferred_realm, 7, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams preferred_realm_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->preferred_realm, validation_context,
                                         &preferred_realm_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->additional_logins, 9, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams additional_logins_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->additional_logins, validation_context,
                                         &additional_logins_validate_params)) {
    return false;
  }

  return true;
}

PasswordFormFillData_Data::PasswordFormFillData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PasswordFormGenerationData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PasswordFormGenerationData_Data* object = static_cast<const PasswordFormGenerationData_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->new_password_renderer_id, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->new_password_renderer_id, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->confirmation_password_renderer_id, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->confirmation_password_renderer_id, validation_context))
    return false;

  return true;
}

PasswordFormGenerationData_Data::PasswordFormGenerationData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PasswordGenerationUIData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PasswordGenerationUIData_Data* object = static_cast<const PasswordGenerationUIData_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->bounds, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->bounds, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->generation_element, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->generation_element, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->generation_element_id, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->generation_element_id, validation_context))
    return false;


  if (!::mojo_base::mojom::internal::TextDirection_Data
        ::Validate(object->text_direction, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->form_data, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->form_data, validation_context))
    return false;

  return true;
}

PasswordGenerationUIData_Data::PasswordGenerationUIData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool ValueElementPair_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ValueElementPair_Data* object = static_cast<const ValueElementPair_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->value, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->value, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->field_name, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->field_name, validation_context))
    return false;

  return true;
}

ValueElementPair_Data::ValueElementPair_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PasswordForm_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PasswordForm_Data* object = static_cast<const PasswordForm_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 192 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }


  if (!::autofill::mojom::internal::PasswordForm_Scheme_Data
        ::Validate(object->scheme, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->signon_realm, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams signon_realm_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->signon_realm, validation_context,
                                         &signon_realm_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->url, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->url, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->action, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->action, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->affiliated_web_realm, 5, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams affiliated_web_realm_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->affiliated_web_realm, validation_context,
                                         &affiliated_web_realm_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->submit_element, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->submit_element, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->username_element, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->username_element, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->username_value, 9, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->username_value, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->all_possible_usernames, 10, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams all_possible_usernames_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->all_possible_usernames, validation_context,
                                         &all_possible_usernames_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->all_possible_passwords, 11, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams all_possible_passwords_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->all_possible_passwords, validation_context,
                                         &all_possible_passwords_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->password_element, 13, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->password_element, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->password_value, 14, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->password_value, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->new_password_element, 15, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->new_password_element, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->new_password_value, 16, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->new_password_value, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->confirmation_password_element, 18, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->confirmation_password_element, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->date_created, 19, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->date_created, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->date_synced, 20, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->date_synced, validation_context))
    return false;


  if (!::autofill::mojom::internal::PasswordForm_Type_Data
        ::Validate(object->type, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->form_data, 24, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->form_data, validation_context))
    return false;


  if (!::autofill::mojom::internal::PasswordForm_GenerationUploadStatus_Data
        ::Validate(object->generation_upload_status, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->display_name, 26, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->display_name, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->icon_url, 27, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->icon_url, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->federation_origin, 28, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->federation_origin, validation_context))
    return false;


  if (!::autofill::mojom::internal::SubmissionIndicatorEvent_Data
        ::Validate(object->submission_event, validation_context))
    return false;

  return true;
}

PasswordForm_Data::PasswordForm_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool ParsingResult_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ParsingResult_Data* object = static_cast<const ParsingResult_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->username_renderer_id, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->username_renderer_id, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->password_renderer_id, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->password_renderer_id, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->new_password_renderer_id, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->new_password_renderer_id, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->confirm_password_renderer_id, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->confirm_password_renderer_id, validation_context))
    return false;

  return true;
}

ParsingResult_Data::ParsingResult_Data()
    : header_({sizeof(*this), 0}) {}

}  // namespace internal
}  // namespace mojom
}  // namespace autofill