// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: extension_install.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_extension_5finstall_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_extension_5finstall_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_extension_5finstall_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_extension_5finstall_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace metrics {
class ExtensionInstallProto;
class ExtensionInstallProtoDefaultTypeInternal;
extern ExtensionInstallProtoDefaultTypeInternal _ExtensionInstallProto_default_instance_;
}  // namespace metrics
PROTOBUF_NAMESPACE_OPEN
template<> ::metrics::ExtensionInstallProto* Arena::CreateMaybeMessage<::metrics::ExtensionInstallProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace metrics {

enum ExtensionInstallProto_Type : int {
  ExtensionInstallProto_Type_UNKNOWN_TYPE = 0,
  ExtensionInstallProto_Type_EXTENSION = 1,
  ExtensionInstallProto_Type_THEME = 2,
  ExtensionInstallProto_Type_USER_SCRIPT = 3,
  ExtensionInstallProto_Type_HOSTED_APP = 4,
  ExtensionInstallProto_Type_LEGACY_PACKAGED_APP = 5,
  ExtensionInstallProto_Type_PLATFORM_APP = 6,
  ExtensionInstallProto_Type_SHARED_MODULE = 7,
  ExtensionInstallProto_Type_LOGIN_SCREEN_EXTENSION = 8
};
bool ExtensionInstallProto_Type_IsValid(int value);
constexpr ExtensionInstallProto_Type ExtensionInstallProto_Type_Type_MIN = ExtensionInstallProto_Type_UNKNOWN_TYPE;
constexpr ExtensionInstallProto_Type ExtensionInstallProto_Type_Type_MAX = ExtensionInstallProto_Type_LOGIN_SCREEN_EXTENSION;
constexpr int ExtensionInstallProto_Type_Type_ARRAYSIZE = ExtensionInstallProto_Type_Type_MAX + 1;

const std::string& ExtensionInstallProto_Type_Name(ExtensionInstallProto_Type value);
template<typename T>
inline const std::string& ExtensionInstallProto_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallProto_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallProto_Type_Name.");
  return ExtensionInstallProto_Type_Name(static_cast<ExtensionInstallProto_Type>(enum_t_value));
}
bool ExtensionInstallProto_Type_Parse(
    const std::string& name, ExtensionInstallProto_Type* value);
enum ExtensionInstallProto_InstallLocation : int {
  ExtensionInstallProto_InstallLocation_UNKNOWN_LOCATION = 0,
  ExtensionInstallProto_InstallLocation_INTERNAL = 1,
  ExtensionInstallProto_InstallLocation_EXTERNAL_PREF = 2,
  ExtensionInstallProto_InstallLocation_EXTERNAL_REGISTRY = 3,
  ExtensionInstallProto_InstallLocation_UNPACKED = 4,
  ExtensionInstallProto_InstallLocation_COMPONENT = 5,
  ExtensionInstallProto_InstallLocation_EXTERNAL_PREF_DOWNLOAD = 6,
  ExtensionInstallProto_InstallLocation_EXTERNAL_POLICY_DOWNLOAD = 7,
  ExtensionInstallProto_InstallLocation_COMMAND_LINE = 8,
  ExtensionInstallProto_InstallLocation_EXTERNAL_POLICY = 9,
  ExtensionInstallProto_InstallLocation_EXTERNAL_COMPONENT = 10
};
bool ExtensionInstallProto_InstallLocation_IsValid(int value);
constexpr ExtensionInstallProto_InstallLocation ExtensionInstallProto_InstallLocation_InstallLocation_MIN = ExtensionInstallProto_InstallLocation_UNKNOWN_LOCATION;
constexpr ExtensionInstallProto_InstallLocation ExtensionInstallProto_InstallLocation_InstallLocation_MAX = ExtensionInstallProto_InstallLocation_EXTERNAL_COMPONENT;
constexpr int ExtensionInstallProto_InstallLocation_InstallLocation_ARRAYSIZE = ExtensionInstallProto_InstallLocation_InstallLocation_MAX + 1;

const std::string& ExtensionInstallProto_InstallLocation_Name(ExtensionInstallProto_InstallLocation value);
template<typename T>
inline const std::string& ExtensionInstallProto_InstallLocation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallProto_InstallLocation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallProto_InstallLocation_Name.");
  return ExtensionInstallProto_InstallLocation_Name(static_cast<ExtensionInstallProto_InstallLocation>(enum_t_value));
}
bool ExtensionInstallProto_InstallLocation_Parse(
    const std::string& name, ExtensionInstallProto_InstallLocation* value);
enum ExtensionInstallProto_ActionType : int {
  ExtensionInstallProto_ActionType_NO_ACTION = 0,
  ExtensionInstallProto_ActionType_BROWSER_ACTION = 1,
  ExtensionInstallProto_ActionType_PAGE_ACTION = 2,
  ExtensionInstallProto_ActionType_SYSTEM_INDICATOR = 3
};
bool ExtensionInstallProto_ActionType_IsValid(int value);
constexpr ExtensionInstallProto_ActionType ExtensionInstallProto_ActionType_ActionType_MIN = ExtensionInstallProto_ActionType_NO_ACTION;
constexpr ExtensionInstallProto_ActionType ExtensionInstallProto_ActionType_ActionType_MAX = ExtensionInstallProto_ActionType_SYSTEM_INDICATOR;
constexpr int ExtensionInstallProto_ActionType_ActionType_ARRAYSIZE = ExtensionInstallProto_ActionType_ActionType_MAX + 1;

const std::string& ExtensionInstallProto_ActionType_Name(ExtensionInstallProto_ActionType value);
template<typename T>
inline const std::string& ExtensionInstallProto_ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallProto_ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallProto_ActionType_Name.");
  return ExtensionInstallProto_ActionType_Name(static_cast<ExtensionInstallProto_ActionType>(enum_t_value));
}
bool ExtensionInstallProto_ActionType_Parse(
    const std::string& name, ExtensionInstallProto_ActionType* value);
enum ExtensionInstallProto_BackgroundScriptType : int {
  ExtensionInstallProto_BackgroundScriptType_NO_BACKGROUND_SCRIPT = 0,
  ExtensionInstallProto_BackgroundScriptType_PERSISTENT_BACKGROUND_PAGE = 1,
  ExtensionInstallProto_BackgroundScriptType_EVENT_PAGE = 2,
  ExtensionInstallProto_BackgroundScriptType_SERVICE_WORKER = 3
};
bool ExtensionInstallProto_BackgroundScriptType_IsValid(int value);
constexpr ExtensionInstallProto_BackgroundScriptType ExtensionInstallProto_BackgroundScriptType_BackgroundScriptType_MIN = ExtensionInstallProto_BackgroundScriptType_NO_BACKGROUND_SCRIPT;
constexpr ExtensionInstallProto_BackgroundScriptType ExtensionInstallProto_BackgroundScriptType_BackgroundScriptType_MAX = ExtensionInstallProto_BackgroundScriptType_SERVICE_WORKER;
constexpr int ExtensionInstallProto_BackgroundScriptType_BackgroundScriptType_ARRAYSIZE = ExtensionInstallProto_BackgroundScriptType_BackgroundScriptType_MAX + 1;

const std::string& ExtensionInstallProto_BackgroundScriptType_Name(ExtensionInstallProto_BackgroundScriptType value);
template<typename T>
inline const std::string& ExtensionInstallProto_BackgroundScriptType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallProto_BackgroundScriptType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallProto_BackgroundScriptType_Name.");
  return ExtensionInstallProto_BackgroundScriptType_Name(static_cast<ExtensionInstallProto_BackgroundScriptType>(enum_t_value));
}
bool ExtensionInstallProto_BackgroundScriptType_Parse(
    const std::string& name, ExtensionInstallProto_BackgroundScriptType* value);
enum ExtensionInstallProto_DisableReason : int {
  ExtensionInstallProto_DisableReason_USER_ACTION = 0,
  ExtensionInstallProto_DisableReason_PERMISSIONS_INCREASE = 1,
  ExtensionInstallProto_DisableReason_RELOAD = 2,
  ExtensionInstallProto_DisableReason_UNSUPPORTED_REQUIREMENT = 3,
  ExtensionInstallProto_DisableReason_SIDELOAD_WIPEOUT = 4,
  ExtensionInstallProto_DisableReason_UNKNOWN_FROM_SYNC = 5,
  ExtensionInstallProto_DisableReason_NOT_VERIFIED = 6,
  ExtensionInstallProto_DisableReason_GREYLIST = 7,
  ExtensionInstallProto_DisableReason_CORRUPTED = 8,
  ExtensionInstallProto_DisableReason_REMOTE_INSTALL = 9,
  ExtensionInstallProto_DisableReason_EXTERNAL_EXTENSION = 10,
  ExtensionInstallProto_DisableReason_UPDATE_REQUIRED_BY_POLICY = 11,
  ExtensionInstallProto_DisableReason_CUSTODIAN_APPROVAL_REQUIRED = 12,
  ExtensionInstallProto_DisableReason_BLOCKED_BY_POLICY = 13,
  ExtensionInstallProto_DisableReason_DEPRECATED_BLOCKED_MATURE = 14,
  ExtensionInstallProto_DisableReason_DISABLE_REMOTELY_FOR_MALWARE = 15
};
bool ExtensionInstallProto_DisableReason_IsValid(int value);
constexpr ExtensionInstallProto_DisableReason ExtensionInstallProto_DisableReason_DisableReason_MIN = ExtensionInstallProto_DisableReason_USER_ACTION;
constexpr ExtensionInstallProto_DisableReason ExtensionInstallProto_DisableReason_DisableReason_MAX = ExtensionInstallProto_DisableReason_DISABLE_REMOTELY_FOR_MALWARE;
constexpr int ExtensionInstallProto_DisableReason_DisableReason_ARRAYSIZE = ExtensionInstallProto_DisableReason_DisableReason_MAX + 1;

const std::string& ExtensionInstallProto_DisableReason_Name(ExtensionInstallProto_DisableReason value);
template<typename T>
inline const std::string& ExtensionInstallProto_DisableReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallProto_DisableReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallProto_DisableReason_Name.");
  return ExtensionInstallProto_DisableReason_Name(static_cast<ExtensionInstallProto_DisableReason>(enum_t_value));
}
bool ExtensionInstallProto_DisableReason_Parse(
    const std::string& name, ExtensionInstallProto_DisableReason* value);
enum ExtensionInstallProto_BlacklistState : int {
  ExtensionInstallProto_BlacklistState_NOT_BLACKLISTED = 0,
  ExtensionInstallProto_BlacklistState_BLACKLISTED_MALWARE = 1,
  ExtensionInstallProto_BlacklistState_BLACKLISTED_SECURITY_VULNERABILITY = 2,
  ExtensionInstallProto_BlacklistState_BLACKLISTED_CWS_POLICY_VIOLATION = 3,
  ExtensionInstallProto_BlacklistState_BLACKLISTED_POTENTIALLY_UNWANTED = 4,
  ExtensionInstallProto_BlacklistState_BLACKLISTED_UNKNOWN = 5
};
bool ExtensionInstallProto_BlacklistState_IsValid(int value);
constexpr ExtensionInstallProto_BlacklistState ExtensionInstallProto_BlacklistState_BlacklistState_MIN = ExtensionInstallProto_BlacklistState_NOT_BLACKLISTED;
constexpr ExtensionInstallProto_BlacklistState ExtensionInstallProto_BlacklistState_BlacklistState_MAX = ExtensionInstallProto_BlacklistState_BLACKLISTED_UNKNOWN;
constexpr int ExtensionInstallProto_BlacklistState_BlacklistState_ARRAYSIZE = ExtensionInstallProto_BlacklistState_BlacklistState_MAX + 1;

const std::string& ExtensionInstallProto_BlacklistState_Name(ExtensionInstallProto_BlacklistState value);
template<typename T>
inline const std::string& ExtensionInstallProto_BlacklistState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallProto_BlacklistState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallProto_BlacklistState_Name.");
  return ExtensionInstallProto_BlacklistState_Name(static_cast<ExtensionInstallProto_BlacklistState>(enum_t_value));
}
bool ExtensionInstallProto_BlacklistState_Parse(
    const std::string& name, ExtensionInstallProto_BlacklistState* value);
// ===================================================================

class ExtensionInstallProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.ExtensionInstallProto) */ {
 public:
  ExtensionInstallProto();
  virtual ~ExtensionInstallProto();

  ExtensionInstallProto(const ExtensionInstallProto& from);
  ExtensionInstallProto(ExtensionInstallProto&& from) noexcept
    : ExtensionInstallProto() {
    *this = ::std::move(from);
  }

  inline ExtensionInstallProto& operator=(const ExtensionInstallProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionInstallProto& operator=(ExtensionInstallProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ExtensionInstallProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtensionInstallProto* internal_default_instance() {
    return reinterpret_cast<const ExtensionInstallProto*>(
               &_ExtensionInstallProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExtensionInstallProto& a, ExtensionInstallProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtensionInstallProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExtensionInstallProto* New() const final {
    return CreateMaybeMessage<ExtensionInstallProto>(nullptr);
  }

  ExtensionInstallProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtensionInstallProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ExtensionInstallProto& from);
  void MergeFrom(const ExtensionInstallProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionInstallProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.ExtensionInstallProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExtensionInstallProto_Type Type;
  static constexpr Type UNKNOWN_TYPE =
    ExtensionInstallProto_Type_UNKNOWN_TYPE;
  static constexpr Type EXTENSION =
    ExtensionInstallProto_Type_EXTENSION;
  static constexpr Type THEME =
    ExtensionInstallProto_Type_THEME;
  static constexpr Type USER_SCRIPT =
    ExtensionInstallProto_Type_USER_SCRIPT;
  static constexpr Type HOSTED_APP =
    ExtensionInstallProto_Type_HOSTED_APP;
  static constexpr Type LEGACY_PACKAGED_APP =
    ExtensionInstallProto_Type_LEGACY_PACKAGED_APP;
  static constexpr Type PLATFORM_APP =
    ExtensionInstallProto_Type_PLATFORM_APP;
  static constexpr Type SHARED_MODULE =
    ExtensionInstallProto_Type_SHARED_MODULE;
  static constexpr Type LOGIN_SCREEN_EXTENSION =
    ExtensionInstallProto_Type_LOGIN_SCREEN_EXTENSION;
  static inline bool Type_IsValid(int value) {
    return ExtensionInstallProto_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ExtensionInstallProto_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ExtensionInstallProto_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ExtensionInstallProto_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ExtensionInstallProto_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return ExtensionInstallProto_Type_Parse(name, value);
  }

  typedef ExtensionInstallProto_InstallLocation InstallLocation;
  static constexpr InstallLocation UNKNOWN_LOCATION =
    ExtensionInstallProto_InstallLocation_UNKNOWN_LOCATION;
  static constexpr InstallLocation INTERNAL =
    ExtensionInstallProto_InstallLocation_INTERNAL;
  static constexpr InstallLocation EXTERNAL_PREF =
    ExtensionInstallProto_InstallLocation_EXTERNAL_PREF;
  static constexpr InstallLocation EXTERNAL_REGISTRY =
    ExtensionInstallProto_InstallLocation_EXTERNAL_REGISTRY;
  static constexpr InstallLocation UNPACKED =
    ExtensionInstallProto_InstallLocation_UNPACKED;
  static constexpr InstallLocation COMPONENT =
    ExtensionInstallProto_InstallLocation_COMPONENT;
  static constexpr InstallLocation EXTERNAL_PREF_DOWNLOAD =
    ExtensionInstallProto_InstallLocation_EXTERNAL_PREF_DOWNLOAD;
  static constexpr InstallLocation EXTERNAL_POLICY_DOWNLOAD =
    ExtensionInstallProto_InstallLocation_EXTERNAL_POLICY_DOWNLOAD;
  static constexpr InstallLocation COMMAND_LINE =
    ExtensionInstallProto_InstallLocation_COMMAND_LINE;
  static constexpr InstallLocation EXTERNAL_POLICY =
    ExtensionInstallProto_InstallLocation_EXTERNAL_POLICY;
  static constexpr InstallLocation EXTERNAL_COMPONENT =
    ExtensionInstallProto_InstallLocation_EXTERNAL_COMPONENT;
  static inline bool InstallLocation_IsValid(int value) {
    return ExtensionInstallProto_InstallLocation_IsValid(value);
  }
  static constexpr InstallLocation InstallLocation_MIN =
    ExtensionInstallProto_InstallLocation_InstallLocation_MIN;
  static constexpr InstallLocation InstallLocation_MAX =
    ExtensionInstallProto_InstallLocation_InstallLocation_MAX;
  static constexpr int InstallLocation_ARRAYSIZE =
    ExtensionInstallProto_InstallLocation_InstallLocation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InstallLocation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstallLocation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstallLocation_Name.");
    return ExtensionInstallProto_InstallLocation_Name(enum_t_value);
  }
  static inline bool InstallLocation_Parse(const std::string& name,
      InstallLocation* value) {
    return ExtensionInstallProto_InstallLocation_Parse(name, value);
  }

  typedef ExtensionInstallProto_ActionType ActionType;
  static constexpr ActionType NO_ACTION =
    ExtensionInstallProto_ActionType_NO_ACTION;
  static constexpr ActionType BROWSER_ACTION =
    ExtensionInstallProto_ActionType_BROWSER_ACTION;
  static constexpr ActionType PAGE_ACTION =
    ExtensionInstallProto_ActionType_PAGE_ACTION;
  static constexpr ActionType SYSTEM_INDICATOR =
    ExtensionInstallProto_ActionType_SYSTEM_INDICATOR;
  static inline bool ActionType_IsValid(int value) {
    return ExtensionInstallProto_ActionType_IsValid(value);
  }
  static constexpr ActionType ActionType_MIN =
    ExtensionInstallProto_ActionType_ActionType_MIN;
  static constexpr ActionType ActionType_MAX =
    ExtensionInstallProto_ActionType_ActionType_MAX;
  static constexpr int ActionType_ARRAYSIZE =
    ExtensionInstallProto_ActionType_ActionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ActionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActionType_Name.");
    return ExtensionInstallProto_ActionType_Name(enum_t_value);
  }
  static inline bool ActionType_Parse(const std::string& name,
      ActionType* value) {
    return ExtensionInstallProto_ActionType_Parse(name, value);
  }

  typedef ExtensionInstallProto_BackgroundScriptType BackgroundScriptType;
  static constexpr BackgroundScriptType NO_BACKGROUND_SCRIPT =
    ExtensionInstallProto_BackgroundScriptType_NO_BACKGROUND_SCRIPT;
  static constexpr BackgroundScriptType PERSISTENT_BACKGROUND_PAGE =
    ExtensionInstallProto_BackgroundScriptType_PERSISTENT_BACKGROUND_PAGE;
  static constexpr BackgroundScriptType EVENT_PAGE =
    ExtensionInstallProto_BackgroundScriptType_EVENT_PAGE;
  static constexpr BackgroundScriptType SERVICE_WORKER =
    ExtensionInstallProto_BackgroundScriptType_SERVICE_WORKER;
  static inline bool BackgroundScriptType_IsValid(int value) {
    return ExtensionInstallProto_BackgroundScriptType_IsValid(value);
  }
  static constexpr BackgroundScriptType BackgroundScriptType_MIN =
    ExtensionInstallProto_BackgroundScriptType_BackgroundScriptType_MIN;
  static constexpr BackgroundScriptType BackgroundScriptType_MAX =
    ExtensionInstallProto_BackgroundScriptType_BackgroundScriptType_MAX;
  static constexpr int BackgroundScriptType_ARRAYSIZE =
    ExtensionInstallProto_BackgroundScriptType_BackgroundScriptType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BackgroundScriptType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BackgroundScriptType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BackgroundScriptType_Name.");
    return ExtensionInstallProto_BackgroundScriptType_Name(enum_t_value);
  }
  static inline bool BackgroundScriptType_Parse(const std::string& name,
      BackgroundScriptType* value) {
    return ExtensionInstallProto_BackgroundScriptType_Parse(name, value);
  }

  typedef ExtensionInstallProto_DisableReason DisableReason;
  static constexpr DisableReason USER_ACTION =
    ExtensionInstallProto_DisableReason_USER_ACTION;
  static constexpr DisableReason PERMISSIONS_INCREASE =
    ExtensionInstallProto_DisableReason_PERMISSIONS_INCREASE;
  static constexpr DisableReason RELOAD =
    ExtensionInstallProto_DisableReason_RELOAD;
  static constexpr DisableReason UNSUPPORTED_REQUIREMENT =
    ExtensionInstallProto_DisableReason_UNSUPPORTED_REQUIREMENT;
  static constexpr DisableReason SIDELOAD_WIPEOUT =
    ExtensionInstallProto_DisableReason_SIDELOAD_WIPEOUT;
  static constexpr DisableReason UNKNOWN_FROM_SYNC =
    ExtensionInstallProto_DisableReason_UNKNOWN_FROM_SYNC;
  static constexpr DisableReason NOT_VERIFIED =
    ExtensionInstallProto_DisableReason_NOT_VERIFIED;
  static constexpr DisableReason GREYLIST =
    ExtensionInstallProto_DisableReason_GREYLIST;
  static constexpr DisableReason CORRUPTED =
    ExtensionInstallProto_DisableReason_CORRUPTED;
  static constexpr DisableReason REMOTE_INSTALL =
    ExtensionInstallProto_DisableReason_REMOTE_INSTALL;
  static constexpr DisableReason EXTERNAL_EXTENSION =
    ExtensionInstallProto_DisableReason_EXTERNAL_EXTENSION;
  static constexpr DisableReason UPDATE_REQUIRED_BY_POLICY =
    ExtensionInstallProto_DisableReason_UPDATE_REQUIRED_BY_POLICY;
  static constexpr DisableReason CUSTODIAN_APPROVAL_REQUIRED =
    ExtensionInstallProto_DisableReason_CUSTODIAN_APPROVAL_REQUIRED;
  static constexpr DisableReason BLOCKED_BY_POLICY =
    ExtensionInstallProto_DisableReason_BLOCKED_BY_POLICY;
  static constexpr DisableReason DEPRECATED_BLOCKED_MATURE =
    ExtensionInstallProto_DisableReason_DEPRECATED_BLOCKED_MATURE;
  static constexpr DisableReason DISABLE_REMOTELY_FOR_MALWARE =
    ExtensionInstallProto_DisableReason_DISABLE_REMOTELY_FOR_MALWARE;
  static inline bool DisableReason_IsValid(int value) {
    return ExtensionInstallProto_DisableReason_IsValid(value);
  }
  static constexpr DisableReason DisableReason_MIN =
    ExtensionInstallProto_DisableReason_DisableReason_MIN;
  static constexpr DisableReason DisableReason_MAX =
    ExtensionInstallProto_DisableReason_DisableReason_MAX;
  static constexpr int DisableReason_ARRAYSIZE =
    ExtensionInstallProto_DisableReason_DisableReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DisableReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DisableReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DisableReason_Name.");
    return ExtensionInstallProto_DisableReason_Name(enum_t_value);
  }
  static inline bool DisableReason_Parse(const std::string& name,
      DisableReason* value) {
    return ExtensionInstallProto_DisableReason_Parse(name, value);
  }

  typedef ExtensionInstallProto_BlacklistState BlacklistState;
  static constexpr BlacklistState NOT_BLACKLISTED =
    ExtensionInstallProto_BlacklistState_NOT_BLACKLISTED;
  static constexpr BlacklistState BLACKLISTED_MALWARE =
    ExtensionInstallProto_BlacklistState_BLACKLISTED_MALWARE;
  static constexpr BlacklistState BLACKLISTED_SECURITY_VULNERABILITY =
    ExtensionInstallProto_BlacklistState_BLACKLISTED_SECURITY_VULNERABILITY;
  static constexpr BlacklistState BLACKLISTED_CWS_POLICY_VIOLATION =
    ExtensionInstallProto_BlacklistState_BLACKLISTED_CWS_POLICY_VIOLATION;
  static constexpr BlacklistState BLACKLISTED_POTENTIALLY_UNWANTED =
    ExtensionInstallProto_BlacklistState_BLACKLISTED_POTENTIALLY_UNWANTED;
  static constexpr BlacklistState BLACKLISTED_UNKNOWN =
    ExtensionInstallProto_BlacklistState_BLACKLISTED_UNKNOWN;
  static inline bool BlacklistState_IsValid(int value) {
    return ExtensionInstallProto_BlacklistState_IsValid(value);
  }
  static constexpr BlacklistState BlacklistState_MIN =
    ExtensionInstallProto_BlacklistState_BlacklistState_MIN;
  static constexpr BlacklistState BlacklistState_MAX =
    ExtensionInstallProto_BlacklistState_BlacklistState_MAX;
  static constexpr int BlacklistState_ARRAYSIZE =
    ExtensionInstallProto_BlacklistState_BlacklistState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BlacklistState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BlacklistState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BlacklistState_Name.");
    return ExtensionInstallProto_BlacklistState_Name(enum_t_value);
  }
  static inline bool BlacklistState_Parse(const std::string& name,
      BlacklistState* value) {
    return ExtensionInstallProto_BlacklistState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDisableReasonsFieldNumber = 14,
    kTypeFieldNumber = 1,
    kInstallLocationFieldNumber = 2,
    kManifestVersionFieldNumber = 3,
    kActionTypeFieldNumber = 4,
    kHasFileAccessFieldNumber = 5,
    kHasIncognitoAccessFieldNumber = 6,
    kIsFromStoreFieldNumber = 7,
    kUpdatesFromStoreFieldNumber = 8,
    kIsFromBookmarkFieldNumber = 9,
    kIsConvertedFromUserScriptFieldNumber = 10,
    kIsDefaultInstalledFieldNumber = 11,
    kIsOemInstalledFieldNumber = 12,
    kBackgroundScriptTypeFieldNumber = 13,
    kBlacklistStateFieldNumber = 15,
    kInstalledInThisSamplePeriodFieldNumber = 16,
  };
  // repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;
  int disable_reasons_size() const;
  void clear_disable_reasons();
  ::metrics::ExtensionInstallProto_DisableReason disable_reasons(int index) const;
  void set_disable_reasons(int index, ::metrics::ExtensionInstallProto_DisableReason value);
  void add_disable_reasons(::metrics::ExtensionInstallProto_DisableReason value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& disable_reasons() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_disable_reasons();

  // optional .metrics.ExtensionInstallProto.Type type = 1;
  bool has_type() const;
  void clear_type();
  ::metrics::ExtensionInstallProto_Type type() const;
  void set_type(::metrics::ExtensionInstallProto_Type value);

  // optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;
  bool has_install_location() const;
  void clear_install_location();
  ::metrics::ExtensionInstallProto_InstallLocation install_location() const;
  void set_install_location(::metrics::ExtensionInstallProto_InstallLocation value);

  // optional int32 manifest_version = 3;
  bool has_manifest_version() const;
  void clear_manifest_version();
  ::PROTOBUF_NAMESPACE_ID::int32 manifest_version() const;
  void set_manifest_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .metrics.ExtensionInstallProto.ActionType action_type = 4;
  bool has_action_type() const;
  void clear_action_type();
  ::metrics::ExtensionInstallProto_ActionType action_type() const;
  void set_action_type(::metrics::ExtensionInstallProto_ActionType value);

  // optional bool has_file_access = 5;
  bool has_has_file_access() const;
  void clear_has_file_access();
  bool has_file_access() const;
  void set_has_file_access(bool value);

  // optional bool has_incognito_access = 6;
  bool has_has_incognito_access() const;
  void clear_has_incognito_access();
  bool has_incognito_access() const;
  void set_has_incognito_access(bool value);

  // optional bool is_from_store = 7;
  bool has_is_from_store() const;
  void clear_is_from_store();
  bool is_from_store() const;
  void set_is_from_store(bool value);

  // optional bool updates_from_store = 8;
  bool has_updates_from_store() const;
  void clear_updates_from_store();
  bool updates_from_store() const;
  void set_updates_from_store(bool value);

  // optional bool is_from_bookmark = 9;
  bool has_is_from_bookmark() const;
  void clear_is_from_bookmark();
  bool is_from_bookmark() const;
  void set_is_from_bookmark(bool value);

  // optional bool is_converted_from_user_script = 10;
  bool has_is_converted_from_user_script() const;
  void clear_is_converted_from_user_script();
  bool is_converted_from_user_script() const;
  void set_is_converted_from_user_script(bool value);

  // optional bool is_default_installed = 11;
  bool has_is_default_installed() const;
  void clear_is_default_installed();
  bool is_default_installed() const;
  void set_is_default_installed(bool value);

  // optional bool is_oem_installed = 12;
  bool has_is_oem_installed() const;
  void clear_is_oem_installed();
  bool is_oem_installed() const;
  void set_is_oem_installed(bool value);

  // optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;
  bool has_background_script_type() const;
  void clear_background_script_type();
  ::metrics::ExtensionInstallProto_BackgroundScriptType background_script_type() const;
  void set_background_script_type(::metrics::ExtensionInstallProto_BackgroundScriptType value);

  // optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;
  bool has_blacklist_state() const;
  void clear_blacklist_state();
  ::metrics::ExtensionInstallProto_BlacklistState blacklist_state() const;
  void set_blacklist_state(::metrics::ExtensionInstallProto_BlacklistState value);

  // optional bool installed_in_this_sample_period = 16;
  bool has_installed_in_this_sample_period() const;
  void clear_installed_in_this_sample_period();
  bool installed_in_this_sample_period() const;
  void set_installed_in_this_sample_period(bool value);

  // @@protoc_insertion_point(class_scope:metrics.ExtensionInstallProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> disable_reasons_;
  int type_;
  int install_location_;
  ::PROTOBUF_NAMESPACE_ID::int32 manifest_version_;
  int action_type_;
  bool has_file_access_;
  bool has_incognito_access_;
  bool is_from_store_;
  bool updates_from_store_;
  bool is_from_bookmark_;
  bool is_converted_from_user_script_;
  bool is_default_installed_;
  bool is_oem_installed_;
  int background_script_type_;
  int blacklist_state_;
  bool installed_in_this_sample_period_;
  friend struct ::TableStruct_extension_5finstall_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExtensionInstallProto

// optional .metrics.ExtensionInstallProto.Type type = 1;
inline bool ExtensionInstallProto::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionInstallProto::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::metrics::ExtensionInstallProto_Type ExtensionInstallProto::type() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.type)
  return static_cast< ::metrics::ExtensionInstallProto_Type >(type_);
}
inline void ExtensionInstallProto::set_type(::metrics::ExtensionInstallProto_Type value) {
  assert(::metrics::ExtensionInstallProto_Type_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.type)
}

// optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;
inline bool ExtensionInstallProto::has_install_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtensionInstallProto::clear_install_location() {
  install_location_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::metrics::ExtensionInstallProto_InstallLocation ExtensionInstallProto::install_location() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.install_location)
  return static_cast< ::metrics::ExtensionInstallProto_InstallLocation >(install_location_);
}
inline void ExtensionInstallProto::set_install_location(::metrics::ExtensionInstallProto_InstallLocation value) {
  assert(::metrics::ExtensionInstallProto_InstallLocation_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  install_location_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.install_location)
}

// optional int32 manifest_version = 3;
inline bool ExtensionInstallProto::has_manifest_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtensionInstallProto::clear_manifest_version() {
  manifest_version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExtensionInstallProto::manifest_version() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.manifest_version)
  return manifest_version_;
}
inline void ExtensionInstallProto::set_manifest_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  manifest_version_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.manifest_version)
}

// optional .metrics.ExtensionInstallProto.ActionType action_type = 4;
inline bool ExtensionInstallProto::has_action_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtensionInstallProto::clear_action_type() {
  action_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::metrics::ExtensionInstallProto_ActionType ExtensionInstallProto::action_type() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.action_type)
  return static_cast< ::metrics::ExtensionInstallProto_ActionType >(action_type_);
}
inline void ExtensionInstallProto::set_action_type(::metrics::ExtensionInstallProto_ActionType value) {
  assert(::metrics::ExtensionInstallProto_ActionType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  action_type_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.action_type)
}

// optional bool has_file_access = 5;
inline bool ExtensionInstallProto::has_has_file_access() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtensionInstallProto::clear_has_file_access() {
  has_file_access_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ExtensionInstallProto::has_file_access() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.has_file_access)
  return has_file_access_;
}
inline void ExtensionInstallProto::set_has_file_access(bool value) {
  _has_bits_[0] |= 0x00000010u;
  has_file_access_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.has_file_access)
}

// optional bool has_incognito_access = 6;
inline bool ExtensionInstallProto::has_has_incognito_access() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtensionInstallProto::clear_has_incognito_access() {
  has_incognito_access_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ExtensionInstallProto::has_incognito_access() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.has_incognito_access)
  return has_incognito_access_;
}
inline void ExtensionInstallProto::set_has_incognito_access(bool value) {
  _has_bits_[0] |= 0x00000020u;
  has_incognito_access_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.has_incognito_access)
}

// optional bool is_from_store = 7;
inline bool ExtensionInstallProto::has_is_from_store() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtensionInstallProto::clear_is_from_store() {
  is_from_store_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ExtensionInstallProto::is_from_store() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.is_from_store)
  return is_from_store_;
}
inline void ExtensionInstallProto::set_is_from_store(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_from_store_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.is_from_store)
}

// optional bool updates_from_store = 8;
inline bool ExtensionInstallProto::has_updates_from_store() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExtensionInstallProto::clear_updates_from_store() {
  updates_from_store_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ExtensionInstallProto::updates_from_store() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.updates_from_store)
  return updates_from_store_;
}
inline void ExtensionInstallProto::set_updates_from_store(bool value) {
  _has_bits_[0] |= 0x00000080u;
  updates_from_store_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.updates_from_store)
}

// optional bool is_from_bookmark = 9;
inline bool ExtensionInstallProto::has_is_from_bookmark() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExtensionInstallProto::clear_is_from_bookmark() {
  is_from_bookmark_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ExtensionInstallProto::is_from_bookmark() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.is_from_bookmark)
  return is_from_bookmark_;
}
inline void ExtensionInstallProto::set_is_from_bookmark(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_from_bookmark_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.is_from_bookmark)
}

// optional bool is_converted_from_user_script = 10;
inline bool ExtensionInstallProto::has_is_converted_from_user_script() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExtensionInstallProto::clear_is_converted_from_user_script() {
  is_converted_from_user_script_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ExtensionInstallProto::is_converted_from_user_script() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.is_converted_from_user_script)
  return is_converted_from_user_script_;
}
inline void ExtensionInstallProto::set_is_converted_from_user_script(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_converted_from_user_script_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.is_converted_from_user_script)
}

// optional bool is_default_installed = 11;
inline bool ExtensionInstallProto::has_is_default_installed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExtensionInstallProto::clear_is_default_installed() {
  is_default_installed_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ExtensionInstallProto::is_default_installed() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.is_default_installed)
  return is_default_installed_;
}
inline void ExtensionInstallProto::set_is_default_installed(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_default_installed_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.is_default_installed)
}

// optional bool is_oem_installed = 12;
inline bool ExtensionInstallProto::has_is_oem_installed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExtensionInstallProto::clear_is_oem_installed() {
  is_oem_installed_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool ExtensionInstallProto::is_oem_installed() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.is_oem_installed)
  return is_oem_installed_;
}
inline void ExtensionInstallProto::set_is_oem_installed(bool value) {
  _has_bits_[0] |= 0x00000800u;
  is_oem_installed_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.is_oem_installed)
}

// optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;
inline bool ExtensionInstallProto::has_background_script_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExtensionInstallProto::clear_background_script_type() {
  background_script_type_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::metrics::ExtensionInstallProto_BackgroundScriptType ExtensionInstallProto::background_script_type() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.background_script_type)
  return static_cast< ::metrics::ExtensionInstallProto_BackgroundScriptType >(background_script_type_);
}
inline void ExtensionInstallProto::set_background_script_type(::metrics::ExtensionInstallProto_BackgroundScriptType value) {
  assert(::metrics::ExtensionInstallProto_BackgroundScriptType_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  background_script_type_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.background_script_type)
}

// repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;
inline int ExtensionInstallProto::disable_reasons_size() const {
  return disable_reasons_.size();
}
inline void ExtensionInstallProto::clear_disable_reasons() {
  disable_reasons_.Clear();
}
inline ::metrics::ExtensionInstallProto_DisableReason ExtensionInstallProto::disable_reasons(int index) const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.disable_reasons)
  return static_cast< ::metrics::ExtensionInstallProto_DisableReason >(disable_reasons_.Get(index));
}
inline void ExtensionInstallProto::set_disable_reasons(int index, ::metrics::ExtensionInstallProto_DisableReason value) {
  assert(::metrics::ExtensionInstallProto_DisableReason_IsValid(value));
  disable_reasons_.Set(index, value);
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.disable_reasons)
}
inline void ExtensionInstallProto::add_disable_reasons(::metrics::ExtensionInstallProto_DisableReason value) {
  assert(::metrics::ExtensionInstallProto_DisableReason_IsValid(value));
  disable_reasons_.Add(value);
  // @@protoc_insertion_point(field_add:metrics.ExtensionInstallProto.disable_reasons)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ExtensionInstallProto::disable_reasons() const {
  // @@protoc_insertion_point(field_list:metrics.ExtensionInstallProto.disable_reasons)
  return disable_reasons_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ExtensionInstallProto::mutable_disable_reasons() {
  // @@protoc_insertion_point(field_mutable_list:metrics.ExtensionInstallProto.disable_reasons)
  return &disable_reasons_;
}

// optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;
inline bool ExtensionInstallProto::has_blacklist_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExtensionInstallProto::clear_blacklist_state() {
  blacklist_state_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::metrics::ExtensionInstallProto_BlacklistState ExtensionInstallProto::blacklist_state() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.blacklist_state)
  return static_cast< ::metrics::ExtensionInstallProto_BlacklistState >(blacklist_state_);
}
inline void ExtensionInstallProto::set_blacklist_state(::metrics::ExtensionInstallProto_BlacklistState value) {
  assert(::metrics::ExtensionInstallProto_BlacklistState_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  blacklist_state_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.blacklist_state)
}

// optional bool installed_in_this_sample_period = 16;
inline bool ExtensionInstallProto::has_installed_in_this_sample_period() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExtensionInstallProto::clear_installed_in_this_sample_period() {
  installed_in_this_sample_period_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ExtensionInstallProto::installed_in_this_sample_period() const {
  // @@protoc_insertion_point(field_get:metrics.ExtensionInstallProto.installed_in_this_sample_period)
  return installed_in_this_sample_period_;
}
inline void ExtensionInstallProto::set_installed_in_this_sample_period(bool value) {
  _has_bits_[0] |= 0x00004000u;
  installed_in_this_sample_period_ = value;
  // @@protoc_insertion_point(field_set:metrics.ExtensionInstallProto.installed_in_this_sample_period)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace metrics

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::metrics::ExtensionInstallProto_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::ExtensionInstallProto_InstallLocation> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::ExtensionInstallProto_ActionType> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::ExtensionInstallProto_BackgroundScriptType> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::ExtensionInstallProto_DisableReason> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::ExtensionInstallProto_BlacklistState> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_extension_5finstall_2eproto
