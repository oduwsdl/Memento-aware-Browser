{"src/include/dawn/webgpu_cpp.h": "\n#ifndef WEBGPU_CPP_H_\n#define WEBGPU_CPP_H_\n\n#include \"dawn/webgpu.h\"\n#include \"dawn/EnumClassBitmasks.h\"\n\nnamespace wgpu {\n\n    static constexpr uint64_t kWholeSize = WGPU_WHOLE_SIZE;\n\n    enum class AdapterType : uint32_t {\n        DiscreteGPU = 0x00000000,\n        IntegratedGPU = 0x00000001,\n        CPU = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class AddressMode : uint32_t {\n        Repeat = 0x00000000,\n        MirrorRepeat = 0x00000001,\n        ClampToEdge = 0x00000002,\n    };\n\n    enum class BackendType : uint32_t {\n        Null = 0x00000000,\n        D3D11 = 0x00000001,\n        D3D12 = 0x00000002,\n        Metal = 0x00000003,\n        Vulkan = 0x00000004,\n        OpenGL = 0x00000005,\n        OpenGLES = 0x00000006,\n    };\n\n    enum class BindingType : uint32_t {\n        UniformBuffer = 0x00000000,\n        StorageBuffer = 0x00000001,\n        ReadonlyStorageBuffer = 0x00000002,\n        Sampler = 0x00000003,\n        ComparisonSampler = 0x00000004,\n        SampledTexture = 0x00000005,\n        StorageTexture = 0x00000006,\n        ReadonlyStorageTexture = 0x00000007,\n        WriteonlyStorageTexture = 0x00000008,\n    };\n\n    enum class BlendFactor : uint32_t {\n        Zero = 0x00000000,\n        One = 0x00000001,\n        SrcColor = 0x00000002,\n        OneMinusSrcColor = 0x00000003,\n        SrcAlpha = 0x00000004,\n        OneMinusSrcAlpha = 0x00000005,\n        DstColor = 0x00000006,\n        OneMinusDstColor = 0x00000007,\n        DstAlpha = 0x00000008,\n        OneMinusDstAlpha = 0x00000009,\n        SrcAlphaSaturated = 0x0000000A,\n        BlendColor = 0x0000000B,\n        OneMinusBlendColor = 0x0000000C,\n    };\n\n    enum class BlendOperation : uint32_t {\n        Add = 0x00000000,\n        Subtract = 0x00000001,\n        ReverseSubtract = 0x00000002,\n        Min = 0x00000003,\n        Max = 0x00000004,\n    };\n\n    enum class BufferMapAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n    };\n\n    enum class CompareFunction : uint32_t {\n        Undefined = 0x00000000,\n        Never = 0x00000001,\n        Less = 0x00000002,\n        LessEqual = 0x00000003,\n        Greater = 0x00000004,\n        GreaterEqual = 0x00000005,\n        Equal = 0x00000006,\n        NotEqual = 0x00000007,\n        Always = 0x00000008,\n    };\n\n    enum class CullMode : uint32_t {\n        None = 0x00000000,\n        Front = 0x00000001,\n        Back = 0x00000002,\n    };\n\n    enum class ErrorFilter : uint32_t {\n        None = 0x00000000,\n        Validation = 0x00000001,\n        OutOfMemory = 0x00000002,\n    };\n\n    enum class ErrorType : uint32_t {\n        NoError = 0x00000000,\n        Validation = 0x00000001,\n        OutOfMemory = 0x00000002,\n        Unknown = 0x00000003,\n        DeviceLost = 0x00000004,\n    };\n\n    enum class FenceCompletionStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n    };\n\n    enum class FilterMode : uint32_t {\n        Nearest = 0x00000000,\n        Linear = 0x00000001,\n    };\n\n    enum class FrontFace : uint32_t {\n        CCW = 0x00000000,\n        CW = 0x00000001,\n    };\n\n    enum class IndexFormat : uint32_t {\n        Uint16 = 0x00000000,\n        Uint32 = 0x00000001,\n    };\n\n    enum class InputStepMode : uint32_t {\n        Vertex = 0x00000000,\n        Instance = 0x00000001,\n    };\n\n    enum class LoadOp : uint32_t {\n        Clear = 0x00000000,\n        Load = 0x00000001,\n    };\n\n    enum class PipelineStatisticsName : uint32_t {\n        VertexShaderInvocations = 0x00000000,\n        ClipperInvocations = 0x00000001,\n        ClipperPrimitivesOut = 0x00000002,\n        FragmentShaderInvocations = 0x00000003,\n        ComputeShaderInvocations = 0x00000004,\n    };\n\n    enum class PresentMode : uint32_t {\n        Immediate = 0x00000000,\n        Mailbox = 0x00000001,\n        Fifo = 0x00000002,\n    };\n\n    enum class PrimitiveTopology : uint32_t {\n        PointList = 0x00000000,\n        LineList = 0x00000001,\n        LineStrip = 0x00000002,\n        TriangleList = 0x00000003,\n        TriangleStrip = 0x00000004,\n    };\n\n    enum class QueryType : uint32_t {\n        Occlusion = 0x00000000,\n        PipelineStatistics = 0x00000001,\n        Timestamp = 0x00000002,\n    };\n\n    enum class SType : uint32_t {\n        Invalid = 0x00000000,\n        SurfaceDescriptorFromMetalLayer = 0x00000001,\n        SurfaceDescriptorFromWindowsHWND = 0x00000002,\n        SurfaceDescriptorFromXlib = 0x00000003,\n        SurfaceDescriptorFromHTMLCanvasId = 0x00000004,\n        ShaderModuleSPIRVDescriptor = 0x00000005,\n        ShaderModuleWGSLDescriptor = 0x00000006,\n        SamplerDescriptorDummyAnisotropicFiltering = 0x00000007,\n        RenderPipelineDescriptorDummyExtension = 0x00000008,\n    };\n\n    enum class StencilOperation : uint32_t {\n        Keep = 0x00000000,\n        Zero = 0x00000001,\n        Replace = 0x00000002,\n        Invert = 0x00000003,\n        IncrementClamp = 0x00000004,\n        DecrementClamp = 0x00000005,\n        IncrementWrap = 0x00000006,\n        DecrementWrap = 0x00000007,\n    };\n\n    enum class StoreOp : uint32_t {\n        Store = 0x00000000,\n        Clear = 0x00000001,\n    };\n\n    enum class TextureAspect : uint32_t {\n        All = 0x00000000,\n        StencilOnly = 0x00000001,\n        DepthOnly = 0x00000002,\n    };\n\n    enum class TextureComponentType : uint32_t {\n        Float = 0x00000000,\n        Sint = 0x00000001,\n        Uint = 0x00000002,\n    };\n\n    enum class TextureDimension : uint32_t {\n        e1D = 0x00000000,\n        e2D = 0x00000001,\n        e3D = 0x00000002,\n    };\n\n    enum class TextureFormat : uint32_t {\n        Undefined = 0x00000000,\n        R8Unorm = 0x00000001,\n        R8Snorm = 0x00000002,\n        R8Uint = 0x00000003,\n        R8Sint = 0x00000004,\n        R16Uint = 0x00000005,\n        R16Sint = 0x00000006,\n        R16Float = 0x00000007,\n        RG8Unorm = 0x00000008,\n        RG8Snorm = 0x00000009,\n        RG8Uint = 0x0000000A,\n        RG8Sint = 0x0000000B,\n        R32Float = 0x0000000C,\n        R32Uint = 0x0000000D,\n        R32Sint = 0x0000000E,\n        RG16Uint = 0x0000000F,\n        RG16Sint = 0x00000010,\n        RG16Float = 0x00000011,\n        RGBA8Unorm = 0x00000012,\n        RGBA8UnormSrgb = 0x00000013,\n        RGBA8Snorm = 0x00000014,\n        RGBA8Uint = 0x00000015,\n        RGBA8Sint = 0x00000016,\n        BGRA8Unorm = 0x00000017,\n        BGRA8UnormSrgb = 0x00000018,\n        RGB10A2Unorm = 0x00000019,\n        RG11B10Float = 0x0000001A,\n        RG32Float = 0x0000001B,\n        RG32Uint = 0x0000001C,\n        RG32Sint = 0x0000001D,\n        RGBA16Uint = 0x0000001E,\n        RGBA16Sint = 0x0000001F,\n        RGBA16Float = 0x00000020,\n        RGBA32Float = 0x00000021,\n        RGBA32Uint = 0x00000022,\n        RGBA32Sint = 0x00000023,\n        Depth32Float = 0x00000024,\n        Depth24Plus = 0x00000025,\n        Depth24PlusStencil8 = 0x00000026,\n        BC1RGBAUnorm = 0x00000027,\n        BC1RGBAUnormSrgb = 0x00000028,\n        BC2RGBAUnorm = 0x00000029,\n        BC2RGBAUnormSrgb = 0x0000002A,\n        BC3RGBAUnorm = 0x0000002B,\n        BC3RGBAUnormSrgb = 0x0000002C,\n        BC4RUnorm = 0x0000002D,\n        BC4RSnorm = 0x0000002E,\n        BC5RGUnorm = 0x0000002F,\n        BC5RGSnorm = 0x00000030,\n        BC6HRGBUfloat = 0x00000031,\n        BC6HRGBSfloat = 0x00000032,\n        BC7RGBAUnorm = 0x00000033,\n        BC7RGBAUnormSrgb = 0x00000034,\n    };\n\n    enum class TextureViewDimension : uint32_t {\n        Undefined = 0x00000000,\n        e1D = 0x00000001,\n        e2D = 0x00000002,\n        e2DArray = 0x00000003,\n        Cube = 0x00000004,\n        CubeArray = 0x00000005,\n        e3D = 0x00000006,\n    };\n\n    enum class VertexFormat : uint32_t {\n        UChar2 = 0x00000000,\n        UChar4 = 0x00000001,\n        Char2 = 0x00000002,\n        Char4 = 0x00000003,\n        UChar2Norm = 0x00000004,\n        UChar4Norm = 0x00000005,\n        Char2Norm = 0x00000006,\n        Char4Norm = 0x00000007,\n        UShort2 = 0x00000008,\n        UShort4 = 0x00000009,\n        Short2 = 0x0000000A,\n        Short4 = 0x0000000B,\n        UShort2Norm = 0x0000000C,\n        UShort4Norm = 0x0000000D,\n        Short2Norm = 0x0000000E,\n        Short4Norm = 0x0000000F,\n        Half2 = 0x00000010,\n        Half4 = 0x00000011,\n        Float = 0x00000012,\n        Float2 = 0x00000013,\n        Float3 = 0x00000014,\n        Float4 = 0x00000015,\n        UInt = 0x00000016,\n        UInt2 = 0x00000017,\n        UInt3 = 0x00000018,\n        UInt4 = 0x00000019,\n        Int = 0x0000001A,\n        Int2 = 0x0000001B,\n        Int3 = 0x0000001C,\n        Int4 = 0x0000001D,\n    };\n\n\n    enum class BufferUsage : uint32_t {\n        None = 0x00000000,\n        MapRead = 0x00000001,\n        MapWrite = 0x00000002,\n        CopySrc = 0x00000004,\n        CopyDst = 0x00000008,\n        Index = 0x00000010,\n        Vertex = 0x00000020,\n        Uniform = 0x00000040,\n        Storage = 0x00000080,\n        Indirect = 0x00000100,\n    };\n\n    enum class ColorWriteMask : uint32_t {\n        None = 0x00000000,\n        Red = 0x00000001,\n        Green = 0x00000002,\n        Blue = 0x00000004,\n        Alpha = 0x00000008,\n        All = 0x0000000F,\n    };\n\n    enum class ShaderStage : uint32_t {\n        None = 0x00000000,\n        Vertex = 0x00000001,\n        Fragment = 0x00000002,\n        Compute = 0x00000004,\n    };\n\n    enum class TextureUsage : uint32_t {\n        None = 0x00000000,\n        CopySrc = 0x00000001,\n        CopyDst = 0x00000002,\n        Sampled = 0x00000004,\n        Storage = 0x00000008,\n        OutputAttachment = 0x00000010,\n        Present = 0x00000020,\n    };\n\n\n    template<>\n    struct IsDawnBitmask<BufferUsage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<ColorWriteMask> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<ShaderStage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<TextureUsage> {\n        static constexpr bool enable = true;\n    };\n\n\n    using Proc = WGPUProc;\n    using BufferMapReadCallback = WGPUBufferMapReadCallback;\n    using BufferMapWriteCallback = WGPUBufferMapWriteCallback;\n    using DeviceLostCallback = WGPUDeviceLostCallback;\n    using ErrorCallback = WGPUErrorCallback;\n    using FenceOnCompletionCallback = WGPUFenceOnCompletionCallback;\n\n    class BindGroup;\n    class BindGroupLayout;\n    class Buffer;\n    class CommandBuffer;\n    class CommandEncoder;\n    class ComputePassEncoder;\n    class ComputePipeline;\n    class Device;\n    class Fence;\n    class Instance;\n    class PipelineLayout;\n    class QuerySet;\n    class Queue;\n    class RenderBundle;\n    class RenderBundleEncoder;\n    class RenderPassEncoder;\n    class RenderPipeline;\n    class Sampler;\n    class ShaderModule;\n    class Surface;\n    class SwapChain;\n    class Texture;\n    class TextureView;\n\n    struct AdapterProperties;\n    struct BindGroupEntry;\n    struct BindGroupLayoutEntry;\n    struct BlendDescriptor;\n    struct BufferCopyView;\n    struct BufferDescriptor;\n    struct Color;\n    struct CommandBufferDescriptor;\n    struct CommandEncoderDescriptor;\n    struct ComputePassDescriptor;\n    struct CreateBufferMappedResult;\n    struct DeviceProperties;\n    struct Extent3D;\n    struct FenceDescriptor;\n    struct InstanceDescriptor;\n    struct Origin3D;\n    struct PipelineLayoutDescriptor;\n    struct ProgrammableStageDescriptor;\n    struct QuerySetDescriptor;\n    struct RasterizationStateDescriptor;\n    struct RenderBundleDescriptor;\n    struct RenderBundleEncoderDescriptor;\n    struct RenderPassDepthStencilAttachmentDescriptor;\n    struct SamplerDescriptor;\n    struct SamplerDescriptorDummyAnisotropicFiltering;\n    struct ShaderModuleDescriptor;\n    struct ShaderModuleSPIRVDescriptor;\n    struct ShaderModuleWGSLDescriptor;\n    struct StencilStateFaceDescriptor;\n    struct SurfaceDescriptor;\n    struct SurfaceDescriptorFromHTMLCanvasId;\n    struct SurfaceDescriptorFromMetalLayer;\n    struct SurfaceDescriptorFromWindowsHWND;\n    struct SurfaceDescriptorFromXlib;\n    struct SwapChainDescriptor;\n    struct TextureViewDescriptor;\n    struct VertexAttributeDescriptor;\n    struct BindGroupDescriptor;\n    struct BindGroupLayoutDescriptor;\n    struct ColorStateDescriptor;\n    struct ComputePipelineDescriptor;\n    struct DepthStencilStateDescriptor;\n    struct RenderPassColorAttachmentDescriptor;\n    struct RenderPipelineDescriptorDummyExtension;\n    struct TextureCopyView;\n    struct TextureDescriptor;\n    struct VertexBufferLayoutDescriptor;\n    struct RenderPassDescriptor;\n    struct VertexStateDescriptor;\n    struct RenderPipelineDescriptor;\n\n    template<typename Derived, typename CType>\n    class ObjectBase {\n      public:\n        ObjectBase() = default;\n        ObjectBase(CType handle): mHandle(handle) {\n            if (mHandle) Derived::WGPUReference(mHandle);\n        }\n        ~ObjectBase() {\n            if (mHandle) Derived::WGPURelease(mHandle);\n        }\n\n        ObjectBase(ObjectBase const& other)\n            : ObjectBase(other.Get()) {\n        }\n        Derived& operator=(ObjectBase const& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                if (mHandle) Derived::WGPUReference(mHandle);\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(ObjectBase&& other) {\n            mHandle = other.mHandle;\n            other.mHandle = 0;\n        }\n        Derived& operator=(ObjectBase&& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                other.mHandle = 0;\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(std::nullptr_t) {}\n        Derived& operator=(std::nullptr_t) {\n            if (mHandle != nullptr) {\n                Derived::WGPURelease(mHandle);\n                mHandle = nullptr;\n            }\n            return static_cast<Derived&>(*this);\n        }\n\n        bool operator==(std::nullptr_t) const {\n            return mHandle == nullptr;\n        }\n        bool operator!=(std::nullptr_t) const {\n            return mHandle != nullptr;\n        }\n\n        explicit operator bool() const {\n            return mHandle != nullptr;\n        }\n        CType Get() const {\n            return mHandle;\n        }\n        CType Release() {\n            CType result = mHandle;\n            mHandle = 0;\n            return result;\n        }\n        static Derived Acquire(CType handle) {\n            Derived result;\n            result.mHandle = handle;\n            return result;\n        }\n\n      protected:\n        CType mHandle = nullptr;\n    };\n\n\n\n    class BindGroup : public ObjectBase<BindGroup, WGPUBindGroup> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<BindGroup, WGPUBindGroup>;\n        static void WGPUReference(WGPUBindGroup handle);\n        static void WGPURelease(WGPUBindGroup handle);\n    };\n\n    class BindGroupLayout : public ObjectBase<BindGroupLayout, WGPUBindGroupLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<BindGroupLayout, WGPUBindGroupLayout>;\n        static void WGPUReference(WGPUBindGroupLayout handle);\n        static void WGPURelease(WGPUBindGroupLayout handle);\n    };\n\n    class Buffer : public ObjectBase<Buffer, WGPUBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void MapReadAsync(BufferMapReadCallback callback, void * userdata) const;\n        void MapWriteAsync(BufferMapWriteCallback callback, void * userdata) const;\n        void SetSubData(uint64_t start, uint64_t count, void const * data) const;\n        void Unmap() const;\n\n      private:\n        friend ObjectBase<Buffer, WGPUBuffer>;\n        static void WGPUReference(WGPUBuffer handle);\n        static void WGPURelease(WGPUBuffer handle);\n    };\n\n    class CommandBuffer : public ObjectBase<CommandBuffer, WGPUCommandBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<CommandBuffer, WGPUCommandBuffer>;\n        static void WGPUReference(WGPUCommandBuffer handle);\n        static void WGPURelease(WGPUCommandBuffer handle);\n    };\n\n    class CommandEncoder : public ObjectBase<CommandEncoder, WGPUCommandEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        ComputePassEncoder BeginComputePass(ComputePassDescriptor const * descriptor = nullptr) const;\n        RenderPassEncoder BeginRenderPass(RenderPassDescriptor const * descriptor) const;\n        void CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const;\n        void CopyBufferToTexture(BufferCopyView const * source, TextureCopyView const * destination, Extent3D const * copySize) const;\n        void CopyTextureToBuffer(TextureCopyView const * source, BufferCopyView const * destination, Extent3D const * copySize) const;\n        void CopyTextureToTexture(TextureCopyView const * source, TextureCopyView const * destination, Extent3D const * copySize) const;\n        CommandBuffer Finish(CommandBufferDescriptor const * descriptor = nullptr) const;\n        void InsertDebugMarker(char const * groupLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n\n      private:\n        friend ObjectBase<CommandEncoder, WGPUCommandEncoder>;\n        static void WGPUReference(WGPUCommandEncoder handle);\n        static void WGPURelease(WGPUCommandEncoder handle);\n    };\n\n    class ComputePassEncoder : public ObjectBase<ComputePassEncoder, WGPUComputePassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Dispatch(uint32_t x, uint32_t y = 1, uint32_t z = 1) const;\n        void DispatchIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void EndPass() const;\n        void InsertDebugMarker(char const * groupLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetPipeline(ComputePipeline const& pipeline) const;\n\n      private:\n        friend ObjectBase<ComputePassEncoder, WGPUComputePassEncoder>;\n        static void WGPUReference(WGPUComputePassEncoder handle);\n        static void WGPURelease(WGPUComputePassEncoder handle);\n    };\n\n    class ComputePipeline : public ObjectBase<ComputePipeline, WGPUComputePipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n\n      private:\n        friend ObjectBase<ComputePipeline, WGPUComputePipeline>;\n        static void WGPUReference(WGPUComputePipeline handle);\n        static void WGPURelease(WGPUComputePipeline handle);\n    };\n\n    class Device : public ObjectBase<Device, WGPUDevice> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroup CreateBindGroup(BindGroupDescriptor const * descriptor) const;\n        BindGroupLayout CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const;\n        Buffer CreateBuffer(BufferDescriptor const * descriptor) const;\n        CreateBufferMappedResult CreateBufferMapped(BufferDescriptor const * descriptor) const;\n        CommandEncoder CreateCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) const;\n        ComputePipeline CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const;\n        Buffer CreateErrorBuffer() const;\n        PipelineLayout CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const;\n        QuerySet CreateQuerySet(QuerySetDescriptor const * descriptor) const;\n        RenderBundleEncoder CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const;\n        RenderPipeline CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const;\n        Sampler CreateSampler(SamplerDescriptor const * descriptor) const;\n        ShaderModule CreateShaderModule(ShaderModuleDescriptor const * descriptor) const;\n        SwapChain CreateSwapChain(Surface const& surface, SwapChainDescriptor const * descriptor) const;\n        Texture CreateTexture(TextureDescriptor const * descriptor) const;\n        Queue GetDefaultQueue() const;\n        void InjectError(ErrorType type, char const * message) const;\n        void LoseForTesting() const;\n        bool PopErrorScope(ErrorCallback callback, void * userdata) const;\n        void PushErrorScope(ErrorFilter filter) const;\n        void SetDeviceLostCallback(DeviceLostCallback callback, void * userdata) const;\n        void SetUncapturedErrorCallback(ErrorCallback callback, void * userdata) const;\n        void Tick() const;\n\n      private:\n        friend ObjectBase<Device, WGPUDevice>;\n        static void WGPUReference(WGPUDevice handle);\n        static void WGPURelease(WGPUDevice handle);\n    };\n\n    class Fence : public ObjectBase<Fence, WGPUFence> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        uint64_t GetCompletedValue() const;\n        void OnCompletion(uint64_t value, FenceOnCompletionCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Fence, WGPUFence>;\n        static void WGPUReference(WGPUFence handle);\n        static void WGPURelease(WGPUFence handle);\n    };\n\n    class Instance : public ObjectBase<Instance, WGPUInstance> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Surface CreateSurface(SurfaceDescriptor const * descriptor) const;\n\n      private:\n        friend ObjectBase<Instance, WGPUInstance>;\n        static void WGPUReference(WGPUInstance handle);\n        static void WGPURelease(WGPUInstance handle);\n    };\n\n    class PipelineLayout : public ObjectBase<PipelineLayout, WGPUPipelineLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<PipelineLayout, WGPUPipelineLayout>;\n        static void WGPUReference(WGPUPipelineLayout handle);\n        static void WGPURelease(WGPUPipelineLayout handle);\n    };\n\n    class QuerySet : public ObjectBase<QuerySet, WGPUQuerySet> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n\n      private:\n        friend ObjectBase<QuerySet, WGPUQuerySet>;\n        static void WGPUReference(WGPUQuerySet handle);\n        static void WGPURelease(WGPUQuerySet handle);\n    };\n\n    class Queue : public ObjectBase<Queue, WGPUQueue> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Fence CreateFence(FenceDescriptor const * descriptor = nullptr) const;\n        void Signal(Fence const& fence, uint64_t signalValue) const;\n        void Submit(uint32_t commandCount, CommandBuffer const * commands) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const;\n\n      private:\n        friend ObjectBase<Queue, WGPUQueue>;\n        static void WGPUReference(WGPUQueue handle);\n        static void WGPURelease(WGPUQueue handle);\n    };\n\n    class RenderBundle : public ObjectBase<RenderBundle, WGPURenderBundle> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<RenderBundle, WGPURenderBundle>;\n        static void WGPUReference(WGPURenderBundle handle);\n        static void WGPURelease(WGPURenderBundle handle);\n    };\n\n    class RenderBundleEncoder : public ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        RenderBundle Finish(RenderBundleDescriptor const * descriptor = nullptr) const;\n        void InsertDebugMarker(char const * groupLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetIndexBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = 0) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = 0) const;\n\n      private:\n        friend ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder>;\n        static void WGPUReference(WGPURenderBundleEncoder handle);\n        static void WGPURelease(WGPURenderBundleEncoder handle);\n    };\n\n    class RenderPassEncoder : public ObjectBase<RenderPassEncoder, WGPURenderPassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void EndPass() const;\n        void ExecuteBundles(uint32_t bundlesCount, RenderBundle const * bundles) const;\n        void InsertDebugMarker(char const * groupLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetBlendColor(Color const * color) const;\n        void SetIndexBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = 0) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const;\n        void SetStencilReference(uint32_t reference) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = 0) const;\n        void SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const;\n\n      private:\n        friend ObjectBase<RenderPassEncoder, WGPURenderPassEncoder>;\n        static void WGPUReference(WGPURenderPassEncoder handle);\n        static void WGPURelease(WGPURenderPassEncoder handle);\n    };\n\n    class RenderPipeline : public ObjectBase<RenderPipeline, WGPURenderPipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n\n      private:\n        friend ObjectBase<RenderPipeline, WGPURenderPipeline>;\n        static void WGPUReference(WGPURenderPipeline handle);\n        static void WGPURelease(WGPURenderPipeline handle);\n    };\n\n    class Sampler : public ObjectBase<Sampler, WGPUSampler> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<Sampler, WGPUSampler>;\n        static void WGPUReference(WGPUSampler handle);\n        static void WGPURelease(WGPUSampler handle);\n    };\n\n    class ShaderModule : public ObjectBase<ShaderModule, WGPUShaderModule> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<ShaderModule, WGPUShaderModule>;\n        static void WGPUReference(WGPUShaderModule handle);\n        static void WGPURelease(WGPUShaderModule handle);\n    };\n\n    class Surface : public ObjectBase<Surface, WGPUSurface> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<Surface, WGPUSurface>;\n        static void WGPUReference(WGPUSurface handle);\n        static void WGPURelease(WGPUSurface handle);\n    };\n\n    class SwapChain : public ObjectBase<SwapChain, WGPUSwapChain> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Configure(TextureFormat format, TextureUsage allowedUsage, uint32_t width, uint32_t height) const;\n        TextureView GetCurrentTextureView() const;\n        void Present() const;\n\n      private:\n        friend ObjectBase<SwapChain, WGPUSwapChain>;\n        static void WGPUReference(WGPUSwapChain handle);\n        static void WGPURelease(WGPUSwapChain handle);\n    };\n\n    class Texture : public ObjectBase<Texture, WGPUTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        TextureView CreateView(TextureViewDescriptor const * descriptor = nullptr) const;\n        void Destroy() const;\n\n      private:\n        friend ObjectBase<Texture, WGPUTexture>;\n        static void WGPUReference(WGPUTexture handle);\n        static void WGPURelease(WGPUTexture handle);\n    };\n\n    class TextureView : public ObjectBase<TextureView, WGPUTextureView> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<TextureView, WGPUTextureView>;\n        static void WGPUReference(WGPUTextureView handle);\n        static void WGPURelease(WGPUTextureView handle);\n    };\n\n\n    Instance CreateInstance(InstanceDescriptor const * descriptor = nullptr);\n    Proc GetProcAddress(Device const& device, const char* procName);\n\n    struct ChainedStruct {\n        ChainedStruct const * nextInChain = nullptr;\n        SType sType = SType::Invalid;\n    };\n\n    struct AdapterProperties {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t deviceID;\n        uint32_t vendorID;\n        char const * name;\n        AdapterType adapterType;\n        BackendType backendType;\n    };\n\n    struct BindGroupEntry {\n        uint32_t binding;\n        Buffer buffer;\n        uint64_t offset = 0;\n        uint64_t size;\n        Sampler sampler;\n        TextureView textureView;\n    };\n\n    struct BindGroupLayoutEntry {\n        uint32_t binding;\n        ShaderStage visibility;\n        BindingType type;\n        bool hasDynamicOffset = false;\n        bool multisampled = false;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n        TextureComponentType textureComponentType = TextureComponentType::Float;\n        TextureFormat storageTextureFormat = TextureFormat::Undefined;\n        uint64_t minBufferBindingSize = 0;\n    };\n\n    struct BlendDescriptor {\n        BlendOperation operation = BlendOperation::Add;\n        BlendFactor srcFactor = BlendFactor::One;\n        BlendFactor dstFactor = BlendFactor::Zero;\n    };\n\n    struct BufferCopyView {\n        ChainedStruct const * nextInChain = nullptr;\n        Buffer buffer;\n        uint64_t offset = 0;\n        uint32_t bytesPerRow;\n        uint32_t rowsPerImage = 0;\n    };\n\n    struct BufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BufferUsage usage;\n        uint64_t size;\n    };\n\n    struct Color {\n        float r;\n        float g;\n        float b;\n        float a;\n    };\n\n    struct CommandBufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CommandEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct ComputePassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CreateBufferMappedResult {\n        Buffer buffer;\n        uint64_t dataLength;\n        void * data;\n    };\n\n    struct DeviceProperties {\n        bool textureCompressionBC = false;\n        bool shaderFloat16 = false;\n        bool pipelineStatisticsQuery = false;\n        bool timestampQuery = false;\n    };\n\n    struct Extent3D {\n        uint32_t width;\n        uint32_t height;\n        uint32_t depth;\n    };\n\n    struct FenceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint64_t initialValue = 0;\n    };\n\n    struct InstanceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n    };\n\n    struct Origin3D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n        uint32_t z = 0;\n    };\n\n    struct PipelineLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t bindGroupLayoutCount;\n        BindGroupLayout const * bindGroupLayouts;\n    };\n\n    struct ProgrammableStageDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n    };\n\n    struct QuerySetDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        QueryType type;\n        uint32_t count;\n        uint32_t pipelineStatisticsCount = 0;\n        PipelineStatisticsName const * pipelineStatistics;\n    };\n\n    struct RasterizationStateDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        FrontFace frontFace = FrontFace::CCW;\n        CullMode cullMode = CullMode::None;\n        int32_t depthBias = 0;\n        float depthBiasSlopeScale = 0.0f;\n        float depthBiasClamp = 0.0f;\n    };\n\n    struct RenderBundleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorFormatsCount;\n        TextureFormat const * colorFormats;\n        TextureFormat depthStencilFormat = TextureFormat::Undefined;\n        uint32_t sampleCount = 1;\n    };\n\n    struct RenderPassDepthStencilAttachmentDescriptor {\n        TextureView attachment;\n        LoadOp depthLoadOp;\n        StoreOp depthStoreOp;\n        float clearDepth;\n        LoadOp stencilLoadOp;\n        StoreOp stencilStoreOp;\n        uint32_t clearStencil = 0;\n    };\n\n    struct SamplerDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        AddressMode addressModeU = AddressMode::ClampToEdge;\n        AddressMode addressModeV = AddressMode::ClampToEdge;\n        AddressMode addressModeW = AddressMode::ClampToEdge;\n        FilterMode magFilter = FilterMode::Nearest;\n        FilterMode minFilter = FilterMode::Nearest;\n        FilterMode mipmapFilter = FilterMode::Nearest;\n        float lodMinClamp = 0.0f;\n        float lodMaxClamp = 1000.0f;\n        CompareFunction compare = CompareFunction::Undefined;\n    };\n\n    struct SamplerDescriptorDummyAnisotropicFiltering : ChainedStruct {\n        SamplerDescriptorDummyAnisotropicFiltering() {\n            sType = SType::SamplerDescriptorDummyAnisotropicFiltering;\n        }\n        alignas(ChainedStruct) float maxAnisotropy;\n    };\n\n    struct ShaderModuleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct ShaderModuleSPIRVDescriptor : ChainedStruct {\n        ShaderModuleSPIRVDescriptor() {\n            sType = SType::ShaderModuleSPIRVDescriptor;\n        }\n        alignas(ChainedStruct) uint32_t codeSize;\n        uint32_t const * code;\n    };\n\n    struct ShaderModuleWGSLDescriptor : ChainedStruct {\n        ShaderModuleWGSLDescriptor() {\n            sType = SType::ShaderModuleWGSLDescriptor;\n        }\n        alignas(ChainedStruct) char const * source;\n    };\n\n    struct StencilStateFaceDescriptor {\n        CompareFunction compare = CompareFunction::Always;\n        StencilOperation failOp = StencilOperation::Keep;\n        StencilOperation depthFailOp = StencilOperation::Keep;\n        StencilOperation passOp = StencilOperation::Keep;\n    };\n\n    struct SurfaceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct SurfaceDescriptorFromHTMLCanvasId : ChainedStruct {\n        SurfaceDescriptorFromHTMLCanvasId() {\n            sType = SType::SurfaceDescriptorFromHTMLCanvasId;\n        }\n        alignas(ChainedStruct) char const * id;\n    };\n\n    struct SurfaceDescriptorFromMetalLayer : ChainedStruct {\n        SurfaceDescriptorFromMetalLayer() {\n            sType = SType::SurfaceDescriptorFromMetalLayer;\n        }\n        alignas(ChainedStruct) void * layer;\n    };\n\n    struct SurfaceDescriptorFromWindowsHWND : ChainedStruct {\n        SurfaceDescriptorFromWindowsHWND() {\n            sType = SType::SurfaceDescriptorFromWindowsHWND;\n        }\n        alignas(ChainedStruct) void * hinstance;\n        void * hwnd;\n    };\n\n    struct SurfaceDescriptorFromXlib : ChainedStruct {\n        SurfaceDescriptorFromXlib() {\n            sType = SType::SurfaceDescriptorFromXlib;\n        }\n        alignas(ChainedStruct) void * display;\n        uint32_t window;\n    };\n\n    struct SwapChainDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureFormat format;\n        uint32_t width;\n        uint32_t height;\n        PresentMode presentMode;\n        uint64_t implementation = 0;\n    };\n\n    struct TextureViewDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension dimension = TextureViewDimension::Undefined;\n        uint32_t baseMipLevel = 0;\n        uint32_t mipLevelCount = 0;\n        uint32_t baseArrayLayer = 0;\n        uint32_t arrayLayerCount = 0;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct VertexAttributeDescriptor {\n        VertexFormat format;\n        uint64_t offset;\n        uint32_t shaderLocation;\n    };\n\n    struct BindGroupDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BindGroupLayout layout;\n        uint32_t entryCount;\n        BindGroupEntry const * entries;\n    };\n\n    struct BindGroupLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t entryCount;\n        BindGroupLayoutEntry const * entries;\n    };\n\n    struct ColorStateDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        BlendDescriptor alphaBlend;\n        BlendDescriptor colorBlend;\n        ColorWriteMask writeMask = ColorWriteMask::All;\n    };\n\n    struct ComputePipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout;\n        ProgrammableStageDescriptor computeStage;\n    };\n\n    struct DepthStencilStateDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        bool depthWriteEnabled = false;\n        CompareFunction depthCompare = CompareFunction::Always;\n        StencilStateFaceDescriptor stencilFront;\n        StencilStateFaceDescriptor stencilBack;\n        uint32_t stencilReadMask = 0xFFFFFFFF;\n        uint32_t stencilWriteMask = 0xFFFFFFFF;\n    };\n\n    struct RenderPassColorAttachmentDescriptor {\n        TextureView attachment;\n        TextureView resolveTarget;\n        LoadOp loadOp;\n        StoreOp storeOp;\n        Color clearColor;\n    };\n\n    struct RenderPipelineDescriptorDummyExtension : ChainedStruct {\n        RenderPipelineDescriptorDummyExtension() {\n            sType = SType::RenderPipelineDescriptorDummyExtension;\n        }\n        alignas(ChainedStruct) ProgrammableStageDescriptor dummyStage;\n    };\n\n    struct TextureCopyView {\n        ChainedStruct const * nextInChain = nullptr;\n        Texture texture;\n        uint32_t mipLevel = 0;\n        uint32_t arrayLayer = 0;\n        Origin3D origin;\n    };\n\n    struct TextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureDimension dimension = TextureDimension::e2D;\n        Extent3D size;\n        uint32_t arrayLayerCount = 1;\n        TextureFormat format;\n        uint32_t mipLevelCount = 1;\n        uint32_t sampleCount = 1;\n    };\n\n    struct VertexBufferLayoutDescriptor {\n        uint64_t arrayStride;\n        InputStepMode stepMode = InputStepMode::Vertex;\n        uint32_t attributeCount;\n        VertexAttributeDescriptor const * attributes;\n    };\n\n    struct RenderPassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorAttachmentCount;\n        RenderPassColorAttachmentDescriptor const * colorAttachments;\n        RenderPassDepthStencilAttachmentDescriptor const * depthStencilAttachment = nullptr;\n    };\n\n    struct VertexStateDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        IndexFormat indexFormat = IndexFormat::Uint32;\n        uint32_t vertexBufferCount = 0;\n        VertexBufferLayoutDescriptor const * vertexBuffers;\n    };\n\n    struct RenderPipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout;\n        ProgrammableStageDescriptor vertexStage;\n        ProgrammableStageDescriptor const * fragmentStage = nullptr;\n        VertexStateDescriptor const * vertexState = nullptr;\n        PrimitiveTopology primitiveTopology;\n        RasterizationStateDescriptor const * rasterizationState = nullptr;\n        uint32_t sampleCount = 1;\n        DepthStencilStateDescriptor const * depthStencilState = nullptr;\n        uint32_t colorStateCount;\n        ColorStateDescriptor const * colorStates;\n        uint32_t sampleMask = 0xFFFFFFFF;\n        bool alphaToCoverageEnabled = false;\n    };\n\n\n}  // namespace wgpu\n\n#endif // WEBGPU_CPP_H_\n"}