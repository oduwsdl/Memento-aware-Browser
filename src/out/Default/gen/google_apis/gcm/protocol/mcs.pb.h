// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include "google_apis/gcm/base/gcm_export.h"
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mcs_2eproto GCM_EXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct GCM_EXPORT TableStruct_mcs_2eproto {
static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace mcs_proto {
class AppData;
class AppDataDefaultTypeInternal;
GCM_EXPORT extern AppDataDefaultTypeInternal _AppData_default_instance_;
class ClientEvent;
class ClientEventDefaultTypeInternal;
GCM_EXPORT extern ClientEventDefaultTypeInternal _ClientEvent_default_instance_;
class Close;
class CloseDefaultTypeInternal;
GCM_EXPORT extern CloseDefaultTypeInternal _Close_default_instance_;
class DataMessageStanza;
class DataMessageStanzaDefaultTypeInternal;
GCM_EXPORT extern DataMessageStanzaDefaultTypeInternal _DataMessageStanza_default_instance_;
class ErrorInfo;
class ErrorInfoDefaultTypeInternal;
GCM_EXPORT extern ErrorInfoDefaultTypeInternal _ErrorInfo_default_instance_;
class Extension;
class ExtensionDefaultTypeInternal;
GCM_EXPORT extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class HeartbeatAck;
class HeartbeatAckDefaultTypeInternal;
GCM_EXPORT extern HeartbeatAckDefaultTypeInternal _HeartbeatAck_default_instance_;
class HeartbeatConfig;
class HeartbeatConfigDefaultTypeInternal;
GCM_EXPORT extern HeartbeatConfigDefaultTypeInternal _HeartbeatConfig_default_instance_;
class HeartbeatPing;
class HeartbeatPingDefaultTypeInternal;
GCM_EXPORT extern HeartbeatPingDefaultTypeInternal _HeartbeatPing_default_instance_;
class HeartbeatStat;
class HeartbeatStatDefaultTypeInternal;
GCM_EXPORT extern HeartbeatStatDefaultTypeInternal _HeartbeatStat_default_instance_;
class IqStanza;
class IqStanzaDefaultTypeInternal;
GCM_EXPORT extern IqStanzaDefaultTypeInternal _IqStanza_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
GCM_EXPORT extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
GCM_EXPORT extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class SelectiveAck;
class SelectiveAckDefaultTypeInternal;
GCM_EXPORT extern SelectiveAckDefaultTypeInternal _SelectiveAck_default_instance_;
class Setting;
class SettingDefaultTypeInternal;
GCM_EXPORT extern SettingDefaultTypeInternal _Setting_default_instance_;
class StreamAck;
class StreamAckDefaultTypeInternal;
GCM_EXPORT extern StreamAckDefaultTypeInternal _StreamAck_default_instance_;
class StreamErrorStanza;
class StreamErrorStanzaDefaultTypeInternal;
GCM_EXPORT extern StreamErrorStanzaDefaultTypeInternal _StreamErrorStanza_default_instance_;
}  // namespace mcs_proto
PROTOBUF_NAMESPACE_OPEN
template<> GCM_EXPORT ::mcs_proto::AppData* Arena::CreateMaybeMessage<::mcs_proto::AppData>(Arena*);
template<> GCM_EXPORT ::mcs_proto::ClientEvent* Arena::CreateMaybeMessage<::mcs_proto::ClientEvent>(Arena*);
template<> GCM_EXPORT ::mcs_proto::Close* Arena::CreateMaybeMessage<::mcs_proto::Close>(Arena*);
template<> GCM_EXPORT ::mcs_proto::DataMessageStanza* Arena::CreateMaybeMessage<::mcs_proto::DataMessageStanza>(Arena*);
template<> GCM_EXPORT ::mcs_proto::ErrorInfo* Arena::CreateMaybeMessage<::mcs_proto::ErrorInfo>(Arena*);
template<> GCM_EXPORT ::mcs_proto::Extension* Arena::CreateMaybeMessage<::mcs_proto::Extension>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatAck* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatAck>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatConfig* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatConfig>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatPing* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatPing>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatStat* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatStat>(Arena*);
template<> GCM_EXPORT ::mcs_proto::IqStanza* Arena::CreateMaybeMessage<::mcs_proto::IqStanza>(Arena*);
template<> GCM_EXPORT ::mcs_proto::LoginRequest* Arena::CreateMaybeMessage<::mcs_proto::LoginRequest>(Arena*);
template<> GCM_EXPORT ::mcs_proto::LoginResponse* Arena::CreateMaybeMessage<::mcs_proto::LoginResponse>(Arena*);
template<> GCM_EXPORT ::mcs_proto::SelectiveAck* Arena::CreateMaybeMessage<::mcs_proto::SelectiveAck>(Arena*);
template<> GCM_EXPORT ::mcs_proto::Setting* Arena::CreateMaybeMessage<::mcs_proto::Setting>(Arena*);
template<> GCM_EXPORT ::mcs_proto::StreamAck* Arena::CreateMaybeMessage<::mcs_proto::StreamAck>(Arena*);
template<> GCM_EXPORT ::mcs_proto::StreamErrorStanza* Arena::CreateMaybeMessage<::mcs_proto::StreamErrorStanza>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mcs_proto {

enum ClientEvent_Type : int {
ClientEvent_Type_UNKNOWN = 0,
ClientEvent_Type_DISCARDED_EVENTS = 1,
ClientEvent_Type_FAILED_CONNECTION = 2,
ClientEvent_Type_SUCCESSFUL_CONNECTION = 3
};
GCM_EXPORT bool ClientEvent_Type_IsValid(int value);
constexpr ClientEvent_Type ClientEvent_Type_Type_MIN = ClientEvent_Type_UNKNOWN;
constexpr ClientEvent_Type ClientEvent_Type_Type_MAX = ClientEvent_Type_SUCCESSFUL_CONNECTION;
constexpr int ClientEvent_Type_Type_ARRAYSIZE = ClientEvent_Type_Type_MAX + 1;

const std::string& ClientEvent_Type_Name(ClientEvent_Type value);
template<typename T>
inline const std::string& ClientEvent_Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, ClientEvent_Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ClientEvent_Type_Name.");
return ClientEvent_Type_Name(static_cast<ClientEvent_Type>(enum_t_value));
}
bool ClientEvent_Type_Parse(
const std::string& name, ClientEvent_Type* value);
enum LoginRequest_AuthService : int {
LoginRequest_AuthService_ANDROID_ID = 2
};
GCM_EXPORT bool LoginRequest_AuthService_IsValid(int value);
constexpr LoginRequest_AuthService LoginRequest_AuthService_AuthService_MIN = LoginRequest_AuthService_ANDROID_ID;
constexpr LoginRequest_AuthService LoginRequest_AuthService_AuthService_MAX = LoginRequest_AuthService_ANDROID_ID;
constexpr int LoginRequest_AuthService_AuthService_ARRAYSIZE = LoginRequest_AuthService_AuthService_MAX + 1;

const std::string& LoginRequest_AuthService_Name(LoginRequest_AuthService value);
template<typename T>
inline const std::string& LoginRequest_AuthService_Name(T enum_t_value) {
static_assert(::std::is_same<T, LoginRequest_AuthService>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function LoginRequest_AuthService_Name.");
return LoginRequest_AuthService_Name(static_cast<LoginRequest_AuthService>(enum_t_value));
}
bool LoginRequest_AuthService_Parse(
const std::string& name, LoginRequest_AuthService* value);
enum IqStanza_IqType : int {
IqStanza_IqType_GET = 0,
IqStanza_IqType_SET = 1,
IqStanza_IqType_RESULT = 2,
IqStanza_IqType_IQ_ERROR = 3
};
GCM_EXPORT bool IqStanza_IqType_IsValid(int value);
constexpr IqStanza_IqType IqStanza_IqType_IqType_MIN = IqStanza_IqType_GET;
constexpr IqStanza_IqType IqStanza_IqType_IqType_MAX = IqStanza_IqType_IQ_ERROR;
constexpr int IqStanza_IqType_IqType_ARRAYSIZE = IqStanza_IqType_IqType_MAX + 1;

const std::string& IqStanza_IqType_Name(IqStanza_IqType value);
template<typename T>
inline const std::string& IqStanza_IqType_Name(T enum_t_value) {
static_assert(::std::is_same<T, IqStanza_IqType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function IqStanza_IqType_Name.");
return IqStanza_IqType_Name(static_cast<IqStanza_IqType>(enum_t_value));
}
bool IqStanza_IqType_Parse(
const std::string& name, IqStanza_IqType* value);
// ===================================================================

class GCM_EXPORT HeartbeatPing :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatPing) */ {
public:
HeartbeatPing();
virtual ~HeartbeatPing();

HeartbeatPing(const HeartbeatPing& from);
HeartbeatPing(HeartbeatPing&& from) noexcept
: HeartbeatPing() {
*this = ::std::move(from);
}

inline HeartbeatPing& operator=(const HeartbeatPing& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatPing& operator=(HeartbeatPing&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const HeartbeatPing& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const HeartbeatPing* internal_default_instance() {
return reinterpret_cast<const HeartbeatPing*>(
&_HeartbeatPing_default_instance_);
}
static constexpr int kIndexInFileMessages =
0;

friend void swap(HeartbeatPing& a, HeartbeatPing& b) {
a.Swap(&b);
}
inline void Swap(HeartbeatPing* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline HeartbeatPing* New() const final {
return CreateMaybeMessage<HeartbeatPing>(nullptr);
}

HeartbeatPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<HeartbeatPing>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const HeartbeatPing& from);
void MergeFrom(const HeartbeatPing& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatPing* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatPing";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kStreamIdFieldNumber = 1,
kLastStreamIdReceivedFieldNumber = 2,
kStatusFieldNumber = 3,
};
// optional int32 stream_id = 1;
bool has_stream_id() const;
void clear_stream_id();
::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 last_stream_id_received = 2;
bool has_last_stream_id_received() const;
void clear_last_stream_id_received();
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 status = 3;
bool has_status() const;
void clear_status();
::PROTOBUF_NAMESPACE_ID::int64 status() const;
void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatPing)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
::PROTOBUF_NAMESPACE_ID::int64 status_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT HeartbeatAck :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatAck) */ {
public:
HeartbeatAck();
virtual ~HeartbeatAck();

HeartbeatAck(const HeartbeatAck& from);
HeartbeatAck(HeartbeatAck&& from) noexcept
: HeartbeatAck() {
*this = ::std::move(from);
}

inline HeartbeatAck& operator=(const HeartbeatAck& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatAck& operator=(HeartbeatAck&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const HeartbeatAck& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const HeartbeatAck* internal_default_instance() {
return reinterpret_cast<const HeartbeatAck*>(
&_HeartbeatAck_default_instance_);
}
static constexpr int kIndexInFileMessages =
1;

friend void swap(HeartbeatAck& a, HeartbeatAck& b) {
a.Swap(&b);
}
inline void Swap(HeartbeatAck* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline HeartbeatAck* New() const final {
return CreateMaybeMessage<HeartbeatAck>(nullptr);
}

HeartbeatAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<HeartbeatAck>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const HeartbeatAck& from);
void MergeFrom(const HeartbeatAck& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatAck* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatAck";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kStreamIdFieldNumber = 1,
kLastStreamIdReceivedFieldNumber = 2,
kStatusFieldNumber = 3,
};
// optional int32 stream_id = 1;
bool has_stream_id() const;
void clear_stream_id();
::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 last_stream_id_received = 2;
bool has_last_stream_id_received() const;
void clear_last_stream_id_received();
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 status = 3;
bool has_status() const;
void clear_status();
::PROTOBUF_NAMESPACE_ID::int64 status() const;
void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatAck)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
::PROTOBUF_NAMESPACE_ID::int64 status_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT ErrorInfo :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ErrorInfo) */ {
public:
ErrorInfo();
virtual ~ErrorInfo();

ErrorInfo(const ErrorInfo& from);
ErrorInfo(ErrorInfo&& from) noexcept
: ErrorInfo() {
*this = ::std::move(from);
}

inline ErrorInfo& operator=(const ErrorInfo& from) {
CopyFrom(from);
return *this;
}
inline ErrorInfo& operator=(ErrorInfo&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ErrorInfo& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ErrorInfo* internal_default_instance() {
return reinterpret_cast<const ErrorInfo*>(
&_ErrorInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
2;

friend void swap(ErrorInfo& a, ErrorInfo& b) {
a.Swap(&b);
}
inline void Swap(ErrorInfo* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ErrorInfo* New() const final {
return CreateMaybeMessage<ErrorInfo>(nullptr);
}

ErrorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ErrorInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ErrorInfo& from);
void MergeFrom(const ErrorInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ErrorInfo* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.ErrorInfo";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kMessageFieldNumber = 2,
kTypeFieldNumber = 3,
kExtensionFieldNumber = 4,
kCodeFieldNumber = 1,
};
// optional string message = 2;
bool has_message() const;
void clear_message();
const std::string& message() const;
void set_message(const std::string& value);
void set_message(std::string&& value);
void set_message(const char* value);
void set_message(const char* value, size_t size);
std::string* mutable_message();
std::string* release_message();
void set_allocated_message(std::string* message);

// optional string type = 3;
bool has_type() const;
void clear_type();
const std::string& type() const;
void set_type(const std::string& value);
void set_type(std::string&& value);
void set_type(const char* value);
void set_type(const char* value, size_t size);
std::string* mutable_type();
std::string* release_type();
void set_allocated_type(std::string* type);

// optional .mcs_proto.Extension extension = 4;
bool has_extension() const;
void clear_extension();
const ::mcs_proto::Extension& extension() const;
::mcs_proto::Extension* release_extension();
::mcs_proto::Extension* mutable_extension();
void set_allocated_extension(::mcs_proto::Extension* extension);

// required int32 code = 1;
bool has_code() const;
void clear_code();
::PROTOBUF_NAMESPACE_ID::int32 code() const;
void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:mcs_proto.ErrorInfo)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
::mcs_proto::Extension* extension_;
::PROTOBUF_NAMESPACE_ID::int32 code_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT Setting :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Setting) */ {
public:
Setting();
virtual ~Setting();

Setting(const Setting& from);
Setting(Setting&& from) noexcept
: Setting() {
*this = ::std::move(from);
}

inline Setting& operator=(const Setting& from) {
CopyFrom(from);
return *this;
}
inline Setting& operator=(Setting&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Setting& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Setting* internal_default_instance() {
return reinterpret_cast<const Setting*>(
&_Setting_default_instance_);
}
static constexpr int kIndexInFileMessages =
3;

friend void swap(Setting& a, Setting& b) {
a.Swap(&b);
}
inline void Swap(Setting* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Setting* New() const final {
return CreateMaybeMessage<Setting>(nullptr);
}

Setting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Setting>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Setting& from);
void MergeFrom(const Setting& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Setting* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.Setting";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kValueFieldNumber = 2,
};
// required string name = 1;
bool has_name() const;
void clear_name();
const std::string& name() const;
void set_name(const std::string& value);
void set_name(std::string&& value);
void set_name(const char* value);
void set_name(const char* value, size_t size);
std::string* mutable_name();
std::string* release_name();
void set_allocated_name(std::string* name);

// required string value = 2;
bool has_value() const;
void clear_value();
const std::string& value() const;
void set_value(const std::string& value);
void set_value(std::string&& value);
void set_value(const char* value);
void set_value(const char* value, size_t size);
std::string* mutable_value();
std::string* release_value();
void set_allocated_value(std::string* value);

// @@protoc_insertion_point(class_scope:mcs_proto.Setting)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT HeartbeatStat :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatStat) */ {
public:
HeartbeatStat();
virtual ~HeartbeatStat();

HeartbeatStat(const HeartbeatStat& from);
HeartbeatStat(HeartbeatStat&& from) noexcept
: HeartbeatStat() {
*this = ::std::move(from);
}

inline HeartbeatStat& operator=(const HeartbeatStat& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatStat& operator=(HeartbeatStat&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const HeartbeatStat& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const HeartbeatStat* internal_default_instance() {
return reinterpret_cast<const HeartbeatStat*>(
&_HeartbeatStat_default_instance_);
}
static constexpr int kIndexInFileMessages =
4;

friend void swap(HeartbeatStat& a, HeartbeatStat& b) {
a.Swap(&b);
}
inline void Swap(HeartbeatStat* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline HeartbeatStat* New() const final {
return CreateMaybeMessage<HeartbeatStat>(nullptr);
}

HeartbeatStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<HeartbeatStat>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const HeartbeatStat& from);
void MergeFrom(const HeartbeatStat& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatStat* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatStat";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kIpFieldNumber = 1,
kTimeoutFieldNumber = 2,
kIntervalMsFieldNumber = 3,
};
// required string ip = 1;
bool has_ip() const;
void clear_ip();
const std::string& ip() const;
void set_ip(const std::string& value);
void set_ip(std::string&& value);
void set_ip(const char* value);
void set_ip(const char* value, size_t size);
std::string* mutable_ip();
std::string* release_ip();
void set_allocated_ip(std::string* ip);

// required bool timeout = 2;
bool has_timeout() const;
void clear_timeout();
bool timeout() const;
void set_timeout(bool value);

// required int32 interval_ms = 3;
bool has_interval_ms() const;
void clear_interval_ms();
::PROTOBUF_NAMESPACE_ID::int32 interval_ms() const;
void set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatStat)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
bool timeout_;
::PROTOBUF_NAMESPACE_ID::int32 interval_ms_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT HeartbeatConfig :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatConfig) */ {
public:
HeartbeatConfig();
virtual ~HeartbeatConfig();

HeartbeatConfig(const HeartbeatConfig& from);
HeartbeatConfig(HeartbeatConfig&& from) noexcept
: HeartbeatConfig() {
*this = ::std::move(from);
}

inline HeartbeatConfig& operator=(const HeartbeatConfig& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatConfig& operator=(HeartbeatConfig&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const HeartbeatConfig& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const HeartbeatConfig* internal_default_instance() {
return reinterpret_cast<const HeartbeatConfig*>(
&_HeartbeatConfig_default_instance_);
}
static constexpr int kIndexInFileMessages =
5;

friend void swap(HeartbeatConfig& a, HeartbeatConfig& b) {
a.Swap(&b);
}
inline void Swap(HeartbeatConfig* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline HeartbeatConfig* New() const final {
return CreateMaybeMessage<HeartbeatConfig>(nullptr);
}

HeartbeatConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<HeartbeatConfig>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const HeartbeatConfig& from);
void MergeFrom(const HeartbeatConfig& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatConfig* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatConfig";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kIpFieldNumber = 2,
kUploadStatFieldNumber = 1,
kIntervalMsFieldNumber = 3,
};
// optional string ip = 2;
bool has_ip() const;
void clear_ip();
const std::string& ip() const;
void set_ip(const std::string& value);
void set_ip(std::string&& value);
void set_ip(const char* value);
void set_ip(const char* value, size_t size);
std::string* mutable_ip();
std::string* release_ip();
void set_allocated_ip(std::string* ip);

// optional bool upload_stat = 1;
bool has_upload_stat() const;
void clear_upload_stat();
bool upload_stat() const;
void set_upload_stat(bool value);

// optional int32 interval_ms = 3;
bool has_interval_ms() const;
void clear_interval_ms();
::PROTOBUF_NAMESPACE_ID::int32 interval_ms() const;
void set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatConfig)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
bool upload_stat_;
::PROTOBUF_NAMESPACE_ID::int32 interval_ms_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT ClientEvent :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ClientEvent) */ {
public:
ClientEvent();
virtual ~ClientEvent();

ClientEvent(const ClientEvent& from);
ClientEvent(ClientEvent&& from) noexcept
: ClientEvent() {
*this = ::std::move(from);
}

inline ClientEvent& operator=(const ClientEvent& from) {
CopyFrom(from);
return *this;
}
inline ClientEvent& operator=(ClientEvent&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const ClientEvent& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const ClientEvent* internal_default_instance() {
return reinterpret_cast<const ClientEvent*>(
&_ClientEvent_default_instance_);
}
static constexpr int kIndexInFileMessages =
6;

friend void swap(ClientEvent& a, ClientEvent& b) {
a.Swap(&b);
}
inline void Swap(ClientEvent* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline ClientEvent* New() const final {
return CreateMaybeMessage<ClientEvent>(nullptr);
}

ClientEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<ClientEvent>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const ClientEvent& from);
void MergeFrom(const ClientEvent& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ClientEvent* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.ClientEvent";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef ClientEvent_Type Type;
static constexpr Type UNKNOWN =
ClientEvent_Type_UNKNOWN;
static constexpr Type DISCARDED_EVENTS =
ClientEvent_Type_DISCARDED_EVENTS;
static constexpr Type FAILED_CONNECTION =
ClientEvent_Type_FAILED_CONNECTION;
static constexpr Type SUCCESSFUL_CONNECTION =
ClientEvent_Type_SUCCESSFUL_CONNECTION;
static inline bool Type_IsValid(int value) {
return ClientEvent_Type_IsValid(value);
}
static constexpr Type Type_MIN =
ClientEvent_Type_Type_MIN;
static constexpr Type Type_MAX =
ClientEvent_Type_Type_MAX;
static constexpr int Type_ARRAYSIZE =
ClientEvent_Type_Type_ARRAYSIZE;
template<typename T>
static inline const std::string& Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Type_Name.");
return ClientEvent_Type_Name(enum_t_value);
}
static inline bool Type_Parse(const std::string& name,
Type* value) {
return ClientEvent_Type_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kTypeFieldNumber = 1,
kNumberDiscardedEventsFieldNumber = 100,
kTimeConnectionStartedMsFieldNumber = 202,
kNetworkTypeFieldNumber = 200,
kErrorCodeFieldNumber = 204,
kTimeConnectionEndedMsFieldNumber = 203,
kTimeConnectionEstablishedMsFieldNumber = 300,
};
// optional .mcs_proto.ClientEvent.Type type = 1;
bool has_type() const;
void clear_type();
::mcs_proto::ClientEvent_Type type() const;
void set_type(::mcs_proto::ClientEvent_Type value);

// optional uint32 number_discarded_events = 100;
bool has_number_discarded_events() const;
void clear_number_discarded_events();
::PROTOBUF_NAMESPACE_ID::uint32 number_discarded_events() const;
void set_number_discarded_events(::PROTOBUF_NAMESPACE_ID::uint32 value);

// optional uint64 time_connection_started_ms = 202;
bool has_time_connection_started_ms() const;
void clear_time_connection_started_ms();
::PROTOBUF_NAMESPACE_ID::uint64 time_connection_started_ms() const;
void set_time_connection_started_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional int32 network_type = 200;
bool has_network_type() const;
void clear_network_type();
::PROTOBUF_NAMESPACE_ID::int32 network_type() const;
void set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 error_code = 204;
bool has_error_code() const;
void clear_error_code();
::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional uint64 time_connection_ended_ms = 203;
bool has_time_connection_ended_ms() const;
void clear_time_connection_ended_ms();
::PROTOBUF_NAMESPACE_ID::uint64 time_connection_ended_ms() const;
void set_time_connection_ended_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);

// optional uint64 time_connection_established_ms = 300;
bool has_time_connection_established_ms() const;
void clear_time_connection_established_ms();
::PROTOBUF_NAMESPACE_ID::uint64 time_connection_established_ms() const;
void set_time_connection_established_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);

// @@protoc_insertion_point(class_scope:mcs_proto.ClientEvent)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int type_;
::PROTOBUF_NAMESPACE_ID::uint32 number_discarded_events_;
::PROTOBUF_NAMESPACE_ID::uint64 time_connection_started_ms_;
::PROTOBUF_NAMESPACE_ID::int32 network_type_;
::PROTOBUF_NAMESPACE_ID::int32 error_code_;
::PROTOBUF_NAMESPACE_ID::uint64 time_connection_ended_ms_;
::PROTOBUF_NAMESPACE_ID::uint64 time_connection_established_ms_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT LoginRequest :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginRequest) */ {
public:
LoginRequest();
virtual ~LoginRequest();

LoginRequest(const LoginRequest& from);
LoginRequest(LoginRequest&& from) noexcept
: LoginRequest() {
*this = ::std::move(from);
}

inline LoginRequest& operator=(const LoginRequest& from) {
CopyFrom(from);
return *this;
}
inline LoginRequest& operator=(LoginRequest&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const LoginRequest& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const LoginRequest* internal_default_instance() {
return reinterpret_cast<const LoginRequest*>(
&_LoginRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
7;

friend void swap(LoginRequest& a, LoginRequest& b) {
a.Swap(&b);
}
inline void Swap(LoginRequest* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline LoginRequest* New() const final {
return CreateMaybeMessage<LoginRequest>(nullptr);
}

LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<LoginRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const LoginRequest& from);
void MergeFrom(const LoginRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LoginRequest* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.LoginRequest";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef LoginRequest_AuthService AuthService;
static constexpr AuthService ANDROID_ID =
LoginRequest_AuthService_ANDROID_ID;
static inline bool AuthService_IsValid(int value) {
return LoginRequest_AuthService_IsValid(value);
}
static constexpr AuthService AuthService_MIN =
LoginRequest_AuthService_AuthService_MIN;
static constexpr AuthService AuthService_MAX =
LoginRequest_AuthService_AuthService_MAX;
static constexpr int AuthService_ARRAYSIZE =
LoginRequest_AuthService_AuthService_ARRAYSIZE;
template<typename T>
static inline const std::string& AuthService_Name(T enum_t_value) {
static_assert(::std::is_same<T, AuthService>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AuthService_Name.");
return LoginRequest_AuthService_Name(enum_t_value);
}
static inline bool AuthService_Parse(const std::string& name,
AuthService* value) {
return LoginRequest_AuthService_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kSettingFieldNumber = 8,
kReceivedPersistentIdFieldNumber = 10,
kClientEventFieldNumber = 22,
kIdFieldNumber = 1,
kDomainFieldNumber = 2,
kUserFieldNumber = 3,
kResourceFieldNumber = 4,
kAuthTokenFieldNumber = 5,
kDeviceIdFieldNumber = 6,
kHeartbeatStatFieldNumber = 13,
kLastRmqIdFieldNumber = 7,
kAdaptiveHeartbeatFieldNumber = 12,
kUseRmq2FieldNumber = 14,
kNetworkTypeFieldNumber = 17,
kAccountIdFieldNumber = 15,
kStatusFieldNumber = 18,
kAuthServiceFieldNumber = 16,
};
// repeated .mcs_proto.Setting setting = 8;
int setting_size() const;
void clear_setting();
::mcs_proto::Setting* mutable_setting(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
mutable_setting();
const ::mcs_proto::Setting& setting(int index) const;
::mcs_proto::Setting* add_setting();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
setting() const;

// repeated string received_persistent_id = 10;
int received_persistent_id_size() const;
void clear_received_persistent_id();
const std::string& received_persistent_id(int index) const;
std::string* mutable_received_persistent_id(int index);
void set_received_persistent_id(int index, const std::string& value);
void set_received_persistent_id(int index, std::string&& value);
void set_received_persistent_id(int index, const char* value);
void set_received_persistent_id(int index, const char* value, size_t size);
std::string* add_received_persistent_id();
void add_received_persistent_id(const std::string& value);
void add_received_persistent_id(std::string&& value);
void add_received_persistent_id(const char* value);
void add_received_persistent_id(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& received_persistent_id() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_received_persistent_id();

// repeated .mcs_proto.ClientEvent client_event = 22;
int client_event_size() const;
void clear_client_event();
::mcs_proto::ClientEvent* mutable_client_event(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >*
mutable_client_event();
const ::mcs_proto::ClientEvent& client_event(int index) const;
::mcs_proto::ClientEvent* add_client_event();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >&
client_event() const;

// required string id = 1;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// required string domain = 2;
bool has_domain() const;
void clear_domain();
const std::string& domain() const;
void set_domain(const std::string& value);
void set_domain(std::string&& value);
void set_domain(const char* value);
void set_domain(const char* value, size_t size);
std::string* mutable_domain();
std::string* release_domain();
void set_allocated_domain(std::string* domain);

// required string user = 3;
bool has_user() const;
void clear_user();
const std::string& user() const;
void set_user(const std::string& value);
void set_user(std::string&& value);
void set_user(const char* value);
void set_user(const char* value, size_t size);
std::string* mutable_user();
std::string* release_user();
void set_allocated_user(std::string* user);

// required string resource = 4;
bool has_resource() const;
void clear_resource();
const std::string& resource() const;
void set_resource(const std::string& value);
void set_resource(std::string&& value);
void set_resource(const char* value);
void set_resource(const char* value, size_t size);
std::string* mutable_resource();
std::string* release_resource();
void set_allocated_resource(std::string* resource);

// required string auth_token = 5;
bool has_auth_token() const;
void clear_auth_token();
const std::string& auth_token() const;
void set_auth_token(const std::string& value);
void set_auth_token(std::string&& value);
void set_auth_token(const char* value);
void set_auth_token(const char* value, size_t size);
std::string* mutable_auth_token();
std::string* release_auth_token();
void set_allocated_auth_token(std::string* auth_token);

// optional string device_id = 6;
bool has_device_id() const;
void clear_device_id();
const std::string& device_id() const;
void set_device_id(const std::string& value);
void set_device_id(std::string&& value);
void set_device_id(const char* value);
void set_device_id(const char* value, size_t size);
std::string* mutable_device_id();
std::string* release_device_id();
void set_allocated_device_id(std::string* device_id);

// optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
bool has_heartbeat_stat() const;
void clear_heartbeat_stat();
const ::mcs_proto::HeartbeatStat& heartbeat_stat() const;
::mcs_proto::HeartbeatStat* release_heartbeat_stat();
::mcs_proto::HeartbeatStat* mutable_heartbeat_stat();
void set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat);

// optional int64 last_rmq_id = 7;
bool has_last_rmq_id() const;
void clear_last_rmq_id();
::PROTOBUF_NAMESPACE_ID::int64 last_rmq_id() const;
void set_last_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional bool adaptive_heartbeat = 12;
bool has_adaptive_heartbeat() const;
void clear_adaptive_heartbeat();
bool adaptive_heartbeat() const;
void set_adaptive_heartbeat(bool value);

// optional bool use_rmq2 = 14;
bool has_use_rmq2() const;
void clear_use_rmq2();
bool use_rmq2() const;
void set_use_rmq2(bool value);

// optional int32 network_type = 17;
bool has_network_type() const;
void clear_network_type();
::PROTOBUF_NAMESPACE_ID::int32 network_type() const;
void set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 account_id = 15;
bool has_account_id() const;
void clear_account_id();
::PROTOBUF_NAMESPACE_ID::int64 account_id() const;
void set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 status = 18;
bool has_status() const;
void clear_status();
::PROTOBUF_NAMESPACE_ID::int64 status() const;
void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
bool has_auth_service() const;
void clear_auth_service();
::mcs_proto::LoginRequest_AuthService auth_service() const;
void set_auth_service(::mcs_proto::LoginRequest_AuthService value);

// @@protoc_insertion_point(class_scope:mcs_proto.LoginRequest)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting > setting_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> received_persistent_id_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent > client_event_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
::mcs_proto::HeartbeatStat* heartbeat_stat_;
::PROTOBUF_NAMESPACE_ID::int64 last_rmq_id_;
bool adaptive_heartbeat_;
bool use_rmq2_;
::PROTOBUF_NAMESPACE_ID::int32 network_type_;
::PROTOBUF_NAMESPACE_ID::int64 account_id_;
::PROTOBUF_NAMESPACE_ID::int64 status_;
int auth_service_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT LoginResponse :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginResponse) */ {
public:
LoginResponse();
virtual ~LoginResponse();

LoginResponse(const LoginResponse& from);
LoginResponse(LoginResponse&& from) noexcept
: LoginResponse() {
*this = ::std::move(from);
}

inline LoginResponse& operator=(const LoginResponse& from) {
CopyFrom(from);
return *this;
}
inline LoginResponse& operator=(LoginResponse&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const LoginResponse& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const LoginResponse* internal_default_instance() {
return reinterpret_cast<const LoginResponse*>(
&_LoginResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
8;

friend void swap(LoginResponse& a, LoginResponse& b) {
a.Swap(&b);
}
inline void Swap(LoginResponse* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline LoginResponse* New() const final {
return CreateMaybeMessage<LoginResponse>(nullptr);
}

LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<LoginResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const LoginResponse& from);
void MergeFrom(const LoginResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LoginResponse* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.LoginResponse";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSettingFieldNumber = 4,
kIdFieldNumber = 1,
kJidFieldNumber = 2,
kErrorFieldNumber = 3,
kHeartbeatConfigFieldNumber = 7,
kStreamIdFieldNumber = 5,
kLastStreamIdReceivedFieldNumber = 6,
kServerTimestampFieldNumber = 8,
};
// repeated .mcs_proto.Setting setting = 4;
int setting_size() const;
void clear_setting();
::mcs_proto::Setting* mutable_setting(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
mutable_setting();
const ::mcs_proto::Setting& setting(int index) const;
::mcs_proto::Setting* add_setting();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
setting() const;

// required string id = 1;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// optional string jid = 2;
bool has_jid() const;
void clear_jid();
const std::string& jid() const;
void set_jid(const std::string& value);
void set_jid(std::string&& value);
void set_jid(const char* value);
void set_jid(const char* value, size_t size);
std::string* mutable_jid();
std::string* release_jid();
void set_allocated_jid(std::string* jid);

// optional .mcs_proto.ErrorInfo error = 3;
bool has_error() const;
void clear_error();
const ::mcs_proto::ErrorInfo& error() const;
::mcs_proto::ErrorInfo* release_error();
::mcs_proto::ErrorInfo* mutable_error();
void set_allocated_error(::mcs_proto::ErrorInfo* error);

// optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
bool has_heartbeat_config() const;
void clear_heartbeat_config();
const ::mcs_proto::HeartbeatConfig& heartbeat_config() const;
::mcs_proto::HeartbeatConfig* release_heartbeat_config();
::mcs_proto::HeartbeatConfig* mutable_heartbeat_config();
void set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config);

// optional int32 stream_id = 5;
bool has_stream_id() const;
void clear_stream_id();
::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 last_stream_id_received = 6;
bool has_last_stream_id_received() const;
void clear_last_stream_id_received();
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 server_timestamp = 8;
bool has_server_timestamp() const;
void clear_server_timestamp();
::PROTOBUF_NAMESPACE_ID::int64 server_timestamp() const;
void set_server_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:mcs_proto.LoginResponse)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting > setting_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jid_;
::mcs_proto::ErrorInfo* error_;
::mcs_proto::HeartbeatConfig* heartbeat_config_;
::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
::PROTOBUF_NAMESPACE_ID::int64 server_timestamp_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT StreamErrorStanza :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamErrorStanza) */ {
public:
StreamErrorStanza();
virtual ~StreamErrorStanza();

StreamErrorStanza(const StreamErrorStanza& from);
StreamErrorStanza(StreamErrorStanza&& from) noexcept
: StreamErrorStanza() {
*this = ::std::move(from);
}

inline StreamErrorStanza& operator=(const StreamErrorStanza& from) {
CopyFrom(from);
return *this;
}
inline StreamErrorStanza& operator=(StreamErrorStanza&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const StreamErrorStanza& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const StreamErrorStanza* internal_default_instance() {
return reinterpret_cast<const StreamErrorStanza*>(
&_StreamErrorStanza_default_instance_);
}
static constexpr int kIndexInFileMessages =
9;

friend void swap(StreamErrorStanza& a, StreamErrorStanza& b) {
a.Swap(&b);
}
inline void Swap(StreamErrorStanza* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline StreamErrorStanza* New() const final {
return CreateMaybeMessage<StreamErrorStanza>(nullptr);
}

StreamErrorStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<StreamErrorStanza>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const StreamErrorStanza& from);
void MergeFrom(const StreamErrorStanza& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StreamErrorStanza* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.StreamErrorStanza";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kTypeFieldNumber = 1,
kTextFieldNumber = 2,
};
// required string type = 1;
bool has_type() const;
void clear_type();
const std::string& type() const;
void set_type(const std::string& value);
void set_type(std::string&& value);
void set_type(const char* value);
void set_type(const char* value, size_t size);
std::string* mutable_type();
std::string* release_type();
void set_allocated_type(std::string* type);

// optional string text = 2;
bool has_text() const;
void clear_text();
const std::string& text() const;
void set_text(const std::string& value);
void set_text(std::string&& value);
void set_text(const char* value);
void set_text(const char* value, size_t size);
std::string* mutable_text();
std::string* release_text();
void set_allocated_text(std::string* text);

// @@protoc_insertion_point(class_scope:mcs_proto.StreamErrorStanza)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT Close :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Close) */ {
public:
Close();
virtual ~Close();

Close(const Close& from);
Close(Close&& from) noexcept
: Close() {
*this = ::std::move(from);
}

inline Close& operator=(const Close& from) {
CopyFrom(from);
return *this;
}
inline Close& operator=(Close&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Close& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Close* internal_default_instance() {
return reinterpret_cast<const Close*>(
&_Close_default_instance_);
}
static constexpr int kIndexInFileMessages =
10;

friend void swap(Close& a, Close& b) {
a.Swap(&b);
}
inline void Swap(Close* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Close* New() const final {
return CreateMaybeMessage<Close>(nullptr);
}

Close* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Close>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Close& from);
void MergeFrom(const Close& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Close* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.Close";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:mcs_proto.Close)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT Extension :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Extension) */ {
public:
Extension();
virtual ~Extension();

Extension(const Extension& from);
Extension(Extension&& from) noexcept
: Extension() {
*this = ::std::move(from);
}

inline Extension& operator=(const Extension& from) {
CopyFrom(from);
return *this;
}
inline Extension& operator=(Extension&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Extension& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Extension* internal_default_instance() {
return reinterpret_cast<const Extension*>(
&_Extension_default_instance_);
}
static constexpr int kIndexInFileMessages =
11;

friend void swap(Extension& a, Extension& b) {
a.Swap(&b);
}
inline void Swap(Extension* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Extension* New() const final {
return CreateMaybeMessage<Extension>(nullptr);
}

Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Extension>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Extension& from);
void MergeFrom(const Extension& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Extension* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.Extension";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kDataFieldNumber = 2,
kIdFieldNumber = 1,
};
// required bytes data = 2;
bool has_data() const;
void clear_data();
const std::string& data() const;
void set_data(const std::string& value);
void set_data(std::string&& value);
void set_data(const char* value);
void set_data(const void* value, size_t size);
std::string* mutable_data();
std::string* release_data();
void set_allocated_data(std::string* data);

// required int32 id = 1;
bool has_id() const;
void clear_id();
::PROTOBUF_NAMESPACE_ID::int32 id() const;
void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:mcs_proto.Extension)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
::PROTOBUF_NAMESPACE_ID::int32 id_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT IqStanza :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.IqStanza) */ {
public:
IqStanza();
virtual ~IqStanza();

IqStanza(const IqStanza& from);
IqStanza(IqStanza&& from) noexcept
: IqStanza() {
*this = ::std::move(from);
}

inline IqStanza& operator=(const IqStanza& from) {
CopyFrom(from);
return *this;
}
inline IqStanza& operator=(IqStanza&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const IqStanza& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const IqStanza* internal_default_instance() {
return reinterpret_cast<const IqStanza*>(
&_IqStanza_default_instance_);
}
static constexpr int kIndexInFileMessages =
12;

friend void swap(IqStanza& a, IqStanza& b) {
a.Swap(&b);
}
inline void Swap(IqStanza* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline IqStanza* New() const final {
return CreateMaybeMessage<IqStanza>(nullptr);
}

IqStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<IqStanza>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const IqStanza& from);
void MergeFrom(const IqStanza& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(IqStanza* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.IqStanza";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef IqStanza_IqType IqType;
static constexpr IqType GET =
IqStanza_IqType_GET;
static constexpr IqType SET =
IqStanza_IqType_SET;
static constexpr IqType RESULT =
IqStanza_IqType_RESULT;
static constexpr IqType IQ_ERROR =
IqStanza_IqType_IQ_ERROR;
static inline bool IqType_IsValid(int value) {
return IqStanza_IqType_IsValid(value);
}
static constexpr IqType IqType_MIN =
IqStanza_IqType_IqType_MIN;
static constexpr IqType IqType_MAX =
IqStanza_IqType_IqType_MAX;
static constexpr int IqType_ARRAYSIZE =
IqStanza_IqType_IqType_ARRAYSIZE;
template<typename T>
static inline const std::string& IqType_Name(T enum_t_value) {
static_assert(::std::is_same<T, IqType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function IqType_Name.");
return IqStanza_IqType_Name(enum_t_value);
}
static inline bool IqType_Parse(const std::string& name,
IqType* value) {
return IqStanza_IqType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kIdFieldNumber = 3,
kFromFieldNumber = 4,
kToFieldNumber = 5,
kPersistentIdFieldNumber = 8,
kErrorFieldNumber = 6,
kExtensionFieldNumber = 7,
kRmqIdFieldNumber = 1,
kTypeFieldNumber = 2,
kStreamIdFieldNumber = 9,
kAccountIdFieldNumber = 11,
kStatusFieldNumber = 12,
kLastStreamIdReceivedFieldNumber = 10,
};
// required string id = 3;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// optional string from = 4;
bool has_from() const;
void clear_from();
const std::string& from() const;
void set_from(const std::string& value);
void set_from(std::string&& value);
void set_from(const char* value);
void set_from(const char* value, size_t size);
std::string* mutable_from();
std::string* release_from();
void set_allocated_from(std::string* from);

// optional string to = 5;
bool has_to() const;
void clear_to();
const std::string& to() const;
void set_to(const std::string& value);
void set_to(std::string&& value);
void set_to(const char* value);
void set_to(const char* value, size_t size);
std::string* mutable_to();
std::string* release_to();
void set_allocated_to(std::string* to);

// optional string persistent_id = 8;
bool has_persistent_id() const;
void clear_persistent_id();
const std::string& persistent_id() const;
void set_persistent_id(const std::string& value);
void set_persistent_id(std::string&& value);
void set_persistent_id(const char* value);
void set_persistent_id(const char* value, size_t size);
std::string* mutable_persistent_id();
std::string* release_persistent_id();
void set_allocated_persistent_id(std::string* persistent_id);

// optional .mcs_proto.ErrorInfo error = 6;
bool has_error() const;
void clear_error();
const ::mcs_proto::ErrorInfo& error() const;
::mcs_proto::ErrorInfo* release_error();
::mcs_proto::ErrorInfo* mutable_error();
void set_allocated_error(::mcs_proto::ErrorInfo* error);

// optional .mcs_proto.Extension extension = 7;
bool has_extension() const;
void clear_extension();
const ::mcs_proto::Extension& extension() const;
::mcs_proto::Extension* release_extension();
::mcs_proto::Extension* mutable_extension();
void set_allocated_extension(::mcs_proto::Extension* extension);

// optional int64 rmq_id = 1;
bool has_rmq_id() const;
void clear_rmq_id();
::PROTOBUF_NAMESPACE_ID::int64 rmq_id() const;
void set_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// required .mcs_proto.IqStanza.IqType type = 2;
bool has_type() const;
void clear_type();
::mcs_proto::IqStanza_IqType type() const;
void set_type(::mcs_proto::IqStanza_IqType value);

// optional int32 stream_id = 9;
bool has_stream_id() const;
void clear_stream_id();
::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 account_id = 11;
bool has_account_id() const;
void clear_account_id();
::PROTOBUF_NAMESPACE_ID::int64 account_id() const;
void set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int64 status = 12;
bool has_status() const;
void clear_status();
::PROTOBUF_NAMESPACE_ID::int64 status() const;
void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 last_stream_id_received = 10;
bool has_last_stream_id_received() const;
void clear_last_stream_id_received();
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:mcs_proto.IqStanza)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persistent_id_;
::mcs_proto::ErrorInfo* error_;
::mcs_proto::Extension* extension_;
::PROTOBUF_NAMESPACE_ID::int64 rmq_id_;
int type_;
::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
::PROTOBUF_NAMESPACE_ID::int64 account_id_;
::PROTOBUF_NAMESPACE_ID::int64 status_;
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT AppData :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.AppData) */ {
public:
AppData();
virtual ~AppData();

AppData(const AppData& from);
AppData(AppData&& from) noexcept
: AppData() {
*this = ::std::move(from);
}

inline AppData& operator=(const AppData& from) {
CopyFrom(from);
return *this;
}
inline AppData& operator=(AppData&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const AppData& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const AppData* internal_default_instance() {
return reinterpret_cast<const AppData*>(
&_AppData_default_instance_);
}
static constexpr int kIndexInFileMessages =
13;

friend void swap(AppData& a, AppData& b) {
a.Swap(&b);
}
inline void Swap(AppData* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline AppData* New() const final {
return CreateMaybeMessage<AppData>(nullptr);
}

AppData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<AppData>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const AppData& from);
void MergeFrom(const AppData& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppData* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.AppData";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kKeyFieldNumber = 1,
kValueFieldNumber = 2,
};
// required string key = 1;
bool has_key() const;
void clear_key();
const std::string& key() const;
void set_key(const std::string& value);
void set_key(std::string&& value);
void set_key(const char* value);
void set_key(const char* value, size_t size);
std::string* mutable_key();
std::string* release_key();
void set_allocated_key(std::string* key);

// required string value = 2;
bool has_value() const;
void clear_value();
const std::string& value() const;
void set_value(const std::string& value);
void set_value(std::string&& value);
void set_value(const char* value);
void set_value(const char* value, size_t size);
std::string* mutable_value();
std::string* release_value();
void set_allocated_value(std::string* value);

// @@protoc_insertion_point(class_scope:mcs_proto.AppData)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT DataMessageStanza :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.DataMessageStanza) */ {
public:
DataMessageStanza();
virtual ~DataMessageStanza();

DataMessageStanza(const DataMessageStanza& from);
DataMessageStanza(DataMessageStanza&& from) noexcept
: DataMessageStanza() {
*this = ::std::move(from);
}

inline DataMessageStanza& operator=(const DataMessageStanza& from) {
CopyFrom(from);
return *this;
}
inline DataMessageStanza& operator=(DataMessageStanza&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const DataMessageStanza& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const DataMessageStanza* internal_default_instance() {
return reinterpret_cast<const DataMessageStanza*>(
&_DataMessageStanza_default_instance_);
}
static constexpr int kIndexInFileMessages =
14;

friend void swap(DataMessageStanza& a, DataMessageStanza& b) {
a.Swap(&b);
}
inline void Swap(DataMessageStanza* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline DataMessageStanza* New() const final {
return CreateMaybeMessage<DataMessageStanza>(nullptr);
}

DataMessageStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<DataMessageStanza>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const DataMessageStanza& from);
void MergeFrom(const DataMessageStanza& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DataMessageStanza* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.DataMessageStanza";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAppDataFieldNumber = 7,
kIdFieldNumber = 2,
kFromFieldNumber = 3,
kToFieldNumber = 4,
kCategoryFieldNumber = 5,
kTokenFieldNumber = 6,
kPersistentIdFieldNumber = 9,
kRegIdFieldNumber = 13,
kRawDataFieldNumber = 21,
kStreamIdFieldNumber = 10,
kLastStreamIdReceivedFieldNumber = 11,
kDeviceUserIdFieldNumber = 16,
kFromTrustedServerFieldNumber = 8,
kImmediateAckFieldNumber = 24,
kTtlFieldNumber = 17,
kSentFieldNumber = 18,
kQueuedFieldNumber = 19,
kStatusFieldNumber = 20,
};
// repeated .mcs_proto.AppData app_data = 7;
int app_data_size() const;
void clear_app_data();
::mcs_proto::AppData* mutable_app_data(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >*
mutable_app_data();
const ::mcs_proto::AppData& app_data(int index) const;
::mcs_proto::AppData* add_app_data();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >&
app_data() const;

// optional string id = 2;
bool has_id() const;
void clear_id();
const std::string& id() const;
void set_id(const std::string& value);
void set_id(std::string&& value);
void set_id(const char* value);
void set_id(const char* value, size_t size);
std::string* mutable_id();
std::string* release_id();
void set_allocated_id(std::string* id);

// required string from = 3;
bool has_from() const;
void clear_from();
const std::string& from() const;
void set_from(const std::string& value);
void set_from(std::string&& value);
void set_from(const char* value);
void set_from(const char* value, size_t size);
std::string* mutable_from();
std::string* release_from();
void set_allocated_from(std::string* from);

// optional string to = 4;
bool has_to() const;
void clear_to();
const std::string& to() const;
void set_to(const std::string& value);
void set_to(std::string&& value);
void set_to(const char* value);
void set_to(const char* value, size_t size);
std::string* mutable_to();
std::string* release_to();
void set_allocated_to(std::string* to);

// required string category = 5;
bool has_category() const;
void clear_category();
const std::string& category() const;
void set_category(const std::string& value);
void set_category(std::string&& value);
void set_category(const char* value);
void set_category(const char* value, size_t size);
std::string* mutable_category();
std::string* release_category();
void set_allocated_category(std::string* category);

// optional string token = 6;
bool has_token() const;
void clear_token();
const std::string& token() const;
void set_token(const std::string& value);
void set_token(std::string&& value);
void set_token(const char* value);
void set_token(const char* value, size_t size);
std::string* mutable_token();
std::string* release_token();
void set_allocated_token(std::string* token);

// optional string persistent_id = 9;
bool has_persistent_id() const;
void clear_persistent_id();
const std::string& persistent_id() const;
void set_persistent_id(const std::string& value);
void set_persistent_id(std::string&& value);
void set_persistent_id(const char* value);
void set_persistent_id(const char* value, size_t size);
std::string* mutable_persistent_id();
std::string* release_persistent_id();
void set_allocated_persistent_id(std::string* persistent_id);

// optional string reg_id = 13;
bool has_reg_id() const;
void clear_reg_id();
const std::string& reg_id() const;
void set_reg_id(const std::string& value);
void set_reg_id(std::string&& value);
void set_reg_id(const char* value);
void set_reg_id(const char* value, size_t size);
std::string* mutable_reg_id();
std::string* release_reg_id();
void set_allocated_reg_id(std::string* reg_id);

// optional bytes raw_data = 21;
bool has_raw_data() const;
void clear_raw_data();
const std::string& raw_data() const;
void set_raw_data(const std::string& value);
void set_raw_data(std::string&& value);
void set_raw_data(const char* value);
void set_raw_data(const void* value, size_t size);
std::string* mutable_raw_data();
std::string* release_raw_data();
void set_allocated_raw_data(std::string* raw_data);

// optional int32 stream_id = 10;
bool has_stream_id() const;
void clear_stream_id();
::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int32 last_stream_id_received = 11;
bool has_last_stream_id_received() const;
void clear_last_stream_id_received();
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 device_user_id = 16;
bool has_device_user_id() const;
void clear_device_user_id();
::PROTOBUF_NAMESPACE_ID::int64 device_user_id() const;
void set_device_user_id(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional bool from_trusted_server = 8;
bool has_from_trusted_server() const;
void clear_from_trusted_server();
bool from_trusted_server() const;
void set_from_trusted_server(bool value);

// optional bool immediate_ack = 24;
bool has_immediate_ack() const;
void clear_immediate_ack();
bool immediate_ack() const;
void set_immediate_ack(bool value);

// optional int32 ttl = 17;
bool has_ttl() const;
void clear_ttl();
::PROTOBUF_NAMESPACE_ID::int32 ttl() const;
void set_ttl(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 sent = 18;
bool has_sent() const;
void clear_sent();
::PROTOBUF_NAMESPACE_ID::int64 sent() const;
void set_sent(::PROTOBUF_NAMESPACE_ID::int64 value);

// optional int32 queued = 19;
bool has_queued() const;
void clear_queued();
::PROTOBUF_NAMESPACE_ID::int32 queued() const;
void set_queued(::PROTOBUF_NAMESPACE_ID::int32 value);

// optional int64 status = 20;
bool has_status() const;
void clear_status();
::PROTOBUF_NAMESPACE_ID::int64 status() const;
void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);

// @@protoc_insertion_point(class_scope:mcs_proto.DataMessageStanza)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData > app_data_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persistent_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reg_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
::PROTOBUF_NAMESPACE_ID::int64 device_user_id_;
bool from_trusted_server_;
bool immediate_ack_;
::PROTOBUF_NAMESPACE_ID::int32 ttl_;
::PROTOBUF_NAMESPACE_ID::int64 sent_;
::PROTOBUF_NAMESPACE_ID::int32 queued_;
::PROTOBUF_NAMESPACE_ID::int64 status_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT StreamAck :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamAck) */ {
public:
StreamAck();
virtual ~StreamAck();

StreamAck(const StreamAck& from);
StreamAck(StreamAck&& from) noexcept
: StreamAck() {
*this = ::std::move(from);
}

inline StreamAck& operator=(const StreamAck& from) {
CopyFrom(from);
return *this;
}
inline StreamAck& operator=(StreamAck&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const StreamAck& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const StreamAck* internal_default_instance() {
return reinterpret_cast<const StreamAck*>(
&_StreamAck_default_instance_);
}
static constexpr int kIndexInFileMessages =
15;

friend void swap(StreamAck& a, StreamAck& b) {
a.Swap(&b);
}
inline void Swap(StreamAck* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline StreamAck* New() const final {
return CreateMaybeMessage<StreamAck>(nullptr);
}

StreamAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<StreamAck>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const StreamAck& from);
void MergeFrom(const StreamAck& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StreamAck* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.StreamAck";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:mcs_proto.StreamAck)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT SelectiveAck :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.SelectiveAck) */ {
public:
SelectiveAck();
virtual ~SelectiveAck();

SelectiveAck(const SelectiveAck& from);
SelectiveAck(SelectiveAck&& from) noexcept
: SelectiveAck() {
*this = ::std::move(from);
}

inline SelectiveAck& operator=(const SelectiveAck& from) {
CopyFrom(from);
return *this;
}
inline SelectiveAck& operator=(SelectiveAck&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const SelectiveAck& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const SelectiveAck* internal_default_instance() {
return reinterpret_cast<const SelectiveAck*>(
&_SelectiveAck_default_instance_);
}
static constexpr int kIndexInFileMessages =
16;

friend void swap(SelectiveAck& a, SelectiveAck& b) {
a.Swap(&b);
}
inline void Swap(SelectiveAck* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline SelectiveAck* New() const final {
return CreateMaybeMessage<SelectiveAck>(nullptr);
}

SelectiveAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<SelectiveAck>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const SelectiveAck& from);
void MergeFrom(const SelectiveAck& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SelectiveAck* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.SelectiveAck";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kIdFieldNumber = 1,
};
// repeated string id = 1;
int id_size() const;
void clear_id();
const std::string& id(int index) const;
std::string* mutable_id(int index);
void set_id(int index, const std::string& value);
void set_id(int index, std::string&& value);
void set_id(int index, const char* value);
void set_id(int index, const char* value, size_t size);
std::string* add_id();
void add_id(const std::string& value);
void add_id(std::string&& value);
void add_id(const char* value);
void add_id(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();

// @@protoc_insertion_point(class_scope:mcs_proto.SelectiveAck)
private:
class _Internal;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
friend struct ::TableStruct_mcs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatPing

// optional int32 stream_id = 1;
inline bool HeartbeatPing::has_stream_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatPing::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatPing::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.stream_id)
return stream_id_;
}
inline void HeartbeatPing::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000001u;
stream_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatPing::has_last_stream_id_received() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatPing::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatPing::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.last_stream_id_received)
return last_stream_id_received_;
}
inline void HeartbeatPing::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
last_stream_id_received_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatPing::has_status() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatPing::clear_status() {
status_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeartbeatPing::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.status)
return status_;
}
inline void HeartbeatPing::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
status_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.status)
}

// -------------------------------------------------------------------

// HeartbeatAck

// optional int32 stream_id = 1;
inline bool HeartbeatAck::has_stream_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatAck::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatAck::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.stream_id)
return stream_id_;
}
inline void HeartbeatAck::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000001u;
stream_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatAck::has_last_stream_id_received() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatAck::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatAck::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.last_stream_id_received)
return last_stream_id_received_;
}
inline void HeartbeatAck::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
last_stream_id_received_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatAck::has_status() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatAck::clear_status() {
status_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeartbeatAck::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.status)
return status_;
}
inline void HeartbeatAck::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000004u;
status_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.status)
}

// -------------------------------------------------------------------

// ErrorInfo

// required int32 code = 1;
inline bool ErrorInfo::has_code() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ErrorInfo::clear_code() {
code_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ErrorInfo::code() const {
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.code)
return code_;
}
inline void ErrorInfo::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000008u;
code_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.code)
}

// optional string message = 2;
inline bool ErrorInfo::has_message() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorInfo::clear_message() {
message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorInfo::message() const {
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.message)
return message_.GetNoArena();
}
inline void ErrorInfo::set_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.message)
}
inline void ErrorInfo::set_message(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.ErrorInfo.message)
}
inline void ErrorInfo::set_message(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.ErrorInfo.message)
}
inline void ErrorInfo::set_message(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.ErrorInfo.message)
}
inline std::string* ErrorInfo::mutable_message() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.message)
return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ErrorInfo::release_message() {
// @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.message)
if (!has_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorInfo::set_allocated_message(std::string* message) {
if (message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.message)
}

// optional string type = 3;
inline bool ErrorInfo::has_type() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorInfo::clear_type() {
type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ErrorInfo::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.type)
return type_.GetNoArena();
}
inline void ErrorInfo::set_type(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.type)
}
inline void ErrorInfo::set_type(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.ErrorInfo.type)
}
inline void ErrorInfo::set_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.ErrorInfo.type)
}
inline void ErrorInfo::set_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.ErrorInfo.type)
}
inline std::string* ErrorInfo::mutable_type() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.type)
return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ErrorInfo::release_type() {
// @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.type)
if (!has_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorInfo::set_allocated_type(std::string* type) {
if (type != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.type)
}

// optional .mcs_proto.Extension extension = 4;
inline bool ErrorInfo::has_extension() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ErrorInfo::clear_extension() {
if (extension_ != nullptr) extension_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::mcs_proto::Extension& ErrorInfo::extension() const {
const ::mcs_proto::Extension* p = extension_;
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.extension)
return p != nullptr ? *p : *reinterpret_cast<const ::mcs_proto::Extension*>(
&::mcs_proto::_Extension_default_instance_);
}
inline ::mcs_proto::Extension* ErrorInfo::release_extension() {
// @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.extension)
_has_bits_[0] &= ~0x00000004u;
::mcs_proto::Extension* temp = extension_;
extension_ = nullptr;
return temp;
}
inline ::mcs_proto::Extension* ErrorInfo::mutable_extension() {
_has_bits_[0] |= 0x00000004u;
if (extension_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::Extension>(GetArenaNoVirtual());
extension_ = p;
}
// @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.extension)
return extension_;
}
inline void ErrorInfo::set_allocated_extension(::mcs_proto::Extension* extension) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete extension_;
}
if (extension) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, extension, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
extension_ = extension;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.extension)
}

// -------------------------------------------------------------------

// Setting

// required string name = 1;
inline bool Setting::has_name() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Setting::clear_name() {
name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Setting::name() const {
// @@protoc_insertion_point(field_get:mcs_proto.Setting.name)
return name_.GetNoArena();
}
inline void Setting::set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.Setting.name)
}
inline void Setting::set_name(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.Setting.name)
}
inline void Setting::set_name(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.Setting.name)
}
inline void Setting::set_name(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.Setting.name)
}
inline std::string* Setting::mutable_name() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.Setting.name)
return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Setting::release_name() {
// @@protoc_insertion_point(field_release:mcs_proto.Setting.name)
if (!has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Setting::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.name)
}

// required string value = 2;
inline bool Setting::has_value() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Setting::clear_value() {
value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Setting::value() const {
// @@protoc_insertion_point(field_get:mcs_proto.Setting.value)
return value_.GetNoArena();
}
inline void Setting::set_value(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.Setting.value)
}
inline void Setting::set_value(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.Setting.value)
}
inline void Setting::set_value(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.Setting.value)
}
inline void Setting::set_value(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.Setting.value)
}
inline std::string* Setting::mutable_value() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.Setting.value)
return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Setting::release_value() {
// @@protoc_insertion_point(field_release:mcs_proto.Setting.value)
if (!has_value()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Setting::set_allocated_value(std::string* value) {
if (value != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.value)
}

// -------------------------------------------------------------------

// HeartbeatStat

// required string ip = 1;
inline bool HeartbeatStat::has_ip() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatStat::clear_ip() {
ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HeartbeatStat::ip() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.ip)
return ip_.GetNoArena();
}
inline void HeartbeatStat::set_ip(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.ip)
}
inline void HeartbeatStat::set_ip(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.HeartbeatStat.ip)
}
inline void HeartbeatStat::set_ip(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.HeartbeatStat.ip)
}
inline void HeartbeatStat::set_ip(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.HeartbeatStat.ip)
}
inline std::string* HeartbeatStat::mutable_ip() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatStat.ip)
return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeartbeatStat::release_ip() {
// @@protoc_insertion_point(field_release:mcs_proto.HeartbeatStat.ip)
if (!has_ip()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return ip_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatStat::set_allocated_ip(std::string* ip) {
if (ip != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatStat.ip)
}

// required bool timeout = 2;
inline bool HeartbeatStat::has_timeout() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatStat::clear_timeout() {
timeout_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool HeartbeatStat::timeout() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.timeout)
return timeout_;
}
inline void HeartbeatStat::set_timeout(bool value) {
_has_bits_[0] |= 0x00000002u;
timeout_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.timeout)
}

// required int32 interval_ms = 3;
inline bool HeartbeatStat::has_interval_ms() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatStat::clear_interval_ms() {
interval_ms_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatStat::interval_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.interval_ms)
return interval_ms_;
}
inline void HeartbeatStat::set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000004u;
interval_ms_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.interval_ms)
}

// -------------------------------------------------------------------

// HeartbeatConfig

// optional bool upload_stat = 1;
inline bool HeartbeatConfig::has_upload_stat() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatConfig::clear_upload_stat() {
upload_stat_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool HeartbeatConfig::upload_stat() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.upload_stat)
return upload_stat_;
}
inline void HeartbeatConfig::set_upload_stat(bool value) {
_has_bits_[0] |= 0x00000002u;
upload_stat_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.upload_stat)
}

// optional string ip = 2;
inline bool HeartbeatConfig::has_ip() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatConfig::clear_ip() {
ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HeartbeatConfig::ip() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.ip)
return ip_.GetNoArena();
}
inline void HeartbeatConfig::set_ip(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.ip)
}
inline void HeartbeatConfig::set_ip(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.HeartbeatConfig.ip)
}
inline void HeartbeatConfig::set_ip(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.HeartbeatConfig.ip)
}
inline void HeartbeatConfig::set_ip(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.HeartbeatConfig.ip)
}
inline std::string* HeartbeatConfig::mutable_ip() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatConfig.ip)
return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeartbeatConfig::release_ip() {
// @@protoc_insertion_point(field_release:mcs_proto.HeartbeatConfig.ip)
if (!has_ip()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return ip_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatConfig::set_allocated_ip(std::string* ip) {
if (ip != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatConfig.ip)
}

// optional int32 interval_ms = 3;
inline bool HeartbeatConfig::has_interval_ms() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatConfig::clear_interval_ms() {
interval_ms_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatConfig::interval_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.interval_ms)
return interval_ms_;
}
inline void HeartbeatConfig::set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000004u;
interval_ms_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.interval_ms)
}

// -------------------------------------------------------------------

// ClientEvent

// optional .mcs_proto.ClientEvent.Type type = 1;
inline bool ClientEvent::has_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientEvent::clear_type() {
type_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::mcs_proto::ClientEvent_Type ClientEvent::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.type)
return static_cast< ::mcs_proto::ClientEvent_Type >(type_);
}
inline void ClientEvent::set_type(::mcs_proto::ClientEvent_Type value) {
assert(::mcs_proto::ClientEvent_Type_IsValid(value));
_has_bits_[0] |= 0x00000001u;
type_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.type)
}

// optional uint32 number_discarded_events = 100;
inline bool ClientEvent::has_number_discarded_events() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientEvent::clear_number_discarded_events() {
number_discarded_events_ = 0u;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientEvent::number_discarded_events() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.number_discarded_events)
return number_discarded_events_;
}
inline void ClientEvent::set_number_discarded_events(::PROTOBUF_NAMESPACE_ID::uint32 value) {
_has_bits_[0] |= 0x00000002u;
number_discarded_events_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.number_discarded_events)
}

// optional int32 network_type = 200;
inline bool ClientEvent::has_network_type() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientEvent::clear_network_type() {
network_type_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientEvent::network_type() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.network_type)
return network_type_;
}
inline void ClientEvent::set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000008u;
network_type_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.network_type)
}

// optional uint64 time_connection_started_ms = 202;
inline bool ClientEvent::has_time_connection_started_ms() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientEvent::clear_time_connection_started_ms() {
time_connection_started_ms_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::time_connection_started_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_started_ms)
return time_connection_started_ms_;
}
inline void ClientEvent::set_time_connection_started_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000004u;
time_connection_started_ms_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_started_ms)
}

// optional uint64 time_connection_ended_ms = 203;
inline bool ClientEvent::has_time_connection_ended_ms() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientEvent::clear_time_connection_ended_ms() {
time_connection_ended_ms_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::time_connection_ended_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_ended_ms)
return time_connection_ended_ms_;
}
inline void ClientEvent::set_time_connection_ended_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000020u;
time_connection_ended_ms_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_ended_ms)
}

// optional int32 error_code = 204;
inline bool ClientEvent::has_error_code() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientEvent::clear_error_code() {
error_code_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientEvent::error_code() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.error_code)
return error_code_;
}
inline void ClientEvent::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000010u;
error_code_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.error_code)
}

// optional uint64 time_connection_established_ms = 300;
inline bool ClientEvent::has_time_connection_established_ms() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientEvent::clear_time_connection_established_ms() {
time_connection_established_ms_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::time_connection_established_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_established_ms)
return time_connection_established_ms_;
}
inline void ClientEvent::set_time_connection_established_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000040u;
time_connection_established_ms_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_established_ms)
}

// -------------------------------------------------------------------

// LoginRequest

// required string id = 1;
inline bool LoginRequest::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginRequest::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.id)
return id_.GetNoArena();
}
inline void LoginRequest::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.id)
}
inline void LoginRequest::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.id)
}
inline void LoginRequest::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.id)
}
inline void LoginRequest::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.id)
}
inline std::string* LoginRequest::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.id)
}

// required string domain = 2;
inline bool LoginRequest::has_domain() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::clear_domain() {
domain_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginRequest::domain() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.domain)
return domain_.GetNoArena();
}
inline void LoginRequest::set_domain(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.domain)
}
inline void LoginRequest::set_domain(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.domain)
}
inline void LoginRequest::set_domain(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.domain)
}
inline void LoginRequest::set_domain(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
domain_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.domain)
}
inline std::string* LoginRequest::mutable_domain() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.domain)
return domain_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_domain() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.domain)
if (!has_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return domain_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_domain(std::string* domain) {
if (domain != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
domain_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.domain)
}

// required string user = 3;
inline bool LoginRequest::has_user() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::clear_user() {
user_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoginRequest::user() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.user)
return user_.GetNoArena();
}
inline void LoginRequest::set_user(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.user)
}
inline void LoginRequest::set_user(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
user_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.user)
}
inline void LoginRequest::set_user(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.user)
}
inline void LoginRequest::set_user(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.user)
}
inline std::string* LoginRequest::mutable_user() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.user)
return user_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_user() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.user)
if (!has_user()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return user_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_user(std::string* user) {
if (user != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
user_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.user)
}

// required string resource = 4;
inline bool LoginRequest::has_resource() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::clear_resource() {
resource_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LoginRequest::resource() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.resource)
return resource_.GetNoArena();
}
inline void LoginRequest::set_resource(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
resource_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.resource)
}
inline void LoginRequest::set_resource(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
resource_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.resource)
}
inline void LoginRequest::set_resource(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
resource_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.resource)
}
inline void LoginRequest::set_resource(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
resource_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.resource)
}
inline std::string* LoginRequest::mutable_resource() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.resource)
return resource_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_resource() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.resource)
if (!has_resource()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return resource_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_resource(std::string* resource) {
if (resource != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
resource_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.resource)
}

// required string auth_token = 5;
inline bool LoginRequest::has_auth_token() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::clear_auth_token() {
auth_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LoginRequest::auth_token() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_token)
return auth_token_.GetNoArena();
}
inline void LoginRequest::set_auth_token(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
auth_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_token)
}
inline void LoginRequest::set_auth_token(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
auth_token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.auth_token)
}
inline void LoginRequest::set_auth_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
auth_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.auth_token)
}
inline void LoginRequest::set_auth_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
auth_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.auth_token)
}
inline std::string* LoginRequest::mutable_auth_token() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.auth_token)
return auth_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_auth_token() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.auth_token)
if (!has_auth_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return auth_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_auth_token(std::string* auth_token) {
if (auth_token != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
auth_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_token);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.auth_token)
}

// optional string device_id = 6;
inline bool LoginRequest::has_device_id() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRequest::clear_device_id() {
device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& LoginRequest::device_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.device_id)
return device_id_.GetNoArena();
}
inline void LoginRequest::set_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.device_id)
}
inline std::string* LoginRequest::mutable_device_id() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.device_id)
return device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_device_id() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.device_id)
if (!has_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_device_id(std::string* device_id) {
if (device_id != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.device_id)
}

// optional int64 last_rmq_id = 7;
inline bool LoginRequest::has_last_rmq_id() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginRequest::clear_last_rmq_id() {
last_rmq_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::last_rmq_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.last_rmq_id)
return last_rmq_id_;
}
inline void LoginRequest::set_last_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000080u;
last_rmq_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.last_rmq_id)
}

// repeated .mcs_proto.Setting setting = 8;
inline int LoginRequest::setting_size() const {
return setting_.size();
}
inline void LoginRequest::clear_setting() {
setting_.Clear();
}
inline ::mcs_proto::Setting* LoginRequest::mutable_setting(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.setting)
return setting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
LoginRequest::mutable_setting() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.setting)
return &setting_;
}
inline const ::mcs_proto::Setting& LoginRequest::setting(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.setting)
return setting_.Get(index);
}
inline ::mcs_proto::Setting* LoginRequest::add_setting() {
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.setting)
return setting_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
LoginRequest::setting() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.setting)
return setting_;
}

// repeated string received_persistent_id = 10;
inline int LoginRequest::received_persistent_id_size() const {
return received_persistent_id_.size();
}
inline void LoginRequest::clear_received_persistent_id() {
received_persistent_id_.Clear();
}
inline const std::string& LoginRequest::received_persistent_id(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.received_persistent_id)
return received_persistent_id_.Get(index);
}
inline std::string* LoginRequest::mutable_received_persistent_id(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.received_persistent_id)
return received_persistent_id_.Mutable(index);
}
inline void LoginRequest::set_received_persistent_id(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
received_persistent_id_.Mutable(index)->assign(value);
}
inline void LoginRequest::set_received_persistent_id(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
received_persistent_id_.Mutable(index)->assign(std::move(value));
}
inline void LoginRequest::set_received_persistent_id(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
received_persistent_id_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::set_received_persistent_id(int index, const char* value, size_t size) {
received_persistent_id_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline std::string* LoginRequest::add_received_persistent_id() {
// @@protoc_insertion_point(field_add_mutable:mcs_proto.LoginRequest.received_persistent_id)
return received_persistent_id_.Add();
}
inline void LoginRequest::add_received_persistent_id(const std::string& value) {
received_persistent_id_.Add()->assign(value);
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(std::string&& value) {
received_persistent_id_.Add(std::move(value));
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
received_persistent_id_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(const char* value, size_t size) {
received_persistent_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoginRequest::received_persistent_id() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.received_persistent_id)
return received_persistent_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoginRequest::mutable_received_persistent_id() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.received_persistent_id)
return &received_persistent_id_;
}

// optional bool adaptive_heartbeat = 12;
inline bool LoginRequest::has_adaptive_heartbeat() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginRequest::clear_adaptive_heartbeat() {
adaptive_heartbeat_ = false;
_has_bits_[0] &= ~0x00000100u;
}
inline bool LoginRequest::adaptive_heartbeat() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.adaptive_heartbeat)
return adaptive_heartbeat_;
}
inline void LoginRequest::set_adaptive_heartbeat(bool value) {
_has_bits_[0] |= 0x00000100u;
adaptive_heartbeat_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.adaptive_heartbeat)
}

// optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
inline bool LoginRequest::has_heartbeat_stat() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginRequest::clear_heartbeat_stat() {
if (heartbeat_stat_ != nullptr) heartbeat_stat_->Clear();
_has_bits_[0] &= ~0x00000040u;
}
inline const ::mcs_proto::HeartbeatStat& LoginRequest::heartbeat_stat() const {
const ::mcs_proto::HeartbeatStat* p = heartbeat_stat_;
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.heartbeat_stat)
return p != nullptr ? *p : *reinterpret_cast<const ::mcs_proto::HeartbeatStat*>(
&::mcs_proto::_HeartbeatStat_default_instance_);
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::release_heartbeat_stat() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.heartbeat_stat)
_has_bits_[0] &= ~0x00000040u;
::mcs_proto::HeartbeatStat* temp = heartbeat_stat_;
heartbeat_stat_ = nullptr;
return temp;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::mutable_heartbeat_stat() {
_has_bits_[0] |= 0x00000040u;
if (heartbeat_stat_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::HeartbeatStat>(GetArenaNoVirtual());
heartbeat_stat_ = p;
}
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.heartbeat_stat)
return heartbeat_stat_;
}
inline void LoginRequest::set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete heartbeat_stat_;
}
if (heartbeat_stat) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
heartbeat_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, heartbeat_stat, submessage_arena);
}
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
heartbeat_stat_ = heartbeat_stat;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.heartbeat_stat)
}

// optional bool use_rmq2 = 14;
inline bool LoginRequest::has_use_rmq2() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginRequest::clear_use_rmq2() {
use_rmq2_ = false;
_has_bits_[0] &= ~0x00000200u;
}
inline bool LoginRequest::use_rmq2() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.use_rmq2)
return use_rmq2_;
}
inline void LoginRequest::set_use_rmq2(bool value) {
_has_bits_[0] |= 0x00000200u;
use_rmq2_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.use_rmq2)
}

// optional int64 account_id = 15;
inline bool LoginRequest::has_account_id() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoginRequest::clear_account_id() {
account_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::account_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.account_id)
return account_id_;
}
inline void LoginRequest::set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000800u;
account_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.account_id)
}

// optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
inline bool LoginRequest::has_auth_service() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LoginRequest::clear_auth_service() {
auth_service_ = 2;
_has_bits_[0] &= ~0x00002000u;
}
inline ::mcs_proto::LoginRequest_AuthService LoginRequest::auth_service() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_service)
return static_cast< ::mcs_proto::LoginRequest_AuthService >(auth_service_);
}
inline void LoginRequest::set_auth_service(::mcs_proto::LoginRequest_AuthService value) {
assert(::mcs_proto::LoginRequest_AuthService_IsValid(value));
_has_bits_[0] |= 0x00002000u;
auth_service_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_service)
}

// optional int32 network_type = 17;
inline bool LoginRequest::has_network_type() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginRequest::clear_network_type() {
network_type_ = 0;
_has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginRequest::network_type() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.network_type)
return network_type_;
}
inline void LoginRequest::set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000400u;
network_type_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.network_type)
}

// optional int64 status = 18;
inline bool LoginRequest::has_status() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoginRequest::clear_status() {
status_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.status)
return status_;
}
inline void LoginRequest::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00001000u;
status_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.status)
}

// repeated .mcs_proto.ClientEvent client_event = 22;
inline int LoginRequest::client_event_size() const {
return client_event_.size();
}
inline void LoginRequest::clear_client_event() {
client_event_.Clear();
}
inline ::mcs_proto::ClientEvent* LoginRequest::mutable_client_event(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.client_event)
return client_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >*
LoginRequest::mutable_client_event() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.client_event)
return &client_event_;
}
inline const ::mcs_proto::ClientEvent& LoginRequest::client_event(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.client_event)
return client_event_.Get(index);
}
inline ::mcs_proto::ClientEvent* LoginRequest::add_client_event() {
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.client_event)
return client_event_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >&
LoginRequest::client_event() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.client_event)
return client_event_;
}

// -------------------------------------------------------------------

// LoginResponse

// required string id = 1;
inline bool LoginResponse::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginResponse::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.id)
return id_.GetNoArena();
}
inline void LoginResponse::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.id)
}
inline void LoginResponse::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginResponse.id)
}
inline void LoginResponse::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginResponse.id)
}
inline void LoginResponse::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginResponse.id)
}
inline std::string* LoginResponse::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginResponse::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.id)
}

// optional string jid = 2;
inline bool LoginResponse::has_jid() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::clear_jid() {
jid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginResponse::jid() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.jid)
return jid_.GetNoArena();
}
inline void LoginResponse::set_jid(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
jid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.jid)
}
inline void LoginResponse::set_jid(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
jid_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginResponse.jid)
}
inline void LoginResponse::set_jid(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
jid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginResponse.jid)
}
inline void LoginResponse::set_jid(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
jid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginResponse.jid)
}
inline std::string* LoginResponse::mutable_jid() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.jid)
return jid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginResponse::release_jid() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.jid)
if (!has_jid()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return jid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_jid(std::string* jid) {
if (jid != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
jid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jid);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.jid)
}

// optional .mcs_proto.ErrorInfo error = 3;
inline bool LoginResponse::has_error() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::clear_error() {
if (error_ != nullptr) error_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::mcs_proto::ErrorInfo& LoginResponse::error() const {
const ::mcs_proto::ErrorInfo* p = error_;
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.error)
return p != nullptr ? *p : *reinterpret_cast<const ::mcs_proto::ErrorInfo*>(
&::mcs_proto::_ErrorInfo_default_instance_);
}
inline ::mcs_proto::ErrorInfo* LoginResponse::release_error() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.error)
_has_bits_[0] &= ~0x00000004u;
::mcs_proto::ErrorInfo* temp = error_;
error_ = nullptr;
return temp;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::mutable_error() {
_has_bits_[0] |= 0x00000004u;
if (error_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::ErrorInfo>(GetArenaNoVirtual());
error_ = p;
}
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.error)
return error_;
}
inline void LoginResponse::set_allocated_error(::mcs_proto::ErrorInfo* error) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete error_;
}
if (error) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, error, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
error_ = error;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.error)
}

// repeated .mcs_proto.Setting setting = 4;
inline int LoginResponse::setting_size() const {
return setting_.size();
}
inline void LoginResponse::clear_setting() {
setting_.Clear();
}
inline ::mcs_proto::Setting* LoginResponse::mutable_setting(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.setting)
return setting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
LoginResponse::mutable_setting() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginResponse.setting)
return &setting_;
}
inline const ::mcs_proto::Setting& LoginResponse::setting(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.setting)
return setting_.Get(index);
}
inline ::mcs_proto::Setting* LoginResponse::add_setting() {
// @@protoc_insertion_point(field_add:mcs_proto.LoginResponse.setting)
return setting_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
LoginResponse::setting() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginResponse.setting)
return setting_;
}

// optional int32 stream_id = 5;
inline bool LoginResponse::has_stream_id() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginResponse::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.stream_id)
return stream_id_;
}
inline void LoginResponse::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000010u;
stream_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.stream_id)
}

// optional int32 last_stream_id_received = 6;
inline bool LoginResponse::has_last_stream_id_received() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponse::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginResponse::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.last_stream_id_received)
return last_stream_id_received_;
}
inline void LoginResponse::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000020u;
last_stream_id_received_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.last_stream_id_received)
}

// optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
inline bool LoginResponse::has_heartbeat_config() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::clear_heartbeat_config() {
if (heartbeat_config_ != nullptr) heartbeat_config_->Clear();
_has_bits_[0] &= ~0x00000008u;
}
inline const ::mcs_proto::HeartbeatConfig& LoginResponse::heartbeat_config() const {
const ::mcs_proto::HeartbeatConfig* p = heartbeat_config_;
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.heartbeat_config)
return p != nullptr ? *p : *reinterpret_cast<const ::mcs_proto::HeartbeatConfig*>(
&::mcs_proto::_HeartbeatConfig_default_instance_);
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::release_heartbeat_config() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.heartbeat_config)
_has_bits_[0] &= ~0x00000008u;
::mcs_proto::HeartbeatConfig* temp = heartbeat_config_;
heartbeat_config_ = nullptr;
return temp;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::mutable_heartbeat_config() {
_has_bits_[0] |= 0x00000008u;
if (heartbeat_config_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::HeartbeatConfig>(GetArenaNoVirtual());
heartbeat_config_ = p;
}
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.heartbeat_config)
return heartbeat_config_;
}
inline void LoginResponse::set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete heartbeat_config_;
}
if (heartbeat_config) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
heartbeat_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, heartbeat_config, submessage_arena);
}
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
heartbeat_config_ = heartbeat_config;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.heartbeat_config)
}

// optional int64 server_timestamp = 8;
inline bool LoginResponse::has_server_timestamp() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResponse::clear_server_timestamp() {
server_timestamp_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginResponse::server_timestamp() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.server_timestamp)
return server_timestamp_;
}
inline void LoginResponse::set_server_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000040u;
server_timestamp_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.server_timestamp)
}

// -------------------------------------------------------------------

// StreamErrorStanza

// required string type = 1;
inline bool StreamErrorStanza::has_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamErrorStanza::clear_type() {
type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamErrorStanza::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.type)
return type_.GetNoArena();
}
inline void StreamErrorStanza::set_type(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.type)
}
inline void StreamErrorStanza::set_type(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.StreamErrorStanza.type)
}
inline void StreamErrorStanza::set_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.StreamErrorStanza.type)
}
inline void StreamErrorStanza::set_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.StreamErrorStanza.type)
}
inline std::string* StreamErrorStanza::mutable_type() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.type)
return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StreamErrorStanza::release_type() {
// @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.type)
if (!has_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StreamErrorStanza::set_allocated_type(std::string* type) {
if (type != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.type)
}

// optional string text = 2;
inline bool StreamErrorStanza::has_text() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamErrorStanza::clear_text() {
text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamErrorStanza::text() const {
// @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.text)
return text_.GetNoArena();
}
inline void StreamErrorStanza::set_text(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.text)
}
inline void StreamErrorStanza::set_text(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
text_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.StreamErrorStanza.text)
}
inline void StreamErrorStanza::set_text(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.StreamErrorStanza.text)
}
inline void StreamErrorStanza::set_text(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.StreamErrorStanza.text)
}
inline std::string* StreamErrorStanza::mutable_text() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.text)
return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StreamErrorStanza::release_text() {
// @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.text)
if (!has_text()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return text_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StreamErrorStanza::set_allocated_text(std::string* text) {
if (text != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.text)
}

// -------------------------------------------------------------------

// Close

// -------------------------------------------------------------------

// Extension

// required int32 id = 1;
inline bool Extension::has_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extension::clear_id() {
id_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Extension::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.Extension.id)
return id_;
}
inline void Extension::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000002u;
id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.Extension.id)
}

// required bytes data = 2;
inline bool Extension::has_data() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extension::clear_data() {
data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Extension::data() const {
// @@protoc_insertion_point(field_get:mcs_proto.Extension.data)
return data_.GetNoArena();
}
inline void Extension::set_data(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.Extension.data)
}
inline void Extension::set_data(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.Extension.data)
}
inline void Extension::set_data(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.Extension.data)
}
inline void Extension::set_data(const void* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.Extension.data)
}
inline std::string* Extension::mutable_data() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.Extension.data)
return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_data() {
// @@protoc_insertion_point(field_release:mcs_proto.Extension.data)
if (!has_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_data(std::string* data) {
if (data != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.Extension.data)
}

// -------------------------------------------------------------------

// IqStanza

// optional int64 rmq_id = 1;
inline bool IqStanza::has_rmq_id() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IqStanza::clear_rmq_id() {
rmq_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::rmq_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.rmq_id)
return rmq_id_;
}
inline void IqStanza::set_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000040u;
rmq_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.rmq_id)
}

// required .mcs_proto.IqStanza.IqType type = 2;
inline bool IqStanza::has_type() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IqStanza::clear_type() {
type_ = 0;
_has_bits_[0] &= ~0x00000080u;
}
inline ::mcs_proto::IqStanza_IqType IqStanza::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.type)
return static_cast< ::mcs_proto::IqStanza_IqType >(type_);
}
inline void IqStanza::set_type(::mcs_proto::IqStanza_IqType value) {
assert(::mcs_proto::IqStanza_IqType_IsValid(value));
_has_bits_[0] |= 0x00000080u;
type_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.type)
}

// required string id = 3;
inline bool IqStanza::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IqStanza::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IqStanza::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.id)
return id_.GetNoArena();
}
inline void IqStanza::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.id)
}
inline void IqStanza::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.id)
}
inline void IqStanza::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.id)
}
inline void IqStanza::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.id)
}
inline std::string* IqStanza::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IqStanza::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.id)
}

// optional string from = 4;
inline bool IqStanza::has_from() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IqStanza::clear_from() {
from_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IqStanza::from() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.from)
return from_.GetNoArena();
}
inline void IqStanza::set_from(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.from)
}
inline void IqStanza::set_from(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.from)
}
inline void IqStanza::set_from(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.from)
}
inline void IqStanza::set_from(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.from)
}
inline std::string* IqStanza::mutable_from() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.from)
return from_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IqStanza::release_from() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.from)
if (!has_from()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return from_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_from(std::string* from) {
if (from != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
from_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.from)
}

// optional string to = 5;
inline bool IqStanza::has_to() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IqStanza::clear_to() {
to_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IqStanza::to() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.to)
return to_.GetNoArena();
}
inline void IqStanza::set_to(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.to)
}
inline void IqStanza::set_to(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.to)
}
inline void IqStanza::set_to(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.to)
}
inline void IqStanza::set_to(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.to)
}
inline std::string* IqStanza::mutable_to() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.to)
return to_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IqStanza::release_to() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.to)
if (!has_to()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return to_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_to(std::string* to) {
if (to != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
to_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.to)
}

// optional .mcs_proto.ErrorInfo error = 6;
inline bool IqStanza::has_error() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IqStanza::clear_error() {
if (error_ != nullptr) error_->Clear();
_has_bits_[0] &= ~0x00000010u;
}
inline const ::mcs_proto::ErrorInfo& IqStanza::error() const {
const ::mcs_proto::ErrorInfo* p = error_;
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.error)
return p != nullptr ? *p : *reinterpret_cast<const ::mcs_proto::ErrorInfo*>(
&::mcs_proto::_ErrorInfo_default_instance_);
}
inline ::mcs_proto::ErrorInfo* IqStanza::release_error() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.error)
_has_bits_[0] &= ~0x00000010u;
::mcs_proto::ErrorInfo* temp = error_;
error_ = nullptr;
return temp;
}
inline ::mcs_proto::ErrorInfo* IqStanza::mutable_error() {
_has_bits_[0] |= 0x00000010u;
if (error_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::ErrorInfo>(GetArenaNoVirtual());
error_ = p;
}
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.error)
return error_;
}
inline void IqStanza::set_allocated_error(::mcs_proto::ErrorInfo* error) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete error_;
}
if (error) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, error, submessage_arena);
}
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
error_ = error;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.error)
}

// optional .mcs_proto.Extension extension = 7;
inline bool IqStanza::has_extension() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IqStanza::clear_extension() {
if (extension_ != nullptr) extension_->Clear();
_has_bits_[0] &= ~0x00000020u;
}
inline const ::mcs_proto::Extension& IqStanza::extension() const {
const ::mcs_proto::Extension* p = extension_;
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.extension)
return p != nullptr ? *p : *reinterpret_cast<const ::mcs_proto::Extension*>(
&::mcs_proto::_Extension_default_instance_);
}
inline ::mcs_proto::Extension* IqStanza::release_extension() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.extension)
_has_bits_[0] &= ~0x00000020u;
::mcs_proto::Extension* temp = extension_;
extension_ = nullptr;
return temp;
}
inline ::mcs_proto::Extension* IqStanza::mutable_extension() {
_has_bits_[0] |= 0x00000020u;
if (extension_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::Extension>(GetArenaNoVirtual());
extension_ = p;
}
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.extension)
return extension_;
}
inline void IqStanza::set_allocated_extension(::mcs_proto::Extension* extension) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
if (message_arena == nullptr) {
delete extension_;
}
if (extension) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
if (message_arena != submessage_arena) {
extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, extension, submessage_arena);
}
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
extension_ = extension;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.extension)
}

// optional string persistent_id = 8;
inline bool IqStanza::has_persistent_id() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IqStanza::clear_persistent_id() {
persistent_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& IqStanza::persistent_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.persistent_id)
return persistent_id_.GetNoArena();
}
inline void IqStanza::set_persistent_id(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
persistent_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.persistent_id)
}
inline void IqStanza::set_persistent_id(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
persistent_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.persistent_id)
}
inline void IqStanza::set_persistent_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
persistent_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.persistent_id)
}
inline void IqStanza::set_persistent_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
persistent_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.persistent_id)
}
inline std::string* IqStanza::mutable_persistent_id() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.persistent_id)
return persistent_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IqStanza::release_persistent_id() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.persistent_id)
if (!has_persistent_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return persistent_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_persistent_id(std::string* persistent_id) {
if (persistent_id != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
persistent_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), persistent_id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.persistent_id)
}

// optional int32 stream_id = 9;
inline bool IqStanza::has_stream_id() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IqStanza::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IqStanza::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.stream_id)
return stream_id_;
}
inline void IqStanza::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000100u;
stream_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.stream_id)
}

// optional int32 last_stream_id_received = 10;
inline bool IqStanza::has_last_stream_id_received() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IqStanza::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IqStanza::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.last_stream_id_received)
return last_stream_id_received_;
}
inline void IqStanza::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000800u;
last_stream_id_received_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.last_stream_id_received)
}

// optional int64 account_id = 11;
inline bool IqStanza::has_account_id() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IqStanza::clear_account_id() {
account_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::account_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.account_id)
return account_id_;
}
inline void IqStanza::set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000200u;
account_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.account_id)
}

// optional int64 status = 12;
inline bool IqStanza::has_status() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IqStanza::clear_status() {
status_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.status)
return status_;
}
inline void IqStanza::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000400u;
status_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.status)
}

// -------------------------------------------------------------------

// AppData

// required string key = 1;
inline bool AppData::has_key() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppData::clear_key() {
key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppData::key() const {
// @@protoc_insertion_point(field_get:mcs_proto.AppData.key)
return key_.GetNoArena();
}
inline void AppData::set_key(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.AppData.key)
}
inline void AppData::set_key(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.AppData.key)
}
inline void AppData::set_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.AppData.key)
}
inline void AppData::set_key(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.AppData.key)
}
inline std::string* AppData::mutable_key() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.AppData.key)
return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppData::release_key() {
// @@protoc_insertion_point(field_release:mcs_proto.AppData.key)
if (!has_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppData::set_allocated_key(std::string* key) {
if (key != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.key)
}

// required string value = 2;
inline bool AppData::has_value() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppData::clear_value() {
value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppData::value() const {
// @@protoc_insertion_point(field_get:mcs_proto.AppData.value)
return value_.GetNoArena();
}
inline void AppData::set_value(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.AppData.value)
}
inline void AppData::set_value(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.AppData.value)
}
inline void AppData::set_value(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.AppData.value)
}
inline void AppData::set_value(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.AppData.value)
}
inline std::string* AppData::mutable_value() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.AppData.value)
return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AppData::release_value() {
// @@protoc_insertion_point(field_release:mcs_proto.AppData.value)
if (!has_value()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AppData::set_allocated_value(std::string* value) {
if (value != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.value)
}

// -------------------------------------------------------------------

// DataMessageStanza

// optional string id = 2;
inline bool DataMessageStanza::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMessageStanza::clear_id() {
id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessageStanza::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.id)
return id_.GetNoArena();
}
inline void DataMessageStanza::set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.id)
}
inline void DataMessageStanza::set_id(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.id)
}
inline void DataMessageStanza::set_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.id)
}
inline void DataMessageStanza::set_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.id)
}
inline std::string* DataMessageStanza::mutable_id() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.id)
return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.id)
if (!has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.id)
}

// required string from = 3;
inline bool DataMessageStanza::has_from() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMessageStanza::clear_from() {
from_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessageStanza::from() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from)
return from_.GetNoArena();
}
inline void DataMessageStanza::set_from(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from)
}
inline void DataMessageStanza::set_from(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.from)
}
inline void DataMessageStanza::set_from(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.from)
}
inline void DataMessageStanza::set_from(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
from_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.from)
}
inline std::string* DataMessageStanza::mutable_from() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.from)
return from_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_from() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.from)
if (!has_from()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return from_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_from(std::string* from) {
if (from != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
from_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.from)
}

// optional string to = 4;
inline bool DataMessageStanza::has_to() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataMessageStanza::clear_to() {
to_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataMessageStanza::to() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.to)
return to_.GetNoArena();
}
inline void DataMessageStanza::set_to(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.to)
}
inline void DataMessageStanza::set_to(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.to)
}
inline void DataMessageStanza::set_to(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.to)
}
inline void DataMessageStanza::set_to(const char* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
to_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.to)
}
inline std::string* DataMessageStanza::mutable_to() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.to)
return to_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_to() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.to)
if (!has_to()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return to_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_to(std::string* to) {
if (to != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
to_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.to)
}

// required string category = 5;
inline bool DataMessageStanza::has_category() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataMessageStanza::clear_category() {
category_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DataMessageStanza::category() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.category)
return category_.GetNoArena();
}
inline void DataMessageStanza::set_category(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
category_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.category)
}
inline void DataMessageStanza::set_category(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
category_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.category)
}
inline void DataMessageStanza::set_category(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
category_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.category)
}
inline void DataMessageStanza::set_category(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
category_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.category)
}
inline std::string* DataMessageStanza::mutable_category() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.category)
return category_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_category() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.category)
if (!has_category()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return category_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_category(std::string* category) {
if (category != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
category_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.category)
}

// optional string token = 6;
inline bool DataMessageStanza::has_token() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataMessageStanza::clear_token() {
token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DataMessageStanza::token() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.token)
return token_.GetNoArena();
}
inline void DataMessageStanza::set_token(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.token)
}
inline void DataMessageStanza::set_token(std::string&& value) {
_has_bits_[0] |= 0x00000010u;
token_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.token)
}
inline void DataMessageStanza::set_token(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000010u;
token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.token)
}
inline void DataMessageStanza::set_token(const char* value, size_t size) {
_has_bits_[0] |= 0x00000010u;
token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.token)
}
inline std::string* DataMessageStanza::mutable_token() {
_has_bits_[0] |= 0x00000010u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.token)
return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_token() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.token)
if (!has_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
return token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_token(std::string* token) {
if (token != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.token)
}

// repeated .mcs_proto.AppData app_data = 7;
inline int DataMessageStanza::app_data_size() const {
return app_data_.size();
}
inline void DataMessageStanza::clear_app_data() {
app_data_.Clear();
}
inline ::mcs_proto::AppData* DataMessageStanza::mutable_app_data(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.app_data)
return app_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >*
DataMessageStanza::mutable_app_data() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.DataMessageStanza.app_data)
return &app_data_;
}
inline const ::mcs_proto::AppData& DataMessageStanza::app_data(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.app_data)
return app_data_.Get(index);
}
inline ::mcs_proto::AppData* DataMessageStanza::add_app_data() {
// @@protoc_insertion_point(field_add:mcs_proto.DataMessageStanza.app_data)
return app_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >&
DataMessageStanza::app_data() const {
// @@protoc_insertion_point(field_list:mcs_proto.DataMessageStanza.app_data)
return app_data_;
}

// optional bool from_trusted_server = 8;
inline bool DataMessageStanza::has_from_trusted_server() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataMessageStanza::clear_from_trusted_server() {
from_trusted_server_ = false;
_has_bits_[0] &= ~0x00000800u;
}
inline bool DataMessageStanza::from_trusted_server() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from_trusted_server)
return from_trusted_server_;
}
inline void DataMessageStanza::set_from_trusted_server(bool value) {
_has_bits_[0] |= 0x00000800u;
from_trusted_server_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from_trusted_server)
}

// optional string persistent_id = 9;
inline bool DataMessageStanza::has_persistent_id() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataMessageStanza::clear_persistent_id() {
persistent_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DataMessageStanza::persistent_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.persistent_id)
return persistent_id_.GetNoArena();
}
inline void DataMessageStanza::set_persistent_id(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
persistent_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.persistent_id)
}
inline void DataMessageStanza::set_persistent_id(std::string&& value) {
_has_bits_[0] |= 0x00000020u;
persistent_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.persistent_id)
}
inline void DataMessageStanza::set_persistent_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000020u;
persistent_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.persistent_id)
}
inline void DataMessageStanza::set_persistent_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000020u;
persistent_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.persistent_id)
}
inline std::string* DataMessageStanza::mutable_persistent_id() {
_has_bits_[0] |= 0x00000020u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.persistent_id)
return persistent_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_persistent_id() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.persistent_id)
if (!has_persistent_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
return persistent_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_persistent_id(std::string* persistent_id) {
if (persistent_id != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
persistent_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), persistent_id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.persistent_id)
}

// optional int32 stream_id = 10;
inline bool DataMessageStanza::has_stream_id() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataMessageStanza::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.stream_id)
return stream_id_;
}
inline void DataMessageStanza::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000100u;
stream_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.stream_id)
}

// optional int32 last_stream_id_received = 11;
inline bool DataMessageStanza::has_last_stream_id_received() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataMessageStanza::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.last_stream_id_received)
return last_stream_id_received_;
}
inline void DataMessageStanza::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000200u;
last_stream_id_received_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.last_stream_id_received)
}

// optional string reg_id = 13;
inline bool DataMessageStanza::has_reg_id() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataMessageStanza::clear_reg_id() {
reg_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DataMessageStanza::reg_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.reg_id)
return reg_id_.GetNoArena();
}
inline void DataMessageStanza::set_reg_id(const std::string& value) {
_has_bits_[0] |= 0x00000040u;
reg_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.reg_id)
}
inline void DataMessageStanza::set_reg_id(std::string&& value) {
_has_bits_[0] |= 0x00000040u;
reg_id_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.reg_id)
}
inline void DataMessageStanza::set_reg_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000040u;
reg_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.reg_id)
}
inline void DataMessageStanza::set_reg_id(const char* value, size_t size) {
_has_bits_[0] |= 0x00000040u;
reg_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.reg_id)
}
inline std::string* DataMessageStanza::mutable_reg_id() {
_has_bits_[0] |= 0x00000040u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.reg_id)
return reg_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_reg_id() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.reg_id)
if (!has_reg_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000040u;
return reg_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_reg_id(std::string* reg_id) {
if (reg_id != nullptr) {
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
reg_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reg_id);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.reg_id)
}

// optional int64 device_user_id = 16;
inline bool DataMessageStanza::has_device_user_id() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataMessageStanza::clear_device_user_id() {
device_user_id_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::device_user_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.device_user_id)
return device_user_id_;
}
inline void DataMessageStanza::set_device_user_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00000400u;
device_user_id_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.device_user_id)
}

// optional int32 ttl = 17;
inline bool DataMessageStanza::has_ttl() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataMessageStanza::clear_ttl() {
ttl_ = 0;
_has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::ttl() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.ttl)
return ttl_;
}
inline void DataMessageStanza::set_ttl(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00002000u;
ttl_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.ttl)
}

// optional int64 sent = 18;
inline bool DataMessageStanza::has_sent() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataMessageStanza::clear_sent() {
sent_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::sent() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.sent)
return sent_;
}
inline void DataMessageStanza::set_sent(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00004000u;
sent_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.sent)
}

// optional int32 queued = 19;
inline bool DataMessageStanza::has_queued() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataMessageStanza::clear_queued() {
queued_ = 0;
_has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::queued() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.queued)
return queued_;
}
inline void DataMessageStanza::set_queued(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00008000u;
queued_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.queued)
}

// optional int64 status = 20;
inline bool DataMessageStanza::has_status() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataMessageStanza::clear_status() {
status_ = PROTOBUF_LONGLONG(0);
_has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.status)
return status_;
}
inline void DataMessageStanza::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
_has_bits_[0] |= 0x00010000u;
status_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.status)
}

// optional bytes raw_data = 21;
inline bool DataMessageStanza::has_raw_data() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataMessageStanza::clear_raw_data() {
raw_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DataMessageStanza::raw_data() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.raw_data)
return raw_data_.GetNoArena();
}
inline void DataMessageStanza::set_raw_data(const std::string& value) {
_has_bits_[0] |= 0x00000080u;
raw_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.raw_data)
}
inline void DataMessageStanza::set_raw_data(std::string&& value) {
_has_bits_[0] |= 0x00000080u;
raw_data_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.raw_data)
}
inline void DataMessageStanza::set_raw_data(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000080u;
raw_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.raw_data)
}
inline void DataMessageStanza::set_raw_data(const void* value, size_t size) {
_has_bits_[0] |= 0x00000080u;
raw_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.raw_data)
}
inline std::string* DataMessageStanza::mutable_raw_data() {
_has_bits_[0] |= 0x00000080u;
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.raw_data)
return raw_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataMessageStanza::release_raw_data() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.raw_data)
if (!has_raw_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000080u;
return raw_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_raw_data(std::string* raw_data) {
if (raw_data != nullptr) {
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
raw_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_data);
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.raw_data)
}

// optional bool immediate_ack = 24;
inline bool DataMessageStanza::has_immediate_ack() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataMessageStanza::clear_immediate_ack() {
immediate_ack_ = false;
_has_bits_[0] &= ~0x00001000u;
}
inline bool DataMessageStanza::immediate_ack() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.immediate_ack)
return immediate_ack_;
}
inline void DataMessageStanza::set_immediate_ack(bool value) {
_has_bits_[0] |= 0x00001000u;
immediate_ack_ = value;
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.immediate_ack)
}

// -------------------------------------------------------------------

// StreamAck

// -------------------------------------------------------------------

// SelectiveAck

// repeated string id = 1;
inline int SelectiveAck::id_size() const {
return id_.size();
}
inline void SelectiveAck::clear_id() {
id_.Clear();
}
inline const std::string& SelectiveAck::id(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.SelectiveAck.id)
return id_.Get(index);
}
inline std::string* SelectiveAck::mutable_id(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.SelectiveAck.id)
return id_.Mutable(index);
}
inline void SelectiveAck::set_id(int index, const std::string& value) {
// @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
id_.Mutable(index)->assign(value);
}
inline void SelectiveAck::set_id(int index, std::string&& value) {
// @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
id_.Mutable(index)->assign(std::move(value));
}
inline void SelectiveAck::set_id(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
id_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::set_id(int index, const char* value, size_t size) {
id_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:mcs_proto.SelectiveAck.id)
}
inline std::string* SelectiveAck::add_id() {
// @@protoc_insertion_point(field_add_mutable:mcs_proto.SelectiveAck.id)
return id_.Add();
}
inline void SelectiveAck::add_id(const std::string& value) {
id_.Add()->assign(value);
// @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(std::string&& value) {
id_.Add(std::move(value));
// @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
id_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(const char* value, size_t size) {
id_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:mcs_proto.SelectiveAck.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectiveAck::id() const {
// @@protoc_insertion_point(field_list:mcs_proto.SelectiveAck.id)
return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectiveAck::mutable_id() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.SelectiveAck.id)
return &id_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcs_proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mcs_proto::ClientEvent_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::mcs_proto::LoginRequest_AuthService> : ::std::true_type {};
template <> struct is_proto_enum< ::mcs_proto::IqStanza_IqType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto
